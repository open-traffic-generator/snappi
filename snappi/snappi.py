# Open Traffic Generator API 0.13.0
# License: MIT

import importlib
import logging
import json
import platform
import yaml
import requests
import urllib3
import io
import sys
import time
import grpc
import semantic_version
import types
import platform
from google.protobuf import json_format

try:
    from snappi import otg_pb2_grpc as pb2_grpc
except ImportError:
    import otg_pb2_grpc as pb2_grpc
try:
    from snappi import otg_pb2 as pb2
except ImportError:
    import otg_pb2 as pb2

try:
    from typing import Union, Dict, List, Any, Literal
except ImportError:
    from typing_extensions import Literal


if sys.version_info[0] == 3:
    unicode = str


openapi_warnings = []


class Transport:
    HTTP = "http"
    GRPC = "grpc"


def api(
    location=None,
    transport=None,
    verify=True,
    logger=None,
    loglevel=logging.INFO,
    ext=None,
    version_check=False,
):
    """Create an instance of an Api class

    generator.Generator outputs a base Api class with the following:
    - an abstract method for each OpenAPI path item object
    - a concrete properties for each unique OpenAPI path item parameter.

    generator.Generator also outputs an HttpApi class that inherits the base
    Api class, implements the abstract methods and uses the common HttpTransport
    class send_recv method to communicate with a REST based server.

    Args
    ----
    - location (str): The location of an Open Traffic Generator server.
    - transport (enum["http", "grpc"]): Transport Type
    - verify (bool): Verify the server's TLS certificate, or a string, in which
      case it must be a path to a CA bundle to use. Defaults to `True`.
      When set to `False`, requests will accept any TLS certificate presented by
      the server, and will ignore hostname mismatches and/or expired
      certificates, which will make your application vulnerable to
      man-in-the-middle (MitM) attacks. Setting verify to `False`
      may be useful during local development or testing.
    - logger (logging.Logger): A user defined logging.logger, if none is provided
      then a default logger with a stdout handler will be provided
    - loglevel (logging.loglevel): The logging package log level.
      The default loglevel is logging.INFO
    - ext (str): Name of an extension package
    """
    params = locals()
    transport_types = ["http", "grpc"]
    if ext is None:
        transport = "http" if transport is None else transport
        if transport not in transport_types:
            raise Exception(
                "{transport} is not within valid transport types {transport_types}".format(
                    transport=transport, transport_types=transport_types
                )
            )
        if transport == "http":
            return HttpApi(**params)
        else:
            return GrpcApi(**params)
    try:
        if transport is not None:
            raise Exception(
                "ext and transport are not mutually exclusive. Please configure one of them."
            )
        lib = importlib.import_module("snappi_{}.snappi_api".format(ext))
        return lib.Api(**params)
    except ImportError as err:
        msg = "Extension %s is not installed or invalid: %s"
        raise Exception(msg % (ext, err))


class HttpTransport(object):
    def __init__(self, **kwargs):
        """Use args from api() method to instantiate an HTTP transport"""
        self.location = (
            kwargs["location"]
            if "location" in kwargs and kwargs["location"] is not None
            else "https://localhost:443"
        )
        self.verify = kwargs["verify"] if "verify" in kwargs else False
        self.logger = kwargs["logger"] if "logger" in kwargs else None
        self.loglevel = kwargs["loglevel"] if "loglevel" in kwargs else logging.DEBUG
        if self.logger is None:
            stdout_handler = logging.StreamHandler(sys.stdout)
            formatter = logging.Formatter(
                fmt="%(asctime)s [%(name)s] [%(levelname)s] %(message)s",
                datefmt="%Y-%m-%d %H:%M:%S",
            )
            formatter.converter = time.gmtime
            stdout_handler.setFormatter(formatter)
            self.logger = logging.Logger(self.__module__, level=self.loglevel)
            self.logger.addHandler(stdout_handler)
        self.logger.debug(
            "HttpTransport args: {}".format(
                ", ".join(["{}={!r}".format(k, v) for k, v in kwargs.items()])
            )
        )
        self.set_verify(self.verify)
        self._session = requests.Session()

    def set_verify(self, verify):
        self.verify = verify
        if self.verify is False:
            urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
            self.logger.warning("Certificate verification is disabled")

    def _parse_response_error(self, response_code, response_text):
        error_response = ""
        try:
            error_response = yaml.safe_load(response_text)
        except Exception as _:
            error_response = response_text

        err_obj = Error()
        try:
            err_obj.deserialize(error_response)
        except Exception as _:
            err_obj.code = response_code
            err_obj.errors = [str(error_response)]

        raise Exception(err_obj)

    def send_recv(
        self,
        method,
        relative_url,
        payload=None,
        return_object=None,
        headers=None,
        request_class=None,
    ):
        url = "%s%s" % (self.location, relative_url)
        data = None
        headers = headers or {"Content-Type": "application/json"}
        if payload is not None:
            if isinstance(payload, bytes):
                data = payload
                headers["Content-Type"] = "application/octet-stream"
            elif isinstance(payload, (str, unicode)):
                if request_class is not None:
                    request_class().deserialize(payload)
                data = payload
            elif isinstance(payload, OpenApiBase):
                data = payload.serialize()
            else:
                raise Exception("Type of payload provided is unknown")
        response = self._session.request(
            method=method,
            url=url,
            data=data,
            verify=False,
            allow_redirects=True,
            # TODO: add a timeout here
            headers=headers,
        )
        if response.ok:
            if "application/json" in response.headers["content-type"]:
                # TODO: we might want to check for utf-8 charset and decode
                # accordingly, but current impl works for now
                response_dict = yaml.safe_load(response.text)
                if return_object is None:
                    # if response type is not provided, return dictionary
                    # instead of python object
                    return response_dict
                else:
                    return return_object.deserialize(response_dict)
            elif "application/octet-stream" in response.headers["content-type"]:
                return io.BytesIO(response.content)
            else:
                # TODO: for now, return bare response object for unknown
                # content types
                return response
        else:
            self._parse_response_error(response.status_code, response.text)


class OpenApiStatus:
    messages = {}
    # logger = logging.getLogger(__module__)

    @classmethod
    def warn(cls, key, object):
        if cls.messages.get(key) is not None:
            if cls.messages[key] in object.__warnings__:
                return
            # cls.logger.warning(cls.messages[key])
            logging.warning(cls.messages[key])
            object.__warnings__.append(cls.messages[key])
            # openapi_warnings.append(cls.messages[key])

    @staticmethod
    def deprecated(func_or_data):
        def inner(self, *args, **kwargs):
            OpenApiStatus.warn(
                "{}.{}".format(type(self).__name__, func_or_data.__name__),
                self,
            )
            return func_or_data(self, *args, **kwargs)

        if isinstance(func_or_data, types.FunctionType):
            return inner
        OpenApiStatus.warn(func_or_data)

    @staticmethod
    def under_review(func_or_data):
        def inner(self, *args, **kwargs):
            OpenApiStatus.warn(
                "{}.{}".format(type(self).__name__, func_or_data.__name__),
                self,
            )
            return func_or_data(self, *args, **kwargs)

        if isinstance(func_or_data, types.FunctionType):
            return inner
        OpenApiStatus.warn(func_or_data)


class OpenApiBase(object):
    """Base class for all generated classes"""

    JSON = "json"
    YAML = "yaml"
    DICT = "dict"

    __slots__ = ()

    __constraints__ = {"global": []}
    __validate_latter__ = {"unique": [], "constraint": []}

    def __init__(self):
        pass

    def serialize(self, encoding=JSON):
        """Serialize the current object according to a specified encoding.

        Args
        ----
        - encoding (str[json, yaml, dict]): The object will be recursively
            serialized according to the specified encoding.
            The supported encodings are json, yaml and python dict.

        Returns
        -------
        - obj(Union[str, dict]): A str or dict object depending on the specified
            encoding. The json and yaml encodings will return a str object and
            the dict encoding will return a python dict object.
        """
        # TODO: restore behavior
        # self._clear_globals()
        if encoding == OpenApiBase.JSON:
            data = json.dumps(self._encode(), indent=2, sort_keys=True)
        elif encoding == OpenApiBase.YAML:
            data = yaml.safe_dump(self._encode())
        elif encoding == OpenApiBase.DICT:
            data = self._encode()
        else:
            raise NotImplementedError("Encoding %s not supported" % encoding)
        # TODO: restore behavior
        # self._validate_coded()
        return data

    def _encode(self):
        raise NotImplementedError()

    def deserialize(self, serialized_object):
        """Deserialize a python object into the current object.

        If the input `serialized_object` does not match the current
        openapi object an exception will be raised.

        Args
        ----
        - serialized_object (Union[str, dict]): The object to deserialize.
            If the serialized_object is of type str then the internal encoding
            of the serialized_object must be json or yaml.

        Returns
        -------
        - obj(OpenApiObject): This object with all the
            serialized_object deserialized within.
        """
        # TODO: restore behavior
        # self._clear_globals()
        if isinstance(serialized_object, (str, unicode)):
            serialized_object = yaml.safe_load(serialized_object)
        self._decode(serialized_object)
        # TODO: restore behavior
        # self._validate_coded()
        return self

    def _decode(self, dict_object):
        raise NotImplementedError()

    def warnings(self):
        warns = list(self.__warnings__)
        if "2.7" in platform.python_version().rsplit(".", 1)[0]:
            del self.__warnings__[:]
        else:
            self.__warnings__.clear()
        return warns


class OpenApiValidator(object):

    __slots__ = ()

    _validation_errors = []

    def __init__(self):
        pass

    def _clear_errors(self):
        if "2.7" in platform.python_version().rsplit(".", 1)[0]:
            del self._validation_errors[:]
        else:
            self._validation_errors.clear()

    def validate_mac(self, mac):
        if mac is None or not isinstance(mac, (str, unicode)) or mac.count(" ") != 0:
            return False
        try:
            if len(mac) != 17:
                return False
            return all([0 <= int(oct, 16) <= 255 for oct in mac.split(":")])
        except Exception:
            return False

    def validate_ipv4(self, ip):
        if ip is None or not isinstance(ip, (str, unicode)) or ip.count(" ") != 0:
            return False
        if len(ip.split(".")) != 4:
            return False
        try:
            return all([0 <= int(oct) <= 255 for oct in ip.split(".", 3)])
        except Exception:
            return False

    def validate_ipv6(self, ip):
        if ip is None or not isinstance(ip, (str, unicode)):
            return False
        ip = ip.strip()
        if (
            ip.count(" ") > 0
            or ip.count(":") > 7
            or ip.count("::") > 1
            or ip.count(":::") > 0
        ):
            return False
        if (ip[0] == ":" and ip[:2] != "::") or (ip[-1] == ":" and ip[-2:] != "::"):
            return False
        if ip.count("::") == 0 and ip.count(":") != 7:
            return False
        if ip == "::":
            return True
        if ip[:2] == "::":
            ip = ip.replace("::", "0:")
        elif ip[-2:] == "::":
            ip = ip.replace("::", ":0")
        else:
            ip = ip.replace("::", ":0:")
        try:
            return all(
                [
                    True
                    if (0 <= int(oct, 16) <= 65535) and (1 <= len(oct) <= 4)
                    else False
                    for oct in ip.split(":")
                ]
            )
        except Exception:
            return False

    def validate_hex(self, hex):
        if hex is None or not isinstance(hex, (str, unicode)):
            return False
        try:
            int(hex, 16)
            return True
        except Exception:
            return False

    def validate_integer(self, value, min, max, type_format=None):
        if value is None or not isinstance(value, int):
            return False
        if min is not None and value < min:
            return False
        if max is not None and value > max:
            return False
        if type_format is not None:
            if type_format == "uint32" and (value < 0 or value > 4294967295):
                return False
            elif type_format == "uint64" and (
                value < 0 or value > 18446744073709551615
            ):
                return False
            elif type_format == "int32" and (value < -2147483648 or value > 2147483647):
                return False
            elif type_format == "int64" and (
                value < -9223372036854775808 or value > 9223372036854775807
            ):
                return False
        return True

    def validate_float(self, value):
        return isinstance(value, (int, float))

    def validate_string(self, value, min_length, max_length):
        if value is None or not isinstance(value, (str, unicode)):
            return False
        if min_length is not None and len(value) < min_length:
            return False
        if max_length is not None and len(value) > max_length:
            return False
        return True

    def validate_bool(self, value):
        return isinstance(value, bool)

    def validate_list(self, value, itemtype, min, max, min_length, max_length):
        if value is None or not isinstance(value, list):
            return False
        v_obj = getattr(self, "validate_{}".format(itemtype), None)
        if v_obj is None:
            raise AttributeError("{} is not a valid attribute".format(itemtype))
        v_obj_lst = []
        for item in value:
            if itemtype == "integer":
                v_obj_lst.append(v_obj(item, min, max))
            elif itemtype == "string":
                v_obj_lst.append(v_obj(item, min_length, max_length))
            else:
                v_obj_lst.append(v_obj(item))
        return v_obj_lst

    def validate_binary(self, value):
        if value is None or not isinstance(value, (str, unicode)):
            return False
        return all([True if int(bin) == 0 or int(bin) == 1 else False for bin in value])

    def types_validation(
        self,
        value,
        type_,
        err_msg,
        itemtype=None,
        min=None,
        max=None,
        min_length=None,
        max_length=None,
    ):
        type_map = {
            int: "integer",
            str: "string",
            float: "float",
            bool: "bool",
            list: "list",
            "int64": "integer",
            "int32": "integer",
            "uint64": "integer",
            "uint32": "integer",
            "double": "float",
        }
        type_format = type_
        if type_ in type_map:
            type_ = type_map[type_]
        if itemtype is not None and itemtype in type_map:
            itemtype = type_map[itemtype]
        v_obj = getattr(self, "validate_{}".format(type_), None)
        if v_obj is None:
            msg = "{} is not a valid or unsupported format".format(type_)
            raise TypeError(msg)
        if type_ == "list":
            verdict = v_obj(value, itemtype, min, max, min_length, max_length)
            if all(verdict) is True:
                return
            err_msg = "{} \n {} are not valid".format(
                err_msg,
                [value[index] for index, item in enumerate(verdict) if item is False],
            )
            verdict = False
        elif type_ == "integer":
            verdict = v_obj(value, min, max, type_format)
            if verdict is True:
                return
            min_max = ""
            if min is not None:
                min_max = ", expected min {}".format(min)
            if max is not None:
                min_max = min_max + ", expected max {}".format(max)
            err_msg = "{} \n got {} of type {} {}".format(
                err_msg, value, type(value), min_max
            )
        elif type_ == "string":
            verdict = v_obj(value, min_length, max_length)
            if verdict is True:
                return
            msg = ""
            if min_length is not None:
                msg = ", expected min {}".format(min_length)
            if max_length is not None:
                msg = msg + ", expected max {}".format(max_length)
            err_msg = "{} \n got {} of type {} {}".format(
                err_msg, value, type(value), msg
            )
        else:
            verdict = v_obj(value)
        if verdict is False:
            raise TypeError(err_msg)

    def _validate_unique_and_name(self, name, value, latter=False):
        if self._TYPES[name].get("unique") is None or value is None:
            return
        if latter is True:
            self.__validate_latter__["unique"].append(
                (self._validate_unique_and_name, name, value)
            )
            return
        class_name = type(self).__name__
        unique_type = self._TYPES[name]["unique"]
        if class_name not in self.__constraints__:
            self.__constraints__[class_name] = dict()
        if unique_type == "global":
            values = self.__constraints__["global"]
        else:
            values = self.__constraints__[class_name]
        if value in values:
            self._validation_errors.append(
                "{} with {} already exists".format(name, value)
            )
            return
        if isinstance(values, list):
            values.append(value)
        self.__constraints__[class_name].update({value: self})

    def _validate_constraint(self, name, value, latter=False):
        cons = self._TYPES[name].get("constraint")
        if cons is None or value is None:
            return
        if latter is True:
            self.__validate_latter__["constraint"].append(
                (self._validate_constraint, name, value)
            )
            return
        found = False
        for c in cons:
            klass, prop = c.split(".")
            names = self.__constraints__.get(klass, {})
            props = [obj._properties.get(prop) for obj in names.values()]
            if value in props:
                found = True
                break
        if found is not True:
            self._validation_errors.append(
                "{} is not a valid type of {}".format(value, "||".join(cons))
            )
            return

    def _validate_coded(self):
        for item in self.__validate_latter__["unique"]:
            item[0](item[1], item[2])
        for item in self.__validate_latter__["constraint"]:
            item[0](item[1], item[2])
        self._clear_vars()
        if len(self._validation_errors) > 0:
            errors = "\n".join(self._validation_errors)
            self._clear_errors()
            raise Exception(errors)

    def _clear_vars(self):
        if platform.python_version_tuple()[0] == "2":
            self.__validate_latter__["unique"] = []
            self.__validate_latter__["constraint"] = []
        else:
            self.__validate_latter__["unique"].clear()
            self.__validate_latter__["constraint"].clear()

    def _clear_globals(self):
        keys = list(self.__constraints__.keys())
        for k in keys:
            if k == "global":
                self.__constraints__["global"] = []
                continue
            del self.__constraints__[k]


class OpenApiObject(OpenApiBase, OpenApiValidator):
    """Base class for any /components/schemas object

    Every OpenApiObject is reuseable within the schema so it can
    exist in multiple locations within the hierarchy.
    That means it can exist in multiple locations as a
    leaf, parent/choice or parent.
    """

    __slots__ = ("__warnings__", "_properties", "_parent", "_choice")
    _DEFAULTS = {}
    _TYPES = {}
    _REQUIRED = []
    _STATUS = {}

    def __init__(self, parent=None, choice=None):
        super(OpenApiObject, self).__init__()
        self._parent = parent
        self._choice = choice
        self._properties = {}
        self.__warnings__ = []

    @property
    def parent(self):
        return self._parent

    def _set_choice(self, name):
        if self._has_choice(name):
            for enum in self._TYPES["choice"]["enum"]:
                if enum in self._properties and name != enum:
                    self._properties.pop(enum)
            self._properties["choice"] = name

    def _has_choice(self, name):
        if (
            "choice" in dir(self)
            and "_TYPES" in dir(self)
            and "choice" in self._TYPES
            and name in self._TYPES["choice"]["enum"]
        ):
            return True
        else:
            return False

    def _get_property(self, name, default_value=None, parent=None, choice=None):
        if name in self._properties and self._properties[name] is not None:
            return self._properties[name]
        if isinstance(default_value, type) is True:
            self._set_choice(name)
            if "_choice" in default_value.__slots__:
                self._properties[name] = default_value(parent=parent, choice=choice)
            else:
                self._properties[name] = default_value(parent=parent)
            if (
                "_DEFAULTS" in dir(self._properties[name])
                and "choice" in self._properties[name]._DEFAULTS
            ):
                getattr(
                    self._properties[name],
                    self._properties[name]._DEFAULTS["choice"],
                )
        else:
            if default_value is None and name in self._DEFAULTS:
                self._set_choice(name)
                self._properties[name] = self._DEFAULTS[name]
            else:
                self._properties[name] = default_value
        return self._properties[name]

    def _set_property(self, name, value, choice=None):
        if name == "choice":

            if (
                self.parent is None
                and value is not None
                and value not in self._TYPES["choice"]["enum"]
            ):
                raise Exception(
                    "%s is not a valid choice, valid choices are %s"
                    % (value, ", ".join(self._TYPES["choice"]["enum"]))
                )

            self._set_choice(value)
            if name in self._DEFAULTS and value is None:
                self._properties[name] = self._DEFAULTS[name]
        elif name in self._DEFAULTS and value is None:
            self._set_choice(name)
            self._properties[name] = self._DEFAULTS[name]
        else:
            self._set_choice(name)
            self._properties[name] = value
        # TODO: restore behavior
        # self._validate_unique_and_name(name, value)
        # self._validate_constraint(name, value)
        if self._parent is not None and self._choice is not None and value is not None:
            self._parent._set_property("choice", self._choice)

    def _encode(self):
        """Helper method for serialization"""
        output = {}
        self._raise_status_warnings(self, None)
        self._validate_required()
        for key, value in self._properties.items():
            self._validate_types(key, value)
            # TODO: restore behavior
            # self._validate_unique_and_name(key, value, True)
            # self._validate_constraint(key, value, True)
            if isinstance(value, (OpenApiObject, OpenApiIter)):
                output[key] = value._encode()
                if isinstance(value, OpenApiObject):
                    self._raise_status_warnings(key, value)
            elif value is not None:
                if (
                    self._TYPES.get(key, {}).get("format", "") == "int64"
                    or self._TYPES.get(key, {}).get("format", "") == "uint64"
                ):
                    value = str(value)
                elif (
                    self._TYPES.get(key, {}).get("itemformat", "") == "int64"
                    or self._TYPES.get(key, {}).get("itemformat", "") == "uint64"
                ):
                    value = [str(v) for v in value]
                output[key] = value
                self._raise_status_warnings(key, value)
        return output

    def _decode(self, obj):
        dtypes = [list, str, int, float, bool]
        self._raise_status_warnings(self, None)
        for property_name, property_value in obj.items():
            if property_name in self._TYPES:
                ignore_warnings = False
                if isinstance(property_value, dict):
                    child = self._get_child_class(property_name)
                    if "choice" in child[1]._TYPES and "_parent" in child[1].__slots__:
                        property_value = child[1](self, property_name)._decode(
                            property_value
                        )
                    elif "_parent" in child[1].__slots__:
                        property_value = child[1](self)._decode(property_value)
                    else:
                        property_value = child[1]()._decode(property_value)
                elif (
                    isinstance(property_value, list)
                    and property_name in self._TYPES
                    and self._TYPES[property_name]["type"] not in dtypes
                ):
                    child = self._get_child_class(property_name, True)
                    openapi_list = child[0]()
                    for item in property_value:
                        item = child[1]()._decode(item)
                        openapi_list._items.append(item)
                    property_value = openapi_list
                    ignore_warnings = True
                elif property_name in self._DEFAULTS and property_value is None:
                    if isinstance(self._DEFAULTS[property_name], tuple(dtypes)):
                        property_value = self._DEFAULTS[property_name]
                self._set_choice(property_name)
                # convert int64(will be string on wire) to to int
                if (
                    self._TYPES[property_name].get("format", "") == "int64"
                    or self._TYPES[property_name].get("format", "") == "uint64"
                ):
                    property_value = int(property_value)
                elif (
                    self._TYPES[property_name].get("itemformat", "") == "int64"
                    or self._TYPES[property_name].get("itemformat", "") == "uint64"
                ):
                    property_value = [int(v) for v in property_value]
                self._properties[property_name] = property_value
                # TODO: restore behavior
                # OpenApiStatus.warn(
                #     "{}.{}".format(type(self).__name__, property_name), self
                # )
                if not ignore_warnings:
                    self._raise_status_warnings(property_name, property_value)
            self._validate_types(property_name, property_value)
            # TODO: restore behavior
            # self._validate_unique_and_name(property_name, property_value, True)
            # self._validate_constraint(property_name, property_value, True)
        self._validate_required()
        return self

    def _get_child_class(self, property_name, is_property_list=False):
        list_class = None
        class_name = self._TYPES[property_name]["type"]
        module = globals().get(self.__module__)
        if module is None:
            module = importlib.import_module(self.__module__)
            globals()[self.__module__] = module
        object_class = getattr(module, class_name)
        if is_property_list is True:
            list_class = object_class
            object_class = getattr(module, class_name[0:-4])
        return (list_class, object_class)

    def __str__(self):
        return self.serialize(encoding=self.YAML)

    def __deepcopy__(self, memo):
        """Creates a deep copy of the current object"""
        return self.__class__().deserialize(self.serialize())

    def __copy__(self):
        """Creates a deep copy of the current object"""
        return self.__deepcopy__(None)

    def __eq__(self, other):
        return self.__str__() == other.__str__()

    def clone(self):
        """Creates a deep copy of the current object"""
        return self.__deepcopy__(None)

    def _validate_required(self):
        """Validates the required properties are set
        Use getattr as it will set any defaults prior to validating
        """
        if getattr(self, "_REQUIRED", None) is None:
            return
        for name in self._REQUIRED:
            if self._properties.get(name) is None:
                msg = (
                    "{} is a mandatory property of {}"
                    " and should not be set to None".format(
                        name,
                        self.__class__,
                    )
                )
                raise ValueError(msg)

    def _validate_types(self, property_name, property_value):
        common_data_types = [list, str, int, float, bool]
        if property_name not in self._TYPES:
            # raise ValueError("Invalid Property {}".format(property_name))
            return
        details = self._TYPES[property_name]
        if (
            property_value is None
            and property_name not in self._DEFAULTS
            and property_name not in self._REQUIRED
        ):
            return
        if "enum" in details and property_value not in details["enum"]:
            raise_error = False
            if isinstance(property_value, list):
                for value in property_value:
                    if value not in details["enum"]:
                        raise_error = True
                        break
            elif property_value not in details["enum"]:
                raise_error = True

            if raise_error is True:
                msg = "property {} shall be one of these" " {} enum, but got {} at {}"
                raise TypeError(
                    msg.format(
                        property_name,
                        details["enum"],
                        property_value,
                        self.__class__,
                    )
                )
        if details["type"] in common_data_types and "format" not in details:
            msg = "property {} shall be of type {} at {}".format(
                property_name, details["type"], self.__class__
            )

            itemtype = (
                details.get("itemformat")
                if "itemformat" in details
                else details.get("itemtype")
            )
            self.types_validation(
                property_value,
                details["type"],
                msg,
                itemtype,
                details.get("minimum"),
                details.get("maximum"),
                details.get("minLength"),
                details.get("maxLength"),
            )

        if details["type"] not in common_data_types:
            class_name = details["type"]
            # TODO Need to revisit importlib
            module = importlib.import_module(self.__module__)
            object_class = getattr(module, class_name)
            if not isinstance(property_value, object_class):
                msg = "property {} shall be of type {}," " but got {} at {}"
                raise TypeError(
                    msg.format(
                        property_name,
                        class_name,
                        type(property_value),
                        self.__class__,
                    )
                )
        if "format" in details:
            msg = "Invalid {} format, expected {} at {}".format(
                property_value, details["format"], self.__class__
            )
            _type = details["type"] if details["type"] is list else details["format"]
            self.types_validation(
                property_value,
                _type,
                msg,
                details["format"],
                details.get("minimum"),
                details.get("maximum"),
                details.get("minLength"),
                details.get("maxLength"),
            )

    def validate(self):
        self._validate_required()
        for key, value in self._properties.items():
            self._validate_types(key, value)
        # TODO: restore behavior
        # self._validate_coded()

    def get(self, name, with_default=False):
        """
        getattr for openapi object
        """
        if self._properties.get(name) is not None:
            return self._properties[name]
        elif with_default:
            # TODO need to find a way to avoid getattr
            choice = self._properties.get("choice") if "choice" in dir(self) else None
            getattr(self, name)
            if "choice" in dir(self):
                if choice is None and "choice" in self._properties:
                    self._properties.pop("choice")
                else:
                    self._properties["choice"] = choice
            return self._properties.pop(name)
        return None

    def _raise_status_warnings(self, property_name, property_value):
        if len(self._STATUS) > 0:

            if isinstance(property_name, OpenApiObject):
                if "self" in self._STATUS and property_value is None:
                    print("[WARNING]: %s" % self._STATUS["self"])

                return

            enum_key = "%s.%s" % (property_name, property_value)
            if property_name in self._STATUS:
                print("[WARNING]: %s" % self._STATUS[property_name])
            elif enum_key in self._STATUS:
                print("[WARNING]: %s" % self._STATUS[enum_key])


class OpenApiIter(OpenApiBase):
    """Container class for OpenApiObject

    Inheriting classes contain 0..n instances of an OpenAPI components/schemas
    object.
    - config.flows.flow(name="1").flow(name="2").flow(name="3")

    The __getitem__ method allows getting an instance using ordinal.
    - config.flows[0]
    - config.flows[1:]
    - config.flows[0:1]
    - f1, f2, f3 = config.flows

    The __iter__ method allows for iterating across the encapsulated contents
    - for flow in config.flows:
    """

    __slots__ = ("_index", "_items")
    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self):
        super(OpenApiIter, self).__init__()
        self._index = -1
        self._items = []

    def __len__(self):
        return len(self._items)

    def _getitem(self, key):
        found = None
        if isinstance(key, int):
            found = self._items[key]
        elif isinstance(key, slice) is True:
            start, stop, step = key.indices(len(self))
            sliced = self.__class__()
            for i in range(start, stop, step):
                sliced._items.append(self._items[i])
            return sliced
        elif isinstance(key, str):
            for item in self._items:
                if item.name == key:
                    found = item
        if found is None:
            raise IndexError()
        if (
            self._GETITEM_RETURNS_CHOICE_OBJECT is True
            and found._properties.get("choice") is not None
            and found._properties.get(found._properties["choice"]) is not None
        ):
            return found._properties[found._properties["choice"]]
        return found

    def _iter(self):
        self._index = -1
        return self

    def _next(self):
        if self._index + 1 >= len(self._items):
            raise StopIteration
        else:
            self._index += 1
        return self.__getitem__(self._index)

    def __getitem__(self, key):
        raise NotImplementedError("This should be overridden by the generator")

    def _add(self, item):
        self._items.append(item)
        self._index = len(self._items) - 1

    def remove(self, index):
        del self._items[index]
        self._index = len(self._items) - 1

    def append(self, item):
        """Append an item to the end of OpenApiIter
        TBD: type check, raise error on mismatch
        """
        self._instanceOf(item)
        self._add(item)
        return self

    def clear(self):
        del self._items[:]
        self._index = -1

    def set(self, index, item):
        self._instanceOf(item)
        self._items[index] = item
        return self

    def _encode(self):
        return [item._encode() for item in self._items]

    def _decode(self, encoded_list):
        item_class_name = self.__class__.__name__.replace("Iter", "")
        module = importlib.import_module(self.__module__)
        object_class = getattr(module, item_class_name)
        self.clear()
        for item in encoded_list:
            self._add(object_class()._decode(item))

    def __copy__(self):
        raise NotImplementedError(
            "Shallow copy of OpenApiIter objects is not supported"
        )

    def __deepcopy__(self, memo):
        raise NotImplementedError("Deep copy of OpenApiIter objects is not supported")

    def __str__(self):
        return yaml.safe_dump(self._encode())

    def __eq__(self, other):
        return self.__str__() == other.__str__()

    def _instanceOf(self, item):
        raise NotImplementedError("validating an OpenApiIter object is not supported")


class Config(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "ports": {"type": "PortIter"},
        "lags": {"type": "LagIter"},
        "layer1": {"type": "Layer1Iter"},
        "captures": {"type": "CaptureIter"},
        "devices": {"type": "DeviceIter"},
        "flows": {"type": "FlowIter"},
        "events": {"type": "Event"},
        "options": {"type": "ConfigOptions"},
        "lldp": {"type": "LldpIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None):
        super(Config, self).__init__()
        self._parent = parent

    @property
    def ports(self):
        # type: () -> PortIter
        """ports getter

        The ports that will be configured on the traffic generator.

        Returns: PortIter
        """
        return self._get_property("ports", PortIter, self._parent, self._choice)

    @property
    def lags(self):
        # type: () -> LagIter
        """lags getter

        The LAGs that will be configured on the traffic generator.

        Returns: LagIter
        """
        return self._get_property("lags", LagIter, self._parent, self._choice)

    @property
    def layer1(self):
        # type: () -> Layer1Iter
        """layer1 getter

        The layer1 settings that will be configured on the traffic generator.

        Returns: Layer1Iter
        """
        return self._get_property("layer1", Layer1Iter, self._parent, self._choice)

    @property
    def captures(self):
        # type: () -> CaptureIter
        """captures getter

        The capture settings that will be configured on the traffic generator.

        Returns: CaptureIter
        """
        return self._get_property("captures", CaptureIter, self._parent, self._choice)

    @property
    def devices(self):
        # type: () -> DeviceIter
        """devices getter

        The emulated devices that will be configured on the traffic generator.. Each device contains configurations for network interfaces and protocols running on top of those interfaces.

        Returns: DeviceIter
        """
        return self._get_property("devices", DeviceIter, self._parent, self._choice)

    @property
    def flows(self):
        # type: () -> FlowIter
        """flows getter

        The flows that will be configured on the traffic generator.

        Returns: FlowIter
        """
        return self._get_property("flows", FlowIter, self._parent, self._choice)

    @property
    def events(self):
        # type: () -> Event
        """events getter

        The optional container for event configuration.The optional container for event configuration.The optional container for event configuration.

        Returns: Event
        """
        return self._get_property("events", Event)

    @property
    def options(self):
        # type: () -> ConfigOptions
        """options getter

        Global configuration options.Global configuration options.Global configuration options.

        Returns: ConfigOptions
        """
        return self._get_property("options", ConfigOptions)

    @property
    def lldp(self):
        # type: () -> LldpIter
        """lldp getter

        LLDP protocol that will be configured on traffic generator.

        Returns: LldpIter
        """
        return self._get_property("lldp", LldpIter, self._parent, self._choice)


class Port(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "location": {"type": str},
        "name": {"type": str},
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, location=None, name=None):
        super(Port, self).__init__()
        self._parent = parent
        self._set_property("location", location)
        self._set_property("name", name)

    def set(self, location=None, name=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def location(self):
        # type: () -> str
        """location getter

        The location of test port. It is the endpoint where packets will emit from.. Test port locations can be the following:. physical appliance with multiple ports. physical chassis with multiple cards and ports. local interface. virtual machine, docker container, kubernetes cluster. The test port location format is implementation specific. Use the /results/capabilities API to determine what formats an implementation supports for the location property.. Get the configured location state by using the /results/port API.

        Returns: str
        """
        return self._get_property("location")

    @location.setter
    def location(self, value):
        """location setter

        The location of test port. It is the endpoint where packets will emit from.. Test port locations can be the following:. physical appliance with multiple ports. physical chassis with multiple cards and ports. local interface. virtual machine, docker container, kubernetes cluster. The test port location format is implementation specific. Use the /results/capabilities API to determine what formats an implementation supports for the location property.. Get the configured location state by using the /results/port API.

        value: str
        """
        self._set_property("location", value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)


class PortIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PortIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[Port]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PortIter
        return self._iter()

    def __next__(self):
        # type: () -> Port
        return self._next()

    def next(self):
        # type: () -> Port
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, Port):
            raise Exception("Item is not an instance of Port")

    def port(self, location=None, name=None):
        # type: (str,str) -> PortIter
        """Factory method that creates an instance of the Port class

        An abstract test port.

        Returns: PortIter
        """
        item = Port(parent=self._parent, location=location, name=name)
        self._add(item)
        return self

    def add(self, location=None, name=None):
        # type: (str,str) -> Port
        """Add method that creates and returns an instance of the Port class

        An abstract test port.

        Returns: Port
        """
        item = Port(parent=self._parent, location=location, name=name)
        self._add(item)
        return item


class Lag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "ports": {"type": "LagPortIter"},
        "protocol": {"type": "LagProtocol"},
        "min_links": {
            "type": int,
            "format": "uint32",
            "maximum": 32,
        },
        "name": {"type": str},
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "min_links": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, min_links=1, name=None):
        super(Lag, self).__init__()
        self._parent = parent
        self._set_property("min_links", min_links)
        self._set_property("name", name)

    def set(self, min_links=None, name=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def ports(self):
        # type: () -> LagPortIter
        """ports getter

        TBD

        Returns: LagPortIter
        """
        return self._get_property("ports", LagPortIter, self._parent, self._choice)

    @property
    def protocol(self):
        # type: () -> LagProtocol
        """protocol getter



        Returns: LagProtocol
        """
        return self._get_property("protocol", LagProtocol)

    @property
    def min_links(self):
        # type: () -> int
        """min_links getter

        Specifies the mininum number of member interfaces that must be active for the aggregate interface to be available.. If the aggregate interface is not available due to min-links criterion not being met, LACPDUs continue to be transmitted and received by the member interfaces if LACP is enabled, but other PDUs are not transmitted or received.

        Returns: int
        """
        return self._get_property("min_links")

    @min_links.setter
    def min_links(self, value):
        """min_links setter

        Specifies the mininum number of member interfaces that must be active for the aggregate interface to be available.. If the aggregate interface is not available due to min-links criterion not being met, LACPDUs continue to be transmitted and received by the member interfaces if LACP is enabled, but other PDUs are not transmitted or received.

        value: int
        """
        self._set_property("min_links", value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)


class LagPort(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "port_name": {"type": str},
        "lacp": {"type": "LagPortLacp"},
        "ethernet": {"type": "DeviceEthernetBase"},
    }  # type: Dict[str, str]

    _REQUIRED = ("port_name", "ethernet")  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, port_name=None):
        super(LagPort, self).__init__()
        self._parent = parent
        self._set_property("port_name", port_name)

    def set(self, port_name=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def port_name(self):
        # type: () -> str
        """port_name getter

        The name of port object that will be part of the LAG. . x-constraint:. /components/schemas/Port/properties/name. . x-constraint:. /components/schemas/Port/properties/name.

        Returns: str
        """
        return self._get_property("port_name")

    @port_name.setter
    def port_name(self, value):
        """port_name setter

        The name of port object that will be part of the LAG. . x-constraint:. /components/schemas/Port/properties/name. . x-constraint:. /components/schemas/Port/properties/name.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property port_name as None")
        self._set_property("port_name", value)

    @property
    def lacp(self):
        # type: () -> LagPortLacp
        """lacp getter

        The container for link aggregation control protocol settings of LAG member (port).The container for link aggregation control protocol settings of LAG member (port).The container for link aggregation control protocol settings of LAG member (port).

        Returns: LagPortLacp
        """
        return self._get_property("lacp", LagPortLacp)

    @property
    def ethernet(self):
        # type: () -> DeviceEthernetBase
        """ethernet getter

        Base Ethernet interface.Base Ethernet interface.Base Ethernet interface.

        Returns: DeviceEthernetBase
        """
        return self._get_property("ethernet", DeviceEthernetBase)


class LagPortLacp(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "actor_port_number": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "actor_port_priority": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "actor_activity": {
            "type": str,
            "enum": [
                "passive",
                "active",
            ],
        },
        "lacpdu_periodic_time_interval": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "lacpdu_timeout": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "actor_port_number": 0,
        "actor_port_priority": 1,
        "actor_activity": "active",
        "lacpdu_periodic_time_interval": 0,
        "lacpdu_timeout": 0,
    }  # type: Dict[str, Union(type)]

    PASSIVE = "passive"  # type: str
    ACTIVE = "active"  # type: str

    FAST = 1  #
    SLOW = 30  #
    AUTO = 0  #

    SHORT = 3  #
    LONG = 90  #
    AUTO = 0  #

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        actor_port_number=0,
        actor_port_priority=1,
        actor_activity="active",
        lacpdu_periodic_time_interval=0,
        lacpdu_timeout=0,
    ):
        super(LagPortLacp, self).__init__()
        self._parent = parent
        self._set_property("actor_port_number", actor_port_number)
        self._set_property("actor_port_priority", actor_port_priority)
        self._set_property("actor_activity", actor_activity)
        self._set_property(
            "lacpdu_periodic_time_interval", lacpdu_periodic_time_interval
        )
        self._set_property("lacpdu_timeout", lacpdu_timeout)

    def set(
        self,
        actor_port_number=None,
        actor_port_priority=None,
        actor_activity=None,
        lacpdu_periodic_time_interval=None,
        lacpdu_timeout=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def actor_port_number(self):
        # type: () -> int
        """actor_port_number getter

        The actor port number

        Returns: int
        """
        return self._get_property("actor_port_number")

    @actor_port_number.setter
    def actor_port_number(self, value):
        """actor_port_number setter

        The actor port number

        value: int
        """
        self._set_property("actor_port_number", value)

    @property
    def actor_port_priority(self):
        # type: () -> int
        """actor_port_priority getter

        The actor port priority

        Returns: int
        """
        return self._get_property("actor_port_priority")

    @actor_port_priority.setter
    def actor_port_priority(self, value):
        """actor_port_priority setter

        The actor port priority

        value: int
        """
        self._set_property("actor_port_priority", value)

    @property
    def actor_activity(self):
        # type: () -> Union[Literal["active"], Literal["passive"]]
        """actor_activity getter

        Sets the value of LACP actor activity as either passive or active.. Passive indicates the port's preference for not transmitting LACPDUs unless its partner's control is Active.. Active indicates the port's preference to participate in the protocol regardless of the partner's control value.

        Returns: Union[Literal["active"], Literal["passive"]]
        """
        return self._get_property("actor_activity")

    @actor_activity.setter
    def actor_activity(self, value):
        """actor_activity setter

        Sets the value of LACP actor activity as either passive or active.. Passive indicates the port's preference for not transmitting LACPDUs unless its partner's control is Active.. Active indicates the port's preference to participate in the protocol regardless of the partner's control value.

        value: Union[Literal["active"], Literal["passive"]]
        """
        self._set_property("actor_activity", value)

    @property
    def lacpdu_periodic_time_interval(self):
        # type: () -> int
        """lacpdu_periodic_time_interval getter

        This field defines how frequently LACPDUs are sent to the link partner

        Returns: int
        """
        return self._get_property("lacpdu_periodic_time_interval")

    @lacpdu_periodic_time_interval.setter
    def lacpdu_periodic_time_interval(self, value):
        """lacpdu_periodic_time_interval setter

        This field defines how frequently LACPDUs are sent to the link partner

        value: int
        """
        self._set_property("lacpdu_periodic_time_interval", value)

    @property
    def lacpdu_timeout(self):
        # type: () -> int
        """lacpdu_timeout getter

        This timer is used to detect whether received protocol information has expired

        Returns: int
        """
        return self._get_property("lacpdu_timeout")

    @lacpdu_timeout.setter
    def lacpdu_timeout(self, value):
        """lacpdu_timeout setter

        This timer is used to detect whether received protocol information has expired

        value: int
        """
        self._set_property("lacpdu_timeout", value)


class DeviceEthernetBase(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "mac": {
            "type": str,
            "format": "mac",
        },
        "mtu": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "vlans": {"type": "DeviceVlanIter"},
        "name": {"type": str},
    }  # type: Dict[str, str]

    _REQUIRED = ("mac", "name")  # type: tuple(str)

    _DEFAULTS = {
        "mtu": 1500,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, mac=None, mtu=1500, name=None):
        super(DeviceEthernetBase, self).__init__()
        self._parent = parent
        self._set_property("mac", mac)
        self._set_property("mtu", mtu)
        self._set_property("name", name)

    def set(self, mac=None, mtu=None, name=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def mac(self):
        # type: () -> str
        """mac getter

        Media Access Control address.

        Returns: str
        """
        return self._get_property("mac")

    @mac.setter
    def mac(self, value):
        """mac setter

        Media Access Control address.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property mac as None")
        self._set_property("mac", value)

    @property
    def mtu(self):
        # type: () -> int
        """mtu getter

        Maximum Transmission Unit.

        Returns: int
        """
        return self._get_property("mtu")

    @mtu.setter
    def mtu(self, value):
        """mtu setter

        Maximum Transmission Unit.

        value: int
        """
        self._set_property("mtu", value)

    @property
    def vlans(self):
        # type: () -> DeviceVlanIter
        """vlans getter

        List of VLANs

        Returns: DeviceVlanIter
        """
        return self._get_property("vlans", DeviceVlanIter, self._parent, self._choice)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)


class DeviceVlan(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "tpid": {
            "type": str,
            "enum": [
                "x8100",
                "x88A8",
                "x9100",
                "x9200",
                "x9300",
            ],
        },
        "priority": {
            "type": int,
            "format": "uint32",
            "maximum": 3,
        },
        "id": {
            "type": int,
            "format": "uint32",
            "maximum": 4095,
        },
        "name": {"type": str},
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "tpid": "x8100",
        "priority": 0,
        "id": 1,
    }  # type: Dict[str, Union(type)]

    X8100 = "x8100"  # type: str
    X88A8 = "x88A8"  # type: str
    X9100 = "x9100"  # type: str
    X9200 = "x9200"  # type: str
    X9300 = "x9300"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, tpid="x8100", priority=0, id=1, name=None):
        super(DeviceVlan, self).__init__()
        self._parent = parent
        self._set_property("tpid", tpid)
        self._set_property("priority", priority)
        self._set_property("id", id)
        self._set_property("name", name)

    def set(self, tpid=None, priority=None, id=None, name=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def tpid(self):
        # type: () -> Union[Literal["x8100"], Literal["x88A8"], Literal["x9100"], Literal["x9200"], Literal["x9300"]]
        """tpid getter

        Tag protocol identifier

        Returns: Union[Literal["x8100"], Literal["x88A8"], Literal["x9100"], Literal["x9200"], Literal["x9300"]]
        """
        return self._get_property("tpid")

    @tpid.setter
    def tpid(self, value):
        """tpid setter

        Tag protocol identifier

        value: Union[Literal["x8100"], Literal["x88A8"], Literal["x9100"], Literal["x9200"], Literal["x9300"]]
        """
        self._set_property("tpid", value)

    @property
    def priority(self):
        # type: () -> int
        """priority getter

        Priority code point

        Returns: int
        """
        return self._get_property("priority")

    @priority.setter
    def priority(self, value):
        """priority setter

        Priority code point

        value: int
        """
        self._set_property("priority", value)

    @property
    def id(self):
        # type: () -> int
        """id getter

        VLAN identifier

        Returns: int
        """
        return self._get_property("id")

    @id.setter
    def id(self, value):
        """id setter

        VLAN identifier

        value: int
        """
        self._set_property("id", value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)


class DeviceVlanIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(DeviceVlanIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[DeviceVlan]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> DeviceVlanIter
        return self._iter()

    def __next__(self):
        # type: () -> DeviceVlan
        return self._next()

    def next(self):
        # type: () -> DeviceVlan
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, DeviceVlan):
            raise Exception("Item is not an instance of DeviceVlan")

    def vlan(self, tpid="x8100", priority=0, id=1, name=None):
        # type: (Union[Literal["x8100"], Literal["x88A8"], Literal["x9100"], Literal["x9200"], Literal["x9300"]],int,int,str) -> DeviceVlanIter
        """Factory method that creates an instance of the DeviceVlan class

        Emulated VLAN protocol.

        Returns: DeviceVlanIter
        """
        item = DeviceVlan(
            parent=self._parent, tpid=tpid, priority=priority, id=id, name=name
        )
        self._add(item)
        return self

    def add(self, tpid="x8100", priority=0, id=1, name=None):
        # type: (Union[Literal["x8100"], Literal["x88A8"], Literal["x9100"], Literal["x9200"], Literal["x9300"]],int,int,str) -> DeviceVlan
        """Add method that creates and returns an instance of the DeviceVlan class

        Emulated VLAN protocol.

        Returns: DeviceVlan
        """
        item = DeviceVlan(
            parent=self._parent, tpid=tpid, priority=priority, id=id, name=name
        )
        self._add(item)
        return item


class LagPortIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(LagPortIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[LagPort]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> LagPortIter
        return self._iter()

    def __next__(self):
        # type: () -> LagPort
        return self._next()

    def next(self):
        # type: () -> LagPort
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, LagPort):
            raise Exception("Item is not an instance of LagPort")

    def port(self, port_name=None):
        # type: (str) -> LagPortIter
        """Factory method that creates an instance of the LagPort class

        The container for port's ethernet interface and LAG protocol settings

        Returns: LagPortIter
        """
        item = LagPort(parent=self._parent, port_name=port_name)
        self._add(item)
        return self

    def add(self, port_name=None):
        # type: (str) -> LagPort
        """Add method that creates and returns an instance of the LagPort class

        The container for port's ethernet interface and LAG protocol settings

        Returns: LagPort
        """
        item = LagPort(parent=self._parent, port_name=port_name)
        self._add(item)
        return item


class LagProtocol(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "lacp",
                "static",
            ],
        },
        "lacp": {"type": "LagProtocolLacp"},
        "static": {"type": "LagProtocolStatic"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "lacp",
    }  # type: Dict[str, Union(type)]

    LACP = "lacp"  # type: str
    STATIC = "static"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None):
        super(LagProtocol, self).__init__()
        self._parent = parent
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    @property
    def lacp(self):
        # type: () -> LagProtocolLacp
        """Factory property that returns an instance of the LagProtocolLacp class

        The container for link aggregation control protocol settings of LAG (ports group).

        Returns: LagProtocolLacp
        """
        return self._get_property("lacp", LagProtocolLacp, self, "lacp")

    @property
    def static(self):
        # type: () -> LagProtocolStatic
        """Factory property that returns an instance of the LagProtocolStatic class

        The container for static link aggregation protocol settings.

        Returns: LagProtocolStatic
        """
        return self._get_property("static", LagProtocolStatic, self, "static")

    @property
    def choice(self):
        # type: () -> Union[Literal["lacp"], Literal["static"]]
        """choice getter

        The type of controlling protocol for the LAG (ports group).

        Returns: Union[Literal["lacp"], Literal["static"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        The type of controlling protocol for the LAG (ports group).

        value: Union[Literal["lacp"], Literal["static"]]
        """
        self._set_property("choice", value)


class LagProtocolLacp(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "actor_system_id": {
            "type": str,
            "format": "mac",
        },
        "actor_system_priority": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "actor_key": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "actor_system_id": "00:00:00:00:00:00",
        "actor_system_priority": 0,
        "actor_key": 0,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        actor_system_id="00:00:00:00:00:00",
        actor_system_priority=0,
        actor_key=0,
    ):
        super(LagProtocolLacp, self).__init__()
        self._parent = parent
        self._set_property("actor_system_id", actor_system_id)
        self._set_property("actor_system_priority", actor_system_priority)
        self._set_property("actor_key", actor_key)

    def set(self, actor_system_id=None, actor_system_priority=None, actor_key=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def actor_system_id(self):
        # type: () -> str
        """actor_system_id getter

        The actor system id

        Returns: str
        """
        return self._get_property("actor_system_id")

    @actor_system_id.setter
    def actor_system_id(self, value):
        """actor_system_id setter

        The actor system id

        value: str
        """
        self._set_property("actor_system_id", value)

    @property
    def actor_system_priority(self):
        # type: () -> int
        """actor_system_priority getter

        The actor system priority

        Returns: int
        """
        return self._get_property("actor_system_priority")

    @actor_system_priority.setter
    def actor_system_priority(self, value):
        """actor_system_priority setter

        The actor system priority

        value: int
        """
        self._set_property("actor_system_priority", value)

    @property
    def actor_key(self):
        # type: () -> int
        """actor_key getter

        The actor key

        Returns: int
        """
        return self._get_property("actor_key")

    @actor_key.setter
    def actor_key(self, value):
        """actor_key setter

        The actor key

        value: int
        """
        self._set_property("actor_key", value)


class LagProtocolStatic(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "lag_id": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "lag_id": 0,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, lag_id=0):
        super(LagProtocolStatic, self).__init__()
        self._parent = parent
        self._set_property("lag_id", lag_id)

    def set(self, lag_id=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def lag_id(self):
        # type: () -> int
        """lag_id getter

        The static lag id

        Returns: int
        """
        return self._get_property("lag_id")

    @lag_id.setter
    def lag_id(self, value):
        """lag_id setter

        The static lag id

        value: int
        """
        self._set_property("lag_id", value)


class LagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(LagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[Lag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> LagIter
        return self._iter()

    def __next__(self):
        # type: () -> Lag
        return self._next()

    def next(self):
        # type: () -> Lag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, Lag):
            raise Exception("Item is not an instance of Lag")

    def lag(self, min_links=1, name=None):
        # type: (int,str) -> LagIter
        """Factory method that creates an instance of the Lag class

        The container for LAG (ports group) aggregation of multiple LAG members (ports)

        Returns: LagIter
        """
        item = Lag(parent=self._parent, min_links=min_links, name=name)
        self._add(item)
        return self

    def add(self, min_links=1, name=None):
        # type: (int,str) -> Lag
        """Add method that creates and returns an instance of the Lag class

        The container for LAG (ports group) aggregation of multiple LAG members (ports)

        Returns: Lag
        """
        item = Lag(parent=self._parent, min_links=min_links, name=name)
        self._add(item)
        return item


class Layer1(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "port_names": {
            "type": list,
            "itemtype": str,
        },
        "speed": {
            "type": str,
            "enum": [
                "speed_10_fd_mbps",
                "speed_10_hd_mbps",
                "speed_100_fd_mbps",
                "speed_100_hd_mbps",
                "speed_1_gbps",
                "speed_10_gbps",
                "speed_25_gbps",
                "speed_40_gbps",
                "speed_50_gbps",
                "speed_100_gbps",
                "speed_200_gbps",
                "speed_400_gbps",
            ],
        },
        "media": {
            "type": str,
            "enum": [
                "copper",
                "fiber",
                "sgmii",
            ],
        },
        "promiscuous": {"type": bool},
        "mtu": {
            "type": int,
            "format": "uint32",
            "minimum": 64,
            "maximum": 9000,
        },
        "ieee_media_defaults": {"type": bool},
        "auto_negotiate": {"type": bool},
        "auto_negotiation": {"type": "Layer1AutoNegotiation"},
        "flow_control": {"type": "Layer1FlowControl"},
        "name": {"type": str},
    }  # type: Dict[str, str]

    _REQUIRED = ("port_names", "name")  # type: tuple(str)

    _DEFAULTS = {
        "speed": "speed_10_gbps",
        "promiscuous": True,
        "mtu": 1500,
    }  # type: Dict[str, Union(type)]

    SPEED_10_FD_MBPS = "speed_10_fd_mbps"  # type: str
    SPEED_10_HD_MBPS = "speed_10_hd_mbps"  # type: str
    SPEED_100_FD_MBPS = "speed_100_fd_mbps"  # type: str
    SPEED_100_HD_MBPS = "speed_100_hd_mbps"  # type: str
    SPEED_1_GBPS = "speed_1_gbps"  # type: str
    SPEED_10_GBPS = "speed_10_gbps"  # type: str
    SPEED_25_GBPS = "speed_25_gbps"  # type: str
    SPEED_40_GBPS = "speed_40_gbps"  # type: str
    SPEED_50_GBPS = "speed_50_gbps"  # type: str
    SPEED_100_GBPS = "speed_100_gbps"  # type: str
    SPEED_200_GBPS = "speed_200_gbps"  # type: str
    SPEED_400_GBPS = "speed_400_gbps"  # type: str

    COPPER = "copper"  # type: str
    FIBER = "fiber"  # type: str
    SGMII = "sgmii"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        port_names=None,
        speed="speed_10_gbps",
        media=None,
        promiscuous=True,
        mtu=1500,
        ieee_media_defaults=None,
        auto_negotiate=None,
        name=None,
    ):
        super(Layer1, self).__init__()
        self._parent = parent
        self._set_property("port_names", port_names)
        self._set_property("speed", speed)
        self._set_property("media", media)
        self._set_property("promiscuous", promiscuous)
        self._set_property("mtu", mtu)
        self._set_property("ieee_media_defaults", ieee_media_defaults)
        self._set_property("auto_negotiate", auto_negotiate)
        self._set_property("name", name)

    def set(
        self,
        port_names=None,
        speed=None,
        media=None,
        promiscuous=None,
        mtu=None,
        ieee_media_defaults=None,
        auto_negotiate=None,
        name=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def port_names(self):
        # type: () -> List[str]
        """port_names getter

        A list of unique names of port objects that will share the. choice settings. . x-constraint:. /components/schemas/Port/properties/name. . x-constraint:. /components/schemas/Port/properties/name.

        Returns: List[str]
        """
        return self._get_property("port_names")

    @port_names.setter
    def port_names(self, value):
        """port_names setter

        A list of unique names of port objects that will share the. choice settings. . x-constraint:. /components/schemas/Port/properties/name. . x-constraint:. /components/schemas/Port/properties/name.

        value: List[str]
        """
        if value is None:
            raise TypeError("Cannot set required property port_names as None")
        self._set_property("port_names", value)

    @property
    def speed(self):
        # type: () -> Union[Literal["speed_100_fd_mbps"], Literal["speed_100_gbps"], Literal["speed_100_hd_mbps"], Literal["speed_10_fd_mbps"], Literal["speed_10_gbps"], Literal["speed_10_hd_mbps"], Literal["speed_1_gbps"], Literal["speed_200_gbps"], Literal["speed_25_gbps"], Literal["speed_400_gbps"], Literal["speed_40_gbps"], Literal["speed_50_gbps"]]
        """speed getter

        Set the speed if supported.

        Returns: Union[Literal["speed_100_fd_mbps"], Literal["speed_100_gbps"], Literal["speed_100_hd_mbps"], Literal["speed_10_fd_mbps"], Literal["speed_10_gbps"], Literal["speed_10_hd_mbps"], Literal["speed_1_gbps"], Literal["speed_200_gbps"], Literal["speed_25_gbps"], Literal["speed_400_gbps"], Literal["speed_40_gbps"], Literal["speed_50_gbps"]]
        """
        return self._get_property("speed")

    @speed.setter
    def speed(self, value):
        """speed setter

        Set the speed if supported.

        value: Union[Literal["speed_100_fd_mbps"], Literal["speed_100_gbps"], Literal["speed_100_hd_mbps"], Literal["speed_10_fd_mbps"], Literal["speed_10_gbps"], Literal["speed_10_hd_mbps"], Literal["speed_1_gbps"], Literal["speed_200_gbps"], Literal["speed_25_gbps"], Literal["speed_400_gbps"], Literal["speed_40_gbps"], Literal["speed_50_gbps"]]
        """
        self._set_property("speed", value)

    @property
    def media(self):
        # type: () -> Union[Literal["copper"], Literal["fiber"], Literal["sgmii"]]
        """media getter

        Set the type of media interface if supported.

        Returns: Union[Literal["copper"], Literal["fiber"], Literal["sgmii"]]
        """
        return self._get_property("media")

    @media.setter
    def media(self, value):
        """media setter

        Set the type of media interface if supported.

        value: Union[Literal["copper"], Literal["fiber"], Literal["sgmii"]]
        """
        self._set_property("media", value)

    @property
    def promiscuous(self):
        # type: () -> bool
        """promiscuous getter

        Enable promiscuous mode if supported.

        Returns: bool
        """
        return self._get_property("promiscuous")

    @promiscuous.setter
    def promiscuous(self, value):
        """promiscuous setter

        Enable promiscuous mode if supported.

        value: bool
        """
        self._set_property("promiscuous", value)

    @property
    def mtu(self):
        # type: () -> int
        """mtu getter

        Set the maximum transmission unit size if supported.

        Returns: int
        """
        return self._get_property("mtu")

    @mtu.setter
    def mtu(self, value):
        """mtu setter

        Set the maximum transmission unit size if supported.

        value: int
        """
        self._set_property("mtu", value)

    @property
    def ieee_media_defaults(self):
        # type: () -> bool
        """ieee_media_defaults getter

        Set to true to override the auto_negotiate, link_training. and rs_fec settings for gigabit ethernet interfaces.

        Returns: bool
        """
        return self._get_property("ieee_media_defaults")

    @ieee_media_defaults.setter
    def ieee_media_defaults(self, value):
        """ieee_media_defaults setter

        Set to true to override the auto_negotiate, link_training. and rs_fec settings for gigabit ethernet interfaces.

        value: bool
        """
        self._set_property("ieee_media_defaults", value)

    @property
    def auto_negotiate(self):
        # type: () -> bool
        """auto_negotiate getter

        Enable/disable auto negotiation.

        Returns: bool
        """
        return self._get_property("auto_negotiate")

    @auto_negotiate.setter
    def auto_negotiate(self, value):
        """auto_negotiate setter

        Enable/disable auto negotiation.

        value: bool
        """
        self._set_property("auto_negotiate", value)

    @property
    def auto_negotiation(self):
        # type: () -> Layer1AutoNegotiation
        """auto_negotiation getter

        Configuration for auto negotiation settingsConfiguration for auto negotiation settingsConfiguration for auto negotiation settings

        Returns: Layer1AutoNegotiation
        """
        return self._get_property("auto_negotiation", Layer1AutoNegotiation)

    @property
    def flow_control(self):
        # type: () -> Layer1FlowControl
        """flow_control getter

        A container for layer1 receive flow control settings.. To enable flow control settings on ports this object must be valid. object not null value.A container for layer1 receive flow control settings.. To enable flow control settings on ports this object must be valid. object not null value.A container for layer1 receive flow control settings.. To enable flow control settings on ports this object must be valid. object not null value.

        Returns: Layer1FlowControl
        """
        return self._get_property("flow_control", Layer1FlowControl)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)


class Layer1AutoNegotiation(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "advertise_1000_mbps": {"type": bool},
        "advertise_100_fd_mbps": {"type": bool},
        "advertise_100_hd_mbps": {"type": bool},
        "advertise_10_fd_mbps": {"type": bool},
        "advertise_10_hd_mbps": {"type": bool},
        "link_training": {"type": bool},
        "rs_fec": {"type": bool},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "advertise_1000_mbps": True,
        "advertise_100_fd_mbps": True,
        "advertise_100_hd_mbps": True,
        "advertise_10_fd_mbps": True,
        "advertise_10_hd_mbps": True,
        "link_training": False,
        "rs_fec": False,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        advertise_1000_mbps=True,
        advertise_100_fd_mbps=True,
        advertise_100_hd_mbps=True,
        advertise_10_fd_mbps=True,
        advertise_10_hd_mbps=True,
        link_training=False,
        rs_fec=False,
    ):
        super(Layer1AutoNegotiation, self).__init__()
        self._parent = parent
        self._set_property("advertise_1000_mbps", advertise_1000_mbps)
        self._set_property("advertise_100_fd_mbps", advertise_100_fd_mbps)
        self._set_property("advertise_100_hd_mbps", advertise_100_hd_mbps)
        self._set_property("advertise_10_fd_mbps", advertise_10_fd_mbps)
        self._set_property("advertise_10_hd_mbps", advertise_10_hd_mbps)
        self._set_property("link_training", link_training)
        self._set_property("rs_fec", rs_fec)

    def set(
        self,
        advertise_1000_mbps=None,
        advertise_100_fd_mbps=None,
        advertise_100_hd_mbps=None,
        advertise_10_fd_mbps=None,
        advertise_10_hd_mbps=None,
        link_training=None,
        rs_fec=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def advertise_1000_mbps(self):
        # type: () -> bool
        """advertise_1000_mbps getter

        If auto_negotiate is true and the interface supports this option. then this speed will be advertised.

        Returns: bool
        """
        return self._get_property("advertise_1000_mbps")

    @advertise_1000_mbps.setter
    def advertise_1000_mbps(self, value):
        """advertise_1000_mbps setter

        If auto_negotiate is true and the interface supports this option. then this speed will be advertised.

        value: bool
        """
        self._set_property("advertise_1000_mbps", value)

    @property
    def advertise_100_fd_mbps(self):
        # type: () -> bool
        """advertise_100_fd_mbps getter

        If auto_negotiate is true and the interface supports this option. then this speed will be advertised.

        Returns: bool
        """
        return self._get_property("advertise_100_fd_mbps")

    @advertise_100_fd_mbps.setter
    def advertise_100_fd_mbps(self, value):
        """advertise_100_fd_mbps setter

        If auto_negotiate is true and the interface supports this option. then this speed will be advertised.

        value: bool
        """
        self._set_property("advertise_100_fd_mbps", value)

    @property
    def advertise_100_hd_mbps(self):
        # type: () -> bool
        """advertise_100_hd_mbps getter

        If auto_negotiate is true and the interface supports this option. then this speed will be advertised.

        Returns: bool
        """
        return self._get_property("advertise_100_hd_mbps")

    @advertise_100_hd_mbps.setter
    def advertise_100_hd_mbps(self, value):
        """advertise_100_hd_mbps setter

        If auto_negotiate is true and the interface supports this option. then this speed will be advertised.

        value: bool
        """
        self._set_property("advertise_100_hd_mbps", value)

    @property
    def advertise_10_fd_mbps(self):
        # type: () -> bool
        """advertise_10_fd_mbps getter

        If auto_negotiate is true and the interface supports this option. then this speed will be advertised.

        Returns: bool
        """
        return self._get_property("advertise_10_fd_mbps")

    @advertise_10_fd_mbps.setter
    def advertise_10_fd_mbps(self, value):
        """advertise_10_fd_mbps setter

        If auto_negotiate is true and the interface supports this option. then this speed will be advertised.

        value: bool
        """
        self._set_property("advertise_10_fd_mbps", value)

    @property
    def advertise_10_hd_mbps(self):
        # type: () -> bool
        """advertise_10_hd_mbps getter

        If auto_negotiate is true and the interface supports this option. then this speed will be advertised.

        Returns: bool
        """
        return self._get_property("advertise_10_hd_mbps")

    @advertise_10_hd_mbps.setter
    def advertise_10_hd_mbps(self, value):
        """advertise_10_hd_mbps setter

        If auto_negotiate is true and the interface supports this option. then this speed will be advertised.

        value: bool
        """
        self._set_property("advertise_10_hd_mbps", value)

    @property
    def link_training(self):
        # type: () -> bool
        """link_training getter

        Enable/disable gigabit ethernet link training.

        Returns: bool
        """
        return self._get_property("link_training")

    @link_training.setter
    def link_training(self, value):
        """link_training setter

        Enable/disable gigabit ethernet link training.

        value: bool
        """
        self._set_property("link_training", value)

    @property
    def rs_fec(self):
        # type: () -> bool
        """rs_fec getter

        Enable/disable gigabit ethernet reed solomon forward error correction (RS FEC).

        Returns: bool
        """
        return self._get_property("rs_fec")

    @rs_fec.setter
    def rs_fec(self, value):
        """rs_fec setter

        Enable/disable gigabit ethernet reed solomon forward error correction (RS FEC).

        value: bool
        """
        self._set_property("rs_fec", value)


class Layer1FlowControl(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "directed_address": {
            "type": str,
            "format": "mac",
        },
        "choice": {
            "type": str,
            "enum": [
                "ieee_802_1qbb",
                "ieee_802_3x",
            ],
        },
        "ieee_802_1qbb": {"type": "Layer1Ieee8021qbb"},
        "ieee_802_3x": {"type": "Layer1Ieee8023x"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "directed_address": "01:80:C2:00:00:01",
        "choice": "ieee_802_1qbb",
    }  # type: Dict[str, Union(type)]

    IEEE_802_1QBB = "ieee_802_1qbb"  # type: str
    IEEE_802_3X = "ieee_802_3x"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, directed_address="01:80:C2:00:00:01"):
        super(Layer1FlowControl, self).__init__()
        self._parent = parent
        self._set_property("directed_address", directed_address)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, directed_address=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def ieee_802_1qbb(self):
        # type: () -> Layer1Ieee8021qbb
        """Factory property that returns an instance of the Layer1Ieee8021qbb class

        These settings enhance the existing 802.3x pause priority capabilities to enable flow control based on 802.1p priorities (classes of service).

        Returns: Layer1Ieee8021qbb
        """
        return self._get_property(
            "ieee_802_1qbb", Layer1Ieee8021qbb, self, "ieee_802_1qbb"
        )

    @property
    def ieee_802_3x(self):
        # type: () -> Layer1Ieee8023x
        """Factory property that returns an instance of the Layer1Ieee8023x class

        A container for ieee 802.3x rx pause settings

        Returns: Layer1Ieee8023x
        """
        return self._get_property("ieee_802_3x", Layer1Ieee8023x, self, "ieee_802_3x")

    @property
    def directed_address(self):
        # type: () -> str
        """directed_address getter

        The 48bit mac address that the layer1 port names will listen on. for directed pause.

        Returns: str
        """
        return self._get_property("directed_address")

    @directed_address.setter
    def directed_address(self, value):
        """directed_address setter

        The 48bit mac address that the layer1 port names will listen on. for directed pause.

        value: str
        """
        self._set_property("directed_address", value)

    @property
    def choice(self):
        # type: () -> Union[Literal["ieee_802_1qbb"], Literal["ieee_802_3x"]]
        """choice getter

        The type of priority flow control.

        Returns: Union[Literal["ieee_802_1qbb"], Literal["ieee_802_3x"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        The type of priority flow control.

        value: Union[Literal["ieee_802_1qbb"], Literal["ieee_802_3x"]]
        """
        self._set_property("choice", value)


class Layer1Ieee8021qbb(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "pfc_delay": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "pfc_class_0": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "pfc_class_1": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "pfc_class_2": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "pfc_class_3": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "pfc_class_4": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "pfc_class_5": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "pfc_class_6": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "pfc_class_7": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "pfc_delay": 0,
        "pfc_class_0": 0,
        "pfc_class_1": 1,
        "pfc_class_2": 2,
        "pfc_class_3": 3,
        "pfc_class_4": 4,
        "pfc_class_5": 5,
        "pfc_class_6": 6,
        "pfc_class_7": 7,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        pfc_delay=0,
        pfc_class_0=0,
        pfc_class_1=1,
        pfc_class_2=2,
        pfc_class_3=3,
        pfc_class_4=4,
        pfc_class_5=5,
        pfc_class_6=6,
        pfc_class_7=7,
    ):
        super(Layer1Ieee8021qbb, self).__init__()
        self._parent = parent
        self._set_property("pfc_delay", pfc_delay)
        self._set_property("pfc_class_0", pfc_class_0)
        self._set_property("pfc_class_1", pfc_class_1)
        self._set_property("pfc_class_2", pfc_class_2)
        self._set_property("pfc_class_3", pfc_class_3)
        self._set_property("pfc_class_4", pfc_class_4)
        self._set_property("pfc_class_5", pfc_class_5)
        self._set_property("pfc_class_6", pfc_class_6)
        self._set_property("pfc_class_7", pfc_class_7)

    def set(
        self,
        pfc_delay=None,
        pfc_class_0=None,
        pfc_class_1=None,
        pfc_class_2=None,
        pfc_class_3=None,
        pfc_class_4=None,
        pfc_class_5=None,
        pfc_class_6=None,
        pfc_class_7=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def pfc_delay(self):
        # type: () -> int
        """pfc_delay getter

        The upper limit on the transmit time of queue after receiving . message to pause specified priority.. value of or null indicates that pfc delay will not be enabled.

        Returns: int
        """
        return self._get_property("pfc_delay")

    @pfc_delay.setter
    def pfc_delay(self, value):
        """pfc_delay setter

        The upper limit on the transmit time of queue after receiving . message to pause specified priority.. value of or null indicates that pfc delay will not be enabled.

        value: int
        """
        self._set_property("pfc_delay", value)

    @property
    def pfc_class_0(self):
        # type: () -> int
        """pfc_class_0 getter

        The valid values are null, - 7.. null value indicates there is no setting for this pfc class.

        Returns: int
        """
        return self._get_property("pfc_class_0")

    @pfc_class_0.setter
    def pfc_class_0(self, value):
        """pfc_class_0 setter

        The valid values are null, - 7.. null value indicates there is no setting for this pfc class.

        value: int
        """
        self._set_property("pfc_class_0", value)

    @property
    def pfc_class_1(self):
        # type: () -> int
        """pfc_class_1 getter

        The valid values are null, - 7.. null value indicates there is no setting for this pfc class.

        Returns: int
        """
        return self._get_property("pfc_class_1")

    @pfc_class_1.setter
    def pfc_class_1(self, value):
        """pfc_class_1 setter

        The valid values are null, - 7.. null value indicates there is no setting for this pfc class.

        value: int
        """
        self._set_property("pfc_class_1", value)

    @property
    def pfc_class_2(self):
        # type: () -> int
        """pfc_class_2 getter

        The valid values are null, - 7.. null value indicates there is no setting for this pfc class.

        Returns: int
        """
        return self._get_property("pfc_class_2")

    @pfc_class_2.setter
    def pfc_class_2(self, value):
        """pfc_class_2 setter

        The valid values are null, - 7.. null value indicates there is no setting for this pfc class.

        value: int
        """
        self._set_property("pfc_class_2", value)

    @property
    def pfc_class_3(self):
        # type: () -> int
        """pfc_class_3 getter

        The valid values are null, - 7.. null value indicates there is no setting for this pfc class.

        Returns: int
        """
        return self._get_property("pfc_class_3")

    @pfc_class_3.setter
    def pfc_class_3(self, value):
        """pfc_class_3 setter

        The valid values are null, - 7.. null value indicates there is no setting for this pfc class.

        value: int
        """
        self._set_property("pfc_class_3", value)

    @property
    def pfc_class_4(self):
        # type: () -> int
        """pfc_class_4 getter

        The valid values are null, - 7.. null value indicates there is no setting for this pfc class.

        Returns: int
        """
        return self._get_property("pfc_class_4")

    @pfc_class_4.setter
    def pfc_class_4(self, value):
        """pfc_class_4 setter

        The valid values are null, - 7.. null value indicates there is no setting for this pfc class.

        value: int
        """
        self._set_property("pfc_class_4", value)

    @property
    def pfc_class_5(self):
        # type: () -> int
        """pfc_class_5 getter

        The valid values are null, - 7.. null value indicates there is no setting for this pfc class.

        Returns: int
        """
        return self._get_property("pfc_class_5")

    @pfc_class_5.setter
    def pfc_class_5(self, value):
        """pfc_class_5 setter

        The valid values are null, - 7.. null value indicates there is no setting for this pfc class.

        value: int
        """
        self._set_property("pfc_class_5", value)

    @property
    def pfc_class_6(self):
        # type: () -> int
        """pfc_class_6 getter

        The valid values are null, - 7.. null value indicates there is no setting for this pfc class.

        Returns: int
        """
        return self._get_property("pfc_class_6")

    @pfc_class_6.setter
    def pfc_class_6(self, value):
        """pfc_class_6 setter

        The valid values are null, - 7.. null value indicates there is no setting for this pfc class.

        value: int
        """
        self._set_property("pfc_class_6", value)

    @property
    def pfc_class_7(self):
        # type: () -> int
        """pfc_class_7 getter

        The valid values are null, - 7.. null value indicates there is no setting for this pfc class.

        Returns: int
        """
        return self._get_property("pfc_class_7")

    @pfc_class_7.setter
    def pfc_class_7(self, value):
        """pfc_class_7 setter

        The valid values are null, - 7.. null value indicates there is no setting for this pfc class.

        value: int
        """
        self._set_property("pfc_class_7", value)


class Layer1Ieee8023x(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {}  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None):
        super(Layer1Ieee8023x, self).__init__()
        self._parent = parent


class Layer1Iter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(Layer1Iter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[Layer1]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> Layer1Iter
        return self._iter()

    def __next__(self):
        # type: () -> Layer1
        return self._next()

    def next(self):
        # type: () -> Layer1
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, Layer1):
            raise Exception("Item is not an instance of Layer1")

    def layer1(
        self,
        port_names=None,
        speed="speed_10_gbps",
        media=None,
        promiscuous=True,
        mtu=1500,
        ieee_media_defaults=None,
        auto_negotiate=None,
        name=None,
    ):
        # type: (List[str],Union[Literal["speed_100_fd_mbps"], Literal["speed_100_gbps"], Literal["speed_100_hd_mbps"], Literal["speed_10_fd_mbps"], Literal["speed_10_gbps"], Literal["speed_10_hd_mbps"], Literal["speed_1_gbps"], Literal["speed_200_gbps"], Literal["speed_25_gbps"], Literal["speed_400_gbps"], Literal["speed_40_gbps"], Literal["speed_50_gbps"]],Union[Literal["copper"], Literal["fiber"], Literal["sgmii"]],bool,int,bool,bool,str) -> Layer1Iter
        """Factory method that creates an instance of the Layer1 class

        A container for layer1 settings.

        Returns: Layer1Iter
        """
        item = Layer1(
            parent=self._parent,
            port_names=port_names,
            speed=speed,
            media=media,
            promiscuous=promiscuous,
            mtu=mtu,
            ieee_media_defaults=ieee_media_defaults,
            auto_negotiate=auto_negotiate,
            name=name,
        )
        self._add(item)
        return self

    def add(
        self,
        port_names=None,
        speed="speed_10_gbps",
        media=None,
        promiscuous=True,
        mtu=1500,
        ieee_media_defaults=None,
        auto_negotiate=None,
        name=None,
    ):
        # type: (List[str],Union[Literal["speed_100_fd_mbps"], Literal["speed_100_gbps"], Literal["speed_100_hd_mbps"], Literal["speed_10_fd_mbps"], Literal["speed_10_gbps"], Literal["speed_10_hd_mbps"], Literal["speed_1_gbps"], Literal["speed_200_gbps"], Literal["speed_25_gbps"], Literal["speed_400_gbps"], Literal["speed_40_gbps"], Literal["speed_50_gbps"]],Union[Literal["copper"], Literal["fiber"], Literal["sgmii"]],bool,int,bool,bool,str) -> Layer1
        """Add method that creates and returns an instance of the Layer1 class

        A container for layer1 settings.

        Returns: Layer1
        """
        item = Layer1(
            parent=self._parent,
            port_names=port_names,
            speed=speed,
            media=media,
            promiscuous=promiscuous,
            mtu=mtu,
            ieee_media_defaults=ieee_media_defaults,
            auto_negotiate=auto_negotiate,
            name=name,
        )
        self._add(item)
        return item


class Capture(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "port_names": {
            "type": list,
            "itemtype": str,
        },
        "filters": {"type": "CaptureFilterIter"},
        "overwrite": {"type": bool},
        "packet_size": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "format": {
            "type": str,
            "enum": [
                "pcap",
                "pcapng",
            ],
        },
        "name": {"type": str},
    }  # type: Dict[str, str]

    _REQUIRED = ("port_names", "name")  # type: tuple(str)

    _DEFAULTS = {
        "overwrite": True,
        "format": "pcap",
    }  # type: Dict[str, Union(type)]

    PCAP = "pcap"  # type: str
    PCAPNG = "pcapng"  # type: str

    _STATUS = {
        "self": "Capture is under_review, There may be changes in filter configuration",
    }  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        port_names=None,
        overwrite=True,
        packet_size=None,
        format="pcap",
        name=None,
    ):
        super(Capture, self).__init__()
        self._parent = parent
        self._set_property("port_names", port_names)
        self._set_property("overwrite", overwrite)
        self._set_property("packet_size", packet_size)
        self._set_property("format", format)
        self._set_property("name", name)

    def set(
        self, port_names=None, overwrite=None, packet_size=None, format=None, name=None
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def port_names(self):
        # type: () -> List[str]
        """port_names getter

        The unique names of ports that the capture settings will apply to. Port_names cannot be duplicated between capture objects.. x-constraint:. /components/schemas/Port/properties/name. . x-constraint:. /components/schemas/Port/properties/name.

        Returns: List[str]
        """
        return self._get_property("port_names")

    @port_names.setter
    def port_names(self, value):
        """port_names setter

        The unique names of ports that the capture settings will apply to. Port_names cannot be duplicated between capture objects.. x-constraint:. /components/schemas/Port/properties/name. . x-constraint:. /components/schemas/Port/properties/name.

        value: List[str]
        """
        if value is None:
            raise TypeError("Cannot set required property port_names as None")
        self._set_property("port_names", value)

    @property
    def filters(self):
        # type: () -> CaptureFilterIter
        """filters getter

        A list of filters to apply to the capturing ports. If no filters are specified then all packets will be captured. capture can have multiple filters. The number of filters supported is determined by the implementation which can be retrieved using the capabilities API.. When multiple filters are specified the capture implementation must && (and) all the filters.

        Returns: CaptureFilterIter
        """
        return self._get_property(
            "filters", CaptureFilterIter, self._parent, self._choice
        )

    @property
    def overwrite(self):
        # type: () -> bool
        """overwrite getter

        Overwrite the capture buffer.

        Returns: bool
        """
        return self._get_property("overwrite")

    @overwrite.setter
    def overwrite(self, value):
        """overwrite setter

        Overwrite the capture buffer.

        value: bool
        """
        self._set_property("overwrite", value)

    @property
    def packet_size(self):
        # type: () -> int
        """packet_size getter

        The maximum size of each captured packet. If no value is specified or it is null then the entire packet will be captured.

        Returns: int
        """
        return self._get_property("packet_size")

    @packet_size.setter
    def packet_size(self, value):
        """packet_size setter

        The maximum size of each captured packet. If no value is specified or it is null then the entire packet will be captured.

        value: int
        """
        self._set_property("packet_size", value)

    @property
    def format(self):
        # type: () -> Union[Literal["pcap"], Literal["pcapng"]]
        """format getter

        The format of the capture file.

        Returns: Union[Literal["pcap"], Literal["pcapng"]]
        """
        return self._get_property("format")

    @format.setter
    def format(self, value):
        """format setter

        The format of the capture file.

        value: Union[Literal["pcap"], Literal["pcapng"]]
        """
        self._set_property("format", value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)


class CaptureFilter(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "custom",
                "ethernet",
                "vlan",
                "ipv4",
                "ipv6",
            ],
        },
        "custom": {"type": "CaptureCustom"},
        "ethernet": {"type": "CaptureEthernet"},
        "vlan": {"type": "CaptureVlan"},
        "ipv4": {"type": "CaptureIpv4"},
        "ipv6": {"type": "CaptureIpv6"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "custom",
    }  # type: Dict[str, Union(type)]

    CUSTOM = "custom"  # type: str
    ETHERNET = "ethernet"  # type: str
    VLAN = "vlan"  # type: str
    IPV4 = "ipv4"  # type: str
    IPV6 = "ipv6"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None):
        super(CaptureFilter, self).__init__()
        self._parent = parent
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    @property
    def custom(self):
        # type: () -> CaptureCustom
        """Factory property that returns an instance of the CaptureCustom class

        TBD

        Returns: CaptureCustom
        """
        return self._get_property("custom", CaptureCustom, self, "custom")

    @property
    def ethernet(self):
        # type: () -> CaptureEthernet
        """Factory property that returns an instance of the CaptureEthernet class

        TBD

        Returns: CaptureEthernet
        """
        return self._get_property("ethernet", CaptureEthernet, self, "ethernet")

    @property
    def vlan(self):
        # type: () -> CaptureVlan
        """Factory property that returns an instance of the CaptureVlan class

        TBD

        Returns: CaptureVlan
        """
        return self._get_property("vlan", CaptureVlan, self, "vlan")

    @property
    def ipv4(self):
        # type: () -> CaptureIpv4
        """Factory property that returns an instance of the CaptureIpv4 class

        TBD

        Returns: CaptureIpv4
        """
        return self._get_property("ipv4", CaptureIpv4, self, "ipv4")

    @property
    def ipv6(self):
        # type: () -> CaptureIpv6
        """Factory property that returns an instance of the CaptureIpv6 class

        TBD

        Returns: CaptureIpv6
        """
        return self._get_property("ipv6", CaptureIpv6, self, "ipv6")

    @property
    def choice(self):
        # type: () -> Union[Literal["custom"], Literal["ethernet"], Literal["ipv4"], Literal["ipv6"], Literal["vlan"]]
        """choice getter

        The type of capture filter.

        Returns: Union[Literal["custom"], Literal["ethernet"], Literal["ipv4"], Literal["ipv6"], Literal["vlan"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        The type of capture filter.

        value: Union[Literal["custom"], Literal["ethernet"], Literal["ipv4"], Literal["ipv6"], Literal["vlan"]]
        """
        self._set_property("choice", value)


class CaptureCustom(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "offset": {
            "type": int,
            "format": "uint32",
        },
        "bit_length": {
            "type": int,
            "format": "uint32",
        },
        "value": {
            "type": str,
            "format": "hex",
        },
        "mask": {
            "type": str,
            "format": "hex",
        },
        "negate": {"type": bool},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "bit_length": 8,
        "value": "00",
        "mask": "00",
        "negate": False,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        offset=None,
        bit_length=8,
        value="00",
        mask="00",
        negate=False,
    ):
        super(CaptureCustom, self).__init__()
        self._parent = parent
        self._set_property("offset", offset)
        self._set_property("bit_length", bit_length)
        self._set_property("value", value)
        self._set_property("mask", mask)
        self._set_property("negate", negate)

    def set(self, offset=None, bit_length=None, value=None, mask=None, negate=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        The bit offset of field to filter on

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        The bit offset of field to filter on

        value: int
        """
        self._set_property("offset", value)

    @property
    def bit_length(self):
        # type: () -> int
        """bit_length getter

        The bit length of field to filter on

        Returns: int
        """
        return self._get_property("bit_length")

    @bit_length.setter
    def bit_length(self, value):
        """bit_length setter

        The bit length of field to filter on

        value: int
        """
        self._set_property("bit_length", value)

    @property
    def value(self):
        # type: () -> str
        """value getter

        TBD

        Returns: str
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: str
        """
        self._set_property("value", value)

    @property
    def mask(self):
        # type: () -> str
        """mask getter

        TBD

        Returns: str
        """
        return self._get_property("mask")

    @mask.setter
    def mask(self, value):
        """mask setter

        TBD

        value: str
        """
        self._set_property("mask", value)

    @property
    def negate(self):
        # type: () -> bool
        """negate getter

        TBD

        Returns: bool
        """
        return self._get_property("negate")

    @negate.setter
    def negate(self, value):
        """negate setter

        TBD

        value: bool
        """
        self._set_property("negate", value)


class CaptureEthernet(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "src": {"type": "CaptureField"},
        "dst": {"type": "CaptureField"},
        "ether_type": {"type": "CaptureField"},
        "pfc_queue": {"type": "CaptureField"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None):
        super(CaptureEthernet, self).__init__()
        self._parent = parent

    @property
    def src(self):
        # type: () -> CaptureField
        """src getter



        Returns: CaptureField
        """
        return self._get_property("src", CaptureField)

    @property
    def dst(self):
        # type: () -> CaptureField
        """dst getter



        Returns: CaptureField
        """
        return self._get_property("dst", CaptureField)

    @property
    def ether_type(self):
        # type: () -> CaptureField
        """ether_type getter



        Returns: CaptureField
        """
        return self._get_property("ether_type", CaptureField)

    @property
    def pfc_queue(self):
        # type: () -> CaptureField
        """pfc_queue getter



        Returns: CaptureField
        """
        return self._get_property("pfc_queue", CaptureField)


class CaptureField(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "value": {
            "type": str,
            "format": "hex",
        },
        "mask": {
            "type": str,
            "format": "hex",
        },
        "negate": {"type": bool},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "value": "00",
        "mask": "00",
        "negate": False,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, value="00", mask="00", negate=False):
        super(CaptureField, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("mask", mask)
        self._set_property("negate", negate)

    def set(self, value=None, mask=None, negate=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def value(self):
        # type: () -> str
        """value getter

        TBD

        Returns: str
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: str
        """
        self._set_property("value", value)

    @property
    def mask(self):
        # type: () -> str
        """mask getter

        TBD

        Returns: str
        """
        return self._get_property("mask")

    @mask.setter
    def mask(self, value):
        """mask setter

        TBD

        value: str
        """
        self._set_property("mask", value)

    @property
    def negate(self):
        # type: () -> bool
        """negate getter

        TBD

        Returns: bool
        """
        return self._get_property("negate")

    @negate.setter
    def negate(self, value):
        """negate setter

        TBD

        value: bool
        """
        self._set_property("negate", value)


class CaptureVlan(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "priority": {"type": "CaptureField"},
        "cfi": {"type": "CaptureField"},
        "id": {"type": "CaptureField"},
        "protocol": {"type": "CaptureField"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None):
        super(CaptureVlan, self).__init__()
        self._parent = parent

    @property
    def priority(self):
        # type: () -> CaptureField
        """priority getter



        Returns: CaptureField
        """
        return self._get_property("priority", CaptureField)

    @property
    def cfi(self):
        # type: () -> CaptureField
        """cfi getter



        Returns: CaptureField
        """
        return self._get_property("cfi", CaptureField)

    @property
    def id(self):
        # type: () -> CaptureField
        """id getter



        Returns: CaptureField
        """
        return self._get_property("id", CaptureField)

    @property
    def protocol(self):
        # type: () -> CaptureField
        """protocol getter



        Returns: CaptureField
        """
        return self._get_property("protocol", CaptureField)


class CaptureIpv4(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "version": {"type": "CaptureField"},
        "header_length": {"type": "CaptureField"},
        "priority": {"type": "CaptureField"},
        "total_length": {"type": "CaptureField"},
        "identification": {"type": "CaptureField"},
        "reserved": {"type": "CaptureField"},
        "dont_fragment": {"type": "CaptureField"},
        "more_fragments": {"type": "CaptureField"},
        "fragment_offset": {"type": "CaptureField"},
        "time_to_live": {"type": "CaptureField"},
        "protocol": {"type": "CaptureField"},
        "header_checksum": {"type": "CaptureField"},
        "src": {"type": "CaptureField"},
        "dst": {"type": "CaptureField"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None):
        super(CaptureIpv4, self).__init__()
        self._parent = parent

    @property
    def version(self):
        # type: () -> CaptureField
        """version getter



        Returns: CaptureField
        """
        return self._get_property("version", CaptureField)

    @property
    def header_length(self):
        # type: () -> CaptureField
        """header_length getter



        Returns: CaptureField
        """
        return self._get_property("header_length", CaptureField)

    @property
    def priority(self):
        # type: () -> CaptureField
        """priority getter



        Returns: CaptureField
        """
        return self._get_property("priority", CaptureField)

    @property
    def total_length(self):
        # type: () -> CaptureField
        """total_length getter



        Returns: CaptureField
        """
        return self._get_property("total_length", CaptureField)

    @property
    def identification(self):
        # type: () -> CaptureField
        """identification getter



        Returns: CaptureField
        """
        return self._get_property("identification", CaptureField)

    @property
    def reserved(self):
        # type: () -> CaptureField
        """reserved getter



        Returns: CaptureField
        """
        return self._get_property("reserved", CaptureField)

    @property
    def dont_fragment(self):
        # type: () -> CaptureField
        """dont_fragment getter



        Returns: CaptureField
        """
        return self._get_property("dont_fragment", CaptureField)

    @property
    def more_fragments(self):
        # type: () -> CaptureField
        """more_fragments getter



        Returns: CaptureField
        """
        return self._get_property("more_fragments", CaptureField)

    @property
    def fragment_offset(self):
        # type: () -> CaptureField
        """fragment_offset getter



        Returns: CaptureField
        """
        return self._get_property("fragment_offset", CaptureField)

    @property
    def time_to_live(self):
        # type: () -> CaptureField
        """time_to_live getter



        Returns: CaptureField
        """
        return self._get_property("time_to_live", CaptureField)

    @property
    def protocol(self):
        # type: () -> CaptureField
        """protocol getter



        Returns: CaptureField
        """
        return self._get_property("protocol", CaptureField)

    @property
    def header_checksum(self):
        # type: () -> CaptureField
        """header_checksum getter



        Returns: CaptureField
        """
        return self._get_property("header_checksum", CaptureField)

    @property
    def src(self):
        # type: () -> CaptureField
        """src getter



        Returns: CaptureField
        """
        return self._get_property("src", CaptureField)

    @property
    def dst(self):
        # type: () -> CaptureField
        """dst getter



        Returns: CaptureField
        """
        return self._get_property("dst", CaptureField)


class CaptureIpv6(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "version": {"type": "CaptureField"},
        "traffic_class": {"type": "CaptureField"},
        "flow_label": {"type": "CaptureField"},
        "payload_length": {"type": "CaptureField"},
        "next_header": {"type": "CaptureField"},
        "hop_limit": {"type": "CaptureField"},
        "src": {"type": "CaptureField"},
        "dst": {"type": "CaptureField"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None):
        super(CaptureIpv6, self).__init__()
        self._parent = parent

    @property
    def version(self):
        # type: () -> CaptureField
        """version getter



        Returns: CaptureField
        """
        return self._get_property("version", CaptureField)

    @property
    def traffic_class(self):
        # type: () -> CaptureField
        """traffic_class getter



        Returns: CaptureField
        """
        return self._get_property("traffic_class", CaptureField)

    @property
    def flow_label(self):
        # type: () -> CaptureField
        """flow_label getter



        Returns: CaptureField
        """
        return self._get_property("flow_label", CaptureField)

    @property
    def payload_length(self):
        # type: () -> CaptureField
        """payload_length getter



        Returns: CaptureField
        """
        return self._get_property("payload_length", CaptureField)

    @property
    def next_header(self):
        # type: () -> CaptureField
        """next_header getter



        Returns: CaptureField
        """
        return self._get_property("next_header", CaptureField)

    @property
    def hop_limit(self):
        # type: () -> CaptureField
        """hop_limit getter



        Returns: CaptureField
        """
        return self._get_property("hop_limit", CaptureField)

    @property
    def src(self):
        # type: () -> CaptureField
        """src getter



        Returns: CaptureField
        """
        return self._get_property("src", CaptureField)

    @property
    def dst(self):
        # type: () -> CaptureField
        """dst getter



        Returns: CaptureField
        """
        return self._get_property("dst", CaptureField)


class CaptureFilterIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = True

    def __init__(self, parent=None, choice=None):
        super(CaptureFilterIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[CaptureCustom, CaptureEthernet, CaptureFilter, CaptureIpv4, CaptureIpv6, CaptureVlan]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> CaptureFilterIter
        return self._iter()

    def __next__(self):
        # type: () -> CaptureFilter
        return self._next()

    def next(self):
        # type: () -> CaptureFilter
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, CaptureFilter):
            raise Exception("Item is not an instance of CaptureFilter")

    def filter(self):
        # type: () -> CaptureFilterIter
        """Factory method that creates an instance of the CaptureFilter class

        Configuration for capture filters

        Returns: CaptureFilterIter
        """
        item = CaptureFilter(parent=self._parent, choice=self._choice)
        self._add(item)
        return self

    def add(self):
        # type: () -> CaptureFilter
        """Add method that creates and returns an instance of the CaptureFilter class

        Configuration for capture filters

        Returns: CaptureFilter
        """
        item = CaptureFilter(parent=self._parent, choice=self._choice)
        self._add(item)
        return item

    def custom(self, offset=None, bit_length=8, value="00", mask="00", negate=False):
        # type: (int,int,str,str,bool) -> CaptureFilterIter
        """Factory method that creates an instance of the CaptureCustom class

        TBD

        Returns: CaptureFilterIter
        """
        item = CaptureFilter()
        item.custom
        item.choice = "custom"
        self._add(item)
        return self

    def ethernet(self):
        # type: () -> CaptureFilterIter
        """Factory method that creates an instance of the CaptureEthernet class

        TBD

        Returns: CaptureFilterIter
        """
        item = CaptureFilter()
        item.ethernet
        item.choice = "ethernet"
        self._add(item)
        return self

    def vlan(self):
        # type: () -> CaptureFilterIter
        """Factory method that creates an instance of the CaptureVlan class

        TBD

        Returns: CaptureFilterIter
        """
        item = CaptureFilter()
        item.vlan
        item.choice = "vlan"
        self._add(item)
        return self

    def ipv4(self):
        # type: () -> CaptureFilterIter
        """Factory method that creates an instance of the CaptureIpv4 class

        TBD

        Returns: CaptureFilterIter
        """
        item = CaptureFilter()
        item.ipv4
        item.choice = "ipv4"
        self._add(item)
        return self

    def ipv6(self):
        # type: () -> CaptureFilterIter
        """Factory method that creates an instance of the CaptureIpv6 class

        TBD

        Returns: CaptureFilterIter
        """
        item = CaptureFilter()
        item.ipv6
        item.choice = "ipv6"
        self._add(item)
        return self


class CaptureIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(CaptureIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[Capture]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> CaptureIter
        return self._iter()

    def __next__(self):
        # type: () -> Capture
        return self._next()

    def next(self):
        # type: () -> Capture
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, Capture):
            raise Exception("Item is not an instance of Capture")

    def capture(
        self,
        port_names=None,
        overwrite=True,
        packet_size=None,
        format="pcap",
        name=None,
    ):
        # type: (List[str],bool,int,Union[Literal["pcap"], Literal["pcapng"]],str) -> CaptureIter
        """Factory method that creates an instance of the Capture class

        Under Review: There may be changes in filter configuration. Under Review: There may be changes in filter configuration. Configuration for capture settings.

        Returns: CaptureIter
        """
        item = Capture(
            parent=self._parent,
            port_names=port_names,
            overwrite=overwrite,
            packet_size=packet_size,
            format=format,
            name=name,
        )
        self._add(item)
        return self

    def add(
        self,
        port_names=None,
        overwrite=True,
        packet_size=None,
        format="pcap",
        name=None,
    ):
        # type: (List[str],bool,int,Union[Literal["pcap"], Literal["pcapng"]],str) -> Capture
        """Add method that creates and returns an instance of the Capture class

        Under Review: There may be changes in filter configuration. Under Review: There may be changes in filter configuration. Configuration for capture settings.

        Returns: Capture
        """
        item = Capture(
            parent=self._parent,
            port_names=port_names,
            overwrite=overwrite,
            packet_size=packet_size,
            format=format,
            name=name,
        )
        self._add(item)
        return item


class Device(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "ethernets": {"type": "DeviceEthernetIter"},
        "ipv4_loopbacks": {"type": "DeviceIpv4LoopbackIter"},
        "ipv6_loopbacks": {"type": "DeviceIpv6LoopbackIter"},
        "isis": {"type": "DeviceIsisRouter"},
        "bgp": {"type": "DeviceBgpRouter"},
        "vxlan": {"type": "DeviceVxlan"},
        "name": {"type": str},
        "rsvp": {"type": "DeviceRsvp"},
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None):
        super(Device, self).__init__()
        self._parent = parent
        self._set_property("name", name)

    def set(self, name=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def ethernets(self):
        # type: () -> DeviceEthernetIter
        """ethernets getter

        Ethernet configuration for one or more emulated network interfaces.

        Returns: DeviceEthernetIter
        """
        return self._get_property(
            "ethernets", DeviceEthernetIter, self._parent, self._choice
        )

    @property
    def ipv4_loopbacks(self):
        # type: () -> DeviceIpv4LoopbackIter
        """ipv4_loopbacks getter

        IPv4 Loopback interface that can be attached to an Ethernet in the same device or to an Ethernet in another device.

        Returns: DeviceIpv4LoopbackIter
        """
        return self._get_property(
            "ipv4_loopbacks", DeviceIpv4LoopbackIter, self._parent, self._choice
        )

    @property
    def ipv6_loopbacks(self):
        # type: () -> DeviceIpv6LoopbackIter
        """ipv6_loopbacks getter

        IPv6 Loopback interface that can be attached to an Ethernet in the same device or to an Ethernet in another device.

        Returns: DeviceIpv6LoopbackIter
        """
        return self._get_property(
            "ipv6_loopbacks", DeviceIpv6LoopbackIter, self._parent, self._choice
        )

    @property
    def isis(self):
        # type: () -> DeviceIsisRouter
        """isis getter

        A container of properties for an ISIS router and its interfaces.A container of properties for an ISIS router and its interfaces.A container of properties for an ISIS router and its interfaces.The properties of an IS-IS router and its children, such as IS-IS interfaces and route ranges.

        Returns: DeviceIsisRouter
        """
        return self._get_property("isis", DeviceIsisRouter)

    @property
    def bgp(self):
        # type: () -> DeviceBgpRouter
        """bgp getter

        Configuration for one or more IPv4 or IPv6 BGP peers.Configuration for one or more IPv4 or IPv6 BGP peers.Configuration for one or more IPv4 or IPv6 BGP peers.The properties of BGP router and its children, such as BGPv4, BGPv6 peers and their route ranges.

        Returns: DeviceBgpRouter
        """
        return self._get_property("bgp", DeviceBgpRouter)

    @property
    def vxlan(self):
        # type: () -> DeviceVxlan
        """vxlan getter

        Configuration of VXLAN tunnel interfaces RFC Ref: https://datatracker.ietf.org/doc/html/rfc7348

        Returns: DeviceVxlan
        """
        return self._get_property("vxlan", DeviceVxlan)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def rsvp(self):
        # type: () -> DeviceRsvp
        """rsvp getter

        Configuration for one or more RSVP interfaces, ingress and egress LSPs. In this model, currently IPv4 RSVP and point-to-point LSPs are supported as per RFC3209 and related specifications.Configuration for one or more RSVP interfaces, ingress and egress LSPs. In this model, currently IPv4 RSVP and point-to-point LSPs are supported as per RFC3209 and related specifications.Configuration for one or more RSVP interfaces, ingress and egress LSPs. In this model, currently IPv4 RSVP and point-to-point LSPs are supported as per RFC3209 and related specifications.The properties of an RSVP router and its children.

        Returns: DeviceRsvp
        """
        return self._get_property("rsvp", DeviceRsvp)


class DeviceEthernet(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "connection": {"type": "EthernetConnection"},
        "ipv4_addresses": {"type": "DeviceIpv4Iter"},
        "ipv6_addresses": {"type": "DeviceIpv6Iter"},
        "mac": {
            "type": str,
            "format": "mac",
        },
        "mtu": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "vlans": {"type": "DeviceVlanIter"},
        "name": {"type": str},
    }  # type: Dict[str, str]

    _REQUIRED = ("mac", "name")  # type: tuple(str)

    _DEFAULTS = {
        "mtu": 1500,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, mac=None, mtu=1500, name=None):
        super(DeviceEthernet, self).__init__()
        self._parent = parent
        self._set_property("mac", mac)
        self._set_property("mtu", mtu)
        self._set_property("name", name)

    def set(self, mac=None, mtu=None, name=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def connection(self):
        # type: () -> EthernetConnection
        """connection getter

        Ethernet interface connection to port, LAG or VXLAN tunnel.Ethernet interface connection to port, LAG or VXLAN tunnel.Ethernet interface connection to port, LAG or VXLAN tunnel.Device connection to physical, LAG or another device.

        Returns: EthernetConnection
        """
        return self._get_property("connection", EthernetConnection)

    @property
    def ipv4_addresses(self):
        # type: () -> DeviceIpv4Iter
        """ipv4_addresses getter

        List of IPv4 addresses and their gateways.

        Returns: DeviceIpv4Iter
        """
        return self._get_property(
            "ipv4_addresses", DeviceIpv4Iter, self._parent, self._choice
        )

    @property
    def ipv6_addresses(self):
        # type: () -> DeviceIpv6Iter
        """ipv6_addresses getter

        List of global IPv6 addresses and their gateways.. The Link Local IPv6 address will be automatically generated.

        Returns: DeviceIpv6Iter
        """
        return self._get_property(
            "ipv6_addresses", DeviceIpv6Iter, self._parent, self._choice
        )

    @property
    def mac(self):
        # type: () -> str
        """mac getter

        Media Access Control address.

        Returns: str
        """
        return self._get_property("mac")

    @mac.setter
    def mac(self, value):
        """mac setter

        Media Access Control address.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property mac as None")
        self._set_property("mac", value)

    @property
    def mtu(self):
        # type: () -> int
        """mtu getter

        Maximum Transmission Unit.

        Returns: int
        """
        return self._get_property("mtu")

    @mtu.setter
    def mtu(self, value):
        """mtu setter

        Maximum Transmission Unit.

        value: int
        """
        self._set_property("mtu", value)

    @property
    def vlans(self):
        # type: () -> DeviceVlanIter
        """vlans getter

        List of VLANs

        Returns: DeviceVlanIter
        """
        return self._get_property("vlans", DeviceVlanIter, self._parent, self._choice)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)


class EthernetConnection(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "port_name",
                "lag_name",
                "vxlan_name",
            ],
        },
        "port_name": {"type": str},
        "lag_name": {"type": str},
        "vxlan_name": {"type": str},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    PORT_NAME = "port_name"  # type: str
    LAG_NAME = "lag_name"  # type: str
    VXLAN_NAME = "vxlan_name"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self, parent=None, choice=None, port_name=None, lag_name=None, vxlan_name=None
    ):
        super(EthernetConnection, self).__init__()
        self._parent = parent
        self._set_property("port_name", port_name)
        self._set_property("lag_name", lag_name)
        self._set_property("vxlan_name", vxlan_name)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, port_name=None, lag_name=None, vxlan_name=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def choice(self):
        # type: () -> Union[Literal["lag_name"], Literal["port_name"], Literal["vxlan_name"]]
        """choice getter

        port_name, lag_name or vxlan_name

        Returns: Union[Literal["lag_name"], Literal["port_name"], Literal["vxlan_name"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        port_name, lag_name or vxlan_name

        value: Union[Literal["lag_name"], Literal["port_name"], Literal["vxlan_name"]]
        """
        self._set_property("choice", value)

    @property
    def port_name(self):
        # type: () -> str
        """port_name getter

        Name of the port that the Ethernet interface is configured on.. x-constraint:. /components/schemas/Port/properties/name. . x-constraint:. /components/schemas/Port/properties/name.

        Returns: str
        """
        return self._get_property("port_name")

    @port_name.setter
    def port_name(self, value):
        """port_name setter

        Name of the port that the Ethernet interface is configured on.. x-constraint:. /components/schemas/Port/properties/name. . x-constraint:. /components/schemas/Port/properties/name.

        value: str
        """
        self._set_property("port_name", value, "port_name")

    @property
    def lag_name(self):
        # type: () -> str
        """lag_name getter

        Name of the LAG that the Ethernet interface is configured on.. x-constraint:. /components/schemas/Lag/properties/name. . x-constraint:. /components/schemas/Lag/properties/name.

        Returns: str
        """
        return self._get_property("lag_name")

    @lag_name.setter
    def lag_name(self, value):
        """lag_name setter

        Name of the LAG that the Ethernet interface is configured on.. x-constraint:. /components/schemas/Lag/properties/name. . x-constraint:. /components/schemas/Lag/properties/name.

        value: str
        """
        self._set_property("lag_name", value, "lag_name")

    @property
    def vxlan_name(self):
        # type: () -> str
        """vxlan_name getter

        Name of the VXLAN instance (or VXLAN tunnel) that this Ethernet interface is connected to.. x-constraint:. #/components/schemas/Vxlan.V4Tunnel/properties/name. #/components/schemas/Vxlan.V6Tunnel/properties/name. . x-constraint:. #/components/schemas/Vxlan.V4Tunnel/properties/name. #/components/schemas/Vxlan.V6Tunnel/properties/name.

        Returns: str
        """
        return self._get_property("vxlan_name")

    @vxlan_name.setter
    def vxlan_name(self, value):
        """vxlan_name setter

        Name of the VXLAN instance (or VXLAN tunnel) that this Ethernet interface is connected to.. x-constraint:. #/components/schemas/Vxlan.V4Tunnel/properties/name. #/components/schemas/Vxlan.V6Tunnel/properties/name. . x-constraint:. #/components/schemas/Vxlan.V4Tunnel/properties/name. #/components/schemas/Vxlan.V6Tunnel/properties/name.

        value: str
        """
        self._set_property("vxlan_name", value, "vxlan_name")


class DeviceIpv4(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "gateway": {
            "type": str,
            "format": "ipv4",
        },
        "gateway_mac": {"type": "DeviceIpv4GatewayMAC"},
        "address": {
            "type": str,
            "format": "ipv4",
        },
        "prefix": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 32,
        },
        "name": {"type": str},
    }  # type: Dict[str, str]

    _REQUIRED = ("gateway", "address", "name")  # type: tuple(str)

    _DEFAULTS = {
        "prefix": 24,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, gateway=None, address=None, prefix=24, name=None):
        super(DeviceIpv4, self).__init__()
        self._parent = parent
        self._set_property("gateway", gateway)
        self._set_property("address", address)
        self._set_property("prefix", prefix)
        self._set_property("name", name)

    def set(self, gateway=None, address=None, prefix=None, name=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def gateway(self):
        # type: () -> str
        """gateway getter

        The IPv4 address of the gateway

        Returns: str
        """
        return self._get_property("gateway")

    @gateway.setter
    def gateway(self, value):
        """gateway setter

        The IPv4 address of the gateway

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property gateway as None")
        self._set_property("gateway", value)

    @property
    def gateway_mac(self):
        # type: () -> DeviceIpv4GatewayMAC
        """gateway_mac getter

        By default auto(resolved gateway mac) is set. Setting value would mean that ARP will not be used for learning MAC of connected device. The user-configured MAC address will be used for auto-filling the destination. MAC address in the control and data packets sent from this IPv4 endpoint. whenever applicable.By default auto(resolved gateway mac) is set. Setting value would mean that ARP will not be used for learning MAC of connected device. The user-configured MAC address will be used for auto-filling the destination. MAC address in the control and data packets sent from this IPv4 endpoint. whenever applicable.By default auto(resolved gateway mac) is set. Setting value would mean that ARP will not be used for learning MAC of connected device. The user-configured MAC address will be used for auto-filling the destination. MAC address in the control and data packets sent from this IPv4 endpoint. whenever applicable.

        Returns: DeviceIpv4GatewayMAC
        """
        return self._get_property("gateway_mac", DeviceIpv4GatewayMAC)

    @property
    def address(self):
        # type: () -> str
        """address getter

        The IPv4 address

        Returns: str
        """
        return self._get_property("address")

    @address.setter
    def address(self, value):
        """address setter

        The IPv4 address

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property address as None")
        self._set_property("address", value)

    @property
    def prefix(self):
        # type: () -> int
        """prefix getter

        The prefix of the IPv4 address.

        Returns: int
        """
        return self._get_property("prefix")

    @prefix.setter
    def prefix(self, value):
        """prefix setter

        The prefix of the IPv4 address.

        value: int
        """
        self._set_property("prefix", value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)


class DeviceIpv4GatewayMAC(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "auto",
                "value",
            ],
        },
        "auto": {
            "type": str,
            "format": "mac",
        },
        "value": {
            "type": str,
            "format": "mac",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "auto",
        "auto": "00:00:00:00:00:00",
        "value": "00:00:00:00:00:00",
    }  # type: Dict[str, Union(type)]

    AUTO = "auto"  # type: str
    VALUE = "value"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        choice=None,
        auto="00:00:00:00:00:00",
        value="00:00:00:00:00:00",
    ):
        super(DeviceIpv4GatewayMAC, self).__init__()
        self._parent = parent
        self._set_property("auto", auto)
        self._set_property("value", value)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, auto=None, value=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def choice(self):
        # type: () -> Union[Literal["auto"], Literal["value"]]
        """choice getter

        auto or configured value.

        Returns: Union[Literal["auto"], Literal["value"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        auto or configured value.

        value: Union[Literal["auto"], Literal["value"]]
        """
        self._set_property("choice", value)

    @property
    def auto(self):
        # type: () -> str
        """auto getter

        The OTG implementation can provide system generated value for this property. If the OTG is unable to generate value the default value must be used.

        Returns: str
        """
        return self._get_property("auto")

    @property
    def value(self):
        # type: () -> str
        """value getter

        TBD

        Returns: str
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: str
        """
        self._set_property("value", value, "value")


class DeviceIpv4Iter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(DeviceIpv4Iter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[DeviceIpv4]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> DeviceIpv4Iter
        return self._iter()

    def __next__(self):
        # type: () -> DeviceIpv4
        return self._next()

    def next(self):
        # type: () -> DeviceIpv4
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, DeviceIpv4):
            raise Exception("Item is not an instance of DeviceIpv4")

    def ipv4(self, gateway=None, address=None, prefix=24, name=None):
        # type: (str,str,int,str) -> DeviceIpv4Iter
        """Factory method that creates an instance of the DeviceIpv4 class

        An IPv4 interface with gateway

        Returns: DeviceIpv4Iter
        """
        item = DeviceIpv4(
            parent=self._parent,
            gateway=gateway,
            address=address,
            prefix=prefix,
            name=name,
        )
        self._add(item)
        return self

    def add(self, gateway=None, address=None, prefix=24, name=None):
        # type: (str,str,int,str) -> DeviceIpv4
        """Add method that creates and returns an instance of the DeviceIpv4 class

        An IPv4 interface with gateway

        Returns: DeviceIpv4
        """
        item = DeviceIpv4(
            parent=self._parent,
            gateway=gateway,
            address=address,
            prefix=prefix,
            name=name,
        )
        self._add(item)
        return item


class DeviceIpv6(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "gateway": {
            "type": str,
            "format": "ipv6",
        },
        "gateway_mac": {"type": "DeviceIpv6GatewayMAC"},
        "address": {
            "type": str,
            "format": "ipv6",
        },
        "prefix": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 128,
        },
        "name": {"type": str},
    }  # type: Dict[str, str]

    _REQUIRED = ("gateway", "address", "name")  # type: tuple(str)

    _DEFAULTS = {
        "prefix": 64,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, gateway=None, address=None, prefix=64, name=None):
        super(DeviceIpv6, self).__init__()
        self._parent = parent
        self._set_property("gateway", gateway)
        self._set_property("address", address)
        self._set_property("prefix", prefix)
        self._set_property("name", name)

    def set(self, gateway=None, address=None, prefix=None, name=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def gateway(self):
        # type: () -> str
        """gateway getter

        The IPv6 gateway address.

        Returns: str
        """
        return self._get_property("gateway")

    @gateway.setter
    def gateway(self, value):
        """gateway setter

        The IPv6 gateway address.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property gateway as None")
        self._set_property("gateway", value)

    @property
    def gateway_mac(self):
        # type: () -> DeviceIpv6GatewayMAC
        """gateway_mac getter

        By default auto(resolved gateway mac) is set. Setting value would mean that ND will not be used for learning MAC of connected device. The user-configured MAC address will be used for auto-filling the destination. MAC address in the control and data packets sent from this IPv6 endpoint. whenever applicable.By default auto(resolved gateway mac) is set. Setting value would mean that ND will not be used for learning MAC of connected device. The user-configured MAC address will be used for auto-filling the destination. MAC address in the control and data packets sent from this IPv6 endpoint. whenever applicable.By default auto(resolved gateway mac) is set. Setting value would mean that ND will not be used for learning MAC of connected device. The user-configured MAC address will be used for auto-filling the destination. MAC address in the control and data packets sent from this IPv6 endpoint. whenever applicable.

        Returns: DeviceIpv6GatewayMAC
        """
        return self._get_property("gateway_mac", DeviceIpv6GatewayMAC)

    @property
    def address(self):
        # type: () -> str
        """address getter

        The IPv6 address.

        Returns: str
        """
        return self._get_property("address")

    @address.setter
    def address(self, value):
        """address setter

        The IPv6 address.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property address as None")
        self._set_property("address", value)

    @property
    def prefix(self):
        # type: () -> int
        """prefix getter

        The network prefix.

        Returns: int
        """
        return self._get_property("prefix")

    @prefix.setter
    def prefix(self, value):
        """prefix setter

        The network prefix.

        value: int
        """
        self._set_property("prefix", value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)


class DeviceIpv6GatewayMAC(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "auto",
                "value",
            ],
        },
        "auto": {
            "type": str,
            "format": "mac",
        },
        "value": {
            "type": str,
            "format": "mac",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "auto",
        "auto": "00:00:00:00:00:00",
        "value": "00:00:00:00:00:00",
    }  # type: Dict[str, Union(type)]

    AUTO = "auto"  # type: str
    VALUE = "value"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        choice=None,
        auto="00:00:00:00:00:00",
        value="00:00:00:00:00:00",
    ):
        super(DeviceIpv6GatewayMAC, self).__init__()
        self._parent = parent
        self._set_property("auto", auto)
        self._set_property("value", value)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, auto=None, value=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def choice(self):
        # type: () -> Union[Literal["auto"], Literal["value"]]
        """choice getter

        auto or configured value.

        Returns: Union[Literal["auto"], Literal["value"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        auto or configured value.

        value: Union[Literal["auto"], Literal["value"]]
        """
        self._set_property("choice", value)

    @property
    def auto(self):
        # type: () -> str
        """auto getter

        The OTG implementation can provide system generated value for this property. If the OTG is unable to generate value the default value must be used.

        Returns: str
        """
        return self._get_property("auto")

    @property
    def value(self):
        # type: () -> str
        """value getter

        TBD

        Returns: str
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: str
        """
        self._set_property("value", value, "value")


class DeviceIpv6Iter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(DeviceIpv6Iter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[DeviceIpv6]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> DeviceIpv6Iter
        return self._iter()

    def __next__(self):
        # type: () -> DeviceIpv6
        return self._next()

    def next(self):
        # type: () -> DeviceIpv6
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, DeviceIpv6):
            raise Exception("Item is not an instance of DeviceIpv6")

    def ipv6(self, gateway=None, address=None, prefix=64, name=None):
        # type: (str,str,int,str) -> DeviceIpv6Iter
        """Factory method that creates an instance of the DeviceIpv6 class

        An IPv6 interface with gateway.

        Returns: DeviceIpv6Iter
        """
        item = DeviceIpv6(
            parent=self._parent,
            gateway=gateway,
            address=address,
            prefix=prefix,
            name=name,
        )
        self._add(item)
        return self

    def add(self, gateway=None, address=None, prefix=64, name=None):
        # type: (str,str,int,str) -> DeviceIpv6
        """Add method that creates and returns an instance of the DeviceIpv6 class

        An IPv6 interface with gateway.

        Returns: DeviceIpv6
        """
        item = DeviceIpv6(
            parent=self._parent,
            gateway=gateway,
            address=address,
            prefix=prefix,
            name=name,
        )
        self._add(item)
        return item


class DeviceEthernetIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(DeviceEthernetIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[DeviceEthernet]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> DeviceEthernetIter
        return self._iter()

    def __next__(self):
        # type: () -> DeviceEthernet
        return self._next()

    def next(self):
        # type: () -> DeviceEthernet
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, DeviceEthernet):
            raise Exception("Item is not an instance of DeviceEthernet")

    def ethernet(self, mac=None, mtu=1500, name=None):
        # type: (str,int,str) -> DeviceEthernetIter
        """Factory method that creates an instance of the DeviceEthernet class

        An Ethernet interface with IPv4 and IPv6 addresses.

        Returns: DeviceEthernetIter
        """
        item = DeviceEthernet(parent=self._parent, mac=mac, mtu=mtu, name=name)
        self._add(item)
        return self

    def add(self, mac=None, mtu=1500, name=None):
        # type: (str,int,str) -> DeviceEthernet
        """Add method that creates and returns an instance of the DeviceEthernet class

        An Ethernet interface with IPv4 and IPv6 addresses.

        Returns: DeviceEthernet
        """
        item = DeviceEthernet(parent=self._parent, mac=mac, mtu=mtu, name=name)
        self._add(item)
        return item


class DeviceIpv4Loopback(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "eth_name": {"type": str},
        "address": {
            "type": str,
            "format": "ipv4",
        },
        "name": {"type": str},
    }  # type: Dict[str, str]

    _REQUIRED = ("eth_name", "name")  # type: tuple(str)

    _DEFAULTS = {
        "address": "0.0.0.0",
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, eth_name=None, address="0.0.0.0", name=None):
        super(DeviceIpv4Loopback, self).__init__()
        self._parent = parent
        self._set_property("eth_name", eth_name)
        self._set_property("address", address)
        self._set_property("name", name)

    def set(self, eth_name=None, address=None, name=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def eth_name(self):
        # type: () -> str
        """eth_name getter

        The unique name of the Ethernet interface behind which this Loopback interface will be created.. x-constraint:. /components/schemas/Device.Ethernet/properties/name. . x-constraint:. /components/schemas/Device.Ethernet/properties/name.

        Returns: str
        """
        return self._get_property("eth_name")

    @eth_name.setter
    def eth_name(self, value):
        """eth_name setter

        The unique name of the Ethernet interface behind which this Loopback interface will be created.. x-constraint:. /components/schemas/Device.Ethernet/properties/name. . x-constraint:. /components/schemas/Device.Ethernet/properties/name.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property eth_name as None")
        self._set_property("eth_name", value)

    @property
    def address(self):
        # type: () -> str
        """address getter

        The IPv4 Loopback address with prefix length of 32.

        Returns: str
        """
        return self._get_property("address")

    @address.setter
    def address(self, value):
        """address setter

        The IPv4 Loopback address with prefix length of 32.

        value: str
        """
        self._set_property("address", value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)


class DeviceIpv4LoopbackIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(DeviceIpv4LoopbackIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[DeviceIpv4Loopback]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> DeviceIpv4LoopbackIter
        return self._iter()

    def __next__(self):
        # type: () -> DeviceIpv4Loopback
        return self._next()

    def next(self):
        # type: () -> DeviceIpv4Loopback
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, DeviceIpv4Loopback):
            raise Exception("Item is not an instance of DeviceIpv4Loopback")

    def ipv4loopback(self, eth_name=None, address="0.0.0.0", name=None):
        # type: (str,str,str) -> DeviceIpv4LoopbackIter
        """Factory method that creates an instance of the DeviceIpv4Loopback class

        An IPv4 Loopback interface.

        Returns: DeviceIpv4LoopbackIter
        """
        item = DeviceIpv4Loopback(
            parent=self._parent, eth_name=eth_name, address=address, name=name
        )
        self._add(item)
        return self

    def add(self, eth_name=None, address="0.0.0.0", name=None):
        # type: (str,str,str) -> DeviceIpv4Loopback
        """Add method that creates and returns an instance of the DeviceIpv4Loopback class

        An IPv4 Loopback interface.

        Returns: DeviceIpv4Loopback
        """
        item = DeviceIpv4Loopback(
            parent=self._parent, eth_name=eth_name, address=address, name=name
        )
        self._add(item)
        return item


class DeviceIpv6Loopback(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "eth_name": {"type": str},
        "address": {
            "type": str,
            "format": "ipv6",
        },
        "name": {"type": str},
    }  # type: Dict[str, str]

    _REQUIRED = ("eth_name", "name")  # type: tuple(str)

    _DEFAULTS = {
        "address": "::0",
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, eth_name=None, address="::0", name=None):
        super(DeviceIpv6Loopback, self).__init__()
        self._parent = parent
        self._set_property("eth_name", eth_name)
        self._set_property("address", address)
        self._set_property("name", name)

    def set(self, eth_name=None, address=None, name=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def eth_name(self):
        # type: () -> str
        """eth_name getter

        The unique name of the Ethernet interface behind which this Loopback interface will be created.. x-constraint:. /components/schemas/Device.Ethernet/properties/name. . x-constraint:. /components/schemas/Device.Ethernet/properties/name.

        Returns: str
        """
        return self._get_property("eth_name")

    @eth_name.setter
    def eth_name(self, value):
        """eth_name setter

        The unique name of the Ethernet interface behind which this Loopback interface will be created.. x-constraint:. /components/schemas/Device.Ethernet/properties/name. . x-constraint:. /components/schemas/Device.Ethernet/properties/name.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property eth_name as None")
        self._set_property("eth_name", value)

    @property
    def address(self):
        # type: () -> str
        """address getter

        The IPv6 Loopback address with prefix length of 128.

        Returns: str
        """
        return self._get_property("address")

    @address.setter
    def address(self, value):
        """address setter

        The IPv6 Loopback address with prefix length of 128.

        value: str
        """
        self._set_property("address", value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)


class DeviceIpv6LoopbackIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(DeviceIpv6LoopbackIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[DeviceIpv6Loopback]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> DeviceIpv6LoopbackIter
        return self._iter()

    def __next__(self):
        # type: () -> DeviceIpv6Loopback
        return self._next()

    def next(self):
        # type: () -> DeviceIpv6Loopback
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, DeviceIpv6Loopback):
            raise Exception("Item is not an instance of DeviceIpv6Loopback")

    def ipv6loopback(self, eth_name=None, address="::0", name=None):
        # type: (str,str,str) -> DeviceIpv6LoopbackIter
        """Factory method that creates an instance of the DeviceIpv6Loopback class

        An IPv6 Loopback interface

        Returns: DeviceIpv6LoopbackIter
        """
        item = DeviceIpv6Loopback(
            parent=self._parent, eth_name=eth_name, address=address, name=name
        )
        self._add(item)
        return self

    def add(self, eth_name=None, address="::0", name=None):
        # type: (str,str,str) -> DeviceIpv6Loopback
        """Add method that creates and returns an instance of the DeviceIpv6Loopback class

        An IPv6 Loopback interface

        Returns: DeviceIpv6Loopback
        """
        item = DeviceIpv6Loopback(
            parent=self._parent, eth_name=eth_name, address=address, name=name
        )
        self._add(item)
        return item


class DeviceIsisRouter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "instance": {"type": "DeviceIsisMultiInstance"},
        "system_id": {
            "type": str,
            "format": "hex",
        },
        "interfaces": {"type": "IsisInterfaceIter"},
        "basic": {"type": "IsisBasic"},
        "advanced": {"type": "IsisAdvanced"},
        "router_auth": {"type": "IsisAuthentication"},
        "v4_routes": {"type": "IsisV4RouteRangeIter"},
        "v6_routes": {"type": "IsisV6RouteRangeIter"},
        "name": {"type": str},
    }  # type: Dict[str, str]

    _REQUIRED = ("system_id", "interfaces", "name")  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, system_id=None, name=None):
        super(DeviceIsisRouter, self).__init__()
        self._parent = parent
        self._set_property("system_id", system_id)
        self._set_property("name", name)

    def set(self, system_id=None, name=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def instance(self):
        # type: () -> DeviceIsisMultiInstance
        """instance getter

        This container properties of an Multi-Instance-capable router (MI-RTR). This container properties of an Multi-Instance-capable router (MI-RTR). This container properties of an Multi-Instance-capable router (MI-RTR). This contains the properties of Multi-Instance-capable routers or MI-RTR. Each router can emulate one ISIS instance at time.

        Returns: DeviceIsisMultiInstance
        """
        return self._get_property("instance", DeviceIsisMultiInstance)

    @property
    def system_id(self):
        # type: () -> str
        """system_id getter

        The System ID for this emulated ISIS router, e.g. "640100010000".

        Returns: str
        """
        return self._get_property("system_id")

    @system_id.setter
    def system_id(self, value):
        """system_id setter

        The System ID for this emulated ISIS router, e.g. "640100010000".

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property system_id as None")
        self._set_property("system_id", value)

    @property
    def interfaces(self):
        # type: () -> IsisInterfaceIter
        """interfaces getter

        List of ISIS interfaces for this router.

        Returns: IsisInterfaceIter
        """
        return self._get_property(
            "interfaces", IsisInterfaceIter, self._parent, self._choice
        )

    @property
    def basic(self):
        # type: () -> IsisBasic
        """basic getter

        This contains ISIS router basic properties.This contains ISIS router basic properties.This contains ISIS router basic properties.Contains basic properties of an ISIS Router.

        Returns: IsisBasic
        """
        return self._get_property("basic", IsisBasic)

    @property
    def advanced(self):
        # type: () -> IsisAdvanced
        """advanced getter

        Contains ISIS router advanced properties.Contains ISIS router advanced properties.Contains ISIS router advanced properties.Contains advance properties of an ISIS Router..

        Returns: IsisAdvanced
        """
        return self._get_property("advanced", IsisAdvanced)

    @property
    def router_auth(self):
        # type: () -> IsisAuthentication
        """router_auth getter

        This contains ISIS Area/Domain authentication properties.This contains ISIS Area/Domain authentication properties.This contains ISIS Area/Domain authentication properties.ISIS Router authentication properties.

        Returns: IsisAuthentication
        """
        return self._get_property("router_auth", IsisAuthentication)

    @property
    def v4_routes(self):
        # type: () -> IsisV4RouteRangeIter
        """v4_routes getter

        Emulated ISIS IPv4 routes.

        Returns: IsisV4RouteRangeIter
        """
        return self._get_property(
            "v4_routes", IsisV4RouteRangeIter, self._parent, self._choice
        )

    @property
    def v6_routes(self):
        # type: () -> IsisV6RouteRangeIter
        """v6_routes getter

        Emulated ISIS IPv6 routes.

        Returns: IsisV6RouteRangeIter
        """
        return self._get_property(
            "v6_routes", IsisV6RouteRangeIter, self._parent, self._choice
        )

    @property
    def name(self):
        # type: () -> str
        """name getter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)


class DeviceIsisMultiInstance(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "iid": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "itids": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "iid": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, iid=1, itids=None):
        super(DeviceIsisMultiInstance, self).__init__()
        self._parent = parent
        self._set_property("iid", iid)
        self._set_property("itids", itids)

    def set(self, iid=None, itids=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def iid(self):
        # type: () -> int
        """iid getter

        Instance Identifier (IID) TLV will associate PDU with an ISIS instance by using unique 16-bit number and including one or more Instance-Specific Topology Identifiers (ITIDs).

        Returns: int
        """
        return self._get_property("iid")

    @iid.setter
    def iid(self, value):
        """iid setter

        Instance Identifier (IID) TLV will associate PDU with an ISIS instance by using unique 16-bit number and including one or more Instance-Specific Topology Identifiers (ITIDs).

        value: int
        """
        self._set_property("iid", value)

    @property
    def itids(self):
        # type: () -> List[int]
        """itids getter

        This contains one or more ITIDs that will be advertised in IID TLV.

        Returns: List[int]
        """
        return self._get_property("itids")

    @itids.setter
    def itids(self, value):
        """itids setter

        This contains one or more ITIDs that will be advertised in IID TLV.

        value: List[int]
        """
        self._set_property("itids", value)


class IsisInterface(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "eth_name": {"type": str},
        "metric": {
            "type": int,
            "format": "uint32",
            "maximum": 16777215,
        },
        "network_type": {
            "type": str,
            "enum": [
                "broadcast",
                "point_to_point",
            ],
        },
        "level_type": {
            "type": str,
            "enum": [
                "level_1",
                "level_2",
                "level_1_2",
            ],
        },
        "l1_settings": {"type": "IsisInterfaceLevel"},
        "l2_settings": {"type": "IsisInterfaceLevel"},
        "multi_topology_ids": {"type": "IsisMTIter"},
        "traffic_engineering": {"type": "LinkStateTEIter"},
        "authentication": {"type": "IsisInterfaceAuthentication"},
        "advanced": {"type": "IsisInterfaceAdvanced"},
        "link_protection": {"type": "IsisInterfaceLinkProtection"},
        "srlg_values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 16777215,
        },
        "name": {"type": str},
    }  # type: Dict[str, str]

    _REQUIRED = ("eth_name", "name")  # type: tuple(str)

    _DEFAULTS = {
        "metric": 10,
        "network_type": "broadcast",
        "level_type": "level_2",
    }  # type: Dict[str, Union(type)]

    BROADCAST = "broadcast"  # type: str
    POINT_TO_POINT = "point_to_point"  # type: str

    LEVEL_1 = "level_1"  # type: str
    LEVEL_2 = "level_2"  # type: str
    LEVEL_1_2 = "level_1_2"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        eth_name=None,
        metric=10,
        network_type="broadcast",
        level_type="level_2",
        srlg_values=None,
        name=None,
    ):
        super(IsisInterface, self).__init__()
        self._parent = parent
        self._set_property("eth_name", eth_name)
        self._set_property("metric", metric)
        self._set_property("network_type", network_type)
        self._set_property("level_type", level_type)
        self._set_property("srlg_values", srlg_values)
        self._set_property("name", name)

    def set(
        self,
        eth_name=None,
        metric=None,
        network_type=None,
        level_type=None,
        srlg_values=None,
        name=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def eth_name(self):
        # type: () -> str
        """eth_name getter

        The unique name of the Ethernet interface on which ISIS is running. Two ISIS interfaces cannot share the same Ethernet. . x-constraint:. /components/schemas/Device.Ethernet/properties/name. . x-constraint:. /components/schemas/Device.Ethernet/properties/name.

        Returns: str
        """
        return self._get_property("eth_name")

    @eth_name.setter
    def eth_name(self, value):
        """eth_name setter

        The unique name of the Ethernet interface on which ISIS is running. Two ISIS interfaces cannot share the same Ethernet. . x-constraint:. /components/schemas/Device.Ethernet/properties/name. . x-constraint:. /components/schemas/Device.Ethernet/properties/name.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property eth_name as None")
        self._set_property("eth_name", value)

    @property
    def metric(self):
        # type: () -> int
        """metric getter

        The default metric cost for the interface.

        Returns: int
        """
        return self._get_property("metric")

    @metric.setter
    def metric(self, value):
        """metric setter

        The default metric cost for the interface.

        value: int
        """
        self._set_property("metric", value)

    @property
    def network_type(self):
        # type: () -> Union[Literal["broadcast"], Literal["point_to_point"]]
        """network_type getter

        The type of network link.

        Returns: Union[Literal["broadcast"], Literal["point_to_point"]]
        """
        return self._get_property("network_type")

    @network_type.setter
    def network_type(self, value):
        """network_type setter

        The type of network link.

        value: Union[Literal["broadcast"], Literal["point_to_point"]]
        """
        self._set_property("network_type", value)

    @property
    def level_type(self):
        # type: () -> Union[Literal["level_1"], Literal["level_1_2"], Literal["level_2"]]
        """level_type getter

        This indicates whether this router is participating in Level-1 (L1), Level-2 (L2) or both L1 and L2 domains on this interface.

        Returns: Union[Literal["level_1"], Literal["level_1_2"], Literal["level_2"]]
        """
        return self._get_property("level_type")

    @level_type.setter
    def level_type(self, value):
        """level_type setter

        This indicates whether this router is participating in Level-1 (L1), Level-2 (L2) or both L1 and L2 domains on this interface.

        value: Union[Literal["level_1"], Literal["level_1_2"], Literal["level_2"]]
        """
        self._set_property("level_type", value)

    @property
    def l1_settings(self):
        # type: () -> IsisInterfaceLevel
        """l1_settings getter

        Configuration for the properties of Level Hello.Configuration for the properties of Level Hello.Configuration for the properties of Level Hello.Settings of Level Hello.

        Returns: IsisInterfaceLevel
        """
        return self._get_property("l1_settings", IsisInterfaceLevel)

    @property
    def l2_settings(self):
        # type: () -> IsisInterfaceLevel
        """l2_settings getter

        Configuration for the properties of Level Hello.Configuration for the properties of Level Hello.Configuration for the properties of Level Hello.Settings of Level Hello.

        Returns: IsisInterfaceLevel
        """
        return self._get_property("l2_settings", IsisInterfaceLevel)

    @property
    def multi_topology_ids(self):
        # type: () -> IsisMTIter
        """multi_topology_ids getter

        Contains the properties of multiple topologies.

        Returns: IsisMTIter
        """
        return self._get_property(
            "multi_topology_ids", IsisMTIter, self._parent, self._choice
        )

    @property
    def traffic_engineering(self):
        # type: () -> LinkStateTEIter
        """traffic_engineering getter

        Contains list of Traffic Engineering attributes.

        Returns: LinkStateTEIter
        """
        return self._get_property(
            "traffic_engineering", LinkStateTEIter, self._parent, self._choice
        )

    @property
    def authentication(self):
        # type: () -> IsisInterfaceAuthentication
        """authentication getter

        Optional container for circuit authentication properties.Optional container for circuit authentication properties.Optional container for circuit authentication properties.The Circuit authentication method used for the interfaces on this emulated ISIS v4/v6 router.

        Returns: IsisInterfaceAuthentication
        """
        return self._get_property("authentication", IsisInterfaceAuthentication)

    @property
    def advanced(self):
        # type: () -> IsisInterfaceAdvanced
        """advanced getter

        Optional container for advanced interface properties.Optional container for advanced interface properties.Optional container for advanced interface properties.Optional container for advanced interface properties.

        Returns: IsisInterfaceAdvanced
        """
        return self._get_property("advanced", IsisInterfaceAdvanced)

    @property
    def link_protection(self):
        # type: () -> IsisInterfaceLinkProtection
        """link_protection getter

        Optional container for the link protection sub TLV (type 20).Optional container for the link protection sub TLV (type 20).Optional container for the link protection sub TLV (type 20).Link protection on the ISIS link between two interfaces.

        Returns: IsisInterfaceLinkProtection
        """
        return self._get_property("link_protection", IsisInterfaceLinkProtection)

    @property
    def srlg_values(self):
        # type: () -> List[int]
        """srlg_values getter

        This contains list of SRLG values for the link between two interfaces.

        Returns: List[int]
        """
        return self._get_property("srlg_values")

    @srlg_values.setter
    def srlg_values(self, value):
        """srlg_values setter

        This contains list of SRLG values for the link between two interfaces.

        value: List[int]
        """
        self._set_property("srlg_values", value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)


class IsisInterfaceLevel(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "priority": {
            "type": int,
            "format": "uint32",
        },
        "hello_interval": {
            "type": int,
            "format": "uint32",
        },
        "dead_interval": {
            "type": int,
            "format": "uint32",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "priority": 0,
        "hello_interval": 10,
        "dead_interval": 30,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, priority=0, hello_interval=10, dead_interval=30):
        super(IsisInterfaceLevel, self).__init__()
        self._parent = parent
        self._set_property("priority", priority)
        self._set_property("hello_interval", hello_interval)
        self._set_property("dead_interval", dead_interval)

    def set(self, priority=None, hello_interval=None, dead_interval=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def priority(self):
        # type: () -> int
        """priority getter

        The Priority setting in Level LAN Hellos for Designated Router election.

        Returns: int
        """
        return self._get_property("priority")

    @priority.setter
    def priority(self, value):
        """priority setter

        The Priority setting in Level LAN Hellos for Designated Router election.

        value: int
        """
        self._set_property("priority", value)

    @property
    def hello_interval(self):
        # type: () -> int
        """hello_interval getter

        The Hello interval for Level Hello messages, in seconds.

        Returns: int
        """
        return self._get_property("hello_interval")

    @hello_interval.setter
    def hello_interval(self, value):
        """hello_interval setter

        The Hello interval for Level Hello messages, in seconds.

        value: int
        """
        self._set_property("hello_interval", value)

    @property
    def dead_interval(self):
        # type: () -> int
        """dead_interval getter

        The Dead (Holding Time) interval for Level Hello messages, in seconds.

        Returns: int
        """
        return self._get_property("dead_interval")

    @dead_interval.setter
    def dead_interval(self, value):
        """dead_interval setter

        The Dead (Holding Time) interval for Level Hello messages, in seconds.

        value: int
        """
        self._set_property("dead_interval", value)


class IsisMT(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "mt_id": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "link_metric": {
            "type": int,
            "format": "uint32",
            "maximum": 16777215,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "mt_id": 0,
        "link_metric": 10,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, mt_id=0, link_metric=10):
        super(IsisMT, self).__init__()
        self._parent = parent
        self._set_property("mt_id", mt_id)
        self._set_property("link_metric", link_metric)

    def set(self, mt_id=None, link_metric=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def mt_id(self):
        # type: () -> int
        """mt_id getter

        The Multi Topology ID for one of the topologies supported on the ISIS interface.

        Returns: int
        """
        return self._get_property("mt_id")

    @mt_id.setter
    def mt_id(self, value):
        """mt_id setter

        The Multi Topology ID for one of the topologies supported on the ISIS interface.

        value: int
        """
        self._set_property("mt_id", value)

    @property
    def link_metric(self):
        # type: () -> int
        """link_metric getter

        Specifies the link metric for this topology on the ISIS interface.

        Returns: int
        """
        return self._get_property("link_metric")

    @link_metric.setter
    def link_metric(self, value):
        """link_metric setter

        Specifies the link metric for this topology on the ISIS interface.

        value: int
        """
        self._set_property("link_metric", value)


class IsisMTIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(IsisMTIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[IsisMT]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> IsisMTIter
        return self._iter()

    def __next__(self):
        # type: () -> IsisMT
        return self._next()

    def next(self):
        # type: () -> IsisMT
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, IsisMT):
            raise Exception("Item is not an instance of IsisMT")

    def mt(self, mt_id=0, link_metric=10):
        # type: (int,int) -> IsisMTIter
        """Factory method that creates an instance of the IsisMT class

        Configuration of properties per interface per topology when multiple topologies are configured in an ISIS router.. in ISIS router.

        Returns: IsisMTIter
        """
        item = IsisMT(parent=self._parent, mt_id=mt_id, link_metric=link_metric)
        self._add(item)
        return self

    def add(self, mt_id=0, link_metric=10):
        # type: (int,int) -> IsisMT
        """Add method that creates and returns an instance of the IsisMT class

        Configuration of properties per interface per topology when multiple topologies are configured in an ISIS router.. in ISIS router.

        Returns: IsisMT
        """
        item = IsisMT(parent=self._parent, mt_id=mt_id, link_metric=link_metric)
        self._add(item)
        return item


class LinkStateTE(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "administrative_group": {
            "type": str,
            "format": "hex",
        },
        "metric_level": {
            "type": int,
            "format": "uint32",
        },
        "max_bandwith": {
            "type": int,
            "format": "uint32",
        },
        "max_reservable_bandwidth": {
            "type": int,
            "format": "uint32",
        },
        "priority_bandwidths": {"type": "LinkStatepriorityBandwidths"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "administrative_group": "00000000",
        "metric_level": 0,
        "max_bandwith": 125000000,
        "max_reservable_bandwidth": 125000000,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        administrative_group="00000000",
        metric_level=0,
        max_bandwith=125000000,
        max_reservable_bandwidth=125000000,
    ):
        super(LinkStateTE, self).__init__()
        self._parent = parent
        self._set_property("administrative_group", administrative_group)
        self._set_property("metric_level", metric_level)
        self._set_property("max_bandwith", max_bandwith)
        self._set_property("max_reservable_bandwidth", max_reservable_bandwidth)

    def set(
        self,
        administrative_group=None,
        metric_level=None,
        max_bandwith=None,
        max_reservable_bandwidth=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def administrative_group(self):
        # type: () -> str
        """administrative_group getter

        The Administrative group sub-TLV (sub-TLV 3). It is 4-octet user-defined bit mask used to assign administrative group numbers to the interface, for use in assigning colors and resource classes. Each set bit corresponds to single administrative group for this interface. The settings translate into Group numbers, which range from to 31 (integers).

        Returns: str
        """
        return self._get_property("administrative_group")

    @administrative_group.setter
    def administrative_group(self, value):
        """administrative_group setter

        The Administrative group sub-TLV (sub-TLV 3). It is 4-octet user-defined bit mask used to assign administrative group numbers to the interface, for use in assigning colors and resource classes. Each set bit corresponds to single administrative group for this interface. The settings translate into Group numbers, which range from to 31 (integers).

        value: str
        """
        self._set_property("administrative_group", value)

    @property
    def metric_level(self):
        # type: () -> int
        """metric_level getter

        The user-assigned link metric for Traffic Engineering.

        Returns: int
        """
        return self._get_property("metric_level")

    @metric_level.setter
    def metric_level(self, value):
        """metric_level setter

        The user-assigned link metric for Traffic Engineering.

        value: int
        """
        self._set_property("metric_level", value)

    @property
    def max_bandwith(self):
        # type: () -> int
        """max_bandwith getter

        The maximum link bandwidth (sub-TLV 9) in bytes/sec allowed for this link for direction.

        Returns: int
        """
        return self._get_property("max_bandwith")

    @max_bandwith.setter
    def max_bandwith(self, value):
        """max_bandwith setter

        The maximum link bandwidth (sub-TLV 9) in bytes/sec allowed for this link for direction.

        value: int
        """
        self._set_property("max_bandwith", value)

    @property
    def max_reservable_bandwidth(self):
        # type: () -> int
        """max_reservable_bandwidth getter

        The maximum link bandwidth (sub-TLV 10) in bytes/sec allowed for this link in direction.

        Returns: int
        """
        return self._get_property("max_reservable_bandwidth")

    @max_reservable_bandwidth.setter
    def max_reservable_bandwidth(self, value):
        """max_reservable_bandwidth setter

        The maximum link bandwidth (sub-TLV 10) in bytes/sec allowed for this link in direction.

        value: int
        """
        self._set_property("max_reservable_bandwidth", value)

    @property
    def priority_bandwidths(self):
        # type: () -> LinkStatepriorityBandwidths
        """priority_bandwidths getter

        Specifies the amount of bandwidth that can be reserved with setup priority of . through 7, arranged in increasing order with priority having highest priority. In ISIS, this is sent in sub-TLV (11) of Extended IS Reachability TLV. Specifies the amount of bandwidth that can be reserved with setup priority of . through 7, arranged in increasing order with priority having highest priority. In ISIS, this is sent in sub-TLV (11) of Extended IS Reachability TLV. Specifies the amount of bandwidth that can be reserved with setup priority of . through 7, arranged in increasing order with priority having highest priority. In ISIS, this is sent in sub-TLV (11) of Extended IS Reachability TLV. Configuration of bandwidths of priority through priority 7.

        Returns: LinkStatepriorityBandwidths
        """
        return self._get_property("priority_bandwidths", LinkStatepriorityBandwidths)


class LinkStatepriorityBandwidths(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "pb0": {
            "type": int,
            "format": "uint32",
        },
        "pb1": {
            "type": int,
            "format": "uint32",
        },
        "pb2": {
            "type": int,
            "format": "uint32",
        },
        "pb3": {
            "type": int,
            "format": "uint32",
        },
        "pb4": {
            "type": int,
            "format": "uint32",
        },
        "pb5": {
            "type": int,
            "format": "uint32",
        },
        "pb6": {
            "type": int,
            "format": "uint32",
        },
        "pb7": {
            "type": int,
            "format": "uint32",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "pb0": 125000000,
        "pb1": 125000000,
        "pb2": 125000000,
        "pb3": 125000000,
        "pb4": 125000000,
        "pb5": 125000000,
        "pb6": 125000000,
        "pb7": 125000000,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        pb0=125000000,
        pb1=125000000,
        pb2=125000000,
        pb3=125000000,
        pb4=125000000,
        pb5=125000000,
        pb6=125000000,
        pb7=125000000,
    ):
        super(LinkStatepriorityBandwidths, self).__init__()
        self._parent = parent
        self._set_property("pb0", pb0)
        self._set_property("pb1", pb1)
        self._set_property("pb2", pb2)
        self._set_property("pb3", pb3)
        self._set_property("pb4", pb4)
        self._set_property("pb5", pb5)
        self._set_property("pb6", pb6)
        self._set_property("pb7", pb7)

    def set(
        self,
        pb0=None,
        pb1=None,
        pb2=None,
        pb3=None,
        pb4=None,
        pb5=None,
        pb6=None,
        pb7=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def pb0(self):
        # type: () -> int
        """pb0 getter

        Specifies the amount of bandwidth that can be reserved for the Priority 0.

        Returns: int
        """
        return self._get_property("pb0")

    @pb0.setter
    def pb0(self, value):
        """pb0 setter

        Specifies the amount of bandwidth that can be reserved for the Priority 0.

        value: int
        """
        self._set_property("pb0", value)

    @property
    def pb1(self):
        # type: () -> int
        """pb1 getter

        Specifies the amount of bandwidth that can be reserved for the Priority 1.

        Returns: int
        """
        return self._get_property("pb1")

    @pb1.setter
    def pb1(self, value):
        """pb1 setter

        Specifies the amount of bandwidth that can be reserved for the Priority 1.

        value: int
        """
        self._set_property("pb1", value)

    @property
    def pb2(self):
        # type: () -> int
        """pb2 getter

        Specify the amount of bandwidth that can be reserved for the Priority 2.

        Returns: int
        """
        return self._get_property("pb2")

    @pb2.setter
    def pb2(self, value):
        """pb2 setter

        Specify the amount of bandwidth that can be reserved for the Priority 2.

        value: int
        """
        self._set_property("pb2", value)

    @property
    def pb3(self):
        # type: () -> int
        """pb3 getter

        Specifies the amount of bandwidth that can be reserved for the Priority 3.

        Returns: int
        """
        return self._get_property("pb3")

    @pb3.setter
    def pb3(self, value):
        """pb3 setter

        Specifies the amount of bandwidth that can be reserved for the Priority 3.

        value: int
        """
        self._set_property("pb3", value)

    @property
    def pb4(self):
        # type: () -> int
        """pb4 getter

        Specifies the amount of bandwidth that can be reserved for the Priority 4.

        Returns: int
        """
        return self._get_property("pb4")

    @pb4.setter
    def pb4(self, value):
        """pb4 setter

        Specifies the amount of bandwidth that can be reserved for the Priority 4.

        value: int
        """
        self._set_property("pb4", value)

    @property
    def pb5(self):
        # type: () -> int
        """pb5 getter

        Specifies the amount of bandwidth that can be reserved for the Priority 5.

        Returns: int
        """
        return self._get_property("pb5")

    @pb5.setter
    def pb5(self, value):
        """pb5 setter

        Specifies the amount of bandwidth that can be reserved for the Priority 5.

        value: int
        """
        self._set_property("pb5", value)

    @property
    def pb6(self):
        # type: () -> int
        """pb6 getter

        Specifies the amount of bandwidth that can be reserved for the Priority 6.

        Returns: int
        """
        return self._get_property("pb6")

    @pb6.setter
    def pb6(self, value):
        """pb6 setter

        Specifies the amount of bandwidth that can be reserved for the Priority 6.

        value: int
        """
        self._set_property("pb6", value)

    @property
    def pb7(self):
        # type: () -> int
        """pb7 getter

        Specifies the amount of bandwidth that can be reserved for the Priority 7.

        Returns: int
        """
        return self._get_property("pb7")

    @pb7.setter
    def pb7(self, value):
        """pb7 setter

        Specifies the amount of bandwidth that can be reserved for the Priority 7.

        value: int
        """
        self._set_property("pb7", value)


class LinkStateTEIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(LinkStateTEIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[LinkStateTE]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> LinkStateTEIter
        return self._iter()

    def __next__(self):
        # type: () -> LinkStateTE
        return self._next()

    def next(self):
        # type: () -> LinkStateTE
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, LinkStateTE):
            raise Exception("Item is not an instance of LinkStateTE")

    def te(
        self,
        administrative_group="00000000",
        metric_level=0,
        max_bandwith=125000000,
        max_reservable_bandwidth=125000000,
    ):
        # type: (str,int,int,int) -> LinkStateTEIter
        """Factory method that creates an instance of the LinkStateTE class

        A container for Traffic Engineering properties on interface.

        Returns: LinkStateTEIter
        """
        item = LinkStateTE(
            parent=self._parent,
            administrative_group=administrative_group,
            metric_level=metric_level,
            max_bandwith=max_bandwith,
            max_reservable_bandwidth=max_reservable_bandwidth,
        )
        self._add(item)
        return self

    def add(
        self,
        administrative_group="00000000",
        metric_level=0,
        max_bandwith=125000000,
        max_reservable_bandwidth=125000000,
    ):
        # type: (str,int,int,int) -> LinkStateTE
        """Add method that creates and returns an instance of the LinkStateTE class

        A container for Traffic Engineering properties on interface.

        Returns: LinkStateTE
        """
        item = LinkStateTE(
            parent=self._parent,
            administrative_group=administrative_group,
            metric_level=metric_level,
            max_bandwith=max_bandwith,
            max_reservable_bandwidth=max_reservable_bandwidth,
        )
        self._add(item)
        return item


class IsisInterfaceAuthentication(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "auth_type": {
            "type": str,
            "enum": [
                "md5",
                "password",
            ],
        },
        "md5": {
            "type": str,
            "minLength": 0,
            "maxLength": 255,
        },
        "password": {
            "type": str,
            "minLength": 0,
            "maxLength": 255,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("auth_type",)  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    MD5 = "md5"  # type: str
    PASSWORD = "password"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, auth_type=None, md5=None, password=None):
        super(IsisInterfaceAuthentication, self).__init__()
        self._parent = parent
        self._set_property("auth_type", auth_type)
        self._set_property("md5", md5)
        self._set_property("password", password)

    def set(self, auth_type=None, md5=None, password=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def auth_type(self):
        # type: () -> Union[Literal["md5"], Literal["password"]]
        """auth_type getter

        The circuit authentication method.

        Returns: Union[Literal["md5"], Literal["password"]]
        """
        return self._get_property("auth_type")

    @auth_type.setter
    def auth_type(self, value):
        """auth_type setter

        The circuit authentication method.

        value: Union[Literal["md5"], Literal["password"]]
        """
        if value is None:
            raise TypeError("Cannot set required property auth_type as None")
        self._set_property("auth_type", value)

    @property
    def md5(self):
        # type: () -> str
        """md5 getter

        MD5 key to be used for authentication.

        Returns: str
        """
        return self._get_property("md5")

    @md5.setter
    def md5(self, value):
        """md5 setter

        MD5 key to be used for authentication.

        value: str
        """
        self._set_property("md5", value)

    @property
    def password(self):
        # type: () -> str
        """password getter

        The password, in clear text, to be used for Authentication.

        Returns: str
        """
        return self._get_property("password")

    @password.setter
    def password(self, value):
        """password setter

        The password, in clear text, to be used for Authentication.

        value: str
        """
        self._set_property("password", value)


class IsisInterfaceAdvanced(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "auto_adjust_mtu": {"type": bool},
        "auto_adjust_area": {"type": bool},
        "auto_adjust_supported_protocols": {"type": bool},
        "enable_3way_handshake": {"type": bool},
        "p2p_hellos_to_unicast_mac": {"type": bool},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "auto_adjust_mtu": True,
        "auto_adjust_area": True,
        "auto_adjust_supported_protocols": False,
        "enable_3way_handshake": True,
        "p2p_hellos_to_unicast_mac": False,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        auto_adjust_mtu=True,
        auto_adjust_area=True,
        auto_adjust_supported_protocols=False,
        enable_3way_handshake=True,
        p2p_hellos_to_unicast_mac=False,
    ):
        super(IsisInterfaceAdvanced, self).__init__()
        self._parent = parent
        self._set_property("auto_adjust_mtu", auto_adjust_mtu)
        self._set_property("auto_adjust_area", auto_adjust_area)
        self._set_property(
            "auto_adjust_supported_protocols", auto_adjust_supported_protocols
        )
        self._set_property("enable_3way_handshake", enable_3way_handshake)
        self._set_property("p2p_hellos_to_unicast_mac", p2p_hellos_to_unicast_mac)

    def set(
        self,
        auto_adjust_mtu=None,
        auto_adjust_area=None,
        auto_adjust_supported_protocols=None,
        enable_3way_handshake=None,
        p2p_hellos_to_unicast_mac=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def auto_adjust_mtu(self):
        # type: () -> bool
        """auto_adjust_mtu getter

        If padded Hello message is received on the interface, the length of the Hello packets sent out on that interface is adjusted to match.

        Returns: bool
        """
        return self._get_property("auto_adjust_mtu")

    @auto_adjust_mtu.setter
    def auto_adjust_mtu(self, value):
        """auto_adjust_mtu setter

        If padded Hello message is received on the interface, the length of the Hello packets sent out on that interface is adjusted to match.

        value: bool
        """
        self._set_property("auto_adjust_mtu", value)

    @property
    def auto_adjust_area(self):
        # type: () -> bool
        """auto_adjust_area getter

        If Level Hello is received on this emulated router for an area not currently in its area list, an area from the received Hello is added to that list. This ensures an area match for all future Level Hellos from the source L1 router.

        Returns: bool
        """
        return self._get_property("auto_adjust_area")

    @auto_adjust_area.setter
    def auto_adjust_area(self, value):
        """auto_adjust_area setter

        If Level Hello is received on this emulated router for an area not currently in its area list, an area from the received Hello is added to that list. This ensures an area match for all future Level Hellos from the source L1 router.

        value: bool
        """
        self._set_property("auto_adjust_area", value)

    @property
    def auto_adjust_supported_protocols(self):
        # type: () -> bool
        """auto_adjust_supported_protocols getter

        If Hello message listing supported protocols is received on this emulated router, the supported protocols advertised by this router are changed to match exactly.

        Returns: bool
        """
        return self._get_property("auto_adjust_supported_protocols")

    @auto_adjust_supported_protocols.setter
    def auto_adjust_supported_protocols(self, value):
        """auto_adjust_supported_protocols setter

        If Hello message listing supported protocols is received on this emulated router, the supported protocols advertised by this router are changed to match exactly.

        value: bool
        """
        self._set_property("auto_adjust_supported_protocols", value)

    @property
    def enable_3way_handshake(self):
        # type: () -> bool
        """enable_3way_handshake getter

        If it is true, the Point-to-Point circuit will include 3-way TLV in its Point-to-Point IIH and attempt to establish the adjacency as specified in RFC 5303. This field is not applicable if network_type is set to 'broadcast' type in ISIS interface.

        Returns: bool
        """
        return self._get_property("enable_3way_handshake")

    @enable_3way_handshake.setter
    def enable_3way_handshake(self, value):
        """enable_3way_handshake setter

        If it is true, the Point-to-Point circuit will include 3-way TLV in its Point-to-Point IIH and attempt to establish the adjacency as specified in RFC 5303. This field is not applicable if network_type is set to 'broadcast' type in ISIS interface.

        value: bool
        """
        self._set_property("enable_3way_handshake", value)

    @property
    def p2p_hellos_to_unicast_mac(self):
        # type: () -> bool
        """p2p_hellos_to_unicast_mac getter

        If it is true, the Point-to-Point Hello messages will be sent to the unicast MAC address.

        Returns: bool
        """
        return self._get_property("p2p_hellos_to_unicast_mac")

    @p2p_hellos_to_unicast_mac.setter
    def p2p_hellos_to_unicast_mac(self, value):
        """p2p_hellos_to_unicast_mac setter

        If it is true, the Point-to-Point Hello messages will be sent to the unicast MAC address.

        value: bool
        """
        self._set_property("p2p_hellos_to_unicast_mac", value)


class IsisInterfaceLinkProtection(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "extra_traffic": {"type": bool},
        "unprotected": {"type": bool},
        "shared": {"type": bool},
        "dedicated_1_to_1": {"type": bool},
        "dedicated_1_plus_1": {"type": bool},
        "enhanced": {"type": bool},
        "reserved_40": {"type": bool},
        "reserved_80": {"type": bool},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "extra_traffic": False,
        "unprotected": False,
        "shared": False,
        "dedicated_1_to_1": False,
        "dedicated_1_plus_1": False,
        "enhanced": False,
        "reserved_40": False,
        "reserved_80": False,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        extra_traffic=False,
        unprotected=False,
        shared=False,
        dedicated_1_to_1=False,
        dedicated_1_plus_1=False,
        enhanced=False,
        reserved_40=False,
        reserved_80=False,
    ):
        super(IsisInterfaceLinkProtection, self).__init__()
        self._parent = parent
        self._set_property("extra_traffic", extra_traffic)
        self._set_property("unprotected", unprotected)
        self._set_property("shared", shared)
        self._set_property("dedicated_1_to_1", dedicated_1_to_1)
        self._set_property("dedicated_1_plus_1", dedicated_1_plus_1)
        self._set_property("enhanced", enhanced)
        self._set_property("reserved_40", reserved_40)
        self._set_property("reserved_80", reserved_80)

    def set(
        self,
        extra_traffic=None,
        unprotected=None,
        shared=None,
        dedicated_1_to_1=None,
        dedicated_1_plus_1=None,
        enhanced=None,
        reserved_40=None,
        reserved_80=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def extra_traffic(self):
        # type: () -> bool
        """extra_traffic getter

        Enable this to protect other link or links. LSPs on link of this type are lost. if any of the links fail.

        Returns: bool
        """
        return self._get_property("extra_traffic")

    @extra_traffic.setter
    def extra_traffic(self, value):
        """extra_traffic setter

        Enable this to protect other link or links. LSPs on link of this type are lost. if any of the links fail.

        value: bool
        """
        self._set_property("extra_traffic", value)

    @property
    def unprotected(self):
        # type: () -> bool
        """unprotected getter

        Enabling this signifies that there is no other link protecting this link. LSPs on link of this type are lost if the link fails.

        Returns: bool
        """
        return self._get_property("unprotected")

    @unprotected.setter
    def unprotected(self, value):
        """unprotected setter

        Enabling this signifies that there is no other link protecting this link. LSPs on link of this type are lost if the link fails.

        value: bool
        """
        self._set_property("unprotected", value)

    @property
    def shared(self):
        # type: () -> bool
        """shared getter

        Enable this to share the Extra Traffic links between one or more links of type Shared.There are one or more disjoint links of type Extra Traffic that are protecting this link.

        Returns: bool
        """
        return self._get_property("shared")

    @shared.setter
    def shared(self, value):
        """shared setter

        Enable this to share the Extra Traffic links between one or more links of type Shared.There are one or more disjoint links of type Extra Traffic that are protecting this link.

        value: bool
        """
        self._set_property("shared", value)

    @property
    def dedicated_1_to_1(self):
        # type: () -> bool
        """dedicated_1_to_1 getter

        Enabling this signifies that there is one dedicated disjoint link of type Extra Traffic that is protecting this link.

        Returns: bool
        """
        return self._get_property("dedicated_1_to_1")

    @dedicated_1_to_1.setter
    def dedicated_1_to_1(self, value):
        """dedicated_1_to_1 setter

        Enabling this signifies that there is one dedicated disjoint link of type Extra Traffic that is protecting this link.

        value: bool
        """
        self._set_property("dedicated_1_to_1", value)

    @property
    def dedicated_1_plus_1(self):
        # type: () -> bool
        """dedicated_1_plus_1 getter

        Enabling this signifies that dedicated disjoint link is protecting this link. However, the protecting link is not advertised in the link state database and is therefore not available for the routing of LSPs.

        Returns: bool
        """
        return self._get_property("dedicated_1_plus_1")

    @dedicated_1_plus_1.setter
    def dedicated_1_plus_1(self, value):
        """dedicated_1_plus_1 setter

        Enabling this signifies that dedicated disjoint link is protecting this link. However, the protecting link is not advertised in the link state database and is therefore not available for the routing of LSPs.

        value: bool
        """
        self._set_property("dedicated_1_plus_1", value)

    @property
    def enhanced(self):
        # type: () -> bool
        """enhanced getter

        Enabling this signifies that protection scheme that is more reliable than Dedicated 1+1.

        Returns: bool
        """
        return self._get_property("enhanced")

    @enhanced.setter
    def enhanced(self, value):
        """enhanced setter

        Enabling this signifies that protection scheme that is more reliable than Dedicated 1+1.

        value: bool
        """
        self._set_property("enhanced", value)

    @property
    def reserved_40(self):
        # type: () -> bool
        """reserved_40 getter

        This is Protection Scheme with value 0x40.

        Returns: bool
        """
        return self._get_property("reserved_40")

    @reserved_40.setter
    def reserved_40(self, value):
        """reserved_40 setter

        This is Protection Scheme with value 0x40.

        value: bool
        """
        self._set_property("reserved_40", value)

    @property
    def reserved_80(self):
        # type: () -> bool
        """reserved_80 getter

        This is Protection Scheme with value 0x80.

        Returns: bool
        """
        return self._get_property("reserved_80")

    @reserved_80.setter
    def reserved_80(self, value):
        """reserved_80 setter

        This is Protection Scheme with value 0x80.

        value: bool
        """
        self._set_property("reserved_80", value)


class IsisInterfaceIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(IsisInterfaceIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[IsisInterface]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> IsisInterfaceIter
        return self._iter()

    def __next__(self):
        # type: () -> IsisInterface
        return self._next()

    def next(self):
        # type: () -> IsisInterface
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, IsisInterface):
            raise Exception("Item is not an instance of IsisInterface")

    def interface(
        self,
        eth_name=None,
        metric=10,
        network_type="broadcast",
        level_type="level_2",
        srlg_values=None,
        name=None,
    ):
        # type: (str,int,Union[Literal["broadcast"], Literal["point_to_point"]],Union[Literal["level_1"], Literal["level_1_2"], Literal["level_2"]],List[int],str) -> IsisInterfaceIter
        """Factory method that creates an instance of the IsisInterface class

        Configuration for single ISIS interface.

        Returns: IsisInterfaceIter
        """
        item = IsisInterface(
            parent=self._parent,
            eth_name=eth_name,
            metric=metric,
            network_type=network_type,
            level_type=level_type,
            srlg_values=srlg_values,
            name=name,
        )
        self._add(item)
        return self

    def add(
        self,
        eth_name=None,
        metric=10,
        network_type="broadcast",
        level_type="level_2",
        srlg_values=None,
        name=None,
    ):
        # type: (str,int,Union[Literal["broadcast"], Literal["point_to_point"]],Union[Literal["level_1"], Literal["level_1_2"], Literal["level_2"]],List[int],str) -> IsisInterface
        """Add method that creates and returns an instance of the IsisInterface class

        Configuration for single ISIS interface.

        Returns: IsisInterface
        """
        item = IsisInterface(
            parent=self._parent,
            eth_name=eth_name,
            metric=metric,
            network_type=network_type,
            level_type=level_type,
            srlg_values=srlg_values,
            name=name,
        )
        self._add(item)
        return item


class IsisBasic(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "ipv4_te_router_id": {
            "type": str,
            "format": "ipv4",
        },
        "hostname": {"type": str},
        "enable_wide_metric": {"type": bool},
        "learned_lsp_filter": {"type": bool},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "enable_wide_metric": True,
        "learned_lsp_filter": False,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        ipv4_te_router_id=None,
        hostname=None,
        enable_wide_metric=True,
        learned_lsp_filter=False,
    ):
        super(IsisBasic, self).__init__()
        self._parent = parent
        self._set_property("ipv4_te_router_id", ipv4_te_router_id)
        self._set_property("hostname", hostname)
        self._set_property("enable_wide_metric", enable_wide_metric)
        self._set_property("learned_lsp_filter", learned_lsp_filter)

    def set(
        self,
        ipv4_te_router_id=None,
        hostname=None,
        enable_wide_metric=None,
        learned_lsp_filter=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def ipv4_te_router_id(self):
        # type: () -> str
        """ipv4_te_router_id getter

        IPv4 Traffic Engineering(TE) router id. This address should be configured as an IPv4 Loopback address in 'ipv4_loopbacks' in the Device.

        Returns: str
        """
        return self._get_property("ipv4_te_router_id")

    @ipv4_te_router_id.setter
    def ipv4_te_router_id(self, value):
        """ipv4_te_router_id setter

        IPv4 Traffic Engineering(TE) router id. This address should be configured as an IPv4 Loopback address in 'ipv4_loopbacks' in the Device.

        value: str
        """
        self._set_property("ipv4_te_router_id", value)

    @property
    def hostname(self):
        # type: () -> str
        """hostname getter

        Host name for the router. The host name is transmitted in all the packets sent from the router.

        Returns: str
        """
        return self._get_property("hostname")

    @hostname.setter
    def hostname(self, value):
        """hostname setter

        Host name for the router. The host name is transmitted in all the packets sent from the router.

        value: str
        """
        self._set_property("hostname", value)

    @property
    def enable_wide_metric(self):
        # type: () -> bool
        """enable_wide_metric getter

        When set to true, it allows sending of more detailed metric information for the routes using 32-bit wide values using TLV 135 IP reachability and more detailed reachability information for IS reachability by using TLV 22. The detailed usage is described in RFC3784.

        Returns: bool
        """
        return self._get_property("enable_wide_metric")

    @enable_wide_metric.setter
    def enable_wide_metric(self, value):
        """enable_wide_metric setter

        When set to true, it allows sending of more detailed metric information for the routes using 32-bit wide values using TLV 135 IP reachability and more detailed reachability information for IS reachability by using TLV 22. The detailed usage is described in RFC3784.

        value: bool
        """
        self._set_property("enable_wide_metric", value)

    @property
    def learned_lsp_filter(self):
        # type: () -> bool
        """learned_lsp_filter getter

        Configuration for controlling storage of ISIS learned LSPs are received from the neighbors.

        Returns: bool
        """
        return self._get_property("learned_lsp_filter")

    @learned_lsp_filter.setter
    def learned_lsp_filter(self, value):
        """learned_lsp_filter setter

        Configuration for controlling storage of ISIS learned LSPs are received from the neighbors.

        value: bool
        """
        self._set_property("learned_lsp_filter", value)


class IsisAdvanced(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "enable_hello_padding": {"type": bool},
        "max_area_addresses": {
            "type": int,
            "format": "uint32",
            "maximum": 254,
        },
        "area_addresses": {
            "type": list,
            "itemtype": str,
            "itemformat": "hex",
        },
        "lsp_refresh_rate": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "lsp_lifetime": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "psnp_interval": {
            "type": int,
            "format": "uint32",
            "maximum": 60000,
        },
        "csnp_interval": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 65535000,
        },
        "max_lsp_size": {
            "type": int,
            "format": "uint32",
            "minimum": 64,
            "maximum": 9216,
        },
        "lsp_mgroup_min_trans_interval": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 60000,
        },
        "enable_attached_bit": {"type": bool},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "enable_hello_padding": True,
        "max_area_addresses": 3,
        "lsp_refresh_rate": 600,
        "lsp_lifetime": 1200,
        "psnp_interval": 2000,
        "csnp_interval": 10000,
        "max_lsp_size": 1492,
        "lsp_mgroup_min_trans_interval": 5000,
        "enable_attached_bit": True,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        enable_hello_padding=True,
        max_area_addresses=3,
        area_addresses=None,
        lsp_refresh_rate=600,
        lsp_lifetime=1200,
        psnp_interval=2000,
        csnp_interval=10000,
        max_lsp_size=1492,
        lsp_mgroup_min_trans_interval=5000,
        enable_attached_bit=True,
    ):
        super(IsisAdvanced, self).__init__()
        self._parent = parent
        self._set_property("enable_hello_padding", enable_hello_padding)
        self._set_property("max_area_addresses", max_area_addresses)
        self._set_property("area_addresses", area_addresses)
        self._set_property("lsp_refresh_rate", lsp_refresh_rate)
        self._set_property("lsp_lifetime", lsp_lifetime)
        self._set_property("psnp_interval", psnp_interval)
        self._set_property("csnp_interval", csnp_interval)
        self._set_property("max_lsp_size", max_lsp_size)
        self._set_property(
            "lsp_mgroup_min_trans_interval", lsp_mgroup_min_trans_interval
        )
        self._set_property("enable_attached_bit", enable_attached_bit)

    def set(
        self,
        enable_hello_padding=None,
        max_area_addresses=None,
        area_addresses=None,
        lsp_refresh_rate=None,
        lsp_lifetime=None,
        psnp_interval=None,
        csnp_interval=None,
        max_lsp_size=None,
        lsp_mgroup_min_trans_interval=None,
        enable_attached_bit=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def enable_hello_padding(self):
        # type: () -> bool
        """enable_hello_padding getter

        It enables padding of Hello message to MTU size.

        Returns: bool
        """
        return self._get_property("enable_hello_padding")

    @enable_hello_padding.setter
    def enable_hello_padding(self, value):
        """enable_hello_padding setter

        It enables padding of Hello message to MTU size.

        value: bool
        """
        self._set_property("enable_hello_padding", value)

    @property
    def max_area_addresses(self):
        # type: () -> int
        """max_area_addresses getter

        The Number of Area Addresses permitted, with valid range from to 254. zero indicates maximum of addresses.

        Returns: int
        """
        return self._get_property("max_area_addresses")

    @max_area_addresses.setter
    def max_area_addresses(self, value):
        """max_area_addresses setter

        The Number of Area Addresses permitted, with valid range from to 254. zero indicates maximum of addresses.

        value: int
        """
        self._set_property("max_area_addresses", value)

    @property
    def area_addresses(self):
        # type: () -> List[str]
        """area_addresses getter

        Its combination of the ISP and HO-DSP.Usually all nodes within an area have the same area address. If no area addresses are configured, default area of "490001" will be advertised.

        Returns: List[str]
        """
        return self._get_property("area_addresses")

    @area_addresses.setter
    def area_addresses(self, value):
        """area_addresses setter

        Its combination of the ISP and HO-DSP.Usually all nodes within an area have the same area address. If no area addresses are configured, default area of "490001" will be advertised.

        value: List[str]
        """
        self._set_property("area_addresses", value)

    @property
    def lsp_refresh_rate(self):
        # type: () -> int
        """lsp_refresh_rate getter

        The rate at which LSPs are re-sent in seconds.

        Returns: int
        """
        return self._get_property("lsp_refresh_rate")

    @lsp_refresh_rate.setter
    def lsp_refresh_rate(self, value):
        """lsp_refresh_rate setter

        The rate at which LSPs are re-sent in seconds.

        value: int
        """
        self._set_property("lsp_refresh_rate", value)

    @property
    def lsp_lifetime(self):
        # type: () -> int
        """lsp_lifetime getter

        The MaxAge for retaining learned LSP on this router in seconds.

        Returns: int
        """
        return self._get_property("lsp_lifetime")

    @lsp_lifetime.setter
    def lsp_lifetime(self, value):
        """lsp_lifetime setter

        The MaxAge for retaining learned LSP on this router in seconds.

        value: int
        """
        self._set_property("lsp_lifetime", value)

    @property
    def psnp_interval(self):
        # type: () -> int
        """psnp_interval getter

        The number of milliseconds between transmissions of Partial Sequence Number PDU.

        Returns: int
        """
        return self._get_property("psnp_interval")

    @psnp_interval.setter
    def psnp_interval(self, value):
        """psnp_interval setter

        The number of milliseconds between transmissions of Partial Sequence Number PDU.

        value: int
        """
        self._set_property("psnp_interval", value)

    @property
    def csnp_interval(self):
        # type: () -> int
        """csnp_interval getter

        The number of milliseconds between transmissions of Partial Sequence Number PDU.

        Returns: int
        """
        return self._get_property("csnp_interval")

    @csnp_interval.setter
    def csnp_interval(self, value):
        """csnp_interval setter

        The number of milliseconds between transmissions of Partial Sequence Number PDU.

        value: int
        """
        self._set_property("csnp_interval", value)

    @property
    def max_lsp_size(self):
        # type: () -> int
        """max_lsp_size getter

        The maximum size in bytes of any LSP that can be transmitted over link of equal or less than maximum MTU size.

        Returns: int
        """
        return self._get_property("max_lsp_size")

    @max_lsp_size.setter
    def max_lsp_size(self, value):
        """max_lsp_size setter

        The maximum size in bytes of any LSP that can be transmitted over link of equal or less than maximum MTU size.

        value: int
        """
        self._set_property("max_lsp_size", value)

    @property
    def lsp_mgroup_min_trans_interval(self):
        # type: () -> int
        """lsp_mgroup_min_trans_interval getter

        The number of seconds between transmissions of LSPs/MGROUP-PDUs.

        Returns: int
        """
        return self._get_property("lsp_mgroup_min_trans_interval")

    @lsp_mgroup_min_trans_interval.setter
    def lsp_mgroup_min_trans_interval(self, value):
        """lsp_mgroup_min_trans_interval setter

        The number of seconds between transmissions of LSPs/MGROUP-PDUs.

        value: int
        """
        self._set_property("lsp_mgroup_min_trans_interval", value)

    @property
    def enable_attached_bit(self):
        # type: () -> bool
        """enable_attached_bit getter

        If the Attached bit is enabled, it indicates that the ISIS router is attached to another area or the Level backbone. The purpose of an Attached-Bit is to accomplish Inter-Area Routing. When an L1/L2 router is connected to more than one area, it sets the Attached-bit on its L1 LSP. This can cause default route 0.0.0.0/0 to be installed by the receiving router.

        Returns: bool
        """
        return self._get_property("enable_attached_bit")

    @enable_attached_bit.setter
    def enable_attached_bit(self, value):
        """enable_attached_bit setter

        If the Attached bit is enabled, it indicates that the ISIS router is attached to another area or the Level backbone. The purpose of an Attached-Bit is to accomplish Inter-Area Routing. When an L1/L2 router is connected to more than one area, it sets the Attached-bit on its L1 LSP. This can cause default route 0.0.0.0/0 to be installed by the receiving router.

        value: bool
        """
        self._set_property("enable_attached_bit", value)


class IsisAuthentication(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "ignore_receive_md5": {"type": bool},
        "area_auth": {"type": "IsisAuthenticationBase"},
        "domain_auth": {"type": "IsisAuthenticationBase"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "ignore_receive_md5": True,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, ignore_receive_md5=True):
        super(IsisAuthentication, self).__init__()
        self._parent = parent
        self._set_property("ignore_receive_md5", ignore_receive_md5)

    def set(self, ignore_receive_md5=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def ignore_receive_md5(self):
        # type: () -> bool
        """ignore_receive_md5 getter

        Do not verify MD5 checksum in received LSPs.

        Returns: bool
        """
        return self._get_property("ignore_receive_md5")

    @ignore_receive_md5.setter
    def ignore_receive_md5(self, value):
        """ignore_receive_md5 setter

        Do not verify MD5 checksum in received LSPs.

        value: bool
        """
        self._set_property("ignore_receive_md5", value)

    @property
    def area_auth(self):
        # type: () -> IsisAuthenticationBase
        """area_auth getter

        Optional container for ISIS authentication properties.Optional container for ISIS authentication properties.Optional container for ISIS authentication properties.The Area authentication method used for the emulated ISIS router.. This is used for L1 LSPs.

        Returns: IsisAuthenticationBase
        """
        return self._get_property("area_auth", IsisAuthenticationBase)

    @property
    def domain_auth(self):
        # type: () -> IsisAuthenticationBase
        """domain_auth getter

        Optional container for ISIS authentication properties.Optional container for ISIS authentication properties.Optional container for ISIS authentication properties.The Domain authentication method used for the emulated ISIS router.. This is used for L2 LSPs.

        Returns: IsisAuthenticationBase
        """
        return self._get_property("domain_auth", IsisAuthenticationBase)


class IsisAuthenticationBase(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "auth_type": {
            "type": str,
            "enum": [
                "md5",
                "password",
            ],
        },
        "md5": {
            "type": str,
            "minLength": 0,
            "maxLength": 255,
        },
        "password": {
            "type": str,
            "minLength": 0,
            "maxLength": 255,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("auth_type",)  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    MD5 = "md5"  # type: str
    PASSWORD = "password"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, auth_type=None, md5=None, password=None):
        super(IsisAuthenticationBase, self).__init__()
        self._parent = parent
        self._set_property("auth_type", auth_type)
        self._set_property("md5", md5)
        self._set_property("password", password)

    def set(self, auth_type=None, md5=None, password=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def auth_type(self):
        # type: () -> Union[Literal["md5"], Literal["password"]]
        """auth_type getter

        The authentication method.

        Returns: Union[Literal["md5"], Literal["password"]]
        """
        return self._get_property("auth_type")

    @auth_type.setter
    def auth_type(self, value):
        """auth_type setter

        The authentication method.

        value: Union[Literal["md5"], Literal["password"]]
        """
        if value is None:
            raise TypeError("Cannot set required property auth_type as None")
        self._set_property("auth_type", value)

    @property
    def md5(self):
        # type: () -> str
        """md5 getter

        Authentication as an MD5 key.

        Returns: str
        """
        return self._get_property("md5")

    @md5.setter
    def md5(self, value):
        """md5 setter

        Authentication as an MD5 key.

        value: str
        """
        self._set_property("md5", value)

    @property
    def password(self):
        # type: () -> str
        """password getter

        Authentication as clear text password.

        Returns: str
        """
        return self._get_property("password")

    @password.setter
    def password(self, value):
        """password setter

        Authentication as clear text password.

        value: str
        """
        self._set_property("password", value)


class IsisV4RouteRange(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "addresses": {"type": "V4RouteAddressIter"},
        "link_metric": {
            "type": int,
            "format": "uint32",
            "minimum": 0,
            "maximum": 16777215,
        },
        "origin_type": {
            "type": str,
            "enum": [
                "internal",
                "external",
            ],
        },
        "redistribution_type": {
            "type": str,
            "enum": [
                "up",
                "down",
            ],
        },
        "name": {"type": str},
        "prefix_attr_enabled": {"type": bool},
        "x_flag": {"type": bool},
        "r_flag": {"type": bool},
        "n_flag": {"type": bool},
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "link_metric": 0,
        "origin_type": "internal",
        "redistribution_type": "up",
        "prefix_attr_enabled": False,
        "x_flag": False,
        "r_flag": False,
        "n_flag": False,
    }  # type: Dict[str, Union(type)]

    INTERNAL = "internal"  # type: str
    EXTERNAL = "external"  # type: str

    UP = "up"  # type: str
    DOWN = "down"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        link_metric=0,
        origin_type="internal",
        redistribution_type="up",
        name=None,
        prefix_attr_enabled=False,
        x_flag=False,
        r_flag=False,
        n_flag=False,
    ):
        super(IsisV4RouteRange, self).__init__()
        self._parent = parent
        self._set_property("link_metric", link_metric)
        self._set_property("origin_type", origin_type)
        self._set_property("redistribution_type", redistribution_type)
        self._set_property("name", name)
        self._set_property("prefix_attr_enabled", prefix_attr_enabled)
        self._set_property("x_flag", x_flag)
        self._set_property("r_flag", r_flag)
        self._set_property("n_flag", n_flag)

    def set(
        self,
        link_metric=None,
        origin_type=None,
        redistribution_type=None,
        name=None,
        prefix_attr_enabled=None,
        x_flag=None,
        r_flag=None,
        n_flag=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def addresses(self):
        # type: () -> V4RouteAddressIter
        """addresses getter

        A list of group of IPv4 route addresses.

        Returns: V4RouteAddressIter
        """
        return self._get_property(
            "addresses", V4RouteAddressIter, self._parent, self._choice
        )

    @property
    def link_metric(self):
        # type: () -> int
        """link_metric getter

        The user-defined metric associated with this route range.

        Returns: int
        """
        return self._get_property("link_metric")

    @link_metric.setter
    def link_metric(self, value):
        """link_metric setter

        The user-defined metric associated with this route range.

        value: int
        """
        self._set_property("link_metric", value)

    @property
    def origin_type(self):
        # type: () -> Union[Literal["external"], Literal["internal"]]
        """origin_type getter

        The origin of the advertised route-internal or external to the ISIS area. Options include the following: Internal-for intra-area routes, through Level LSPs. External-for inter-area routes redistributed within L1, through Level. LSPs.

        Returns: Union[Literal["external"], Literal["internal"]]
        """
        return self._get_property("origin_type")

    @origin_type.setter
    def origin_type(self, value):
        """origin_type setter

        The origin of the advertised route-internal or external to the ISIS area. Options include the following: Internal-for intra-area routes, through Level LSPs. External-for inter-area routes redistributed within L1, through Level. LSPs.

        value: Union[Literal["external"], Literal["internal"]]
        """
        self._set_property("origin_type", value)

    @property
    def redistribution_type(self):
        # type: () -> Union[Literal["down"], Literal["up"]]
        """redistribution_type getter

        Defines the Up/Down (Redistribution) bit defined for TLVs 128 and 130 by RFC 2966. It is used for domain-wide advertisement of prefix information.. Up (0)-used when prefix is initially advertised within the ISIS L3. hierarchy, and for all other prefixes in L1 and L2 LSPs. (default) Down (1)-used when an L1/L2 router advertises L2 prefixes in L1 LSPs.. The prefixes are being advertised from higher level (L2) down to lower level (L1).

        Returns: Union[Literal["down"], Literal["up"]]
        """
        return self._get_property("redistribution_type")

    @redistribution_type.setter
    def redistribution_type(self, value):
        """redistribution_type setter

        Defines the Up/Down (Redistribution) bit defined for TLVs 128 and 130 by RFC 2966. It is used for domain-wide advertisement of prefix information.. Up (0)-used when prefix is initially advertised within the ISIS L3. hierarchy, and for all other prefixes in L1 and L2 LSPs. (default) Down (1)-used when an L1/L2 router advertises L2 prefixes in L1 LSPs.. The prefixes are being advertised from higher level (L2) down to lower level (L1).

        value: Union[Literal["down"], Literal["up"]]
        """
        self._set_property("redistribution_type", value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def prefix_attr_enabled(self):
        # type: () -> bool
        """prefix_attr_enabled getter

        Specifies whether the sub-TLV for IPv4/IPv6 Extended Reachability Attribute Flags. will be advertised or not.

        Returns: bool
        """
        return self._get_property("prefix_attr_enabled")

    @prefix_attr_enabled.setter
    def prefix_attr_enabled(self, value):
        """prefix_attr_enabled setter

        Specifies whether the sub-TLV for IPv4/IPv6 Extended Reachability Attribute Flags. will be advertised or not.

        value: bool
        """
        self._set_property("prefix_attr_enabled", value)

    @property
    def x_flag(self):
        # type: () -> bool
        """x_flag getter

        External Prefix Flag (Bit 0)

        Returns: bool
        """
        return self._get_property("x_flag")

    @x_flag.setter
    def x_flag(self, value):
        """x_flag setter

        External Prefix Flag (Bit 0)

        value: bool
        """
        self._set_property("x_flag", value)

    @property
    def r_flag(self):
        # type: () -> bool
        """r_flag getter

        Re-advertisement Flag (Bit 1)

        Returns: bool
        """
        return self._get_property("r_flag")

    @r_flag.setter
    def r_flag(self, value):
        """r_flag setter

        Re-advertisement Flag (Bit 1)

        value: bool
        """
        self._set_property("r_flag", value)

    @property
    def n_flag(self):
        # type: () -> bool
        """n_flag getter

        Node Flag (Bit 2)

        Returns: bool
        """
        return self._get_property("n_flag")

    @n_flag.setter
    def n_flag(self, value):
        """n_flag setter

        Node Flag (Bit 2)

        value: bool
        """
        self._set_property("n_flag", value)


class V4RouteAddress(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "address": {
            "type": str,
            "format": "ipv4",
        },
        "prefix": {
            "type": int,
            "format": "uint32",
            "maximum": 32,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("address",)  # type: tuple(str)

    _DEFAULTS = {
        "prefix": 24,
        "count": 1,
        "step": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, address=None, prefix=24, count=1, step=1):
        super(V4RouteAddress, self).__init__()
        self._parent = parent
        self._set_property("address", address)
        self._set_property("prefix", prefix)
        self._set_property("count", count)
        self._set_property("step", step)

    def set(self, address=None, prefix=None, count=None, step=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def address(self):
        # type: () -> str
        """address getter

        The starting address of the network.

        Returns: str
        """
        return self._get_property("address")

    @address.setter
    def address(self, value):
        """address setter

        The starting address of the network.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property address as None")
        self._set_property("address", value)

    @property
    def prefix(self):
        # type: () -> int
        """prefix getter

        The IPv4 network prefix length to be applied to the address.

        Returns: int
        """
        return self._get_property("prefix")

    @prefix.setter
    def prefix(self, value):
        """prefix setter

        The IPv4 network prefix length to be applied to the address.

        value: int
        """
        self._set_property("prefix", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        The total number of addresses in the range.

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        The total number of addresses in the range.

        value: int
        """
        self._set_property("count", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        Increments the network address prefixes within route range where multiple routes are present. The value is incremented according to the Prefix Length and Step.

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        Increments the network address prefixes within route range where multiple routes are present. The value is incremented according to the Prefix Length and Step.

        value: int
        """
        self._set_property("step", value)


class V4RouteAddressIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(V4RouteAddressIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[V4RouteAddress]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> V4RouteAddressIter
        return self._iter()

    def __next__(self):
        # type: () -> V4RouteAddress
        return self._next()

    def next(self):
        # type: () -> V4RouteAddress
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, V4RouteAddress):
            raise Exception("Item is not an instance of V4RouteAddress")

    def v4routeaddress(self, address=None, prefix=24, count=1, step=1):
        # type: (str,int,int,int) -> V4RouteAddressIter
        """Factory method that creates an instance of the V4RouteAddress class

        A container for IPv4 route addresses.

        Returns: V4RouteAddressIter
        """
        item = V4RouteAddress(
            parent=self._parent, address=address, prefix=prefix, count=count, step=step
        )
        self._add(item)
        return self

    def add(self, address=None, prefix=24, count=1, step=1):
        # type: (str,int,int,int) -> V4RouteAddress
        """Add method that creates and returns an instance of the V4RouteAddress class

        A container for IPv4 route addresses.

        Returns: V4RouteAddress
        """
        item = V4RouteAddress(
            parent=self._parent, address=address, prefix=prefix, count=count, step=step
        )
        self._add(item)
        return item


class IsisV4RouteRangeIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(IsisV4RouteRangeIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[IsisV4RouteRange]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> IsisV4RouteRangeIter
        return self._iter()

    def __next__(self):
        # type: () -> IsisV4RouteRange
        return self._next()

    def next(self):
        # type: () -> IsisV4RouteRange
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, IsisV4RouteRange):
            raise Exception("Item is not an instance of IsisV4RouteRange")

    def v4routerange(
        self,
        link_metric=0,
        origin_type="internal",
        redistribution_type="up",
        name=None,
        prefix_attr_enabled=False,
        x_flag=False,
        r_flag=False,
        n_flag=False,
    ):
        # type: (int,Union[Literal["external"], Literal["internal"]],Union[Literal["down"], Literal["up"]],str,bool,bool,bool,bool) -> IsisV4RouteRangeIter
        """Factory method that creates an instance of the IsisV4RouteRange class

        Emulated ISIS IPv4 routes.

        Returns: IsisV4RouteRangeIter
        """
        item = IsisV4RouteRange(
            parent=self._parent,
            link_metric=link_metric,
            origin_type=origin_type,
            redistribution_type=redistribution_type,
            name=name,
            prefix_attr_enabled=prefix_attr_enabled,
            x_flag=x_flag,
            r_flag=r_flag,
            n_flag=n_flag,
        )
        self._add(item)
        return self

    def add(
        self,
        link_metric=0,
        origin_type="internal",
        redistribution_type="up",
        name=None,
        prefix_attr_enabled=False,
        x_flag=False,
        r_flag=False,
        n_flag=False,
    ):
        # type: (int,Union[Literal["external"], Literal["internal"]],Union[Literal["down"], Literal["up"]],str,bool,bool,bool,bool) -> IsisV4RouteRange
        """Add method that creates and returns an instance of the IsisV4RouteRange class

        Emulated ISIS IPv4 routes.

        Returns: IsisV4RouteRange
        """
        item = IsisV4RouteRange(
            parent=self._parent,
            link_metric=link_metric,
            origin_type=origin_type,
            redistribution_type=redistribution_type,
            name=name,
            prefix_attr_enabled=prefix_attr_enabled,
            x_flag=x_flag,
            r_flag=r_flag,
            n_flag=n_flag,
        )
        self._add(item)
        return item


class IsisV6RouteRange(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "addresses": {"type": "V6RouteAddressIter"},
        "link_metric": {
            "type": int,
            "format": "uint32",
            "minimum": 0,
            "maximum": 16777215,
        },
        "origin_type": {
            "type": str,
            "enum": [
                "internal",
                "external",
            ],
        },
        "redistribution_type": {
            "type": str,
            "enum": [
                "up",
                "down",
            ],
        },
        "name": {"type": str},
        "prefix_attr_enabled": {"type": bool},
        "x_flag": {"type": bool},
        "r_flag": {"type": bool},
        "n_flag": {"type": bool},
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "link_metric": 0,
        "origin_type": "internal",
        "redistribution_type": "up",
        "prefix_attr_enabled": False,
        "x_flag": False,
        "r_flag": False,
        "n_flag": False,
    }  # type: Dict[str, Union(type)]

    INTERNAL = "internal"  # type: str
    EXTERNAL = "external"  # type: str

    UP = "up"  # type: str
    DOWN = "down"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        link_metric=0,
        origin_type="internal",
        redistribution_type="up",
        name=None,
        prefix_attr_enabled=False,
        x_flag=False,
        r_flag=False,
        n_flag=False,
    ):
        super(IsisV6RouteRange, self).__init__()
        self._parent = parent
        self._set_property("link_metric", link_metric)
        self._set_property("origin_type", origin_type)
        self._set_property("redistribution_type", redistribution_type)
        self._set_property("name", name)
        self._set_property("prefix_attr_enabled", prefix_attr_enabled)
        self._set_property("x_flag", x_flag)
        self._set_property("r_flag", r_flag)
        self._set_property("n_flag", n_flag)

    def set(
        self,
        link_metric=None,
        origin_type=None,
        redistribution_type=None,
        name=None,
        prefix_attr_enabled=None,
        x_flag=None,
        r_flag=None,
        n_flag=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def addresses(self):
        # type: () -> V6RouteAddressIter
        """addresses getter

        A list of group of IPv6 route addresses.

        Returns: V6RouteAddressIter
        """
        return self._get_property(
            "addresses", V6RouteAddressIter, self._parent, self._choice
        )

    @property
    def link_metric(self):
        # type: () -> int
        """link_metric getter

        The user-defined metric associated with this route range.

        Returns: int
        """
        return self._get_property("link_metric")

    @link_metric.setter
    def link_metric(self, value):
        """link_metric setter

        The user-defined metric associated with this route range.

        value: int
        """
        self._set_property("link_metric", value)

    @property
    def origin_type(self):
        # type: () -> Union[Literal["external"], Literal["internal"]]
        """origin_type getter

        The origin of the advertised route-internal or external to the ISIS area. Options include the following: Internal-for intra-area routes, through Level LSPs. External-for inter-area routes redistributed within L1, through Level. LSPs.

        Returns: Union[Literal["external"], Literal["internal"]]
        """
        return self._get_property("origin_type")

    @origin_type.setter
    def origin_type(self, value):
        """origin_type setter

        The origin of the advertised route-internal or external to the ISIS area. Options include the following: Internal-for intra-area routes, through Level LSPs. External-for inter-area routes redistributed within L1, through Level. LSPs.

        value: Union[Literal["external"], Literal["internal"]]
        """
        self._set_property("origin_type", value)

    @property
    def redistribution_type(self):
        # type: () -> Union[Literal["down"], Literal["up"]]
        """redistribution_type getter

        Defines the Up/Down (Redistribution) bit defined for TLVs 128 and 130 by RFC 2966. It is used for domain-wide advertisement of prefix information.. Up (0)-used when prefix is initially advertised within the ISIS L3. hierarchy, and for all other prefixes in L1 and L2 LSPs. (default) Down (1)-used when an L1/L2 router advertises L2 prefixes in L1 LSPs.. The prefixes are being advertised from higher level (L2) down to lower level (L1).

        Returns: Union[Literal["down"], Literal["up"]]
        """
        return self._get_property("redistribution_type")

    @redistribution_type.setter
    def redistribution_type(self, value):
        """redistribution_type setter

        Defines the Up/Down (Redistribution) bit defined for TLVs 128 and 130 by RFC 2966. It is used for domain-wide advertisement of prefix information.. Up (0)-used when prefix is initially advertised within the ISIS L3. hierarchy, and for all other prefixes in L1 and L2 LSPs. (default) Down (1)-used when an L1/L2 router advertises L2 prefixes in L1 LSPs.. The prefixes are being advertised from higher level (L2) down to lower level (L1).

        value: Union[Literal["down"], Literal["up"]]
        """
        self._set_property("redistribution_type", value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def prefix_attr_enabled(self):
        # type: () -> bool
        """prefix_attr_enabled getter

        Specifies whether the sub-TLV for IPv4/IPv6 Extended Reachability Attribute Flags. will be advertised or not.

        Returns: bool
        """
        return self._get_property("prefix_attr_enabled")

    @prefix_attr_enabled.setter
    def prefix_attr_enabled(self, value):
        """prefix_attr_enabled setter

        Specifies whether the sub-TLV for IPv4/IPv6 Extended Reachability Attribute Flags. will be advertised or not.

        value: bool
        """
        self._set_property("prefix_attr_enabled", value)

    @property
    def x_flag(self):
        # type: () -> bool
        """x_flag getter

        External Prefix Flag (Bit 0)

        Returns: bool
        """
        return self._get_property("x_flag")

    @x_flag.setter
    def x_flag(self, value):
        """x_flag setter

        External Prefix Flag (Bit 0)

        value: bool
        """
        self._set_property("x_flag", value)

    @property
    def r_flag(self):
        # type: () -> bool
        """r_flag getter

        Re-advertisement Flag (Bit 1)

        Returns: bool
        """
        return self._get_property("r_flag")

    @r_flag.setter
    def r_flag(self, value):
        """r_flag setter

        Re-advertisement Flag (Bit 1)

        value: bool
        """
        self._set_property("r_flag", value)

    @property
    def n_flag(self):
        # type: () -> bool
        """n_flag getter

        Node Flag (Bit 2)

        Returns: bool
        """
        return self._get_property("n_flag")

    @n_flag.setter
    def n_flag(self, value):
        """n_flag setter

        Node Flag (Bit 2)

        value: bool
        """
        self._set_property("n_flag", value)


class V6RouteAddress(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "address": {
            "type": str,
            "format": "ipv6",
        },
        "prefix": {
            "type": int,
            "format": "uint32",
            "maximum": 128,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("address",)  # type: tuple(str)

    _DEFAULTS = {
        "prefix": 64,
        "count": 1,
        "step": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, address=None, prefix=64, count=1, step=1):
        super(V6RouteAddress, self).__init__()
        self._parent = parent
        self._set_property("address", address)
        self._set_property("prefix", prefix)
        self._set_property("count", count)
        self._set_property("step", step)

    def set(self, address=None, prefix=None, count=None, step=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def address(self):
        # type: () -> str
        """address getter

        The starting address of the network.

        Returns: str
        """
        return self._get_property("address")

    @address.setter
    def address(self, value):
        """address setter

        The starting address of the network.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property address as None")
        self._set_property("address", value)

    @property
    def prefix(self):
        # type: () -> int
        """prefix getter

        The IPv6 network prefix length to be applied to the address.

        Returns: int
        """
        return self._get_property("prefix")

    @prefix.setter
    def prefix(self, value):
        """prefix setter

        The IPv6 network prefix length to be applied to the address.

        value: int
        """
        self._set_property("prefix", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        The total number of addresses in the range.

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        The total number of addresses in the range.

        value: int
        """
        self._set_property("count", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        Increments the network address prefixes within route range where multiple routes are present. The value is incremented according to the Prefix Length and Step.

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        Increments the network address prefixes within route range where multiple routes are present. The value is incremented according to the Prefix Length and Step.

        value: int
        """
        self._set_property("step", value)


class V6RouteAddressIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(V6RouteAddressIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[V6RouteAddress]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> V6RouteAddressIter
        return self._iter()

    def __next__(self):
        # type: () -> V6RouteAddress
        return self._next()

    def next(self):
        # type: () -> V6RouteAddress
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, V6RouteAddress):
            raise Exception("Item is not an instance of V6RouteAddress")

    def v6routeaddress(self, address=None, prefix=64, count=1, step=1):
        # type: (str,int,int,int) -> V6RouteAddressIter
        """Factory method that creates an instance of the V6RouteAddress class

        A container for IPv6 route addresses.

        Returns: V6RouteAddressIter
        """
        item = V6RouteAddress(
            parent=self._parent, address=address, prefix=prefix, count=count, step=step
        )
        self._add(item)
        return self

    def add(self, address=None, prefix=64, count=1, step=1):
        # type: (str,int,int,int) -> V6RouteAddress
        """Add method that creates and returns an instance of the V6RouteAddress class

        A container for IPv6 route addresses.

        Returns: V6RouteAddress
        """
        item = V6RouteAddress(
            parent=self._parent, address=address, prefix=prefix, count=count, step=step
        )
        self._add(item)
        return item


class IsisV6RouteRangeIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(IsisV6RouteRangeIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[IsisV6RouteRange]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> IsisV6RouteRangeIter
        return self._iter()

    def __next__(self):
        # type: () -> IsisV6RouteRange
        return self._next()

    def next(self):
        # type: () -> IsisV6RouteRange
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, IsisV6RouteRange):
            raise Exception("Item is not an instance of IsisV6RouteRange")

    def v6routerange(
        self,
        link_metric=0,
        origin_type="internal",
        redistribution_type="up",
        name=None,
        prefix_attr_enabled=False,
        x_flag=False,
        r_flag=False,
        n_flag=False,
    ):
        # type: (int,Union[Literal["external"], Literal["internal"]],Union[Literal["down"], Literal["up"]],str,bool,bool,bool,bool) -> IsisV6RouteRangeIter
        """Factory method that creates an instance of the IsisV6RouteRange class

        Emulated ISIS IPv6 routes.

        Returns: IsisV6RouteRangeIter
        """
        item = IsisV6RouteRange(
            parent=self._parent,
            link_metric=link_metric,
            origin_type=origin_type,
            redistribution_type=redistribution_type,
            name=name,
            prefix_attr_enabled=prefix_attr_enabled,
            x_flag=x_flag,
            r_flag=r_flag,
            n_flag=n_flag,
        )
        self._add(item)
        return self

    def add(
        self,
        link_metric=0,
        origin_type="internal",
        redistribution_type="up",
        name=None,
        prefix_attr_enabled=False,
        x_flag=False,
        r_flag=False,
        n_flag=False,
    ):
        # type: (int,Union[Literal["external"], Literal["internal"]],Union[Literal["down"], Literal["up"]],str,bool,bool,bool,bool) -> IsisV6RouteRange
        """Add method that creates and returns an instance of the IsisV6RouteRange class

        Emulated ISIS IPv6 routes.

        Returns: IsisV6RouteRange
        """
        item = IsisV6RouteRange(
            parent=self._parent,
            link_metric=link_metric,
            origin_type=origin_type,
            redistribution_type=redistribution_type,
            name=name,
            prefix_attr_enabled=prefix_attr_enabled,
            x_flag=x_flag,
            r_flag=r_flag,
            n_flag=n_flag,
        )
        self._add(item)
        return item


class DeviceBgpRouter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "router_id": {
            "type": str,
            "format": "ipv4",
        },
        "ipv4_interfaces": {"type": "BgpV4InterfaceIter"},
        "ipv6_interfaces": {"type": "BgpV6InterfaceIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ("router_id",)  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, router_id=None):
        super(DeviceBgpRouter, self).__init__()
        self._parent = parent
        self._set_property("router_id", router_id)

    def set(self, router_id=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def router_id(self):
        # type: () -> str
        """router_id getter

        The BGP router ID is unique identifier used by BGP. It is 32-bit value that is often represented by an IPv4 address.

        Returns: str
        """
        return self._get_property("router_id")

    @router_id.setter
    def router_id(self, value):
        """router_id setter

        The BGP router ID is unique identifier used by BGP. It is 32-bit value that is often represented by an IPv4 address.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property router_id as None")
        self._set_property("router_id", value)

    @property
    def ipv4_interfaces(self):
        # type: () -> BgpV4InterfaceIter
        """ipv4_interfaces getter

        This contains an array of references to IPv4 interfaces, each of which will have list of peers to different destinations.

        Returns: BgpV4InterfaceIter
        """
        return self._get_property(
            "ipv4_interfaces", BgpV4InterfaceIter, self._parent, self._choice
        )

    @property
    def ipv6_interfaces(self):
        # type: () -> BgpV6InterfaceIter
        """ipv6_interfaces getter

        This contains an array of references to IPv6 interfaces, each of which will have list of peers to different destinations.

        Returns: BgpV6InterfaceIter
        """
        return self._get_property(
            "ipv6_interfaces", BgpV6InterfaceIter, self._parent, self._choice
        )


class BgpV4Interface(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "ipv4_name": {"type": str},
        "peers": {"type": "BgpV4PeerIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ("ipv4_name",)  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, ipv4_name=None):
        super(BgpV4Interface, self).__init__()
        self._parent = parent
        self._set_property("ipv4_name", ipv4_name)

    def set(self, ipv4_name=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def ipv4_name(self):
        # type: () -> str
        """ipv4_name getter

        The unique name of the IPv4 or Loopback IPv4 interface used as the source IP for this list of BGP peers.. x-constraint:. /components/schemas/Device.Ipv4/properties/name. /components/schemas/Device.Ipv4Loopback/properties/name. . x-constraint:. /components/schemas/Device.Ipv4/properties/name. /components/schemas/Device.Ipv4Loopback/properties/name.

        Returns: str
        """
        return self._get_property("ipv4_name")

    @ipv4_name.setter
    def ipv4_name(self, value):
        """ipv4_name setter

        The unique name of the IPv4 or Loopback IPv4 interface used as the source IP for this list of BGP peers.. x-constraint:. /components/schemas/Device.Ipv4/properties/name. /components/schemas/Device.Ipv4Loopback/properties/name. . x-constraint:. /components/schemas/Device.Ipv4/properties/name. /components/schemas/Device.Ipv4Loopback/properties/name.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property ipv4_name as None")
        self._set_property("ipv4_name", value)

    @property
    def peers(self):
        # type: () -> BgpV4PeerIter
        """peers getter

        This contains the list of BGPv4 peers configured on this interface.

        Returns: BgpV4PeerIter
        """
        return self._get_property("peers", BgpV4PeerIter, self._parent, self._choice)


class BgpV4Peer(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "peer_address": {
            "type": str,
            "format": "ipv4",
        },
        "evpn_ethernet_segments": {"type": "BgpV4EthernetSegmentIter"},
        "as_type": {
            "type": str,
            "enum": [
                "ibgp",
                "ebgp",
            ],
        },
        "as_number": {
            "type": int,
            "format": "uint32",
        },
        "as_number_width": {
            "type": str,
            "enum": [
                "two",
                "four",
            ],
        },
        "advanced": {"type": "BgpAdvanced"},
        "capability": {"type": "BgpCapability"},
        "learned_information_filter": {"type": "BgpLearnedInformationFilter"},
        "v4_routes": {"type": "BgpV4RouteRangeIter"},
        "v6_routes": {"type": "BgpV6RouteRangeIter"},
        "v4_srte_policies": {"type": "BgpSrteV4PolicyIter"},
        "v6_srte_policies": {"type": "BgpSrteV6PolicyIter"},
        "name": {"type": str},
        "graceful_restart": {"type": "BgpGracefulRestart"},
    }  # type: Dict[str, str]

    _REQUIRED = ("peer_address", "as_type", "as_number", "name")  # type: tuple(str)

    _DEFAULTS = {
        "as_number_width": "four",
    }  # type: Dict[str, Union(type)]

    IBGP = "ibgp"  # type: str
    EBGP = "ebgp"  # type: str

    TWO = "two"  # type: str
    FOUR = "four"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        peer_address=None,
        as_type=None,
        as_number=None,
        as_number_width="four",
        name=None,
    ):
        super(BgpV4Peer, self).__init__()
        self._parent = parent
        self._set_property("peer_address", peer_address)
        self._set_property("as_type", as_type)
        self._set_property("as_number", as_number)
        self._set_property("as_number_width", as_number_width)
        self._set_property("name", name)

    def set(
        self,
        peer_address=None,
        as_type=None,
        as_number=None,
        as_number_width=None,
        name=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def peer_address(self):
        # type: () -> str
        """peer_address getter

        IPv4 address of the BGP peer for the session.

        Returns: str
        """
        return self._get_property("peer_address")

    @peer_address.setter
    def peer_address(self, value):
        """peer_address setter

        IPv4 address of the BGP peer for the session.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property peer_address as None")
        self._set_property("peer_address", value)

    @property
    def evpn_ethernet_segments(self):
        # type: () -> BgpV4EthernetSegmentIter
        """evpn_ethernet_segments getter

        This contains the list of Ethernet Virtual Private Network (EVPN) Ethernet Segments (ES) Per BGP Peer for IPv4 Address Family Identifier (AFI).. Each Ethernet Segment contains list of EVPN Instances (EVIs) . Each EVI contains list of Broadcast Domains. Each Broadcast Domain contains list of MAC/IP Ranges. . <Ethernet Segment, EVI, Broadcast Domain> is responsible for advertising Ethernet Auto-discovery Route Per EVI (Type 1).. <Ethernet Segment, EVI> is responsible for advertising Ethernet Auto-discovery Route Per Ethernet Segment (Type 1).. <Ethernet Segment, EVI, Broadcast Domain, MAC/IP> is responsible for advertising MAC/IP Advertisement Route (Type 2).. <Ethernet Segment, EVI, Broadcast Domain> is responsible for advertising Inclusive Multicast Ethernet Tag Route (Type 3).. Ethernet Segment is responsible for advertising Ethernet Segment Route (Type 4).

        Returns: BgpV4EthernetSegmentIter
        """
        return self._get_property(
            "evpn_ethernet_segments",
            BgpV4EthernetSegmentIter,
            self._parent,
            self._choice,
        )

    @property
    def as_type(self):
        # type: () -> Union[Literal["ebgp"], Literal["ibgp"]]
        """as_type getter

        The type of BGP autonomous system. External BGP is used for BGP links between two or more autonomous systems (ebgp). Internal BGP is used within single autonomous system (ibgp). BGP property defaults are aligned with this object defined as an internal BGP peer. If the as_type is specified as 'ebgp' then other properties will need to be specified as per an external BGP peer. Specifically, for 'ebgp', 'as_set_mode' attribute in 'as_path' field in any Route Range should be changed from default value 'do_not_include_local_as' to any other value.

        Returns: Union[Literal["ebgp"], Literal["ibgp"]]
        """
        return self._get_property("as_type")

    @as_type.setter
    def as_type(self, value):
        """as_type setter

        The type of BGP autonomous system. External BGP is used for BGP links between two or more autonomous systems (ebgp). Internal BGP is used within single autonomous system (ibgp). BGP property defaults are aligned with this object defined as an internal BGP peer. If the as_type is specified as 'ebgp' then other properties will need to be specified as per an external BGP peer. Specifically, for 'ebgp', 'as_set_mode' attribute in 'as_path' field in any Route Range should be changed from default value 'do_not_include_local_as' to any other value.

        value: Union[Literal["ebgp"], Literal["ibgp"]]
        """
        if value is None:
            raise TypeError("Cannot set required property as_type as None")
        self._set_property("as_type", value)

    @property
    def as_number(self):
        # type: () -> int
        """as_number getter

        Autonomous System Number (AS number or ASN)

        Returns: int
        """
        return self._get_property("as_number")

    @as_number.setter
    def as_number(self, value):
        """as_number setter

        Autonomous System Number (AS number or ASN)

        value: int
        """
        if value is None:
            raise TypeError("Cannot set required property as_number as None")
        self._set_property("as_number", value)

    @property
    def as_number_width(self):
        # type: () -> Union[Literal["four"], Literal["two"]]
        """as_number_width getter

        The width in bytes of the as_number values. Any as_number values that exceeds the width MUST result in an error.

        Returns: Union[Literal["four"], Literal["two"]]
        """
        return self._get_property("as_number_width")

    @as_number_width.setter
    def as_number_width(self, value):
        """as_number_width setter

        The width in bytes of the as_number values. Any as_number values that exceeds the width MUST result in an error.

        value: Union[Literal["four"], Literal["two"]]
        """
        self._set_property("as_number_width", value)

    @property
    def advanced(self):
        # type: () -> BgpAdvanced
        """advanced getter

        Configuration for BGP advanced settings.Configuration for BGP advanced settings.Configuration for BGP advanced settings.

        Returns: BgpAdvanced
        """
        return self._get_property("advanced", BgpAdvanced)

    @property
    def capability(self):
        # type: () -> BgpCapability
        """capability getter

        Configuration for BGP capability settings.Configuration for BGP capability settings.Configuration for BGP capability settings.

        Returns: BgpCapability
        """
        return self._get_property("capability", BgpCapability)

    @property
    def learned_information_filter(self):
        # type: () -> BgpLearnedInformationFilter
        """learned_information_filter getter

        Configuration for controlling storage of BGP learned information recieved from the peer.Configuration for controlling storage of BGP learned information recieved from the peer.Configuration for controlling storage of BGP learned information recieved from the peer.

        Returns: BgpLearnedInformationFilter
        """
        return self._get_property(
            "learned_information_filter", BgpLearnedInformationFilter
        )

    @property
    def v4_routes(self):
        # type: () -> BgpV4RouteRangeIter
        """v4_routes getter

        Emulated BGPv4 route ranges.

        Returns: BgpV4RouteRangeIter
        """
        return self._get_property(
            "v4_routes", BgpV4RouteRangeIter, self._parent, self._choice
        )

    @property
    def v6_routes(self):
        # type: () -> BgpV6RouteRangeIter
        """v6_routes getter

        Emulated BGPv6 route ranges.

        Returns: BgpV6RouteRangeIter
        """
        return self._get_property(
            "v6_routes", BgpV6RouteRangeIter, self._parent, self._choice
        )

    @property
    def v4_srte_policies(self):
        # type: () -> BgpSrteV4PolicyIter
        """v4_srte_policies getter

        Segment Routing Traffic Engineering (SR TE) Policies for IPv4 Address Family Identifier (AFI).

        Returns: BgpSrteV4PolicyIter
        """
        return self._get_property(
            "v4_srte_policies", BgpSrteV4PolicyIter, self._parent, self._choice
        )

    @property
    def v6_srte_policies(self):
        # type: () -> BgpSrteV6PolicyIter
        """v6_srte_policies getter

        Segment Routing Traffic Engineering (SR TE) Policies for IPv6 Address Family Identifier (AFI).

        Returns: BgpSrteV6PolicyIter
        """
        return self._get_property(
            "v6_srte_policies", BgpSrteV6PolicyIter, self._parent, self._choice
        )

    @property
    def name(self):
        # type: () -> str
        """name getter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.. Globally unique name of an object. It also serves as the primary key for arrays of objects.

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.. Globally unique name of an object. It also serves as the primary key for arrays of objects.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def graceful_restart(self):
        # type: () -> BgpGracefulRestart
        """graceful_restart getter

        The Graceful Restart Capability (RFC 4724) is BGP capability that can be used by BGP speaker to indicate its ability to preserve its forwarding state during BGP restart. The Graceful Restart (GR) capability is advertised in OPEN messages sent between BGP peers. After BGP session has been established, and the initial routing update has been completed, an End-of-RIB (Routing Information Base) marker is sent in an UPDATE message to convey information about routing convergence.The Graceful Restart Capability (RFC 4724) is BGP capability that can be used by BGP speaker to indicate its ability to preserve its forwarding state during BGP restart. The Graceful Restart (GR) capability is advertised in OPEN messages sent between BGP peers. After BGP session has been established, and the initial routing update has been completed, an End-of-RIB (Routing Information Base) marker is sent in an UPDATE message to convey information about routing convergence.The Graceful Restart Capability (RFC 4724) is BGP capability that can be used by BGP speaker to indicate its ability to preserve its forwarding state during BGP restart. The Graceful Restart (GR) capability is advertised in OPEN messages sent between BGP peers. After BGP session has been established, and the initial routing update has been completed, an End-of-RIB (Routing Information Base) marker is sent in an UPDATE message to convey information about routing convergence.

        Returns: BgpGracefulRestart
        """
        return self._get_property("graceful_restart", BgpGracefulRestart)


class BgpV4EthernetSegment(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "df_election": {"type": "BgpEthernetSegmentDfElection"},
        "evis": {"type": "BgpV4EvpnEvisIter"},
        "esi": {
            "type": str,
            "format": "hex",
        },
        "active_mode": {
            "type": str,
            "enum": [
                "single_active",
                "all_active",
            ],
        },
        "esi_label": {
            "type": int,
            "format": "uint32",
            "maximum": 16777215,
        },
        "advanced": {"type": "BgpRouteAdvanced"},
        "communities": {"type": "BgpCommunityIter"},
        "ext_communities": {"type": "BgpExtCommunityIter"},
        "as_path": {"type": "BgpAsPath"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "esi": "00000000000000000000",
        "active_mode": "all_active",
        "esi_label": 0,
    }  # type: Dict[str, Union(type)]

    SINGLE_ACTIVE = "single_active"  # type: str
    ALL_ACTIVE = "all_active"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        esi="00000000000000000000",
        active_mode="all_active",
        esi_label=0,
    ):
        super(BgpV4EthernetSegment, self).__init__()
        self._parent = parent
        self._set_property("esi", esi)
        self._set_property("active_mode", active_mode)
        self._set_property("esi_label", esi_label)

    def set(self, esi=None, active_mode=None, esi_label=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def df_election(self):
        # type: () -> BgpEthernetSegmentDfElection
        """df_election getter

        Configuration for Designated Forwarder (DF) election among the Provider Edge (PE) routers on the same Ethernet Segment.Configuration for Designated Forwarder (DF) election among the Provider Edge (PE) routers on the same Ethernet Segment.Configuration for Designated Forwarder (DF) election among the Provider Edge (PE) routers on the same Ethernet Segment.Designated Forwarder (DF) election configuration.

        Returns: BgpEthernetSegmentDfElection
        """
        return self._get_property("df_election", BgpEthernetSegmentDfElection)

    @property
    def evis(self):
        # type: () -> BgpV4EvpnEvisIter
        """evis getter

        This contains the list of EVIs.

        Returns: BgpV4EvpnEvisIter
        """
        return self._get_property("evis", BgpV4EvpnEvisIter, self._parent, self._choice)

    @property
    def esi(self):
        # type: () -> str
        """esi getter

        10-octet Ethernet Segment Identifier (ESI) Example For multi-home scenario nonZero ESI is '10000000000000000000' .

        Returns: str
        """
        return self._get_property("esi")

    @esi.setter
    def esi(self, value):
        """esi setter

        10-octet Ethernet Segment Identifier (ESI) Example For multi-home scenario nonZero ESI is '10000000000000000000' .

        value: str
        """
        self._set_property("esi", value)

    @property
    def active_mode(self):
        # type: () -> Union[Literal["all_active"], Literal["single_active"]]
        """active_mode getter

        Single Active or All Active mode Redundancy mode selection for Multi-home.

        Returns: Union[Literal["all_active"], Literal["single_active"]]
        """
        return self._get_property("active_mode")

    @active_mode.setter
    def active_mode(self, value):
        """active_mode setter

        Single Active or All Active mode Redundancy mode selection for Multi-home.

        value: Union[Literal["all_active"], Literal["single_active"]]
        """
        self._set_property("active_mode", value)

    @property
    def esi_label(self):
        # type: () -> int
        """esi_label getter

        The label value to be advertised as ESI Label in ESI Label Extended Community. This is included in Ethernet Auto-discovery per ES Routes advertised by router.

        Returns: int
        """
        return self._get_property("esi_label")

    @esi_label.setter
    def esi_label(self, value):
        """esi_label setter

        The label value to be advertised as ESI Label in ESI Label Extended Community. This is included in Ethernet Auto-discovery per ES Routes advertised by router.

        value: int
        """
        self._set_property("esi_label", value)

    @property
    def advanced(self):
        # type: () -> BgpRouteAdvanced
        """advanced getter

        Configuration for advanced BGP route range settings.Configuration for advanced BGP route range settings.Configuration for advanced BGP route range settings.

        Returns: BgpRouteAdvanced
        """
        return self._get_property("advanced", BgpRouteAdvanced)

    @property
    def communities(self):
        # type: () -> BgpCommunityIter
        """communities getter

        Optional community settings.

        Returns: BgpCommunityIter
        """
        return self._get_property(
            "communities", BgpCommunityIter, self._parent, self._choice
        )

    @property
    def ext_communities(self):
        # type: () -> BgpExtCommunityIter
        """ext_communities getter

        Optional Extended Community settings. The Extended Communities Attribute is transitive optional BGP attribute, with the Type Code 16. Community and Extended Communities attributes are utilized to trigger routing decisions, such as acceptance, rejection, preference, or redistribution. An extended community is an 8-Bytes value. It is divided into two main parts. The first Bytes of the community encode type and sub-type fields and the last Bytes carry unique set of data in format defined by the type and sub-type field. Extended communities provide larger range for grouping or categorizing communities. When type is administrator_as_2octet or administrator_as_4octet, the valid sub types are route target and origin. The valid value for administrator_as_2octet and administrator_as_4octet type is either two byte AS followed by four byte local administrator id or four byte AS followed by two byte local administrator id. When type is administrator_ipv4_address the valid sub types are route target and origin. The valid value for administrator_ipv4_address is four byte IPv4 address followed by two byte local administrator id. When type is opaque, valid sub types are color and encapsulation. When sub type is color, first two bytes of the value field contain flags and last four bytes contains the value of the color. When sub type is encapsulation the first four bytes of value field are reserved and last two bytes carries the tunnel type from IANA's "ETHER TYPES" registry e.g IPv4 (protocol type 0x0800), IPv6 (protocol type 0x86dd), and MPLS (protocol type 0x8847). When type is administrator_as_2octet_link_bandwidth the valid sub type is extended_bandwidth. The first two bytes of the value field contains the AS number and the last four bytes contains the bandwidth in IEEE floating point format. When type is evpn the valid subtype is mac_address. In the value field the low-order bit of the first byte(Flags) is defined as the "Sticky/static" flag and may be set to 1, indicating the MAC address is static and cannot move. The second byte is reserved and the last four bytes contain the sequence number which is used to ensure that PEs retain the correct MAC/IP Advertisement route when multiple updates occur for the same MAC address.

        Returns: BgpExtCommunityIter
        """
        return self._get_property(
            "ext_communities", BgpExtCommunityIter, self._parent, self._choice
        )

    @property
    def as_path(self):
        # type: () -> BgpAsPath
        """as_path getter

        This attribute identifies the autonomous systems through which routing information carried in this UPDATE message has passed. This contains the configuration of how to include the Local AS in the AS path attribute of the MP REACH NLRI. It also contains optional configuration of additional AS Path Segments that can be included in the AS Path attribute. The AS Path consists of Set or Sequence of Autonomous Systems (AS) numbers that routing information passes through to reach the destination.This attribute identifies the autonomous systems through which routing information carried in this UPDATE message has passed. This contains the configuration of how to include the Local AS in the AS path attribute of the MP REACH NLRI. It also contains optional configuration of additional AS Path Segments that can be included in the AS Path attribute. The AS Path consists of Set or Sequence of Autonomous Systems (AS) numbers that routing information passes through to reach the destination.This attribute identifies the autonomous systems through which routing information carried in this UPDATE message has passed. This contains the configuration of how to include the Local AS in the AS path attribute of the MP REACH NLRI. It also contains optional configuration of additional AS Path Segments that can be included in the AS Path attribute. The AS Path consists of Set or Sequence of Autonomous Systems (AS) numbers that routing information passes through to reach the destination.Optional AS PATH settings.

        Returns: BgpAsPath
        """
        return self._get_property("as_path", BgpAsPath)


class BgpEthernetSegmentDfElection(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "election_timer": {
            "type": int,
            "format": "uint32",
            "maximum": 300,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "election_timer": 3,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, election_timer=3):
        super(BgpEthernetSegmentDfElection, self).__init__()
        self._parent = parent
        self._set_property("election_timer", election_timer)

    def set(self, election_timer=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def election_timer(self):
        # type: () -> int
        """election_timer getter

        The DF election timer in seconds.

        Returns: int
        """
        return self._get_property("election_timer")

    @election_timer.setter
    def election_timer(self, value):
        """election_timer setter

        The DF election timer in seconds.

        value: int
        """
        self._set_property("election_timer", value)


class BgpV4EvpnEvis(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "evi_vxlan",
            ],
        },
        "evi_vxlan": {"type": "BgpV4EviVxlan"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "evi_vxlan",
    }  # type: Dict[str, Union(type)]

    EVI_VXLAN = "evi_vxlan"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None):
        super(BgpV4EvpnEvis, self).__init__()
        self._parent = parent
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    @property
    def evi_vxlan(self):
        # type: () -> BgpV4EviVxlan
        """Factory property that returns an instance of the BgpV4EviVxlan class

        Configuration for BGP EVPN EVI. Advertises following routes . Type - Inclusive Multicast Ethernet Tag Route. Type - Ethernet Auto-discovery Route (Per EVI). Type - Ethernet Auto-discovery Route (Per ES)

        Returns: BgpV4EviVxlan
        """
        return self._get_property("evi_vxlan", BgpV4EviVxlan, self, "evi_vxlan")

    @property
    def choice(self):
        # type: () -> Union[Literal["evi_vxlan"]]
        """choice getter

        TBD

        Returns: Union[Literal["evi_vxlan"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["evi_vxlan"]]
        """
        self._set_property("choice", value)


class BgpV4EviVxlan(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "broadcast_domains": {"type": "BgpV4EviVxlanBroadcastDomainIter"},
        "replication_type": {
            "type": str,
            "enum": [
                "ingress_replication",
            ],
        },
        "pmsi_label": {
            "type": int,
            "format": "uint32",
            "maximum": 16777215,
        },
        "ad_label": {
            "type": int,
            "format": "uint32",
            "maximum": 16777215,
        },
        "route_distinguisher": {"type": "BgpRouteDistinguisher"},
        "route_target_export": {"type": "BgpRouteTargetIter"},
        "route_target_import": {"type": "BgpRouteTargetIter"},
        "l3_route_target_export": {"type": "BgpRouteTargetIter"},
        "l3_route_target_import": {"type": "BgpRouteTargetIter"},
        "advanced": {"type": "BgpRouteAdvanced"},
        "communities": {"type": "BgpCommunityIter"},
        "ext_communities": {"type": "BgpExtCommunityIter"},
        "as_path": {"type": "BgpAsPath"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "replication_type": "ingress_replication",
        "pmsi_label": 16,
        "ad_label": 0,
    }  # type: Dict[str, Union(type)]

    INGRESS_REPLICATION = "ingress_replication"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        replication_type="ingress_replication",
        pmsi_label=16,
        ad_label=0,
    ):
        super(BgpV4EviVxlan, self).__init__()
        self._parent = parent
        self._set_property("replication_type", replication_type)
        self._set_property("pmsi_label", pmsi_label)
        self._set_property("ad_label", ad_label)

    def set(self, replication_type=None, pmsi_label=None, ad_label=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def broadcast_domains(self):
        # type: () -> BgpV4EviVxlanBroadcastDomainIter
        """broadcast_domains getter

        This contains the list of Broadcast Domains to be configured per EVI.

        Returns: BgpV4EviVxlanBroadcastDomainIter
        """
        return self._get_property(
            "broadcast_domains",
            BgpV4EviVxlanBroadcastDomainIter,
            self._parent,
            self._choice,
        )

    @property
    def replication_type(self):
        # type: () -> Union[Literal["ingress_replication"]]
        """replication_type getter

        This model only supports Ingress Replication

        Returns: Union[Literal["ingress_replication"]]
        """
        return self._get_property("replication_type")

    @replication_type.setter
    def replication_type(self, value):
        """replication_type setter

        This model only supports Ingress Replication

        value: Union[Literal["ingress_replication"]]
        """
        self._set_property("replication_type", value)

    @property
    def pmsi_label(self):
        # type: () -> int
        """pmsi_label getter

        Downstream assigned VNI to be carried as Part of P-Multicast Service Interface Tunnel attribute (PMSI Tunnel Attribute) in Type Inclusive Multicast Ethernet Tag Route.

        Returns: int
        """
        return self._get_property("pmsi_label")

    @pmsi_label.setter
    def pmsi_label(self, value):
        """pmsi_label setter

        Downstream assigned VNI to be carried as Part of P-Multicast Service Interface Tunnel attribute (PMSI Tunnel Attribute) in Type Inclusive Multicast Ethernet Tag Route.

        value: int
        """
        self._set_property("pmsi_label", value)

    @property
    def ad_label(self):
        # type: () -> int
        """ad_label getter

        The Auto-discovery Route label (AD label) value, which gets advertised in the Ethernet Auto-discovery Route per <EVI, ESI>

        Returns: int
        """
        return self._get_property("ad_label")

    @ad_label.setter
    def ad_label(self, value):
        """ad_label setter

        The Auto-discovery Route label (AD label) value, which gets advertised in the Ethernet Auto-discovery Route per <EVI, ESI>

        value: int
        """
        self._set_property("ad_label", value)

    @property
    def route_distinguisher(self):
        # type: () -> BgpRouteDistinguisher
        """route_distinguisher getter

        BGP Route Distinguisher.BGP Route Distinguisher.BGP Route Distinguisher.BGP Route Distinguisher.Colon separated Extended Community value of Bytes "AS number: Value" identifying an EVI. Example for the as_2octet "60005:100".

        Returns: BgpRouteDistinguisher
        """
        return self._get_property("route_distinguisher", BgpRouteDistinguisher)

    @property
    def route_target_export(self):
        # type: () -> BgpRouteTargetIter
        """route_target_export getter

        List of Layer Virtual Network Identifier (L2VNI) export targets associated with this EVI.

        Returns: BgpRouteTargetIter
        """
        return self._get_property(
            "route_target_export", BgpRouteTargetIter, self._parent, self._choice
        )

    @property
    def route_target_import(self):
        # type: () -> BgpRouteTargetIter
        """route_target_import getter

        List of L2VNI import targets associated with this EVI.

        Returns: BgpRouteTargetIter
        """
        return self._get_property(
            "route_target_import", BgpRouteTargetIter, self._parent, self._choice
        )

    @property
    def l3_route_target_export(self):
        # type: () -> BgpRouteTargetIter
        """l3_route_target_export getter

        List of Layer Virtual Network Identifier (L3VNI) Export Route Targets.

        Returns: BgpRouteTargetIter
        """
        return self._get_property(
            "l3_route_target_export", BgpRouteTargetIter, self._parent, self._choice
        )

    @property
    def l3_route_target_import(self):
        # type: () -> BgpRouteTargetIter
        """l3_route_target_import getter

        List of L3VNI Import Route Targets.

        Returns: BgpRouteTargetIter
        """
        return self._get_property(
            "l3_route_target_import", BgpRouteTargetIter, self._parent, self._choice
        )

    @property
    def advanced(self):
        # type: () -> BgpRouteAdvanced
        """advanced getter

        Configuration for advanced BGP route range settings.Configuration for advanced BGP route range settings.Configuration for advanced BGP route range settings.Configuration for advanced BGP route range settings.

        Returns: BgpRouteAdvanced
        """
        return self._get_property("advanced", BgpRouteAdvanced)

    @property
    def communities(self):
        # type: () -> BgpCommunityIter
        """communities getter

        Optional community settings.

        Returns: BgpCommunityIter
        """
        return self._get_property(
            "communities", BgpCommunityIter, self._parent, self._choice
        )

    @property
    def ext_communities(self):
        # type: () -> BgpExtCommunityIter
        """ext_communities getter

        Optional Extended Community settings. The Extended Communities Attribute is transitive optional BGP attribute, with the Type Code 16. Community and Extended Communities attributes are utilized to trigger routing decisions, such as acceptance, rejection, preference, or redistribution. An extended community is an 8-Bytes value. It is divided into two main parts. The first Bytes of the community encode type and sub-type fields and the last Bytes carry unique set of data in format defined by the type and sub-type field. Extended communities provide larger range for grouping or categorizing communities. When type is administrator_as_2octet or administrator_as_4octet, the valid sub types are route target and origin. The valid value for administrator_as_2octet and administrator_as_4octet type is either two byte AS followed by four byte local administrator id or four byte AS followed by two byte local administrator id. When type is administrator_ipv4_address the valid sub types are route target and origin. The valid value for administrator_ipv4_address is four byte IPv4 address followed by two byte local administrator id. When type is opaque, valid sub types are color and encapsulation. When sub type is color, first two bytes of the value field contain flags and last four bytes contains the value of the color. When sub type is encapsulation the first four bytes of value field are reserved and last two bytes carries the tunnel type from IANA's "ETHER TYPES" registry e.g IPv4 (protocol type 0x0800), IPv6 (protocol type 0x86dd), and MPLS (protocol type 0x8847). When type is administrator_as_2octet_link_bandwidth the valid sub type is extended_bandwidth. The first two bytes of the value field contains the AS number and the last four bytes contains the bandwidth in IEEE floating point format. When type is evpn the valid subtype is mac_address. In the value field the low-order bit of the first byte(Flags) is defined as the "Sticky/static" flag and may be set to 1, indicating the MAC address is static and cannot move. The second byte is reserved and the last four bytes contain the sequence number which is used to ensure that PEs retain the correct MAC/IP Advertisement route when multiple updates occur for the same MAC address.

        Returns: BgpExtCommunityIter
        """
        return self._get_property(
            "ext_communities", BgpExtCommunityIter, self._parent, self._choice
        )

    @property
    def as_path(self):
        # type: () -> BgpAsPath
        """as_path getter

        This attribute identifies the autonomous systems through which routing information carried in this UPDATE message has passed. This contains the configuration of how to include the Local AS in the AS path attribute of the MP REACH NLRI. It also contains optional configuration of additional AS Path Segments that can be included in the AS Path attribute. The AS Path consists of Set or Sequence of Autonomous Systems (AS) numbers that routing information passes through to reach the destination.This attribute identifies the autonomous systems through which routing information carried in this UPDATE message has passed. This contains the configuration of how to include the Local AS in the AS path attribute of the MP REACH NLRI. It also contains optional configuration of additional AS Path Segments that can be included in the AS Path attribute. The AS Path consists of Set or Sequence of Autonomous Systems (AS) numbers that routing information passes through to reach the destination.This attribute identifies the autonomous systems through which routing information carried in this UPDATE message has passed. This contains the configuration of how to include the Local AS in the AS path attribute of the MP REACH NLRI. It also contains optional configuration of additional AS Path Segments that can be included in the AS Path attribute. The AS Path consists of Set or Sequence of Autonomous Systems (AS) numbers that routing information passes through to reach the destination.This attribute identifies the autonomous systems through which routing information carried in this UPDATE message has passed. This contains the configuration of how to include the Local AS in the AS path attribute of the MP REACH NLRI. It also contains optional configuration of additional AS Path Segments that can be included in the AS Path attribute. The AS Path consists of Set or Sequence of Autonomous Systems (AS) numbers that routing information passes through to reach the destination.Optional AS PATH settings.

        Returns: BgpAsPath
        """
        return self._get_property("as_path", BgpAsPath)


class BgpV4EviVxlanBroadcastDomain(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "cmac_ip_range": {"type": "BgpCMacIpRangeIter"},
        "ethernet_tag_id": {
            "type": int,
            "format": "uint32",
        },
        "vlan_aware_service": {"type": bool},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "ethernet_tag_id": 0,
        "vlan_aware_service": False,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, ethernet_tag_id=0, vlan_aware_service=False):
        super(BgpV4EviVxlanBroadcastDomain, self).__init__()
        self._parent = parent
        self._set_property("ethernet_tag_id", ethernet_tag_id)
        self._set_property("vlan_aware_service", vlan_aware_service)

    def set(self, ethernet_tag_id=None, vlan_aware_service=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def cmac_ip_range(self):
        # type: () -> BgpCMacIpRangeIter
        """cmac_ip_range getter

        This contains the list of Customer MAC/IP Ranges to be configured per Broadcast Domain. . Advertises following route . Type - MAC/IP Advertisement Route.

        Returns: BgpCMacIpRangeIter
        """
        return self._get_property(
            "cmac_ip_range", BgpCMacIpRangeIter, self._parent, self._choice
        )

    @property
    def ethernet_tag_id(self):
        # type: () -> int
        """ethernet_tag_id getter

        The Ethernet Tag ID of the Broadcast Domain.

        Returns: int
        """
        return self._get_property("ethernet_tag_id")

    @ethernet_tag_id.setter
    def ethernet_tag_id(self, value):
        """ethernet_tag_id setter

        The Ethernet Tag ID of the Broadcast Domain.

        value: int
        """
        self._set_property("ethernet_tag_id", value)

    @property
    def vlan_aware_service(self):
        # type: () -> bool
        """vlan_aware_service getter

        VLAN-Aware service to be enabled or disabled.

        Returns: bool
        """
        return self._get_property("vlan_aware_service")

    @vlan_aware_service.setter
    def vlan_aware_service(self, value):
        """vlan_aware_service setter

        VLAN-Aware service to be enabled or disabled.

        value: bool
        """
        self._set_property("vlan_aware_service", value)


class BgpCMacIpRange(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "mac_addresses": {"type": "MACRouteAddress"},
        "l2vni": {
            "type": int,
            "format": "uint32",
            "maximum": 16777215,
        },
        "ipv4_addresses": {"type": "V4RouteAddress"},
        "ipv6_addresses": {"type": "V6RouteAddress"},
        "l3vni": {
            "type": int,
            "format": "uint32",
            "maximum": 16777215,
        },
        "include_default_gateway": {"type": bool},
        "advanced": {"type": "BgpRouteAdvanced"},
        "communities": {"type": "BgpCommunityIter"},
        "ext_communities": {"type": "BgpExtCommunityIter"},
        "as_path": {"type": "BgpAsPath"},
        "name": {"type": str},
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "l2vni": 0,
        "l3vni": 0,
        "include_default_gateway": False,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self, parent=None, l2vni=0, l3vni=0, include_default_gateway=False, name=None
    ):
        super(BgpCMacIpRange, self).__init__()
        self._parent = parent
        self._set_property("l2vni", l2vni)
        self._set_property("l3vni", l3vni)
        self._set_property("include_default_gateway", include_default_gateway)
        self._set_property("name", name)

    def set(self, l2vni=None, l3vni=None, include_default_gateway=None, name=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def mac_addresses(self):
        # type: () -> MACRouteAddress
        """mac_addresses getter

        A container for MAC route addresses.A container for MAC route addresses.A container for MAC route addresses.Host MAC address range per Broadcast Domain.

        Returns: MACRouteAddress
        """
        return self._get_property("mac_addresses", MACRouteAddress)

    @property
    def l2vni(self):
        # type: () -> int
        """l2vni getter

        Layer Virtual Network Identifier (L2VNI) to be advertised with MAC/IP Advertisement Route (Type 2)

        Returns: int
        """
        return self._get_property("l2vni")

    @l2vni.setter
    def l2vni(self, value):
        """l2vni setter

        Layer Virtual Network Identifier (L2VNI) to be advertised with MAC/IP Advertisement Route (Type 2)

        value: int
        """
        self._set_property("l2vni", value)

    @property
    def ipv4_addresses(self):
        # type: () -> V4RouteAddress
        """ipv4_addresses getter

        A container for IPv4 route addresses.A container for IPv4 route addresses.A container for IPv4 route addresses.Host IPv4 address range per Broadcast Domain.

        Returns: V4RouteAddress
        """
        return self._get_property("ipv4_addresses", V4RouteAddress)

    @property
    def ipv6_addresses(self):
        # type: () -> V6RouteAddress
        """ipv6_addresses getter

        A container for IPv6 route addresses.A container for IPv6 route addresses.A container for IPv6 route addresses.Host IPv6 address range per Broadcast Domain.

        Returns: V6RouteAddress
        """
        return self._get_property("ipv6_addresses", V6RouteAddress)

    @property
    def l3vni(self):
        # type: () -> int
        """l3vni getter

        Layer Virtual Network Identifier (L3VNI) to be advertised with MAC/IP Advertisement Route (Type 2).

        Returns: int
        """
        return self._get_property("l3vni")

    @l3vni.setter
    def l3vni(self, value):
        """l3vni setter

        Layer Virtual Network Identifier (L3VNI) to be advertised with MAC/IP Advertisement Route (Type 2).

        value: int
        """
        self._set_property("l3vni", value)

    @property
    def include_default_gateway(self):
        # type: () -> bool
        """include_default_gateway getter

        Include default Gateway Extended Community in MAC/IP Advertisement Route (Type 2).

        Returns: bool
        """
        return self._get_property("include_default_gateway")

    @include_default_gateway.setter
    def include_default_gateway(self, value):
        """include_default_gateway setter

        Include default Gateway Extended Community in MAC/IP Advertisement Route (Type 2).

        value: bool
        """
        self._set_property("include_default_gateway", value)

    @property
    def advanced(self):
        # type: () -> BgpRouteAdvanced
        """advanced getter

        Configuration for advanced BGP route range settings.Configuration for advanced BGP route range settings.Configuration for advanced BGP route range settings.

        Returns: BgpRouteAdvanced
        """
        return self._get_property("advanced", BgpRouteAdvanced)

    @property
    def communities(self):
        # type: () -> BgpCommunityIter
        """communities getter

        Optional community settings.

        Returns: BgpCommunityIter
        """
        return self._get_property(
            "communities", BgpCommunityIter, self._parent, self._choice
        )

    @property
    def ext_communities(self):
        # type: () -> BgpExtCommunityIter
        """ext_communities getter

        Optional Extended Community settings. The Extended Communities Attribute is transitive optional BGP attribute, with the Type Code 16. Community and Extended Communities attributes are utilized to trigger routing decisions, such as acceptance, rejection, preference, or redistribution. An extended community is an 8-Bytes value. It is divided into two main parts. The first Bytes of the community encode type and sub-type fields and the last Bytes carry unique set of data in format defined by the type and sub-type field. Extended communities provide larger range for grouping or categorizing communities. When type is administrator_as_2octet or administrator_as_4octet, the valid sub types are route target and origin. The valid value for administrator_as_2octet and administrator_as_4octet type is either two byte AS followed by four byte local administrator id or four byte AS followed by two byte local administrator id. When type is administrator_ipv4_address the valid sub types are route target and origin. The valid value for administrator_ipv4_address is four byte IPv4 address followed by two byte local administrator id. When type is opaque, valid sub types are color and encapsulation. When sub type is color, first two bytes of the value field contain flags and last four bytes contains the value of the color. When sub type is encapsulation the first four bytes of value field are reserved and last two bytes carries the tunnel type from IANA's "ETHER TYPES" registry e.g IPv4 (protocol type 0x0800), IPv6 (protocol type 0x86dd), and MPLS (protocol type 0x8847). When type is administrator_as_2octet_link_bandwidth the valid sub type is extended_bandwidth. The first two bytes of the value field contains the AS number and the last four bytes contains the bandwidth in IEEE floating point format. When type is evpn the valid subtype is mac_address. In the value field the low-order bit of the first byte(Flags) is defined as the "Sticky/static" flag and may be set to 1, indicating the MAC address is static and cannot move. The second byte is reserved and the last four bytes contain the sequence number which is used to ensure that PEs retain the correct MAC/IP Advertisement route when multiple updates occur for the same MAC address.

        Returns: BgpExtCommunityIter
        """
        return self._get_property(
            "ext_communities", BgpExtCommunityIter, self._parent, self._choice
        )

    @property
    def as_path(self):
        # type: () -> BgpAsPath
        """as_path getter

        This attribute identifies the autonomous systems through which routing information carried in this UPDATE message has passed. This contains the configuration of how to include the Local AS in the AS path attribute of the MP REACH NLRI. It also contains optional configuration of additional AS Path Segments that can be included in the AS Path attribute. The AS Path consists of Set or Sequence of Autonomous Systems (AS) numbers that routing information passes through to reach the destination.This attribute identifies the autonomous systems through which routing information carried in this UPDATE message has passed. This contains the configuration of how to include the Local AS in the AS path attribute of the MP REACH NLRI. It also contains optional configuration of additional AS Path Segments that can be included in the AS Path attribute. The AS Path consists of Set or Sequence of Autonomous Systems (AS) numbers that routing information passes through to reach the destination.This attribute identifies the autonomous systems through which routing information carried in this UPDATE message has passed. This contains the configuration of how to include the Local AS in the AS path attribute of the MP REACH NLRI. It also contains optional configuration of additional AS Path Segments that can be included in the AS Path attribute. The AS Path consists of Set or Sequence of Autonomous Systems (AS) numbers that routing information passes through to reach the destination.Optional AS PATH settings.

        Returns: BgpAsPath
        """
        return self._get_property("as_path", BgpAsPath)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)


class MACRouteAddress(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "address": {
            "type": str,
            "format": "mac",
        },
        "prefix": {
            "type": int,
            "format": "uint32",
            "minimum": 0,
            "maximum": 48,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("address",)  # type: tuple(str)

    _DEFAULTS = {
        "prefix": 48,
        "count": 1,
        "step": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, address=None, prefix=48, count=1, step=1):
        super(MACRouteAddress, self).__init__()
        self._parent = parent
        self._set_property("address", address)
        self._set_property("prefix", prefix)
        self._set_property("count", count)
        self._set_property("step", step)

    def set(self, address=None, prefix=None, count=None, step=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def address(self):
        # type: () -> str
        """address getter

        The starting address of the MAC Range.

        Returns: str
        """
        return self._get_property("address")

    @address.setter
    def address(self, value):
        """address setter

        The starting address of the MAC Range.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property address as None")
        self._set_property("address", value)

    @property
    def prefix(self):
        # type: () -> int
        """prefix getter

        The MAC prefix length to be applied to the address.

        Returns: int
        """
        return self._get_property("prefix")

    @prefix.setter
    def prefix(self, value):
        """prefix setter

        The MAC prefix length to be applied to the address.

        value: int
        """
        self._set_property("prefix", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        The total number of mac addresses in the range.

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        The total number of mac addresses in the range.

        value: int
        """
        self._set_property("count", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        Increments the mac address prefixes within mac range where multiple routes are present. The value is incremented according to the mac prefix Length and Step.

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        Increments the mac address prefixes within mac range where multiple routes are present. The value is incremented according to the mac prefix Length and Step.

        value: int
        """
        self._set_property("step", value)


class BgpRouteAdvanced(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "include_multi_exit_discriminator": {"type": bool},
        "multi_exit_discriminator": {
            "type": int,
            "format": "uint32",
        },
        "include_origin": {"type": bool},
        "origin": {
            "type": str,
            "enum": [
                "igp",
                "egp",
                "incomplete",
            ],
        },
        "include_local_preference": {"type": bool},
        "local_preference": {
            "type": int,
            "format": "uint32",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "include_multi_exit_discriminator": True,
        "include_origin": True,
        "origin": "igp",
        "include_local_preference": True,
        "local_preference": 100,
    }  # type: Dict[str, Union(type)]

    IGP = "igp"  # type: str
    EGP = "egp"  # type: str
    INCOMPLETE = "incomplete"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        include_multi_exit_discriminator=True,
        multi_exit_discriminator=None,
        include_origin=True,
        origin="igp",
        include_local_preference=True,
        local_preference=100,
    ):
        super(BgpRouteAdvanced, self).__init__()
        self._parent = parent
        self._set_property(
            "include_multi_exit_discriminator", include_multi_exit_discriminator
        )
        self._set_property("multi_exit_discriminator", multi_exit_discriminator)
        self._set_property("include_origin", include_origin)
        self._set_property("origin", origin)
        self._set_property("include_local_preference", include_local_preference)
        self._set_property("local_preference", local_preference)

    def set(
        self,
        include_multi_exit_discriminator=None,
        multi_exit_discriminator=None,
        include_origin=None,
        origin=None,
        include_local_preference=None,
        local_preference=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def include_multi_exit_discriminator(self):
        # type: () -> bool
        """include_multi_exit_discriminator getter

        BGP Multi Exit Discriminator attribute sent to the peer to help in the route selection process. If set to true, the Multi Exit Discriminator attribute will be included in the route advertisement.

        Returns: bool
        """
        return self._get_property("include_multi_exit_discriminator")

    @include_multi_exit_discriminator.setter
    def include_multi_exit_discriminator(self, value):
        """include_multi_exit_discriminator setter

        BGP Multi Exit Discriminator attribute sent to the peer to help in the route selection process. If set to true, the Multi Exit Discriminator attribute will be included in the route advertisement.

        value: bool
        """
        self._set_property("include_multi_exit_discriminator", value)

    @property
    def multi_exit_discriminator(self):
        # type: () -> int
        """multi_exit_discriminator getter

        The multi exit discriminator (MED) value used for route selection sent to the peer.

        Returns: int
        """
        return self._get_property("multi_exit_discriminator")

    @multi_exit_discriminator.setter
    def multi_exit_discriminator(self, value):
        """multi_exit_discriminator setter

        The multi exit discriminator (MED) value used for route selection sent to the peer.

        value: int
        """
        self._set_property("multi_exit_discriminator", value)

    @property
    def include_origin(self):
        # type: () -> bool
        """include_origin getter

        If set to true, the Origin attribute will be included in the route advertisement.

        Returns: bool
        """
        return self._get_property("include_origin")

    @include_origin.setter
    def include_origin(self, value):
        """include_origin setter

        If set to true, the Origin attribute will be included in the route advertisement.

        value: bool
        """
        self._set_property("include_origin", value)

    @property
    def origin(self):
        # type: () -> Union[Literal["egp"], Literal["igp"], Literal["incomplete"]]
        """origin getter

        The origin attribute of prefix can take three values: the prefix originates from an interior routing protocol 'igp', it originates from 'egp' or the origin is 'incomplete', if the prefix is learned through other means.

        Returns: Union[Literal["egp"], Literal["igp"], Literal["incomplete"]]
        """
        return self._get_property("origin")

    @origin.setter
    def origin(self, value):
        """origin setter

        The origin attribute of prefix can take three values: the prefix originates from an interior routing protocol 'igp', it originates from 'egp' or the origin is 'incomplete', if the prefix is learned through other means.

        value: Union[Literal["egp"], Literal["igp"], Literal["incomplete"]]
        """
        self._set_property("origin", value)

    @property
    def include_local_preference(self):
        # type: () -> bool
        """include_local_preference getter

        BGP Local Preference attribute sent to the peer to indicate the degree of preference for externally learned routes. If set to true, the Local Preference attribute will be included in the route advertisement. This should be included only for internal peers.

        Returns: bool
        """
        return self._get_property("include_local_preference")

    @include_local_preference.setter
    def include_local_preference(self, value):
        """include_local_preference setter

        BGP Local Preference attribute sent to the peer to indicate the degree of preference for externally learned routes. If set to true, the Local Preference attribute will be included in the route advertisement. This should be included only for internal peers.

        value: bool
        """
        self._set_property("include_local_preference", value)

    @property
    def local_preference(self):
        # type: () -> int
        """local_preference getter

        Value to be set in Local Preference attribute if include_local_preference is set to true. It is used for the selection of the path for the traffic leaving the AS. The route with the highest local preference value is preferred.

        Returns: int
        """
        return self._get_property("local_preference")

    @local_preference.setter
    def local_preference(self, value):
        """local_preference setter

        Value to be set in Local Preference attribute if include_local_preference is set to true. It is used for the selection of the path for the traffic leaving the AS. The route with the highest local preference value is preferred.

        value: int
        """
        self._set_property("local_preference", value)


class BgpCommunity(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "type": {
            "type": str,
            "enum": [
                "manual_as_number",
                "no_export",
                "no_advertised",
                "no_export_subconfed",
                "llgr_stale",
                "no_llgr",
            ],
        },
        "as_number": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "as_custom": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "as_number": 0,
        "as_custom": 0,
    }  # type: Dict[str, Union(type)]

    MANUAL_AS_NUMBER = "manual_as_number"  # type: str
    NO_EXPORT = "no_export"  # type: str
    NO_ADVERTISED = "no_advertised"  # type: str
    NO_EXPORT_SUBCONFED = "no_export_subconfed"  # type: str
    LLGR_STALE = "llgr_stale"  # type: str
    NO_LLGR = "no_llgr"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, type=None, as_number=0, as_custom=0):
        super(BgpCommunity, self).__init__()
        self._parent = parent
        self._set_property("type", type)
        self._set_property("as_number", as_number)
        self._set_property("as_custom", as_custom)

    def set(self, type=None, as_number=None, as_custom=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def type(self):
        # type: () -> Union[Literal["llgr_stale"], Literal["manual_as_number"], Literal["no_advertised"], Literal["no_export"], Literal["no_export_subconfed"], Literal["no_llgr"]]
        """type getter

        The type of community AS number.

        Returns: Union[Literal["llgr_stale"], Literal["manual_as_number"], Literal["no_advertised"], Literal["no_export"], Literal["no_export_subconfed"], Literal["no_llgr"]]
        """
        return self._get_property("type")

    @type.setter
    def type(self, value):
        """type setter

        The type of community AS number.

        value: Union[Literal["llgr_stale"], Literal["manual_as_number"], Literal["no_advertised"], Literal["no_export"], Literal["no_export_subconfed"], Literal["no_llgr"]]
        """
        self._set_property("type", value)

    @property
    def as_number(self):
        # type: () -> int
        """as_number getter

        First two octets of 32 bit community AS number.

        Returns: int
        """
        return self._get_property("as_number")

    @as_number.setter
    def as_number(self, value):
        """as_number setter

        First two octets of 32 bit community AS number.

        value: int
        """
        self._set_property("as_number", value)

    @property
    def as_custom(self):
        # type: () -> int
        """as_custom getter

        Last two octets of the community value.

        Returns: int
        """
        return self._get_property("as_custom")

    @as_custom.setter
    def as_custom(self, value):
        """as_custom setter

        Last two octets of the community value.

        value: int
        """
        self._set_property("as_custom", value)


class BgpCommunityIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(BgpCommunityIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[BgpCommunity]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> BgpCommunityIter
        return self._iter()

    def __next__(self):
        # type: () -> BgpCommunity
        return self._next()

    def next(self):
        # type: () -> BgpCommunity
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, BgpCommunity):
            raise Exception("Item is not an instance of BgpCommunity")

    def community(self, type=None, as_number=0, as_custom=0):
        # type: (Union[Literal["llgr_stale"], Literal["manual_as_number"], Literal["no_advertised"], Literal["no_export"], Literal["no_export_subconfed"], Literal["no_llgr"]],int,int) -> BgpCommunityIter
        """Factory method that creates an instance of the BgpCommunity class

        BGP communities provide additional capability for tagging routes and for modifying BGP routing policy on upstream and downstream routers. BGP community is 32-bit number which is broken into 16-bit AS number and 16-bit custom value.

        Returns: BgpCommunityIter
        """
        item = BgpCommunity(
            parent=self._parent, type=type, as_number=as_number, as_custom=as_custom
        )
        self._add(item)
        return self

    def add(self, type=None, as_number=0, as_custom=0):
        # type: (Union[Literal["llgr_stale"], Literal["manual_as_number"], Literal["no_advertised"], Literal["no_export"], Literal["no_export_subconfed"], Literal["no_llgr"]],int,int) -> BgpCommunity
        """Add method that creates and returns an instance of the BgpCommunity class

        BGP communities provide additional capability for tagging routes and for modifying BGP routing policy on upstream and downstream routers. BGP community is 32-bit number which is broken into 16-bit AS number and 16-bit custom value.

        Returns: BgpCommunity
        """
        item = BgpCommunity(
            parent=self._parent, type=type, as_number=as_number, as_custom=as_custom
        )
        self._add(item)
        return item


class BgpExtCommunity(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "type": {
            "type": str,
            "enum": [
                "administrator_as_2octet",
                "administrator_ipv4_address",
                "administrator_as_4octet",
                "opaque",
                "evpn",
                "administrator_as_2octet_link_bandwidth",
            ],
        },
        "subtype": {
            "type": str,
            "enum": [
                "route_target",
                "origin",
                "extended_bandwidth",
                "color",
                "encapsulation",
                "mac_address",
            ],
        },
        "value": {
            "type": str,
            "format": "hex",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    ADMINISTRATOR_AS_2OCTET = "administrator_as_2octet"  # type: str
    ADMINISTRATOR_IPV4_ADDRESS = "administrator_ipv4_address"  # type: str
    ADMINISTRATOR_AS_4OCTET = "administrator_as_4octet"  # type: str
    OPAQUE = "opaque"  # type: str
    EVPN = "evpn"  # type: str
    ADMINISTRATOR_AS_2OCTET_LINK_BANDWIDTH = (
        "administrator_as_2octet_link_bandwidth"
    )  # type: str

    ROUTE_TARGET = "route_target"  # type: str
    ORIGIN = "origin"  # type: str
    EXTENDED_BANDWIDTH = "extended_bandwidth"  # type: str
    COLOR = "color"  # type: str
    ENCAPSULATION = "encapsulation"  # type: str
    MAC_ADDRESS = "mac_address"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, type=None, subtype=None, value=None):
        super(BgpExtCommunity, self).__init__()
        self._parent = parent
        self._set_property("type", type)
        self._set_property("subtype", subtype)
        self._set_property("value", value)

    def set(self, type=None, subtype=None, value=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def type(self):
        # type: () -> Union[Literal["administrator_as_2octet"], Literal["administrator_as_2octet_link_bandwidth"], Literal["administrator_as_4octet"], Literal["administrator_ipv4_address"], Literal["evpn"], Literal["opaque"]]
        """type getter

        Extended Community Type field of Byte.. administrator_as_2octet: Two-Octet AS Specific Extended Community (RFC 4360).. administrator_ipv4_address: IPv4 Address Specific Extended Community (RFC 4360).. administrator_as_4octet: 4-Octet AS Specific Extended Community (RFC 5668).. opaque: Opaque Extended Community (RFC 7432).. evpn: EVPN Extended Community (RFC 7153). - administrator_as_2octet_link_bandwidth Link Bandwidth Extended Community (RFC 7153).

        Returns: Union[Literal["administrator_as_2octet"], Literal["administrator_as_2octet_link_bandwidth"], Literal["administrator_as_4octet"], Literal["administrator_ipv4_address"], Literal["evpn"], Literal["opaque"]]
        """
        return self._get_property("type")

    @type.setter
    def type(self, value):
        """type setter

        Extended Community Type field of Byte.. administrator_as_2octet: Two-Octet AS Specific Extended Community (RFC 4360).. administrator_ipv4_address: IPv4 Address Specific Extended Community (RFC 4360).. administrator_as_4octet: 4-Octet AS Specific Extended Community (RFC 5668).. opaque: Opaque Extended Community (RFC 7432).. evpn: EVPN Extended Community (RFC 7153). - administrator_as_2octet_link_bandwidth Link Bandwidth Extended Community (RFC 7153).

        value: Union[Literal["administrator_as_2octet"], Literal["administrator_as_2octet_link_bandwidth"], Literal["administrator_as_4octet"], Literal["administrator_ipv4_address"], Literal["evpn"], Literal["opaque"]]
        """
        self._set_property("type", value)

    @property
    def subtype(self):
        # type: () -> Union[Literal["color"], Literal["encapsulation"], Literal["extended_bandwidth"], Literal["mac_address"], Literal["origin"], Literal["route_target"]]
        """subtype getter

        Extended Community Sub Type field of Byte.. route_target: Route Target.. origin: Origin.. extended_bandwidth: Specifies the link bandwidth.. color: Specifies the color value.. encapsulation: Specifies the Encapsulation Extended Community.. mac_address: Specifies the Extended community MAC address.

        Returns: Union[Literal["color"], Literal["encapsulation"], Literal["extended_bandwidth"], Literal["mac_address"], Literal["origin"], Literal["route_target"]]
        """
        return self._get_property("subtype")

    @subtype.setter
    def subtype(self, value):
        """subtype setter

        Extended Community Sub Type field of Byte.. route_target: Route Target.. origin: Origin.. extended_bandwidth: Specifies the link bandwidth.. color: Specifies the color value.. encapsulation: Specifies the Encapsulation Extended Community.. mac_address: Specifies the Extended community MAC address.

        value: Union[Literal["color"], Literal["encapsulation"], Literal["extended_bandwidth"], Literal["mac_address"], Literal["origin"], Literal["route_target"]]
        """
        self._set_property("subtype", value)

    @property
    def value(self):
        # type: () -> str
        """value getter

        Extended Community value of Bytes. Example for the Opaque type and Color subtype value can be '0000000000c8' for the color value 200.

        Returns: str
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        Extended Community value of Bytes. Example for the Opaque type and Color subtype value can be '0000000000c8' for the color value 200.

        value: str
        """
        self._set_property("value", value)


class BgpExtCommunityIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(BgpExtCommunityIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[BgpExtCommunity]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> BgpExtCommunityIter
        return self._iter()

    def __next__(self):
        # type: () -> BgpExtCommunity
        return self._next()

    def next(self):
        # type: () -> BgpExtCommunity
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, BgpExtCommunity):
            raise Exception("Item is not an instance of BgpExtCommunity")

    def extcommunity(self, type=None, subtype=None, value=None):
        # type: (Union[Literal["administrator_as_2octet"], Literal["administrator_as_2octet_link_bandwidth"], Literal["administrator_as_4octet"], Literal["administrator_ipv4_address"], Literal["evpn"], Literal["opaque"]],Union[Literal["color"], Literal["encapsulation"], Literal["extended_bandwidth"], Literal["mac_address"], Literal["origin"], Literal["route_target"]],str) -> BgpExtCommunityIter
        """Factory method that creates an instance of the BgpExtCommunity class

        The Extended Communities Attribute is transitive optional BGP attribute, with the Type Code 16. Community and Extended Communities attributes are utilized to trigger routing decisions, such as acceptance, rejection, preference, or redistribution. An extended community is an 8-Bytes value. It is divided into two main parts. The first Bytes of the community encode type and sub-type fields and the last Bytes carry unique set of data in format defined by the type and sub-type field. Extended communities provide larger range for grouping or categorizing communities.

        Returns: BgpExtCommunityIter
        """
        item = BgpExtCommunity(
            parent=self._parent, type=type, subtype=subtype, value=value
        )
        self._add(item)
        return self

    def add(self, type=None, subtype=None, value=None):
        # type: (Union[Literal["administrator_as_2octet"], Literal["administrator_as_2octet_link_bandwidth"], Literal["administrator_as_4octet"], Literal["administrator_ipv4_address"], Literal["evpn"], Literal["opaque"]],Union[Literal["color"], Literal["encapsulation"], Literal["extended_bandwidth"], Literal["mac_address"], Literal["origin"], Literal["route_target"]],str) -> BgpExtCommunity
        """Add method that creates and returns an instance of the BgpExtCommunity class

        The Extended Communities Attribute is transitive optional BGP attribute, with the Type Code 16. Community and Extended Communities attributes are utilized to trigger routing decisions, such as acceptance, rejection, preference, or redistribution. An extended community is an 8-Bytes value. It is divided into two main parts. The first Bytes of the community encode type and sub-type fields and the last Bytes carry unique set of data in format defined by the type and sub-type field. Extended communities provide larger range for grouping or categorizing communities.

        Returns: BgpExtCommunity
        """
        item = BgpExtCommunity(
            parent=self._parent, type=type, subtype=subtype, value=value
        )
        self._add(item)
        return item


class BgpAsPath(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "as_set_mode": {
            "type": str,
            "enum": [
                "do_not_include_local_as",
                "include_as_seq",
                "include_as_set",
                "include_as_confed_seq",
                "include_as_confed_set",
                "prepend_to_first_segment",
            ],
        },
        "segments": {"type": "BgpAsPathSegmentIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "as_set_mode": "do_not_include_local_as",
    }  # type: Dict[str, Union(type)]

    DO_NOT_INCLUDE_LOCAL_AS = "do_not_include_local_as"  # type: str
    INCLUDE_AS_SEQ = "include_as_seq"  # type: str
    INCLUDE_AS_SET = "include_as_set"  # type: str
    INCLUDE_AS_CONFED_SEQ = "include_as_confed_seq"  # type: str
    INCLUDE_AS_CONFED_SET = "include_as_confed_set"  # type: str
    PREPEND_TO_FIRST_SEGMENT = "prepend_to_first_segment"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, as_set_mode="do_not_include_local_as"):
        super(BgpAsPath, self).__init__()
        self._parent = parent
        self._set_property("as_set_mode", as_set_mode)

    def set(self, as_set_mode=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def as_set_mode(self):
        # type: () -> Union[Literal["do_not_include_local_as"], Literal["include_as_confed_seq"], Literal["include_as_confed_set"], Literal["include_as_seq"], Literal["include_as_set"], Literal["prepend_to_first_segment"]]
        """as_set_mode getter

        Defines how the Local AS should be included in the MP REACH NLRI. For iBGP sessions, "Do Not Include Local AS" must be chosen. For eBGP sessions, any choice other than "Do Not Include Local AS" can be chosen.

        Returns: Union[Literal["do_not_include_local_as"], Literal["include_as_confed_seq"], Literal["include_as_confed_set"], Literal["include_as_seq"], Literal["include_as_set"], Literal["prepend_to_first_segment"]]
        """
        return self._get_property("as_set_mode")

    @as_set_mode.setter
    def as_set_mode(self, value):
        """as_set_mode setter

        Defines how the Local AS should be included in the MP REACH NLRI. For iBGP sessions, "Do Not Include Local AS" must be chosen. For eBGP sessions, any choice other than "Do Not Include Local AS" can be chosen.

        value: Union[Literal["do_not_include_local_as"], Literal["include_as_confed_seq"], Literal["include_as_confed_set"], Literal["include_as_seq"], Literal["include_as_set"], Literal["prepend_to_first_segment"]]
        """
        self._set_property("as_set_mode", value)

    @property
    def segments(self):
        # type: () -> BgpAsPathSegmentIter
        """segments getter

        The additional AS path segments to be added in the NLRI. By default, an empty AS path is always included and the local AS is added to it as per the value of 'as_set_mode' attribute.

        Returns: BgpAsPathSegmentIter
        """
        return self._get_property(
            "segments", BgpAsPathSegmentIter, self._parent, self._choice
        )


class BgpAsPathSegment(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "type": {
            "type": str,
            "enum": [
                "as_seq",
                "as_set",
                "as_confed_seq",
                "as_confed_set",
            ],
        },
        "as_numbers": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "type": "as_seq",
    }  # type: Dict[str, Union(type)]

    AS_SEQ = "as_seq"  # type: str
    AS_SET = "as_set"  # type: str
    AS_CONFED_SEQ = "as_confed_seq"  # type: str
    AS_CONFED_SET = "as_confed_set"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, type="as_seq", as_numbers=None):
        super(BgpAsPathSegment, self).__init__()
        self._parent = parent
        self._set_property("type", type)
        self._set_property("as_numbers", as_numbers)

    def set(self, type=None, as_numbers=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def type(self):
        # type: () -> Union[Literal["as_confed_seq"], Literal["as_confed_set"], Literal["as_seq"], Literal["as_set"]]
        """type getter

        AS sequence is the most common type of AS_PATH, it contains the list of ASNs starting with the most recent ASN being added read from left to right.. The other three AS_PATH types are used for Confederations AS_SET is the type of AS_PATH attribute that summarizes routes using using the aggregate-address command, allowing AS_PATHs to be summarized in the update as well. AS_CONFED_SEQ gives the list of ASNs in the path starting with the most recent ASN to be added reading left to right AS_CONFED_SET will allow summarization of multiple AS PATHs to be sent in BGP Updates.

        Returns: Union[Literal["as_confed_seq"], Literal["as_confed_set"], Literal["as_seq"], Literal["as_set"]]
        """
        return self._get_property("type")

    @type.setter
    def type(self, value):
        """type setter

        AS sequence is the most common type of AS_PATH, it contains the list of ASNs starting with the most recent ASN being added read from left to right.. The other three AS_PATH types are used for Confederations AS_SET is the type of AS_PATH attribute that summarizes routes using using the aggregate-address command, allowing AS_PATHs to be summarized in the update as well. AS_CONFED_SEQ gives the list of ASNs in the path starting with the most recent ASN to be added reading left to right AS_CONFED_SET will allow summarization of multiple AS PATHs to be sent in BGP Updates.

        value: Union[Literal["as_confed_seq"], Literal["as_confed_set"], Literal["as_seq"], Literal["as_set"]]
        """
        self._set_property("type", value)

    @property
    def as_numbers(self):
        # type: () -> List[int]
        """as_numbers getter

        The AS numbers in this AS path segment.

        Returns: List[int]
        """
        return self._get_property("as_numbers")

    @as_numbers.setter
    def as_numbers(self, value):
        """as_numbers setter

        The AS numbers in this AS path segment.

        value: List[int]
        """
        self._set_property("as_numbers", value)


class BgpAsPathSegmentIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(BgpAsPathSegmentIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[BgpAsPathSegment]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> BgpAsPathSegmentIter
        return self._iter()

    def __next__(self):
        # type: () -> BgpAsPathSegment
        return self._next()

    def next(self):
        # type: () -> BgpAsPathSegment
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, BgpAsPathSegment):
            raise Exception("Item is not an instance of BgpAsPathSegment")

    def aspathsegment(self, type="as_seq", as_numbers=None):
        # type: (Union[Literal["as_confed_seq"], Literal["as_confed_set"], Literal["as_seq"], Literal["as_set"]],List[int]) -> BgpAsPathSegmentIter
        """Factory method that creates an instance of the BgpAsPathSegment class

        Configuration for single BGP AS path segment

        Returns: BgpAsPathSegmentIter
        """
        item = BgpAsPathSegment(parent=self._parent, type=type, as_numbers=as_numbers)
        self._add(item)
        return self

    def add(self, type="as_seq", as_numbers=None):
        # type: (Union[Literal["as_confed_seq"], Literal["as_confed_set"], Literal["as_seq"], Literal["as_set"]],List[int]) -> BgpAsPathSegment
        """Add method that creates and returns an instance of the BgpAsPathSegment class

        Configuration for single BGP AS path segment

        Returns: BgpAsPathSegment
        """
        item = BgpAsPathSegment(parent=self._parent, type=type, as_numbers=as_numbers)
        self._add(item)
        return item


class BgpCMacIpRangeIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(BgpCMacIpRangeIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[BgpCMacIpRange]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> BgpCMacIpRangeIter
        return self._iter()

    def __next__(self):
        # type: () -> BgpCMacIpRange
        return self._next()

    def next(self):
        # type: () -> BgpCMacIpRange
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, BgpCMacIpRange):
            raise Exception("Item is not an instance of BgpCMacIpRange")

    def cmaciprange(self, l2vni=0, l3vni=0, include_default_gateway=False, name=None):
        # type: (int,int,bool,str) -> BgpCMacIpRangeIter
        """Factory method that creates an instance of the BgpCMacIpRange class

        Configuration for MAC/IP Ranges per Broadcast Domain. . Advertises following route -. Type - MAC/IP Advertisement Route.

        Returns: BgpCMacIpRangeIter
        """
        item = BgpCMacIpRange(
            parent=self._parent,
            l2vni=l2vni,
            l3vni=l3vni,
            include_default_gateway=include_default_gateway,
            name=name,
        )
        self._add(item)
        return self

    def add(self, l2vni=0, l3vni=0, include_default_gateway=False, name=None):
        # type: (int,int,bool,str) -> BgpCMacIpRange
        """Add method that creates and returns an instance of the BgpCMacIpRange class

        Configuration for MAC/IP Ranges per Broadcast Domain. . Advertises following route -. Type - MAC/IP Advertisement Route.

        Returns: BgpCMacIpRange
        """
        item = BgpCMacIpRange(
            parent=self._parent,
            l2vni=l2vni,
            l3vni=l3vni,
            include_default_gateway=include_default_gateway,
            name=name,
        )
        self._add(item)
        return item


class BgpV4EviVxlanBroadcastDomainIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(BgpV4EviVxlanBroadcastDomainIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[BgpV4EviVxlanBroadcastDomain]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> BgpV4EviVxlanBroadcastDomainIter
        return self._iter()

    def __next__(self):
        # type: () -> BgpV4EviVxlanBroadcastDomain
        return self._next()

    def next(self):
        # type: () -> BgpV4EviVxlanBroadcastDomain
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, BgpV4EviVxlanBroadcastDomain):
            raise Exception("Item is not an instance of BgpV4EviVxlanBroadcastDomain")

    def broadcastdomain(self, ethernet_tag_id=0, vlan_aware_service=False):
        # type: (int,bool) -> BgpV4EviVxlanBroadcastDomainIter
        """Factory method that creates an instance of the BgpV4EviVxlanBroadcastDomain class

        Configuration for Broadcast Domains per EVI.

        Returns: BgpV4EviVxlanBroadcastDomainIter
        """
        item = BgpV4EviVxlanBroadcastDomain(
            parent=self._parent,
            ethernet_tag_id=ethernet_tag_id,
            vlan_aware_service=vlan_aware_service,
        )
        self._add(item)
        return self

    def add(self, ethernet_tag_id=0, vlan_aware_service=False):
        # type: (int,bool) -> BgpV4EviVxlanBroadcastDomain
        """Add method that creates and returns an instance of the BgpV4EviVxlanBroadcastDomain class

        Configuration for Broadcast Domains per EVI.

        Returns: BgpV4EviVxlanBroadcastDomain
        """
        item = BgpV4EviVxlanBroadcastDomain(
            parent=self._parent,
            ethernet_tag_id=ethernet_tag_id,
            vlan_aware_service=vlan_aware_service,
        )
        self._add(item)
        return item


class BgpRouteDistinguisher(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "rd_type": {
            "type": str,
            "enum": [
                "as_2octet",
                "ipv4_address",
                "as_4octet",
            ],
        },
        "auto_config_rd_ip_addr": {"type": bool},
        "rd_value": {"type": str},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "rd_type": "as_2octet",
        "auto_config_rd_ip_addr": False,
    }  # type: Dict[str, Union(type)]

    AS_2OCTET = "as_2octet"  # type: str
    IPV4_ADDRESS = "ipv4_address"  # type: str
    AS_4OCTET = "as_4octet"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        rd_type="as_2octet",
        auto_config_rd_ip_addr=False,
        rd_value=None,
    ):
        super(BgpRouteDistinguisher, self).__init__()
        self._parent = parent
        self._set_property("rd_type", rd_type)
        self._set_property("auto_config_rd_ip_addr", auto_config_rd_ip_addr)
        self._set_property("rd_value", rd_value)

    def set(self, rd_type=None, auto_config_rd_ip_addr=None, rd_value=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def rd_type(self):
        # type: () -> Union[Literal["as_2octet"], Literal["as_4octet"], Literal["ipv4_address"]]
        """rd_type getter

        Route Distinguisher Type field of Byte.. as_2octet: Two-Octet AS Specific Extended Community (RFC 4360).. ipv4_address: IPv4 Address Specific Extended Community (RFC 4360).. as_4octet: 4-Octet AS Specific Extended Community (RFC 5668).

        Returns: Union[Literal["as_2octet"], Literal["as_4octet"], Literal["ipv4_address"]]
        """
        return self._get_property("rd_type")

    @rd_type.setter
    def rd_type(self, value):
        """rd_type setter

        Route Distinguisher Type field of Byte.. as_2octet: Two-Octet AS Specific Extended Community (RFC 4360).. ipv4_address: IPv4 Address Specific Extended Community (RFC 4360).. as_4octet: 4-Octet AS Specific Extended Community (RFC 5668).

        value: Union[Literal["as_2octet"], Literal["as_4octet"], Literal["ipv4_address"]]
        """
        self._set_property("rd_type", value)

    @property
    def auto_config_rd_ip_addr(self):
        # type: () -> bool
        """auto_config_rd_ip_addr getter

        Allow to automatically configure RD IP address from local ip.

        Returns: bool
        """
        return self._get_property("auto_config_rd_ip_addr")

    @auto_config_rd_ip_addr.setter
    def auto_config_rd_ip_addr(self, value):
        """auto_config_rd_ip_addr setter

        Allow to automatically configure RD IP address from local ip.

        value: bool
        """
        self._set_property("auto_config_rd_ip_addr", value)

    @property
    def rd_value(self):
        # type: () -> str
        """rd_value getter

        Colon separated Extended Community value of Bytes "AS number: Value". Example for the as_2octet or as_4octet "60005:100", for ipv4_address "1.1.1.1:100"

        Returns: str
        """
        return self._get_property("rd_value")

    @rd_value.setter
    def rd_value(self, value):
        """rd_value setter

        Colon separated Extended Community value of Bytes "AS number: Value". Example for the as_2octet or as_4octet "60005:100", for ipv4_address "1.1.1.1:100"

        value: str
        """
        self._set_property("rd_value", value)


class BgpRouteTarget(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "rt_type": {
            "type": str,
            "enum": [
                "as_2octet",
                "ipv4_address",
                "as_4octet",
            ],
        },
        "rt_value": {"type": str},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    AS_2OCTET = "as_2octet"  # type: str
    IPV4_ADDRESS = "ipv4_address"  # type: str
    AS_4OCTET = "as_4octet"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, rt_type=None, rt_value=None):
        super(BgpRouteTarget, self).__init__()
        self._parent = parent
        self._set_property("rt_type", rt_type)
        self._set_property("rt_value", rt_value)

    def set(self, rt_type=None, rt_value=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def rt_type(self):
        # type: () -> Union[Literal["as_2octet"], Literal["as_4octet"], Literal["ipv4_address"]]
        """rt_type getter

        Extended Community Type field of Byte.. as_2octet: Two-Octet AS Specific Extended Community (RFC 4360).. ipv4_address: IPv4 Address Specific Extended Community (RFC 4360).. as_4octet: 4-Octet AS Specific Extended Community (RFC 5668).

        Returns: Union[Literal["as_2octet"], Literal["as_4octet"], Literal["ipv4_address"]]
        """
        return self._get_property("rt_type")

    @rt_type.setter
    def rt_type(self, value):
        """rt_type setter

        Extended Community Type field of Byte.. as_2octet: Two-Octet AS Specific Extended Community (RFC 4360).. ipv4_address: IPv4 Address Specific Extended Community (RFC 4360).. as_4octet: 4-Octet AS Specific Extended Community (RFC 5668).

        value: Union[Literal["as_2octet"], Literal["as_4octet"], Literal["ipv4_address"]]
        """
        self._set_property("rt_type", value)

    @property
    def rt_value(self):
        # type: () -> str
        """rt_value getter

        Colon separated Extended Community value of Bytes AS number: Assigned Number. Example for the as_2octet or as_4octet "60005:100", for ipv4_address "1.1.1.1:100"

        Returns: str
        """
        return self._get_property("rt_value")

    @rt_value.setter
    def rt_value(self, value):
        """rt_value setter

        Colon separated Extended Community value of Bytes AS number: Assigned Number. Example for the as_2octet or as_4octet "60005:100", for ipv4_address "1.1.1.1:100"

        value: str
        """
        self._set_property("rt_value", value)


class BgpRouteTargetIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(BgpRouteTargetIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[BgpRouteTarget]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> BgpRouteTargetIter
        return self._iter()

    def __next__(self):
        # type: () -> BgpRouteTarget
        return self._next()

    def next(self):
        # type: () -> BgpRouteTarget
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, BgpRouteTarget):
            raise Exception("Item is not an instance of BgpRouteTarget")

    def routetarget(self, rt_type=None, rt_value=None):
        # type: (Union[Literal["as_2octet"], Literal["as_4octet"], Literal["ipv4_address"]],str) -> BgpRouteTargetIter
        """Factory method that creates an instance of the BgpRouteTarget class

        BGP Route Target.

        Returns: BgpRouteTargetIter
        """
        item = BgpRouteTarget(parent=self._parent, rt_type=rt_type, rt_value=rt_value)
        self._add(item)
        return self

    def add(self, rt_type=None, rt_value=None):
        # type: (Union[Literal["as_2octet"], Literal["as_4octet"], Literal["ipv4_address"]],str) -> BgpRouteTarget
        """Add method that creates and returns an instance of the BgpRouteTarget class

        BGP Route Target.

        Returns: BgpRouteTarget
        """
        item = BgpRouteTarget(parent=self._parent, rt_type=rt_type, rt_value=rt_value)
        self._add(item)
        return item


class BgpV4EvpnEvisIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = True

    def __init__(self, parent=None, choice=None):
        super(BgpV4EvpnEvisIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[BgpV4EviVxlan, BgpV4EvpnEvis]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> BgpV4EvpnEvisIter
        return self._iter()

    def __next__(self):
        # type: () -> BgpV4EvpnEvis
        return self._next()

    def next(self):
        # type: () -> BgpV4EvpnEvis
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, BgpV4EvpnEvis):
            raise Exception("Item is not an instance of BgpV4EvpnEvis")

    def evpnevis(self):
        # type: () -> BgpV4EvpnEvisIter
        """Factory method that creates an instance of the BgpV4EvpnEvis class

        This contains list of different flavors of EVPN. For example EVPN over VXLAN or EVPN over MPLS etc to be configured per Ethernet segment. Need to instantiate correct type of EVPN instance as per requirement.

        Returns: BgpV4EvpnEvisIter
        """
        item = BgpV4EvpnEvis(parent=self._parent, choice=self._choice)
        self._add(item)
        return self

    def add(self):
        # type: () -> BgpV4EvpnEvis
        """Add method that creates and returns an instance of the BgpV4EvpnEvis class

        This contains list of different flavors of EVPN. For example EVPN over VXLAN or EVPN over MPLS etc to be configured per Ethernet segment. Need to instantiate correct type of EVPN instance as per requirement.

        Returns: BgpV4EvpnEvis
        """
        item = BgpV4EvpnEvis(parent=self._parent, choice=self._choice)
        self._add(item)
        return item

    def evi_vxlan(
        self, replication_type="ingress_replication", pmsi_label=16, ad_label=0
    ):
        # type: (Union[Literal["ingress_replication"]],int,int) -> BgpV4EvpnEvisIter
        """Factory method that creates an instance of the BgpV4EviVxlan class

        Configuration for BGP EVPN EVI. Advertises following routes . Type - Inclusive Multicast Ethernet Tag Route. Type - Ethernet Auto-discovery Route (Per EVI). Type - Ethernet Auto-discovery Route (Per ES)

        Returns: BgpV4EvpnEvisIter
        """
        item = BgpV4EvpnEvis()
        item.evi_vxlan
        item.choice = "evi_vxlan"
        self._add(item)
        return self


class BgpV4EthernetSegmentIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(BgpV4EthernetSegmentIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[BgpV4EthernetSegment]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> BgpV4EthernetSegmentIter
        return self._iter()

    def __next__(self):
        # type: () -> BgpV4EthernetSegment
        return self._next()

    def next(self):
        # type: () -> BgpV4EthernetSegment
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, BgpV4EthernetSegment):
            raise Exception("Item is not an instance of BgpV4EthernetSegment")

    def ethernetsegment(
        self, esi="00000000000000000000", active_mode="all_active", esi_label=0
    ):
        # type: (str,Union[Literal["all_active"], Literal["single_active"]],int) -> BgpV4EthernetSegmentIter
        """Factory method that creates an instance of the BgpV4EthernetSegment class

        Configuration for BGP Ethernet Segment ranges. Advertises following routes . Type - Ethernet Segment Route

        Returns: BgpV4EthernetSegmentIter
        """
        item = BgpV4EthernetSegment(
            parent=self._parent, esi=esi, active_mode=active_mode, esi_label=esi_label
        )
        self._add(item)
        return self

    def add(self, esi="00000000000000000000", active_mode="all_active", esi_label=0):
        # type: (str,Union[Literal["all_active"], Literal["single_active"]],int) -> BgpV4EthernetSegment
        """Add method that creates and returns an instance of the BgpV4EthernetSegment class

        Configuration for BGP Ethernet Segment ranges. Advertises following routes . Type - Ethernet Segment Route

        Returns: BgpV4EthernetSegment
        """
        item = BgpV4EthernetSegment(
            parent=self._parent, esi=esi, active_mode=active_mode, esi_label=esi_label
        )
        self._add(item)
        return item


class BgpAdvanced(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "hold_time_interval": {
            "type": int,
            "format": "uint32",
        },
        "keep_alive_interval": {
            "type": int,
            "format": "uint32",
        },
        "update_interval": {
            "type": int,
            "format": "uint32",
        },
        "time_to_live": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "md5_key": {"type": str},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "hold_time_interval": 90,
        "keep_alive_interval": 30,
        "update_interval": 0,
        "time_to_live": 64,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        hold_time_interval=90,
        keep_alive_interval=30,
        update_interval=0,
        time_to_live=64,
        md5_key=None,
    ):
        super(BgpAdvanced, self).__init__()
        self._parent = parent
        self._set_property("hold_time_interval", hold_time_interval)
        self._set_property("keep_alive_interval", keep_alive_interval)
        self._set_property("update_interval", update_interval)
        self._set_property("time_to_live", time_to_live)
        self._set_property("md5_key", md5_key)

    def set(
        self,
        hold_time_interval=None,
        keep_alive_interval=None,
        update_interval=None,
        time_to_live=None,
        md5_key=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def hold_time_interval(self):
        # type: () -> int
        """hold_time_interval getter

        Number of seconds the sender proposes for the value of the Hold Timer.

        Returns: int
        """
        return self._get_property("hold_time_interval")

    @hold_time_interval.setter
    def hold_time_interval(self, value):
        """hold_time_interval setter

        Number of seconds the sender proposes for the value of the Hold Timer.

        value: int
        """
        self._set_property("hold_time_interval", value)

    @property
    def keep_alive_interval(self):
        # type: () -> int
        """keep_alive_interval getter

        Number of seconds between transmissions of Keepalive messages by this peer.

        Returns: int
        """
        return self._get_property("keep_alive_interval")

    @keep_alive_interval.setter
    def keep_alive_interval(self, value):
        """keep_alive_interval setter

        Number of seconds between transmissions of Keepalive messages by this peer.

        value: int
        """
        self._set_property("keep_alive_interval", value)

    @property
    def update_interval(self):
        # type: () -> int
        """update_interval getter

        The time interval at which Update messages are sent to the DUT, expressed as the number of milliseconds between Update messages. The update interval implies to send all the updates as fast as possible.

        Returns: int
        """
        return self._get_property("update_interval")

    @update_interval.setter
    def update_interval(self, value):
        """update_interval setter

        The time interval at which Update messages are sent to the DUT, expressed as the number of milliseconds between Update messages. The update interval implies to send all the updates as fast as possible.

        value: int
        """
        self._set_property("update_interval", value)

    @property
    def time_to_live(self):
        # type: () -> int
        """time_to_live getter

        The limited number of iterations that unit of data can experience before the data is discarded. This is placed in the TTL field in the IP header of the transmitted packets.

        Returns: int
        """
        return self._get_property("time_to_live")

    @time_to_live.setter
    def time_to_live(self, value):
        """time_to_live setter

        The limited number of iterations that unit of data can experience before the data is discarded. This is placed in the TTL field in the IP header of the transmitted packets.

        value: int
        """
        self._set_property("time_to_live", value)

    @property
    def md5_key(self):
        # type: () -> str
        """md5_key getter

        The value to be used as secret MD5 key for authentication. If not configured, MD5 authentication will not be enabled.

        Returns: str
        """
        return self._get_property("md5_key")

    @md5_key.setter
    def md5_key(self, value):
        """md5_key setter

        The value to be used as secret MD5 key for authentication. If not configured, MD5 authentication will not be enabled.

        value: str
        """
        self._set_property("md5_key", value)


class BgpCapability(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "ipv4_unicast": {"type": bool},
        "ipv4_multicast": {"type": bool},
        "ipv6_unicast": {"type": bool},
        "ipv6_multicast": {"type": bool},
        "vpls": {"type": bool},
        "route_refresh": {"type": bool},
        "route_constraint": {"type": bool},
        "link_state_non_vpn": {"type": bool},
        "link_state_vpn": {"type": bool},
        "evpn": {"type": bool},
        "extended_next_hop_encoding": {"type": bool},
        "ipv4_multicast_vpn": {"type": bool},
        "ipv4_mpls_vpn": {"type": bool},
        "ipv4_mdt": {"type": bool},
        "ipv4_multicast_mpls_vpn": {"type": bool},
        "ipv4_unicast_flow_spec": {"type": bool},
        "ipv4_sr_te_policy": {"type": bool},
        "ipv4_unicast_add_path": {"type": bool},
        "ipv6_multicast_vpn": {"type": bool},
        "ipv6_mpls_vpn": {"type": bool},
        "ipv6_mdt": {"type": bool},
        "ipv6_multicast_mpls_vpn": {"type": bool},
        "ipv6_unicast_flow_spec": {"type": bool},
        "ipv6_sr_te_policy": {"type": bool},
        "ipv6_unicast_add_path": {"type": bool},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "ipv4_unicast": True,
        "ipv4_multicast": False,
        "ipv6_unicast": True,
        "ipv6_multicast": False,
        "vpls": False,
        "route_refresh": True,
        "route_constraint": False,
        "link_state_non_vpn": False,
        "link_state_vpn": False,
        "evpn": False,
        "extended_next_hop_encoding": False,
        "ipv4_multicast_vpn": False,
        "ipv4_mpls_vpn": False,
        "ipv4_mdt": False,
        "ipv4_multicast_mpls_vpn": False,
        "ipv4_unicast_flow_spec": False,
        "ipv4_sr_te_policy": False,
        "ipv4_unicast_add_path": False,
        "ipv6_multicast_vpn": False,
        "ipv6_mpls_vpn": False,
        "ipv6_mdt": False,
        "ipv6_multicast_mpls_vpn": False,
        "ipv6_unicast_flow_spec": False,
        "ipv6_sr_te_policy": False,
        "ipv6_unicast_add_path": False,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        ipv4_unicast=True,
        ipv4_multicast=False,
        ipv6_unicast=True,
        ipv6_multicast=False,
        vpls=False,
        route_refresh=True,
        route_constraint=False,
        link_state_non_vpn=False,
        link_state_vpn=False,
        evpn=False,
        extended_next_hop_encoding=False,
        ipv4_multicast_vpn=False,
        ipv4_mpls_vpn=False,
        ipv4_mdt=False,
        ipv4_multicast_mpls_vpn=False,
        ipv4_unicast_flow_spec=False,
        ipv4_sr_te_policy=False,
        ipv4_unicast_add_path=False,
        ipv6_multicast_vpn=False,
        ipv6_mpls_vpn=False,
        ipv6_mdt=False,
        ipv6_multicast_mpls_vpn=False,
        ipv6_unicast_flow_spec=False,
        ipv6_sr_te_policy=False,
        ipv6_unicast_add_path=False,
    ):
        super(BgpCapability, self).__init__()
        self._parent = parent
        self._set_property("ipv4_unicast", ipv4_unicast)
        self._set_property("ipv4_multicast", ipv4_multicast)
        self._set_property("ipv6_unicast", ipv6_unicast)
        self._set_property("ipv6_multicast", ipv6_multicast)
        self._set_property("vpls", vpls)
        self._set_property("route_refresh", route_refresh)
        self._set_property("route_constraint", route_constraint)
        self._set_property("link_state_non_vpn", link_state_non_vpn)
        self._set_property("link_state_vpn", link_state_vpn)
        self._set_property("evpn", evpn)
        self._set_property("extended_next_hop_encoding", extended_next_hop_encoding)
        self._set_property("ipv4_multicast_vpn", ipv4_multicast_vpn)
        self._set_property("ipv4_mpls_vpn", ipv4_mpls_vpn)
        self._set_property("ipv4_mdt", ipv4_mdt)
        self._set_property("ipv4_multicast_mpls_vpn", ipv4_multicast_mpls_vpn)
        self._set_property("ipv4_unicast_flow_spec", ipv4_unicast_flow_spec)
        self._set_property("ipv4_sr_te_policy", ipv4_sr_te_policy)
        self._set_property("ipv4_unicast_add_path", ipv4_unicast_add_path)
        self._set_property("ipv6_multicast_vpn", ipv6_multicast_vpn)
        self._set_property("ipv6_mpls_vpn", ipv6_mpls_vpn)
        self._set_property("ipv6_mdt", ipv6_mdt)
        self._set_property("ipv6_multicast_mpls_vpn", ipv6_multicast_mpls_vpn)
        self._set_property("ipv6_unicast_flow_spec", ipv6_unicast_flow_spec)
        self._set_property("ipv6_sr_te_policy", ipv6_sr_te_policy)
        self._set_property("ipv6_unicast_add_path", ipv6_unicast_add_path)

    def set(
        self,
        ipv4_unicast=None,
        ipv4_multicast=None,
        ipv6_unicast=None,
        ipv6_multicast=None,
        vpls=None,
        route_refresh=None,
        route_constraint=None,
        link_state_non_vpn=None,
        link_state_vpn=None,
        evpn=None,
        extended_next_hop_encoding=None,
        ipv4_multicast_vpn=None,
        ipv4_mpls_vpn=None,
        ipv4_mdt=None,
        ipv4_multicast_mpls_vpn=None,
        ipv4_unicast_flow_spec=None,
        ipv4_sr_te_policy=None,
        ipv4_unicast_add_path=None,
        ipv6_multicast_vpn=None,
        ipv6_mpls_vpn=None,
        ipv6_mdt=None,
        ipv6_multicast_mpls_vpn=None,
        ipv6_unicast_flow_spec=None,
        ipv6_sr_te_policy=None,
        ipv6_unicast_add_path=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def ipv4_unicast(self):
        # type: () -> bool
        """ipv4_unicast getter

        Support for the IPv4 Unicast address family.

        Returns: bool
        """
        return self._get_property("ipv4_unicast")

    @ipv4_unicast.setter
    def ipv4_unicast(self, value):
        """ipv4_unicast setter

        Support for the IPv4 Unicast address family.

        value: bool
        """
        self._set_property("ipv4_unicast", value)

    @property
    def ipv4_multicast(self):
        # type: () -> bool
        """ipv4_multicast getter

        Support for the IPv4 Multicast address family.

        Returns: bool
        """
        return self._get_property("ipv4_multicast")

    @ipv4_multicast.setter
    def ipv4_multicast(self, value):
        """ipv4_multicast setter

        Support for the IPv4 Multicast address family.

        value: bool
        """
        self._set_property("ipv4_multicast", value)

    @property
    def ipv6_unicast(self):
        # type: () -> bool
        """ipv6_unicast getter

        Support for the IPv4 Unicast address family.

        Returns: bool
        """
        return self._get_property("ipv6_unicast")

    @ipv6_unicast.setter
    def ipv6_unicast(self, value):
        """ipv6_unicast setter

        Support for the IPv4 Unicast address family.

        value: bool
        """
        self._set_property("ipv6_unicast", value)

    @property
    def ipv6_multicast(self):
        # type: () -> bool
        """ipv6_multicast getter

        Support for the IPv6 Multicast address family.

        Returns: bool
        """
        return self._get_property("ipv6_multicast")

    @ipv6_multicast.setter
    def ipv6_multicast(self, value):
        """ipv6_multicast setter

        Support for the IPv6 Multicast address family.

        value: bool
        """
        self._set_property("ipv6_multicast", value)

    @property
    def vpls(self):
        # type: () -> bool
        """vpls getter

        Support for VPLS as below. RFC4761 Virtual Private LAN Service (VPLS) using BGP for Auto-Discovery. and Signaling. RFC6624 Layer Virtual Private Networks using BGP for Auto-Discovery and Signaling.

        Returns: bool
        """
        return self._get_property("vpls")

    @vpls.setter
    def vpls(self, value):
        """vpls setter

        Support for VPLS as below. RFC4761 Virtual Private LAN Service (VPLS) using BGP for Auto-Discovery. and Signaling. RFC6624 Layer Virtual Private Networks using BGP for Auto-Discovery and Signaling.

        value: bool
        """
        self._set_property("vpls", value)

    @property
    def route_refresh(self):
        # type: () -> bool
        """route_refresh getter

        Support for the route refresh capabilities. Route Refresh allows the dynamic exchange of route refresh requests and routing information between BGP peers and the subsequent re-advertisement of the outbound or inbound routing table.

        Returns: bool
        """
        return self._get_property("route_refresh")

    @route_refresh.setter
    def route_refresh(self, value):
        """route_refresh setter

        Support for the route refresh capabilities. Route Refresh allows the dynamic exchange of route refresh requests and routing information between BGP peers and the subsequent re-advertisement of the outbound or inbound routing table.

        value: bool
        """
        self._set_property("route_refresh", value)

    @property
    def route_constraint(self):
        # type: () -> bool
        """route_constraint getter

        Supports for the route constraint capabilities. Route Constraint allows the advertisement of Route Target Membership information. The BGP peers exchange Route Target Reachability Information, which is used to build route distribution graph. This limits the propagation of VPN Network Layer Reachability Information (NLRI) between different autonomous systems or distinct clusters of the same autonomous system. This is supported for Layer Virtual Private Network scenario.

        Returns: bool
        """
        return self._get_property("route_constraint")

    @route_constraint.setter
    def route_constraint(self, value):
        """route_constraint setter

        Supports for the route constraint capabilities. Route Constraint allows the advertisement of Route Target Membership information. The BGP peers exchange Route Target Reachability Information, which is used to build route distribution graph. This limits the propagation of VPN Network Layer Reachability Information (NLRI) between different autonomous systems or distinct clusters of the same autonomous system. This is supported for Layer Virtual Private Network scenario.

        value: bool
        """
        self._set_property("route_constraint", value)

    @property
    def link_state_non_vpn(self):
        # type: () -> bool
        """link_state_non_vpn getter

        Support for BGP Link State for ISIS and OSPF.

        Returns: bool
        """
        return self._get_property("link_state_non_vpn")

    @link_state_non_vpn.setter
    def link_state_non_vpn(self, value):
        """link_state_non_vpn setter

        Support for BGP Link State for ISIS and OSPF.

        value: bool
        """
        self._set_property("link_state_non_vpn", value)

    @property
    def link_state_vpn(self):
        # type: () -> bool
        """link_state_vpn getter

        Capability advertisement of BGP Link State for VPNs.

        Returns: bool
        """
        return self._get_property("link_state_vpn")

    @link_state_vpn.setter
    def link_state_vpn(self, value):
        """link_state_vpn setter

        Capability advertisement of BGP Link State for VPNs.

        value: bool
        """
        self._set_property("link_state_vpn", value)

    @property
    def evpn(self):
        # type: () -> bool
        """evpn getter

        Support for the EVPN address family.

        Returns: bool
        """
        return self._get_property("evpn")

    @evpn.setter
    def evpn(self, value):
        """evpn setter

        Support for the EVPN address family.

        value: bool
        """
        self._set_property("evpn", value)

    @property
    def extended_next_hop_encoding(self):
        # type: () -> bool
        """extended_next_hop_encoding getter

        Support for extended Next Hop Encoding for Nexthop field in IPv4 routes advertisement. This allows IPv4 routes being advertised by IPv6 peers to include an IPv6 Nexthop.

        Returns: bool
        """
        return self._get_property("extended_next_hop_encoding")

    @extended_next_hop_encoding.setter
    def extended_next_hop_encoding(self, value):
        """extended_next_hop_encoding setter

        Support for extended Next Hop Encoding for Nexthop field in IPv4 routes advertisement. This allows IPv4 routes being advertised by IPv6 peers to include an IPv6 Nexthop.

        value: bool
        """
        self._set_property("extended_next_hop_encoding", value)

    @property
    def ipv4_multicast_vpn(self):
        # type: () -> bool
        """ipv4_multicast_vpn getter

        Support for the IPv4 Multicast VPN address family.

        Returns: bool
        """
        return self._get_property("ipv4_multicast_vpn")

    @ipv4_multicast_vpn.setter
    def ipv4_multicast_vpn(self, value):
        """ipv4_multicast_vpn setter

        Support for the IPv4 Multicast VPN address family.

        value: bool
        """
        self._set_property("ipv4_multicast_vpn", value)

    @property
    def ipv4_mpls_vpn(self):
        # type: () -> bool
        """ipv4_mpls_vpn getter

        Support for the IPv4 MPLS L3VPN address family.

        Returns: bool
        """
        return self._get_property("ipv4_mpls_vpn")

    @ipv4_mpls_vpn.setter
    def ipv4_mpls_vpn(self, value):
        """ipv4_mpls_vpn setter

        Support for the IPv4 MPLS L3VPN address family.

        value: bool
        """
        self._set_property("ipv4_mpls_vpn", value)

    @property
    def ipv4_mdt(self):
        # type: () -> bool
        """ipv4_mdt getter

        Supports for IPv4 MDT address family messages.

        Returns: bool
        """
        return self._get_property("ipv4_mdt")

    @ipv4_mdt.setter
    def ipv4_mdt(self, value):
        """ipv4_mdt setter

        Supports for IPv4 MDT address family messages.

        value: bool
        """
        self._set_property("ipv4_mdt", value)

    @property
    def ipv4_multicast_mpls_vpn(self):
        # type: () -> bool
        """ipv4_multicast_mpls_vpn getter

        Support for the IPv4 Multicast VPN address family.

        Returns: bool
        """
        return self._get_property("ipv4_multicast_mpls_vpn")

    @ipv4_multicast_mpls_vpn.setter
    def ipv4_multicast_mpls_vpn(self, value):
        """ipv4_multicast_mpls_vpn setter

        Support for the IPv4 Multicast VPN address family.

        value: bool
        """
        self._set_property("ipv4_multicast_mpls_vpn", value)

    @property
    def ipv4_unicast_flow_spec(self):
        # type: () -> bool
        """ipv4_unicast_flow_spec getter

        Support for propagation of IPv4 unicast flow specification rules.

        Returns: bool
        """
        return self._get_property("ipv4_unicast_flow_spec")

    @ipv4_unicast_flow_spec.setter
    def ipv4_unicast_flow_spec(self, value):
        """ipv4_unicast_flow_spec setter

        Support for propagation of IPv4 unicast flow specification rules.

        value: bool
        """
        self._set_property("ipv4_unicast_flow_spec", value)

    @property
    def ipv4_sr_te_policy(self):
        # type: () -> bool
        """ipv4_sr_te_policy getter

        Support for IPv4 SRTE policy.

        Returns: bool
        """
        return self._get_property("ipv4_sr_te_policy")

    @ipv4_sr_te_policy.setter
    def ipv4_sr_te_policy(self, value):
        """ipv4_sr_te_policy setter

        Support for IPv4 SRTE policy.

        value: bool
        """
        self._set_property("ipv4_sr_te_policy", value)

    @property
    def ipv4_unicast_add_path(self):
        # type: () -> bool
        """ipv4_unicast_add_path getter

        Support for IPv4 Unicast Add Path Capability.

        Returns: bool
        """
        return self._get_property("ipv4_unicast_add_path")

    @ipv4_unicast_add_path.setter
    def ipv4_unicast_add_path(self, value):
        """ipv4_unicast_add_path setter

        Support for IPv4 Unicast Add Path Capability.

        value: bool
        """
        self._set_property("ipv4_unicast_add_path", value)

    @property
    def ipv6_multicast_vpn(self):
        # type: () -> bool
        """ipv6_multicast_vpn getter

        Support for the IPv6 Multicast VPN address family.

        Returns: bool
        """
        return self._get_property("ipv6_multicast_vpn")

    @ipv6_multicast_vpn.setter
    def ipv6_multicast_vpn(self, value):
        """ipv6_multicast_vpn setter

        Support for the IPv6 Multicast VPN address family.

        value: bool
        """
        self._set_property("ipv6_multicast_vpn", value)

    @property
    def ipv6_mpls_vpn(self):
        # type: () -> bool
        """ipv6_mpls_vpn getter

        Support for the IPv6 MPLS L3VPN address family.

        Returns: bool
        """
        return self._get_property("ipv6_mpls_vpn")

    @ipv6_mpls_vpn.setter
    def ipv6_mpls_vpn(self, value):
        """ipv6_mpls_vpn setter

        Support for the IPv6 MPLS L3VPN address family.

        value: bool
        """
        self._set_property("ipv6_mpls_vpn", value)

    @property
    def ipv6_mdt(self):
        # type: () -> bool
        """ipv6_mdt getter

        Support for IPv6 MDT address family messages.

        Returns: bool
        """
        return self._get_property("ipv6_mdt")

    @ipv6_mdt.setter
    def ipv6_mdt(self, value):
        """ipv6_mdt setter

        Support for IPv6 MDT address family messages.

        value: bool
        """
        self._set_property("ipv6_mdt", value)

    @property
    def ipv6_multicast_mpls_vpn(self):
        # type: () -> bool
        """ipv6_multicast_mpls_vpn getter

        Support for the IPv6 Multicast VPN address family.

        Returns: bool
        """
        return self._get_property("ipv6_multicast_mpls_vpn")

    @ipv6_multicast_mpls_vpn.setter
    def ipv6_multicast_mpls_vpn(self, value):
        """ipv6_multicast_mpls_vpn setter

        Support for the IPv6 Multicast VPN address family.

        value: bool
        """
        self._set_property("ipv6_multicast_mpls_vpn", value)

    @property
    def ipv6_unicast_flow_spec(self):
        # type: () -> bool
        """ipv6_unicast_flow_spec getter

        Support for propagation of IPv6 unicast flow specification rules.

        Returns: bool
        """
        return self._get_property("ipv6_unicast_flow_spec")

    @ipv6_unicast_flow_spec.setter
    def ipv6_unicast_flow_spec(self, value):
        """ipv6_unicast_flow_spec setter

        Support for propagation of IPv6 unicast flow specification rules.

        value: bool
        """
        self._set_property("ipv6_unicast_flow_spec", value)

    @property
    def ipv6_sr_te_policy(self):
        # type: () -> bool
        """ipv6_sr_te_policy getter

        Support for IPv6 SRTE policy.

        Returns: bool
        """
        return self._get_property("ipv6_sr_te_policy")

    @ipv6_sr_te_policy.setter
    def ipv6_sr_te_policy(self, value):
        """ipv6_sr_te_policy setter

        Support for IPv6 SRTE policy.

        value: bool
        """
        self._set_property("ipv6_sr_te_policy", value)

    @property
    def ipv6_unicast_add_path(self):
        # type: () -> bool
        """ipv6_unicast_add_path getter

        Support for IPv6 Unicast Add Path Capability.

        Returns: bool
        """
        return self._get_property("ipv6_unicast_add_path")

    @ipv6_unicast_add_path.setter
    def ipv6_unicast_add_path(self, value):
        """ipv6_unicast_add_path setter

        Support for IPv6 Unicast Add Path Capability.

        value: bool
        """
        self._set_property("ipv6_unicast_add_path", value)


class BgpLearnedInformationFilter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "unicast_ipv4_prefix": {"type": bool},
        "unicast_ipv6_prefix": {"type": bool},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "unicast_ipv4_prefix": False,
        "unicast_ipv6_prefix": False,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self, parent=None, unicast_ipv4_prefix=False, unicast_ipv6_prefix=False
    ):
        super(BgpLearnedInformationFilter, self).__init__()
        self._parent = parent
        self._set_property("unicast_ipv4_prefix", unicast_ipv4_prefix)
        self._set_property("unicast_ipv6_prefix", unicast_ipv6_prefix)

    def set(self, unicast_ipv4_prefix=None, unicast_ipv6_prefix=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def unicast_ipv4_prefix(self):
        # type: () -> bool
        """unicast_ipv4_prefix getter

        If enabled, will store the information related to Unicast IPv4 Prefixes recieved from the peer.

        Returns: bool
        """
        return self._get_property("unicast_ipv4_prefix")

    @unicast_ipv4_prefix.setter
    def unicast_ipv4_prefix(self, value):
        """unicast_ipv4_prefix setter

        If enabled, will store the information related to Unicast IPv4 Prefixes recieved from the peer.

        value: bool
        """
        self._set_property("unicast_ipv4_prefix", value)

    @property
    def unicast_ipv6_prefix(self):
        # type: () -> bool
        """unicast_ipv6_prefix getter

        If enabled, will store the information related to Unicast IPv6 Prefixes recieved from the peer.

        Returns: bool
        """
        return self._get_property("unicast_ipv6_prefix")

    @unicast_ipv6_prefix.setter
    def unicast_ipv6_prefix(self, value):
        """unicast_ipv6_prefix setter

        If enabled, will store the information related to Unicast IPv6 Prefixes recieved from the peer.

        value: bool
        """
        self._set_property("unicast_ipv6_prefix", value)


class BgpV4RouteRange(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "addresses": {"type": "V4RouteAddressIter"},
        "next_hop_mode": {
            "type": str,
            "enum": [
                "local_ip",
                "manual",
            ],
        },
        "next_hop_address_type": {
            "type": str,
            "enum": [
                "ipv4",
                "ipv6",
            ],
        },
        "next_hop_ipv4_address": {
            "type": str,
            "format": "ipv4",
        },
        "next_hop_ipv6_address": {
            "type": str,
            "format": "ipv6",
        },
        "advanced": {"type": "BgpRouteAdvanced"},
        "communities": {"type": "BgpCommunityIter"},
        "as_path": {"type": "BgpAsPath"},
        "add_path": {"type": "BgpAddPath"},
        "name": {"type": str},
        "ext_communities": {"type": "BgpExtCommunityIter"},
        "extended_communities": {"type": "BgpExtendedCommunityIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "next_hop_mode": "local_ip",
        "next_hop_address_type": "ipv4",
        "next_hop_ipv4_address": "0.0.0.0",
        "next_hop_ipv6_address": "::0",
    }  # type: Dict[str, Union(type)]

    LOCAL_IP = "local_ip"  # type: str
    MANUAL = "manual"  # type: str

    IPV4 = "ipv4"  # type: str
    IPV6 = "ipv6"  # type: str

    _STATUS = {
        "ext_communities": "ext_communities property in schema BgpV4RouteRange is deprecated, This property is deprecated in favor of property extended_communities",
    }  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        next_hop_mode="local_ip",
        next_hop_address_type="ipv4",
        next_hop_ipv4_address="0.0.0.0",
        next_hop_ipv6_address="::0",
        name=None,
    ):
        super(BgpV4RouteRange, self).__init__()
        self._parent = parent
        self._set_property("next_hop_mode", next_hop_mode)
        self._set_property("next_hop_address_type", next_hop_address_type)
        self._set_property("next_hop_ipv4_address", next_hop_ipv4_address)
        self._set_property("next_hop_ipv6_address", next_hop_ipv6_address)
        self._set_property("name", name)

    def set(
        self,
        next_hop_mode=None,
        next_hop_address_type=None,
        next_hop_ipv4_address=None,
        next_hop_ipv6_address=None,
        name=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def addresses(self):
        # type: () -> V4RouteAddressIter
        """addresses getter

        A list of group of IPv4 route addresses.

        Returns: V4RouteAddressIter
        """
        return self._get_property(
            "addresses", V4RouteAddressIter, self._parent, self._choice
        )

    @property
    def next_hop_mode(self):
        # type: () -> Union[Literal["local_ip"], Literal["manual"]]
        """next_hop_mode getter

        Specify the NextHop in MP REACH NLRI. The mode for setting the IP address of the NextHop in the MP REACH NLRI can be one of the following:. Local IP: Automatically fills the Nexthop with the Local IP of the BGP. peer.. If BGP peer is of type IPv6, Nexthop Encoding capability should be enabled.. Manual: Override the Nexthop with any arbitrary IPv4/IPv6 address.

        Returns: Union[Literal["local_ip"], Literal["manual"]]
        """
        return self._get_property("next_hop_mode")

    @next_hop_mode.setter
    def next_hop_mode(self, value):
        """next_hop_mode setter

        Specify the NextHop in MP REACH NLRI. The mode for setting the IP address of the NextHop in the MP REACH NLRI can be one of the following:. Local IP: Automatically fills the Nexthop with the Local IP of the BGP. peer.. If BGP peer is of type IPv6, Nexthop Encoding capability should be enabled.. Manual: Override the Nexthop with any arbitrary IPv4/IPv6 address.

        value: Union[Literal["local_ip"], Literal["manual"]]
        """
        self._set_property("next_hop_mode", value)

    @property
    def next_hop_address_type(self):
        # type: () -> Union[Literal["ipv4"], Literal["ipv6"]]
        """next_hop_address_type getter

        If the Nexthop Mode is Manual, it sets the type of the NextHop IP address.

        Returns: Union[Literal["ipv4"], Literal["ipv6"]]
        """
        return self._get_property("next_hop_address_type")

    @next_hop_address_type.setter
    def next_hop_address_type(self, value):
        """next_hop_address_type setter

        If the Nexthop Mode is Manual, it sets the type of the NextHop IP address.

        value: Union[Literal["ipv4"], Literal["ipv6"]]
        """
        self._set_property("next_hop_address_type", value)

    @property
    def next_hop_ipv4_address(self):
        # type: () -> str
        """next_hop_ipv4_address getter

        The IPv4 address of the next hop if the Nexthop Mode is manual and the Nexthop type is IPv4. If BGP peer is of type IPv6, Nexthop Encoding capability should be enabled.

        Returns: str
        """
        return self._get_property("next_hop_ipv4_address")

    @next_hop_ipv4_address.setter
    def next_hop_ipv4_address(self, value):
        """next_hop_ipv4_address setter

        The IPv4 address of the next hop if the Nexthop Mode is manual and the Nexthop type is IPv4. If BGP peer is of type IPv6, Nexthop Encoding capability should be enabled.

        value: str
        """
        self._set_property("next_hop_ipv4_address", value)

    @property
    def next_hop_ipv6_address(self):
        # type: () -> str
        """next_hop_ipv6_address getter

        The IPv6 address of the next hop if the Nexthop Mode is manual and the Nexthop type is IPv6.

        Returns: str
        """
        return self._get_property("next_hop_ipv6_address")

    @next_hop_ipv6_address.setter
    def next_hop_ipv6_address(self, value):
        """next_hop_ipv6_address setter

        The IPv6 address of the next hop if the Nexthop Mode is manual and the Nexthop type is IPv6.

        value: str
        """
        self._set_property("next_hop_ipv6_address", value)

    @property
    def advanced(self):
        # type: () -> BgpRouteAdvanced
        """advanced getter

        Configuration for advanced BGP route range settings.Configuration for advanced BGP route range settings.Configuration for advanced BGP route range settings.

        Returns: BgpRouteAdvanced
        """
        return self._get_property("advanced", BgpRouteAdvanced)

    @property
    def communities(self):
        # type: () -> BgpCommunityIter
        """communities getter

        Optional community settings.

        Returns: BgpCommunityIter
        """
        return self._get_property(
            "communities", BgpCommunityIter, self._parent, self._choice
        )

    @property
    def as_path(self):
        # type: () -> BgpAsPath
        """as_path getter

        This attribute identifies the autonomous systems through which routing information carried in this UPDATE message has passed. This contains the configuration of how to include the Local AS in the AS path attribute of the MP REACH NLRI. It also contains optional configuration of additional AS Path Segments that can be included in the AS Path attribute. The AS Path consists of Set or Sequence of Autonomous Systems (AS) numbers that routing information passes through to reach the destination.This attribute identifies the autonomous systems through which routing information carried in this UPDATE message has passed. This contains the configuration of how to include the Local AS in the AS path attribute of the MP REACH NLRI. It also contains optional configuration of additional AS Path Segments that can be included in the AS Path attribute. The AS Path consists of Set or Sequence of Autonomous Systems (AS) numbers that routing information passes through to reach the destination.This attribute identifies the autonomous systems through which routing information carried in this UPDATE message has passed. This contains the configuration of how to include the Local AS in the AS path attribute of the MP REACH NLRI. It also contains optional configuration of additional AS Path Segments that can be included in the AS Path attribute. The AS Path consists of Set or Sequence of Autonomous Systems (AS) numbers that routing information passes through to reach the destination.

        Returns: BgpAsPath
        """
        return self._get_property("as_path", BgpAsPath)

    @property
    def add_path(self):
        # type: () -> BgpAddPath
        """add_path getter

        The BGP Additional Paths feature is BGP extension that allows the advertisement of multiple paths for the same prefix without the new paths implicitly replacing any previous paths.The BGP Additional Paths feature is BGP extension that allows the advertisement of multiple paths for the same prefix without the new paths implicitly replacing any previous paths.The BGP Additional Paths feature is BGP extension that allows the advertisement of multiple paths for the same prefix without the new paths implicitly replacing any previous paths.

        Returns: BgpAddPath
        """
        return self._get_property("add_path", BgpAddPath)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def ext_communities(self):
        # type: () -> BgpExtCommunityIter
        """ext_communities getter

        Deprecated: This property is deprecated in favor of property extended_communities. Deprecated: This property is deprecated in favor of property extended_communities. Optional Extended Community settings. The Extended Communities Attribute is transitive optional BGP attribute, with the Type Code 16. Community and Extended Communities attributes are utilized to trigger routing decisions, such as acceptance, rejection, preference, or redistribution. An extended community is an 8-Bytes value. It is divided into two main parts. The first Bytes of the community encode type and sub-type fields and the last Bytes carry unique set of data in format defined by the type and sub-type field. Extended communities provide larger range for grouping or categorizing communities. When type is administrator_as_2octet or administrator_as_4octet, the valid sub types are route target and origin. The valid value for administrator_as_2octet and administrator_as_4octet type is either two byte AS followed by four byte local administrator id or four byte AS followed by two byte local administrator id. When type is administrator_ipv4_address the valid sub types are route target and origin. The valid value for administrator_ipv4_address is four byte IPv4 address followed by two byte local administrator id. When type is opaque, valid sub types are color and encapsulation. When sub type is color, first two bytes of the value field contain flags and last four bytes contains the value of the color. When sub type is encapsulation the first four bytes of value field are reserved and last two bytes carries the tunnel type from IANA's "ETHER TYPES" registry e.g IPv4 (protocol type 0x0800), IPv6 (protocol type 0x86dd), and MPLS (protocol type 0x8847). When type is administrator_as_2octet_link_bandwidth the valid sub type is extended_bandwidth. The first two bytes of the value field contains the AS number and the last four bytes contains the bandwidth in IEEE floating point format. When type is evpn the valid subtype is mac_address. In the value field the low-order bit of the first byte(Flags) is defined as the "Sticky/static" flag and may be set to 1, indicating the MAC address is static and cannot move. The second byte is reserved and the last four bytes contain the sequence number which is used to ensure that PEs retain the correct MAC/IP Advertisement route when multiple updates occur for the same MAC address. Note evpn type is defined mainly for use with evpn route updates and not for IPv4 and IPv6 route updates.

        Returns: BgpExtCommunityIter
        """
        return self._get_property(
            "ext_communities", BgpExtCommunityIter, self._parent, self._choice
        )

    @property
    def extended_communities(self):
        # type: () -> BgpExtendedCommunityIter
        """extended_communities getter

        Optional Extended Community settings. The Extended Communities Attribute is transitive optional BGP attribute, with the Type Code 16. Community and Extended Communities attributes are utilized to trigger routing decisions, such as acceptance, rejection, preference, or redistribution. An extended community is an eight byte value. It is divided into two main parts. The first two bytes of the community encode type and sub-type fields and the last six bytes carry unique set of data in format defined by the type and sub-type field. Extended communities provide larger range for grouping or categorizing communities.

        Returns: BgpExtendedCommunityIter
        """
        return self._get_property(
            "extended_communities", BgpExtendedCommunityIter, self._parent, self._choice
        )


class BgpAddPath(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "path_id": {
            "type": int,
            "format": "uint32",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "path_id": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, path_id=1):
        super(BgpAddPath, self).__init__()
        self._parent = parent
        self._set_property("path_id", path_id)

    def set(self, path_id=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def path_id(self):
        # type: () -> int
        """path_id getter

        The id of the additional path.

        Returns: int
        """
        return self._get_property("path_id")

    @path_id.setter
    def path_id(self, value):
        """path_id setter

        The id of the additional path.

        value: int
        """
        self._set_property("path_id", value)


class BgpExtendedCommunity(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "transitive_2octet_as_type",
                "transitive_ipv4_address_type",
                "transitive_4octet_as_type",
                "transitive_opaque_type",
                "transitive_evpn_type",
                "non_transitive_2octet_as_type",
                "custom",
            ],
        },
        "transitive_2octet_as_type": {
            "type": "BgpExtendedCommunityTransitive2OctetAsType"
        },
        "transitive_ipv4_address_type": {
            "type": "BgpExtendedCommunityTransitiveIpv4AddressType"
        },
        "transitive_4octet_as_type": {
            "type": "BgpExtendedCommunityTransitive4OctetAsType"
        },
        "transitive_opaque_type": {"type": "BgpExtendedCommunityTransitiveOpaqueType"},
        "transitive_evpn_type": {"type": "BgpExtendedCommunityTransitiveEvpnType"},
        "non_transitive_2octet_as_type": {
            "type": "BgpExtendedCommunityNonTransitive2OctetAsType"
        },
        "custom": {"type": "BgpExtendedCommunityCustomType"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "transitive_2octet_as_type",
    }  # type: Dict[str, Union(type)]

    TRANSITIVE_2OCTET_AS_TYPE = "transitive_2octet_as_type"  # type: str
    TRANSITIVE_IPV4_ADDRESS_TYPE = "transitive_ipv4_address_type"  # type: str
    TRANSITIVE_4OCTET_AS_TYPE = "transitive_4octet_as_type"  # type: str
    TRANSITIVE_OPAQUE_TYPE = "transitive_opaque_type"  # type: str
    TRANSITIVE_EVPN_TYPE = "transitive_evpn_type"  # type: str
    NON_TRANSITIVE_2OCTET_AS_TYPE = "non_transitive_2octet_as_type"  # type: str
    CUSTOM = "custom"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None):
        super(BgpExtendedCommunity, self).__init__()
        self._parent = parent
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    @property
    def transitive_2octet_as_type(self):
        # type: () -> BgpExtendedCommunityTransitive2OctetAsType
        """Factory property that returns an instance of the BgpExtendedCommunityTransitive2OctetAsType class

        The Transitive Two-Octet AS-Specific Extended Community is sent as type 0x00

        Returns: BgpExtendedCommunityTransitive2OctetAsType
        """
        return self._get_property(
            "transitive_2octet_as_type",
            BgpExtendedCommunityTransitive2OctetAsType,
            self,
            "transitive_2octet_as_type",
        )

    @property
    def transitive_ipv4_address_type(self):
        # type: () -> BgpExtendedCommunityTransitiveIpv4AddressType
        """Factory property that returns an instance of the BgpExtendedCommunityTransitiveIpv4AddressType class

        The Transitive IPv4 Address Specific Extended Community is sent as type 0x01.

        Returns: BgpExtendedCommunityTransitiveIpv4AddressType
        """
        return self._get_property(
            "transitive_ipv4_address_type",
            BgpExtendedCommunityTransitiveIpv4AddressType,
            self,
            "transitive_ipv4_address_type",
        )

    @property
    def transitive_4octet_as_type(self):
        # type: () -> BgpExtendedCommunityTransitive4OctetAsType
        """Factory property that returns an instance of the BgpExtendedCommunityTransitive4OctetAsType class

        The Transitive Four-Octet AS-Specific Extended Community is sent as type 0x02. It is defined in RFC 5668.

        Returns: BgpExtendedCommunityTransitive4OctetAsType
        """
        return self._get_property(
            "transitive_4octet_as_type",
            BgpExtendedCommunityTransitive4OctetAsType,
            self,
            "transitive_4octet_as_type",
        )

    @property
    def transitive_opaque_type(self):
        # type: () -> BgpExtendedCommunityTransitiveOpaqueType
        """Factory property that returns an instance of the BgpExtendedCommunityTransitiveOpaqueType class

        The Transitive Opaque Extended Community is sent as type 0x03.

        Returns: BgpExtendedCommunityTransitiveOpaqueType
        """
        return self._get_property(
            "transitive_opaque_type",
            BgpExtendedCommunityTransitiveOpaqueType,
            self,
            "transitive_opaque_type",
        )

    @property
    def transitive_evpn_type(self):
        # type: () -> BgpExtendedCommunityTransitiveEvpnType
        """Factory property that returns an instance of the BgpExtendedCommunityTransitiveEvpnType class

        The Transitive EVPN Extended Community is sent as type 0x06

        Returns: BgpExtendedCommunityTransitiveEvpnType
        """
        return self._get_property(
            "transitive_evpn_type",
            BgpExtendedCommunityTransitiveEvpnType,
            self,
            "transitive_evpn_type",
        )

    @property
    def non_transitive_2octet_as_type(self):
        # type: () -> BgpExtendedCommunityNonTransitive2OctetAsType
        """Factory property that returns an instance of the BgpExtendedCommunityNonTransitive2OctetAsType class

        The Non-Transitive Two-Octet AS-Specific Extended Community is sent as type 0x40.

        Returns: BgpExtendedCommunityNonTransitive2OctetAsType
        """
        return self._get_property(
            "non_transitive_2octet_as_type",
            BgpExtendedCommunityNonTransitive2OctetAsType,
            self,
            "non_transitive_2octet_as_type",
        )

    @property
    def custom(self):
        # type: () -> BgpExtendedCommunityCustomType
        """Factory property that returns an instance of the BgpExtendedCommunityCustomType class

        Add custom Extended Community with combination of types sub-types and values not explicitly specified above or not defined yet.

        Returns: BgpExtendedCommunityCustomType
        """
        return self._get_property(
            "custom", BgpExtendedCommunityCustomType, self, "custom"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["custom"], Literal["non_transitive_2octet_as_type"], Literal["transitive_2octet_as_type"], Literal["transitive_4octet_as_type"], Literal["transitive_evpn_type"], Literal["transitive_ipv4_address_type"], Literal["transitive_opaque_type"]]
        """choice getter

        TBD

        Returns: Union[Literal["custom"], Literal["non_transitive_2octet_as_type"], Literal["transitive_2octet_as_type"], Literal["transitive_4octet_as_type"], Literal["transitive_evpn_type"], Literal["transitive_ipv4_address_type"], Literal["transitive_opaque_type"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["custom"], Literal["non_transitive_2octet_as_type"], Literal["transitive_2octet_as_type"], Literal["transitive_4octet_as_type"], Literal["transitive_evpn_type"], Literal["transitive_ipv4_address_type"], Literal["transitive_opaque_type"]]
        """
        self._set_property("choice", value)


class BgpExtendedCommunityTransitive2OctetAsType(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "route_target_subtype",
                "route_origin_subtype",
            ],
        },
        "route_target_subtype": {
            "type": "BgpExtendedCommunityTransitive2OctetAsTypeRouteTarget"
        },
        "route_origin_subtype": {
            "type": "BgpExtendedCommunityTransitive2OctetAsTypeRouteOrigin"
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "route_target_subtype",
    }  # type: Dict[str, Union(type)]

    ROUTE_TARGET_SUBTYPE = "route_target_subtype"  # type: str
    ROUTE_ORIGIN_SUBTYPE = "route_origin_subtype"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None):
        super(BgpExtendedCommunityTransitive2OctetAsType, self).__init__()
        self._parent = parent
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    @property
    def route_target_subtype(self):
        # type: () -> BgpExtendedCommunityTransitive2OctetAsTypeRouteTarget
        """Factory property that returns an instance of the BgpExtendedCommunityTransitive2OctetAsTypeRouteTarget class

        The Route Target Community identifies one or more routers that may receive set of routes (that carry this Community) carried by BGP. It is sent with sub-type as 0x02.

        Returns: BgpExtendedCommunityTransitive2OctetAsTypeRouteTarget
        """
        return self._get_property(
            "route_target_subtype",
            BgpExtendedCommunityTransitive2OctetAsTypeRouteTarget,
            self,
            "route_target_subtype",
        )

    @property
    def route_origin_subtype(self):
        # type: () -> BgpExtendedCommunityTransitive2OctetAsTypeRouteOrigin
        """Factory property that returns an instance of the BgpExtendedCommunityTransitive2OctetAsTypeRouteOrigin class

        The Route Origin Community identifies one or more routers that inject set of routes (that carry this Community) into BGP. It is sent with sub-type as 0x03 .

        Returns: BgpExtendedCommunityTransitive2OctetAsTypeRouteOrigin
        """
        return self._get_property(
            "route_origin_subtype",
            BgpExtendedCommunityTransitive2OctetAsTypeRouteOrigin,
            self,
            "route_origin_subtype",
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["route_origin_subtype"], Literal["route_target_subtype"]]
        """choice getter

        TBD

        Returns: Union[Literal["route_origin_subtype"], Literal["route_target_subtype"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["route_origin_subtype"], Literal["route_target_subtype"]]
        """
        self._set_property("choice", value)


class BgpExtendedCommunityTransitive2OctetAsTypeRouteTarget(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "global_2byte_as": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "local_4byte_admin": {
            "type": int,
            "format": "uint32",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "global_2byte_as": 100,
        "local_4byte_admin": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, global_2byte_as=100, local_4byte_admin=1):
        super(BgpExtendedCommunityTransitive2OctetAsTypeRouteTarget, self).__init__()
        self._parent = parent
        self._set_property("global_2byte_as", global_2byte_as)
        self._set_property("local_4byte_admin", local_4byte_admin)

    def set(self, global_2byte_as=None, local_4byte_admin=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def global_2byte_as(self):
        # type: () -> int
        """global_2byte_as getter

        The two octet IANA assigned AS value assigned to the Autonomous System.

        Returns: int
        """
        return self._get_property("global_2byte_as")

    @global_2byte_as.setter
    def global_2byte_as(self, value):
        """global_2byte_as setter

        The two octet IANA assigned AS value assigned to the Autonomous System.

        value: int
        """
        self._set_property("global_2byte_as", value)

    @property
    def local_4byte_admin(self):
        # type: () -> int
        """local_4byte_admin getter

        The Local Administrator sub-field contains number from numbering space that is administered by the organization to which the Autonomous System number carried in the Global Administrator sub-field has been assigned by an appropriate authority.

        Returns: int
        """
        return self._get_property("local_4byte_admin")

    @local_4byte_admin.setter
    def local_4byte_admin(self, value):
        """local_4byte_admin setter

        The Local Administrator sub-field contains number from numbering space that is administered by the organization to which the Autonomous System number carried in the Global Administrator sub-field has been assigned by an appropriate authority.

        value: int
        """
        self._set_property("local_4byte_admin", value)


class BgpExtendedCommunityTransitive2OctetAsTypeRouteOrigin(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "global_2byte_as": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "local_4byte_admin": {
            "type": int,
            "format": "uint32",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "global_2byte_as": 100,
        "local_4byte_admin": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, global_2byte_as=100, local_4byte_admin=1):
        super(BgpExtendedCommunityTransitive2OctetAsTypeRouteOrigin, self).__init__()
        self._parent = parent
        self._set_property("global_2byte_as", global_2byte_as)
        self._set_property("local_4byte_admin", local_4byte_admin)

    def set(self, global_2byte_as=None, local_4byte_admin=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def global_2byte_as(self):
        # type: () -> int
        """global_2byte_as getter

        The two octet IANA assigned AS value assigned to the Autonomous System.

        Returns: int
        """
        return self._get_property("global_2byte_as")

    @global_2byte_as.setter
    def global_2byte_as(self, value):
        """global_2byte_as setter

        The two octet IANA assigned AS value assigned to the Autonomous System.

        value: int
        """
        self._set_property("global_2byte_as", value)

    @property
    def local_4byte_admin(self):
        # type: () -> int
        """local_4byte_admin getter

        The Local Administrator sub-field contains number from numbering space that is administered by the organization to which the Autonomous System number carried in the Global Administrator sub-field has been assigned by an appropriate authority.

        Returns: int
        """
        return self._get_property("local_4byte_admin")

    @local_4byte_admin.setter
    def local_4byte_admin(self, value):
        """local_4byte_admin setter

        The Local Administrator sub-field contains number from numbering space that is administered by the organization to which the Autonomous System number carried in the Global Administrator sub-field has been assigned by an appropriate authority.

        value: int
        """
        self._set_property("local_4byte_admin", value)


class BgpExtendedCommunityTransitiveIpv4AddressType(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "route_target_subtype",
                "route_origin_subtype",
            ],
        },
        "route_target_subtype": {
            "type": "BgpExtendedCommunityTransitiveIpv4AddressTypeRouteTarget"
        },
        "route_origin_subtype": {
            "type": "BgpExtendedCommunityTransitiveIpv4AddressTypeRouteOrigin"
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "route_target_subtype",
    }  # type: Dict[str, Union(type)]

    ROUTE_TARGET_SUBTYPE = "route_target_subtype"  # type: str
    ROUTE_ORIGIN_SUBTYPE = "route_origin_subtype"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None):
        super(BgpExtendedCommunityTransitiveIpv4AddressType, self).__init__()
        self._parent = parent
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    @property
    def route_target_subtype(self):
        # type: () -> BgpExtendedCommunityTransitiveIpv4AddressTypeRouteTarget
        """Factory property that returns an instance of the BgpExtendedCommunityTransitiveIpv4AddressTypeRouteTarget class

        The Route Target Community identifies one or more routers that may receive set of routes (that carry this Community) carried by BGP. It is sent with sub-type as 0x02.

        Returns: BgpExtendedCommunityTransitiveIpv4AddressTypeRouteTarget
        """
        return self._get_property(
            "route_target_subtype",
            BgpExtendedCommunityTransitiveIpv4AddressTypeRouteTarget,
            self,
            "route_target_subtype",
        )

    @property
    def route_origin_subtype(self):
        # type: () -> BgpExtendedCommunityTransitiveIpv4AddressTypeRouteOrigin
        """Factory property that returns an instance of the BgpExtendedCommunityTransitiveIpv4AddressTypeRouteOrigin class

        The Route Origin Community identifies one or more routers that inject set of routes (that carry this Community) into BGP It is sent with sub-type as 0x03.

        Returns: BgpExtendedCommunityTransitiveIpv4AddressTypeRouteOrigin
        """
        return self._get_property(
            "route_origin_subtype",
            BgpExtendedCommunityTransitiveIpv4AddressTypeRouteOrigin,
            self,
            "route_origin_subtype",
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["route_origin_subtype"], Literal["route_target_subtype"]]
        """choice getter

        TBD

        Returns: Union[Literal["route_origin_subtype"], Literal["route_target_subtype"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["route_origin_subtype"], Literal["route_target_subtype"]]
        """
        self._set_property("choice", value)


class BgpExtendedCommunityTransitiveIpv4AddressTypeRouteTarget(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "global_ipv4_admin": {
            "type": str,
            "format": "ipv4",
        },
        "local_2byte_admin": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "global_ipv4_admin": "0.0.0.0",
        "local_2byte_admin": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, global_ipv4_admin="0.0.0.0", local_2byte_admin=1):
        super(BgpExtendedCommunityTransitiveIpv4AddressTypeRouteTarget, self).__init__()
        self._parent = parent
        self._set_property("global_ipv4_admin", global_ipv4_admin)
        self._set_property("local_2byte_admin", local_2byte_admin)

    def set(self, global_ipv4_admin=None, local_2byte_admin=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def global_ipv4_admin(self):
        # type: () -> str
        """global_ipv4_admin getter

        An IPv4 unicast address assigned by one of the Internet registries.

        Returns: str
        """
        return self._get_property("global_ipv4_admin")

    @global_ipv4_admin.setter
    def global_ipv4_admin(self, value):
        """global_ipv4_admin setter

        An IPv4 unicast address assigned by one of the Internet registries.

        value: str
        """
        self._set_property("global_ipv4_admin", value)

    @property
    def local_2byte_admin(self):
        # type: () -> int
        """local_2byte_admin getter

        The Local Administrator sub-field contains number from numbering space that is administered by the organization to which the IP address carried in the Global Administrator sub-field has been assigned by an appropriate authority.

        Returns: int
        """
        return self._get_property("local_2byte_admin")

    @local_2byte_admin.setter
    def local_2byte_admin(self, value):
        """local_2byte_admin setter

        The Local Administrator sub-field contains number from numbering space that is administered by the organization to which the IP address carried in the Global Administrator sub-field has been assigned by an appropriate authority.

        value: int
        """
        self._set_property("local_2byte_admin", value)


class BgpExtendedCommunityTransitiveIpv4AddressTypeRouteOrigin(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "global_ipv4_admin": {
            "type": str,
            "format": "ipv4",
        },
        "local_2byte_admin": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "global_ipv4_admin": "0.0.0.0",
        "local_2byte_admin": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, global_ipv4_admin="0.0.0.0", local_2byte_admin=1):
        super(BgpExtendedCommunityTransitiveIpv4AddressTypeRouteOrigin, self).__init__()
        self._parent = parent
        self._set_property("global_ipv4_admin", global_ipv4_admin)
        self._set_property("local_2byte_admin", local_2byte_admin)

    def set(self, global_ipv4_admin=None, local_2byte_admin=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def global_ipv4_admin(self):
        # type: () -> str
        """global_ipv4_admin getter

        An IPv4 unicast address assigned by one of the Internet registries.

        Returns: str
        """
        return self._get_property("global_ipv4_admin")

    @global_ipv4_admin.setter
    def global_ipv4_admin(self, value):
        """global_ipv4_admin setter

        An IPv4 unicast address assigned by one of the Internet registries.

        value: str
        """
        self._set_property("global_ipv4_admin", value)

    @property
    def local_2byte_admin(self):
        # type: () -> int
        """local_2byte_admin getter

        The Local Administrator sub-field contains number from numbering space that is administered by the organization to which the IP address carried in the Global Administrator sub-field has been assigned by an appropriate authority.

        Returns: int
        """
        return self._get_property("local_2byte_admin")

    @local_2byte_admin.setter
    def local_2byte_admin(self, value):
        """local_2byte_admin setter

        The Local Administrator sub-field contains number from numbering space that is administered by the organization to which the IP address carried in the Global Administrator sub-field has been assigned by an appropriate authority.

        value: int
        """
        self._set_property("local_2byte_admin", value)


class BgpExtendedCommunityTransitive4OctetAsType(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "route_target_subtype",
                "route_origin_subtype",
            ],
        },
        "route_target_subtype": {
            "type": "BgpExtendedCommunityTransitive4OctetAsTypeRouteTarget"
        },
        "route_origin_subtype": {
            "type": "BgpExtendedCommunityTransitive4OctetAsTypeRouteOrigin"
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "route_target_subtype",
    }  # type: Dict[str, Union(type)]

    ROUTE_TARGET_SUBTYPE = "route_target_subtype"  # type: str
    ROUTE_ORIGIN_SUBTYPE = "route_origin_subtype"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None):
        super(BgpExtendedCommunityTransitive4OctetAsType, self).__init__()
        self._parent = parent
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    @property
    def route_target_subtype(self):
        # type: () -> BgpExtendedCommunityTransitive4OctetAsTypeRouteTarget
        """Factory property that returns an instance of the BgpExtendedCommunityTransitive4OctetAsTypeRouteTarget class

        The Route Target Community identifies one or more routers that may receive set of routes (that carry this Community) carried by BGP. It is sent with sub-type as 0x02

        Returns: BgpExtendedCommunityTransitive4OctetAsTypeRouteTarget
        """
        return self._get_property(
            "route_target_subtype",
            BgpExtendedCommunityTransitive4OctetAsTypeRouteTarget,
            self,
            "route_target_subtype",
        )

    @property
    def route_origin_subtype(self):
        # type: () -> BgpExtendedCommunityTransitive4OctetAsTypeRouteOrigin
        """Factory property that returns an instance of the BgpExtendedCommunityTransitive4OctetAsTypeRouteOrigin class

        The Route Origin Community identifies one or more routers that inject set of routes (that carry this Community) into BGP. It is sent with sub-type as 0x03.

        Returns: BgpExtendedCommunityTransitive4OctetAsTypeRouteOrigin
        """
        return self._get_property(
            "route_origin_subtype",
            BgpExtendedCommunityTransitive4OctetAsTypeRouteOrigin,
            self,
            "route_origin_subtype",
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["route_origin_subtype"], Literal["route_target_subtype"]]
        """choice getter

        TBD

        Returns: Union[Literal["route_origin_subtype"], Literal["route_target_subtype"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["route_origin_subtype"], Literal["route_target_subtype"]]
        """
        self._set_property("choice", value)


class BgpExtendedCommunityTransitive4OctetAsTypeRouteTarget(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "global_4byte_as": {
            "type": int,
            "format": "uint32",
        },
        "local_2byte_admin": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "global_4byte_as": 100,
        "local_2byte_admin": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, global_4byte_as=100, local_2byte_admin=1):
        super(BgpExtendedCommunityTransitive4OctetAsTypeRouteTarget, self).__init__()
        self._parent = parent
        self._set_property("global_4byte_as", global_4byte_as)
        self._set_property("local_2byte_admin", local_2byte_admin)

    def set(self, global_4byte_as=None, local_2byte_admin=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def global_4byte_as(self):
        # type: () -> int
        """global_4byte_as getter

        The four octet IANA assigned AS value assigned to the Autonomous System.

        Returns: int
        """
        return self._get_property("global_4byte_as")

    @global_4byte_as.setter
    def global_4byte_as(self, value):
        """global_4byte_as setter

        The four octet IANA assigned AS value assigned to the Autonomous System.

        value: int
        """
        self._set_property("global_4byte_as", value)

    @property
    def local_2byte_admin(self):
        # type: () -> int
        """local_2byte_admin getter

        The Local Administrator sub-field contains number from numbering space that is administered by the organization to which the Autonomous System number carried in the Global Administrator sub-field has been assigned by an appropriate authority.

        Returns: int
        """
        return self._get_property("local_2byte_admin")

    @local_2byte_admin.setter
    def local_2byte_admin(self, value):
        """local_2byte_admin setter

        The Local Administrator sub-field contains number from numbering space that is administered by the organization to which the Autonomous System number carried in the Global Administrator sub-field has been assigned by an appropriate authority.

        value: int
        """
        self._set_property("local_2byte_admin", value)


class BgpExtendedCommunityTransitive4OctetAsTypeRouteOrigin(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "global_4byte_as": {
            "type": int,
            "format": "uint32",
        },
        "local_2byte_admin": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "global_4byte_as": 100,
        "local_2byte_admin": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, global_4byte_as=100, local_2byte_admin=1):
        super(BgpExtendedCommunityTransitive4OctetAsTypeRouteOrigin, self).__init__()
        self._parent = parent
        self._set_property("global_4byte_as", global_4byte_as)
        self._set_property("local_2byte_admin", local_2byte_admin)

    def set(self, global_4byte_as=None, local_2byte_admin=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def global_4byte_as(self):
        # type: () -> int
        """global_4byte_as getter

        The four octet IANA assigned AS value assigned to the Autonomous System.

        Returns: int
        """
        return self._get_property("global_4byte_as")

    @global_4byte_as.setter
    def global_4byte_as(self, value):
        """global_4byte_as setter

        The four octet IANA assigned AS value assigned to the Autonomous System.

        value: int
        """
        self._set_property("global_4byte_as", value)

    @property
    def local_2byte_admin(self):
        # type: () -> int
        """local_2byte_admin getter

        The Local Administrator sub-field contains number from numbering space that is administered by the organization to which the Autonomous System number carried in the Global Administrator sub-field has been assigned by an appropriate authority.

        Returns: int
        """
        return self._get_property("local_2byte_admin")

    @local_2byte_admin.setter
    def local_2byte_admin(self, value):
        """local_2byte_admin setter

        The Local Administrator sub-field contains number from numbering space that is administered by the organization to which the Autonomous System number carried in the Global Administrator sub-field has been assigned by an appropriate authority.

        value: int
        """
        self._set_property("local_2byte_admin", value)


class BgpExtendedCommunityTransitiveOpaqueType(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "color_subtype",
                "encapsulation_subtype",
            ],
        },
        "color_subtype": {"type": "BgpExtendedCommunityTransitiveOpaqueTypeColor"},
        "encapsulation_subtype": {
            "type": "BgpExtendedCommunityTransitiveOpaqueTypeEncapsulation"
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "color_subtype",
    }  # type: Dict[str, Union(type)]

    COLOR_SUBTYPE = "color_subtype"  # type: str
    ENCAPSULATION_SUBTYPE = "encapsulation_subtype"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None):
        super(BgpExtendedCommunityTransitiveOpaqueType, self).__init__()
        self._parent = parent
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    @property
    def color_subtype(self):
        # type: () -> BgpExtendedCommunityTransitiveOpaqueTypeColor
        """Factory property that returns an instance of the BgpExtendedCommunityTransitiveOpaqueTypeColor class

        The Color Community contains locally administrator defined 'color' value which is used in conjunction with Encapsulation attribute to decide whether data packet can be transmitted on certain tunnel or not. It is defined in RFC9012 and sent with sub-type as 0x0b.

        Returns: BgpExtendedCommunityTransitiveOpaqueTypeColor
        """
        return self._get_property(
            "color_subtype",
            BgpExtendedCommunityTransitiveOpaqueTypeColor,
            self,
            "color_subtype",
        )

    @property
    def encapsulation_subtype(self):
        # type: () -> BgpExtendedCommunityTransitiveOpaqueTypeEncapsulation
        """Factory property that returns an instance of the BgpExtendedCommunityTransitiveOpaqueTypeEncapsulation class

        This identifies the type of tunneling technology being signalled. It is defined in RFC9012 and sent with sub-type as 0x0c.

        Returns: BgpExtendedCommunityTransitiveOpaqueTypeEncapsulation
        """
        return self._get_property(
            "encapsulation_subtype",
            BgpExtendedCommunityTransitiveOpaqueTypeEncapsulation,
            self,
            "encapsulation_subtype",
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["color_subtype"], Literal["encapsulation_subtype"]]
        """choice getter

        TBD

        Returns: Union[Literal["color_subtype"], Literal["encapsulation_subtype"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["color_subtype"], Literal["encapsulation_subtype"]]
        """
        self._set_property("choice", value)


class BgpExtendedCommunityTransitiveOpaqueTypeColor(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "flags": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "color": {
            "type": int,
            "format": "uint32",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "flags": 0,
        "color": 0,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, flags=0, color=0):
        super(BgpExtendedCommunityTransitiveOpaqueTypeColor, self).__init__()
        self._parent = parent
        self._set_property("flags", flags)
        self._set_property("color", color)

    def set(self, flags=None, color=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def flags(self):
        # type: () -> int
        """flags getter

        Two octet flag values.

        Returns: int
        """
        return self._get_property("flags")

    @flags.setter
    def flags(self, value):
        """flags setter

        Two octet flag values.

        value: int
        """
        self._set_property("flags", value)

    @property
    def color(self):
        # type: () -> int
        """color getter

        The color value is user defined and configured locally and used to determine whether data packet can be transmitted on certain tunnel or not in conjunction with the Encapsulation attribute. It is defined in RFC9012.

        Returns: int
        """
        return self._get_property("color")

    @color.setter
    def color(self, value):
        """color setter

        The color value is user defined and configured locally and used to determine whether data packet can be transmitted on certain tunnel or not in conjunction with the Encapsulation attribute. It is defined in RFC9012.

        value: int
        """
        self._set_property("color", value)


class BgpExtendedCommunityTransitiveOpaqueTypeEncapsulation(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "reserved": {
            "type": int,
            "format": "uint32",
        },
        "tunnel_type": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "reserved": 0,
        "tunnel_type": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, reserved=0, tunnel_type=1):
        super(BgpExtendedCommunityTransitiveOpaqueTypeEncapsulation, self).__init__()
        self._parent = parent
        self._set_property("reserved", reserved)
        self._set_property("tunnel_type", tunnel_type)

    def set(self, reserved=None, tunnel_type=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def reserved(self):
        # type: () -> int
        """reserved getter

        Four bytes of reserved values. Normally set to on transmit and ignored on receive.

        Returns: int
        """
        return self._get_property("reserved")

    @reserved.setter
    def reserved(self, value):
        """reserved setter

        Four bytes of reserved values. Normally set to on transmit and ignored on receive.

        value: int
        """
        self._set_property("reserved", value)

    @property
    def tunnel_type(self):
        # type: () -> int
        """tunnel_type getter

        Identifies the type of tunneling technology being signalled. Initially defined in RFC5512 and extended in RFC9012. Some of the important tunnel types include L2TPv3 over IP [RFC9012], 2 GRE [RFC9012]. IP in IP [RFC9012]. VXLAN Encapsulation [RFC8365]. NVGRE Encapsulation [RFC8365]. 10 MPLS Encapsulation [RFC8365]. 15 SR TE Policy Type [draft-ietf-idr-segment-routing-te-policy]. 19 Geneve Encapsulation [RFC8926]

        Returns: int
        """
        return self._get_property("tunnel_type")

    @tunnel_type.setter
    def tunnel_type(self, value):
        """tunnel_type setter

        Identifies the type of tunneling technology being signalled. Initially defined in RFC5512 and extended in RFC9012. Some of the important tunnel types include L2TPv3 over IP [RFC9012], 2 GRE [RFC9012]. IP in IP [RFC9012]. VXLAN Encapsulation [RFC8365]. NVGRE Encapsulation [RFC8365]. 10 MPLS Encapsulation [RFC8365]. 15 SR TE Policy Type [draft-ietf-idr-segment-routing-te-policy]. 19 Geneve Encapsulation [RFC8926]

        value: int
        """
        self._set_property("tunnel_type", value)


class BgpExtendedCommunityTransitiveEvpnType(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "router_mac_subtype",
            ],
        },
        "router_mac_subtype": {
            "type": "BgpExtendedCommunityTransitiveEvpnTypeRouterMac"
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "router_mac_subtype",
    }  # type: Dict[str, Union(type)]

    ROUTER_MAC_SUBTYPE = "router_mac_subtype"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None):
        super(BgpExtendedCommunityTransitiveEvpnType, self).__init__()
        self._parent = parent
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    @property
    def router_mac_subtype(self):
        # type: () -> BgpExtendedCommunityTransitiveEvpnTypeRouterMac
        """Factory property that returns an instance of the BgpExtendedCommunityTransitiveEvpnTypeRouterMac class

        The Router MAC EVPN Community is defined in RFC9135 and normally sent only for EVPN Type-2 Routes It is sent with sub-type 0x03.

        Returns: BgpExtendedCommunityTransitiveEvpnTypeRouterMac
        """
        return self._get_property(
            "router_mac_subtype",
            BgpExtendedCommunityTransitiveEvpnTypeRouterMac,
            self,
            "router_mac_subtype",
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["router_mac_subtype"]]
        """choice getter

        TBD

        Returns: Union[Literal["router_mac_subtype"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["router_mac_subtype"]]
        """
        self._set_property("choice", value)


class BgpExtendedCommunityTransitiveEvpnTypeRouterMac(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "router_mac": {
            "type": str,
            "format": "mac",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "router_mac": "0:0:0:0:0:0",
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, router_mac="0:0:0:0:0:0"):
        super(BgpExtendedCommunityTransitiveEvpnTypeRouterMac, self).__init__()
        self._parent = parent
        self._set_property("router_mac", router_mac)

    def set(self, router_mac=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def router_mac(self):
        # type: () -> str
        """router_mac getter

        MAC Address of the PE Router.

        Returns: str
        """
        return self._get_property("router_mac")

    @router_mac.setter
    def router_mac(self, value):
        """router_mac setter

        MAC Address of the PE Router.

        value: str
        """
        self._set_property("router_mac", value)


class BgpExtendedCommunityNonTransitive2OctetAsType(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "link_bandwidth_subtype",
            ],
        },
        "link_bandwidth_subtype": {
            "type": "BgpExtendedCommunityNonTransitive2OctetAsTypeLinkBandwidth"
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "link_bandwidth_subtype",
    }  # type: Dict[str, Union(type)]

    LINK_BANDWIDTH_SUBTYPE = "link_bandwidth_subtype"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None):
        super(BgpExtendedCommunityNonTransitive2OctetAsType, self).__init__()
        self._parent = parent
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    @property
    def link_bandwidth_subtype(self):
        # type: () -> BgpExtendedCommunityNonTransitive2OctetAsTypeLinkBandwidth
        """Factory property that returns an instance of the BgpExtendedCommunityNonTransitive2OctetAsTypeLinkBandwidth class

        The Link Bandwidth Extended Community attribute is defined in draft-ietf-idr-link-bandwidth. It is sent with sub-type as 0x04.

        Returns: BgpExtendedCommunityNonTransitive2OctetAsTypeLinkBandwidth
        """
        return self._get_property(
            "link_bandwidth_subtype",
            BgpExtendedCommunityNonTransitive2OctetAsTypeLinkBandwidth,
            self,
            "link_bandwidth_subtype",
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["link_bandwidth_subtype"]]
        """choice getter

        TBD

        Returns: Union[Literal["link_bandwidth_subtype"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["link_bandwidth_subtype"]]
        """
        self._set_property("choice", value)


class BgpExtendedCommunityNonTransitive2OctetAsTypeLinkBandwidth(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "global_2byte_as": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "bandwidth": {
            "type": float,
            "format": "float",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "global_2byte_as": 100,
        "bandwidth": 0.0,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, global_2byte_as=100, bandwidth=0):
        super(
            BgpExtendedCommunityNonTransitive2OctetAsTypeLinkBandwidth, self
        ).__init__()
        self._parent = parent
        self._set_property("global_2byte_as", global_2byte_as)
        self._set_property("bandwidth", bandwidth)

    def set(self, global_2byte_as=None, bandwidth=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def global_2byte_as(self):
        # type: () -> int
        """global_2byte_as getter

        The value of the Global Administrator subfield should represent the Autonomous System of the router that attaches the Link Bandwidth Community. If four octet AS numbering scheme is used, AS_TRANS (23456) should be used.

        Returns: int
        """
        return self._get_property("global_2byte_as")

    @global_2byte_as.setter
    def global_2byte_as(self, value):
        """global_2byte_as setter

        The value of the Global Administrator subfield should represent the Autonomous System of the router that attaches the Link Bandwidth Community. If four octet AS numbering scheme is used, AS_TRANS (23456) should be used.

        value: int
        """
        self._set_property("global_2byte_as", value)

    @property
    def bandwidth(self):
        # type: () -> float
        """bandwidth getter

        Bandwidth of the link in bytes per second. 1 Kbps is 1000 bytes per second and Mbps is 1000 Kbps per second )

        Returns: float
        """
        return self._get_property("bandwidth")

    @bandwidth.setter
    def bandwidth(self, value):
        """bandwidth setter

        Bandwidth of the link in bytes per second. 1 Kbps is 1000 bytes per second and Mbps is 1000 Kbps per second )

        value: float
        """
        self._set_property("bandwidth", value)


class BgpExtendedCommunityCustomType(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "community_type": {
            "type": str,
            "format": "hex",
            "maxLength": 2,
        },
        "community_subtype": {
            "type": str,
            "format": "hex",
            "maxLength": 2,
        },
        "value": {
            "type": str,
            "format": "hex",
            "maxLength": 12,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "community_type": "00",
        "community_subtype": "00",
        "value": "000000000000",
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        community_type="00",
        community_subtype="00",
        value="000000000000",
    ):
        super(BgpExtendedCommunityCustomType, self).__init__()
        self._parent = parent
        self._set_property("community_type", community_type)
        self._set_property("community_subtype", community_subtype)
        self._set_property("value", value)

    def set(self, community_type=None, community_subtype=None, value=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def community_type(self):
        # type: () -> str
        """community_type getter

        The type to be set in the Extended Community attribute. Accepts hexadecimal input upto ff

        Returns: str
        """
        return self._get_property("community_type")

    @community_type.setter
    def community_type(self, value):
        """community_type setter

        The type to be set in the Extended Community attribute. Accepts hexadecimal input upto ff

        value: str
        """
        self._set_property("community_type", value)

    @property
    def community_subtype(self):
        # type: () -> str
        """community_subtype getter

        The sub-type to be set in the Extended Community attribute. For certain types with no sub-type this byte can also be used as part of an extended value field. Accepts hexadecimal input upto ff.

        Returns: str
        """
        return self._get_property("community_subtype")

    @community_subtype.setter
    def community_subtype(self, value):
        """community_subtype setter

        The sub-type to be set in the Extended Community attribute. For certain types with no sub-type this byte can also be used as part of an extended value field. Accepts hexadecimal input upto ff.

        value: str
        """
        self._set_property("community_subtype", value)

    @property
    def value(self):
        # type: () -> str
        """value getter

        6 byte hex value to be carried in the last bytes of the Extended Community. Accepts hexadecimal input upto ffffffffffff.

        Returns: str
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        6 byte hex value to be carried in the last bytes of the Extended Community. Accepts hexadecimal input upto ffffffffffff.

        value: str
        """
        self._set_property("value", value)


class BgpExtendedCommunityIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = True

    def __init__(self, parent=None, choice=None):
        super(BgpExtendedCommunityIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[BgpExtendedCommunity, BgpExtendedCommunityCustomType, BgpExtendedCommunityNonTransitive2OctetAsType, BgpExtendedCommunityTransitive2OctetAsType, BgpExtendedCommunityTransitive4OctetAsType, BgpExtendedCommunityTransitiveEvpnType, BgpExtendedCommunityTransitiveIpv4AddressType, BgpExtendedCommunityTransitiveOpaqueType]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> BgpExtendedCommunityIter
        return self._iter()

    def __next__(self):
        # type: () -> BgpExtendedCommunity
        return self._next()

    def next(self):
        # type: () -> BgpExtendedCommunity
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, BgpExtendedCommunity):
            raise Exception("Item is not an instance of BgpExtendedCommunity")

    def extendedcommunity(self):
        # type: () -> BgpExtendedCommunityIter
        """Factory method that creates an instance of the BgpExtendedCommunity class

        The Extended Communities Attribute is optional BGP attribute,defined in RFC4360 with the Type Code 16. Community and Extended Communities attributes are utilized to trigger routing decisions, such as acceptance, rejection, preference, or redistribution. An extended community is an 8-Bytes value.It is divided into two main parts. The first Bytes of the community encode type and optonal sub-type field. The last bytes (or bytes for types without sub-type) carry unique set of data in format defined by the type and optional sub-type field. Extended communities provide larger range for grouping or categorizing communities.

        Returns: BgpExtendedCommunityIter
        """
        item = BgpExtendedCommunity(parent=self._parent, choice=self._choice)
        self._add(item)
        return self

    def add(self):
        # type: () -> BgpExtendedCommunity
        """Add method that creates and returns an instance of the BgpExtendedCommunity class

        The Extended Communities Attribute is optional BGP attribute,defined in RFC4360 with the Type Code 16. Community and Extended Communities attributes are utilized to trigger routing decisions, such as acceptance, rejection, preference, or redistribution. An extended community is an 8-Bytes value.It is divided into two main parts. The first Bytes of the community encode type and optonal sub-type field. The last bytes (or bytes for types without sub-type) carry unique set of data in format defined by the type and optional sub-type field. Extended communities provide larger range for grouping or categorizing communities.

        Returns: BgpExtendedCommunity
        """
        item = BgpExtendedCommunity(parent=self._parent, choice=self._choice)
        self._add(item)
        return item

    def transitive_2octet_as_type(self):
        # type: () -> BgpExtendedCommunityIter
        """Factory method that creates an instance of the BgpExtendedCommunityTransitive2OctetAsType class

        The Transitive Two-Octet AS-Specific Extended Community is sent as type 0x00

        Returns: BgpExtendedCommunityIter
        """
        item = BgpExtendedCommunity()
        item.transitive_2octet_as_type
        item.choice = "transitive_2octet_as_type"
        self._add(item)
        return self

    def transitive_ipv4_address_type(self):
        # type: () -> BgpExtendedCommunityIter
        """Factory method that creates an instance of the BgpExtendedCommunityTransitiveIpv4AddressType class

        The Transitive IPv4 Address Specific Extended Community is sent as type 0x01.

        Returns: BgpExtendedCommunityIter
        """
        item = BgpExtendedCommunity()
        item.transitive_ipv4_address_type
        item.choice = "transitive_ipv4_address_type"
        self._add(item)
        return self

    def transitive_4octet_as_type(self):
        # type: () -> BgpExtendedCommunityIter
        """Factory method that creates an instance of the BgpExtendedCommunityTransitive4OctetAsType class

        The Transitive Four-Octet AS-Specific Extended Community is sent as type 0x02. It is defined in RFC 5668.

        Returns: BgpExtendedCommunityIter
        """
        item = BgpExtendedCommunity()
        item.transitive_4octet_as_type
        item.choice = "transitive_4octet_as_type"
        self._add(item)
        return self

    def transitive_opaque_type(self):
        # type: () -> BgpExtendedCommunityIter
        """Factory method that creates an instance of the BgpExtendedCommunityTransitiveOpaqueType class

        The Transitive Opaque Extended Community is sent as type 0x03.

        Returns: BgpExtendedCommunityIter
        """
        item = BgpExtendedCommunity()
        item.transitive_opaque_type
        item.choice = "transitive_opaque_type"
        self._add(item)
        return self

    def transitive_evpn_type(self):
        # type: () -> BgpExtendedCommunityIter
        """Factory method that creates an instance of the BgpExtendedCommunityTransitiveEvpnType class

        The Transitive EVPN Extended Community is sent as type 0x06

        Returns: BgpExtendedCommunityIter
        """
        item = BgpExtendedCommunity()
        item.transitive_evpn_type
        item.choice = "transitive_evpn_type"
        self._add(item)
        return self

    def non_transitive_2octet_as_type(self):
        # type: () -> BgpExtendedCommunityIter
        """Factory method that creates an instance of the BgpExtendedCommunityNonTransitive2OctetAsType class

        The Non-Transitive Two-Octet AS-Specific Extended Community is sent as type 0x40.

        Returns: BgpExtendedCommunityIter
        """
        item = BgpExtendedCommunity()
        item.non_transitive_2octet_as_type
        item.choice = "non_transitive_2octet_as_type"
        self._add(item)
        return self

    def custom(self, community_type="00", community_subtype="00", value="000000000000"):
        # type: (str,str,str) -> BgpExtendedCommunityIter
        """Factory method that creates an instance of the BgpExtendedCommunityCustomType class

        Add custom Extended Community with combination of types sub-types and values not explicitly specified above or not defined yet.

        Returns: BgpExtendedCommunityIter
        """
        item = BgpExtendedCommunity()
        item.custom
        item.choice = "custom"
        self._add(item)
        return self


class BgpV4RouteRangeIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(BgpV4RouteRangeIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[BgpV4RouteRange]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> BgpV4RouteRangeIter
        return self._iter()

    def __next__(self):
        # type: () -> BgpV4RouteRange
        return self._next()

    def next(self):
        # type: () -> BgpV4RouteRange
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, BgpV4RouteRange):
            raise Exception("Item is not an instance of BgpV4RouteRange")

    def v4routerange(
        self,
        next_hop_mode="local_ip",
        next_hop_address_type="ipv4",
        next_hop_ipv4_address="0.0.0.0",
        next_hop_ipv6_address="::0",
        name=None,
    ):
        # type: (Union[Literal["local_ip"], Literal["manual"]],Union[Literal["ipv4"], Literal["ipv6"]],str,str,str) -> BgpV4RouteRangeIter
        """Factory method that creates an instance of the BgpV4RouteRange class

        Emulated BGPv4 route range.

        Returns: BgpV4RouteRangeIter
        """
        item = BgpV4RouteRange(
            parent=self._parent,
            next_hop_mode=next_hop_mode,
            next_hop_address_type=next_hop_address_type,
            next_hop_ipv4_address=next_hop_ipv4_address,
            next_hop_ipv6_address=next_hop_ipv6_address,
            name=name,
        )
        self._add(item)
        return self

    def add(
        self,
        next_hop_mode="local_ip",
        next_hop_address_type="ipv4",
        next_hop_ipv4_address="0.0.0.0",
        next_hop_ipv6_address="::0",
        name=None,
    ):
        # type: (Union[Literal["local_ip"], Literal["manual"]],Union[Literal["ipv4"], Literal["ipv6"]],str,str,str) -> BgpV4RouteRange
        """Add method that creates and returns an instance of the BgpV4RouteRange class

        Emulated BGPv4 route range.

        Returns: BgpV4RouteRange
        """
        item = BgpV4RouteRange(
            parent=self._parent,
            next_hop_mode=next_hop_mode,
            next_hop_address_type=next_hop_address_type,
            next_hop_ipv4_address=next_hop_ipv4_address,
            next_hop_ipv6_address=next_hop_ipv6_address,
            name=name,
        )
        self._add(item)
        return item


class BgpV6RouteRange(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "addresses": {"type": "V6RouteAddressIter"},
        "next_hop_mode": {
            "type": str,
            "enum": [
                "local_ip",
                "manual",
            ],
        },
        "next_hop_address_type": {
            "type": str,
            "enum": [
                "ipv4",
                "ipv6",
            ],
        },
        "next_hop_ipv4_address": {
            "type": str,
            "format": "ipv4",
        },
        "next_hop_ipv6_address": {
            "type": str,
            "format": "ipv6",
        },
        "advanced": {"type": "BgpRouteAdvanced"},
        "communities": {"type": "BgpCommunityIter"},
        "as_path": {"type": "BgpAsPath"},
        "add_path": {"type": "BgpAddPath"},
        "name": {"type": str},
        "ext_communities": {"type": "BgpExtCommunityIter"},
        "extended_communities": {"type": "BgpExtendedCommunityIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "next_hop_mode": "local_ip",
        "next_hop_address_type": "ipv6",
        "next_hop_ipv4_address": "0.0.0.0",
        "next_hop_ipv6_address": "::0",
    }  # type: Dict[str, Union(type)]

    LOCAL_IP = "local_ip"  # type: str
    MANUAL = "manual"  # type: str

    IPV4 = "ipv4"  # type: str
    IPV6 = "ipv6"  # type: str

    _STATUS = {
        "ext_communities": "ext_communities property in schema BgpV6RouteRange is deprecated, This property is deprecated in favor of property extended_communities",
    }  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        next_hop_mode="local_ip",
        next_hop_address_type="ipv6",
        next_hop_ipv4_address="0.0.0.0",
        next_hop_ipv6_address="::0",
        name=None,
    ):
        super(BgpV6RouteRange, self).__init__()
        self._parent = parent
        self._set_property("next_hop_mode", next_hop_mode)
        self._set_property("next_hop_address_type", next_hop_address_type)
        self._set_property("next_hop_ipv4_address", next_hop_ipv4_address)
        self._set_property("next_hop_ipv6_address", next_hop_ipv6_address)
        self._set_property("name", name)

    def set(
        self,
        next_hop_mode=None,
        next_hop_address_type=None,
        next_hop_ipv4_address=None,
        next_hop_ipv6_address=None,
        name=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def addresses(self):
        # type: () -> V6RouteAddressIter
        """addresses getter

        A list of group of IPv6 route addresses.

        Returns: V6RouteAddressIter
        """
        return self._get_property(
            "addresses", V6RouteAddressIter, self._parent, self._choice
        )

    @property
    def next_hop_mode(self):
        # type: () -> Union[Literal["local_ip"], Literal["manual"]]
        """next_hop_mode getter

        Specify the NextHop in MP REACH NLRI. The mode for setting the IP address of the NextHop in the MP REACH NLRI can be one of the following:. Local IP: Automatically fills the Nexthop with the Local IP of the BGP. peer.. If BGP peer is of type IPv6, Nexthop Encoding capability should be enabled.. Manual: Override the Nexthop with any arbitrary IPv4/IPv6 address.

        Returns: Union[Literal["local_ip"], Literal["manual"]]
        """
        return self._get_property("next_hop_mode")

    @next_hop_mode.setter
    def next_hop_mode(self, value):
        """next_hop_mode setter

        Specify the NextHop in MP REACH NLRI. The mode for setting the IP address of the NextHop in the MP REACH NLRI can be one of the following:. Local IP: Automatically fills the Nexthop with the Local IP of the BGP. peer.. If BGP peer is of type IPv6, Nexthop Encoding capability should be enabled.. Manual: Override the Nexthop with any arbitrary IPv4/IPv6 address.

        value: Union[Literal["local_ip"], Literal["manual"]]
        """
        self._set_property("next_hop_mode", value)

    @property
    def next_hop_address_type(self):
        # type: () -> Union[Literal["ipv4"], Literal["ipv6"]]
        """next_hop_address_type getter

        If the Nexthop Mode is Manual, it sets the type of the NextHop IP address.

        Returns: Union[Literal["ipv4"], Literal["ipv6"]]
        """
        return self._get_property("next_hop_address_type")

    @next_hop_address_type.setter
    def next_hop_address_type(self, value):
        """next_hop_address_type setter

        If the Nexthop Mode is Manual, it sets the type of the NextHop IP address.

        value: Union[Literal["ipv4"], Literal["ipv6"]]
        """
        self._set_property("next_hop_address_type", value)

    @property
    def next_hop_ipv4_address(self):
        # type: () -> str
        """next_hop_ipv4_address getter

        The IPv4 address of the next hop if the Nexthop Mode is manual and the Nexthop type is IPv4. If BGP peer is of type IPv6, Nexthop Encoding capability should be enabled.

        Returns: str
        """
        return self._get_property("next_hop_ipv4_address")

    @next_hop_ipv4_address.setter
    def next_hop_ipv4_address(self, value):
        """next_hop_ipv4_address setter

        The IPv4 address of the next hop if the Nexthop Mode is manual and the Nexthop type is IPv4. If BGP peer is of type IPv6, Nexthop Encoding capability should be enabled.

        value: str
        """
        self._set_property("next_hop_ipv4_address", value)

    @property
    def next_hop_ipv6_address(self):
        # type: () -> str
        """next_hop_ipv6_address getter

        The IPv6 address of the next hop if the Nexthop Mode is manual and the Nexthop type is IPv6.

        Returns: str
        """
        return self._get_property("next_hop_ipv6_address")

    @next_hop_ipv6_address.setter
    def next_hop_ipv6_address(self, value):
        """next_hop_ipv6_address setter

        The IPv6 address of the next hop if the Nexthop Mode is manual and the Nexthop type is IPv6.

        value: str
        """
        self._set_property("next_hop_ipv6_address", value)

    @property
    def advanced(self):
        # type: () -> BgpRouteAdvanced
        """advanced getter

        Configuration for advanced BGP route range settings.Configuration for advanced BGP route range settings.Configuration for advanced BGP route range settings.

        Returns: BgpRouteAdvanced
        """
        return self._get_property("advanced", BgpRouteAdvanced)

    @property
    def communities(self):
        # type: () -> BgpCommunityIter
        """communities getter

        Optional community settings.

        Returns: BgpCommunityIter
        """
        return self._get_property(
            "communities", BgpCommunityIter, self._parent, self._choice
        )

    @property
    def as_path(self):
        # type: () -> BgpAsPath
        """as_path getter

        This attribute identifies the autonomous systems through which routing information carried in this UPDATE message has passed. This contains the configuration of how to include the Local AS in the AS path attribute of the MP REACH NLRI. It also contains optional configuration of additional AS Path Segments that can be included in the AS Path attribute. The AS Path consists of Set or Sequence of Autonomous Systems (AS) numbers that routing information passes through to reach the destination.This attribute identifies the autonomous systems through which routing information carried in this UPDATE message has passed. This contains the configuration of how to include the Local AS in the AS path attribute of the MP REACH NLRI. It also contains optional configuration of additional AS Path Segments that can be included in the AS Path attribute. The AS Path consists of Set or Sequence of Autonomous Systems (AS) numbers that routing information passes through to reach the destination.This attribute identifies the autonomous systems through which routing information carried in this UPDATE message has passed. This contains the configuration of how to include the Local AS in the AS path attribute of the MP REACH NLRI. It also contains optional configuration of additional AS Path Segments that can be included in the AS Path attribute. The AS Path consists of Set or Sequence of Autonomous Systems (AS) numbers that routing information passes through to reach the destination.

        Returns: BgpAsPath
        """
        return self._get_property("as_path", BgpAsPath)

    @property
    def add_path(self):
        # type: () -> BgpAddPath
        """add_path getter

        The BGP Additional Paths feature is BGP extension that allows the advertisement of multiple paths for the same prefix without the new paths implicitly replacing any previous paths.The BGP Additional Paths feature is BGP extension that allows the advertisement of multiple paths for the same prefix without the new paths implicitly replacing any previous paths.The BGP Additional Paths feature is BGP extension that allows the advertisement of multiple paths for the same prefix without the new paths implicitly replacing any previous paths.

        Returns: BgpAddPath
        """
        return self._get_property("add_path", BgpAddPath)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def ext_communities(self):
        # type: () -> BgpExtCommunityIter
        """ext_communities getter

        Deprecated: This property is deprecated in favor of property extended_communities. Deprecated: This property is deprecated in favor of property extended_communities. Optional Extended Community settings. The Extended Communities Attribute is transitive optional BGP attribute, with the Type Code 16. Community and Extended Communities attributes are utilized to trigger routing decisions, such as acceptance, rejection, preference, or redistribution. An extended community is an 8-Bytes value. It is divided into two main parts. The first Bytes of the community encode type and sub-type fields and the last Bytes carry unique set of data in format defined by the type and sub-type field. Extended communities provide larger range for grouping or categorizing communities. When type is administrator_as_2octet or administrator_as_4octet, the valid sub types are route target and origin. The valid value for administrator_as_2octet and administrator_as_4octet type is either two byte AS followed by four byte local administrator id or four byte AS followed by two byte local administrator id. When type is administrator_ipv4_address the valid sub types are route target and origin. The valid value for administrator_ipv4_address is four byte IPv4 address followed by two byte local administrator id. When type is opaque, valid sub types are color and encapsulation. When sub type is color, first two bytes of the value field contain flags and last four bytes contains the value of the color. When sub type is encapsulation the first four bytes of value field are reserved and last two bytes carries the tunnel type from IANA's "ETHER TYPES" registry e.g IPv4 (protocol type 0x0800), IPv6 (protocol type 0x86dd), and MPLS (protocol type 0x8847). When type is administrator_as_2octet_link_bandwidth the valid sub type is extended_bandwidth. The first two bytes of the value field contains the AS number and the last four bytes contains the bandwidth in IEEE floating point format. When type is evpn the valid subtype is mac_address. In the value field the low-order bit of the first byte(Flags) is defined as the "Sticky/static" flag and may be set to 1, indicating the MAC address is static and cannot move. The second byte is reserved and the last four bytes contain the sequence number which is used to ensure that PEs retain the correct MAC/IP Advertisement route when multiple updates occur for the same MAC address. Note evpn type is defined mainly for use with evpn route updates and not for IPv4 and IPv6 route updates.

        Returns: BgpExtCommunityIter
        """
        return self._get_property(
            "ext_communities", BgpExtCommunityIter, self._parent, self._choice
        )

    @property
    def extended_communities(self):
        # type: () -> BgpExtendedCommunityIter
        """extended_communities getter

        Optional Extended Community settings. The Extended Communities Attribute is transitive optional BGP attribute, with the Type Code 16. Community and Extended Communities attributes are utilized to trigger routing decisions, such as acceptance, rejection, preference, or redistribution. An extended community is an eight byte value. It is divided into two main parts. The first two bytes of the community encode type and sub-type fields and the last six bytes carry unique set of data in format defined by the type and sub-type field. Extended communities provide larger range for grouping or categorizing communities.

        Returns: BgpExtendedCommunityIter
        """
        return self._get_property(
            "extended_communities", BgpExtendedCommunityIter, self._parent, self._choice
        )


class BgpV6RouteRangeIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(BgpV6RouteRangeIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[BgpV6RouteRange]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> BgpV6RouteRangeIter
        return self._iter()

    def __next__(self):
        # type: () -> BgpV6RouteRange
        return self._next()

    def next(self):
        # type: () -> BgpV6RouteRange
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, BgpV6RouteRange):
            raise Exception("Item is not an instance of BgpV6RouteRange")

    def v6routerange(
        self,
        next_hop_mode="local_ip",
        next_hop_address_type="ipv6",
        next_hop_ipv4_address="0.0.0.0",
        next_hop_ipv6_address="::0",
        name=None,
    ):
        # type: (Union[Literal["local_ip"], Literal["manual"]],Union[Literal["ipv4"], Literal["ipv6"]],str,str,str) -> BgpV6RouteRangeIter
        """Factory method that creates an instance of the BgpV6RouteRange class

        Emulated BGPv6 route range.

        Returns: BgpV6RouteRangeIter
        """
        item = BgpV6RouteRange(
            parent=self._parent,
            next_hop_mode=next_hop_mode,
            next_hop_address_type=next_hop_address_type,
            next_hop_ipv4_address=next_hop_ipv4_address,
            next_hop_ipv6_address=next_hop_ipv6_address,
            name=name,
        )
        self._add(item)
        return self

    def add(
        self,
        next_hop_mode="local_ip",
        next_hop_address_type="ipv6",
        next_hop_ipv4_address="0.0.0.0",
        next_hop_ipv6_address="::0",
        name=None,
    ):
        # type: (Union[Literal["local_ip"], Literal["manual"]],Union[Literal["ipv4"], Literal["ipv6"]],str,str,str) -> BgpV6RouteRange
        """Add method that creates and returns an instance of the BgpV6RouteRange class

        Emulated BGPv6 route range.

        Returns: BgpV6RouteRange
        """
        item = BgpV6RouteRange(
            parent=self._parent,
            next_hop_mode=next_hop_mode,
            next_hop_address_type=next_hop_address_type,
            next_hop_ipv4_address=next_hop_ipv4_address,
            next_hop_ipv6_address=next_hop_ipv6_address,
            name=name,
        )
        self._add(item)
        return item


class BgpSrteV4Policy(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "distinguisher": {
            "type": int,
            "format": "uint32",
        },
        "color": {
            "type": int,
            "format": "uint32",
        },
        "ipv4_endpoint": {
            "type": str,
            "format": "ipv4",
        },
        "next_hop_mode": {
            "type": str,
            "enum": [
                "local_ip",
                "manual",
            ],
        },
        "next_hop_address_type": {
            "type": str,
            "enum": [
                "ipv4",
                "ipv6",
            ],
        },
        "next_hop_ipv4_address": {
            "type": str,
            "format": "ipv4",
        },
        "next_hop_ipv6_address": {
            "type": str,
            "format": "ipv6",
        },
        "advanced": {"type": "BgpRouteAdvanced"},
        "add_path": {"type": "BgpAddPath"},
        "as_path": {"type": "BgpAsPath"},
        "communities": {"type": "BgpCommunityIter"},
        "ext_communities": {"type": "BgpExtCommunityIter"},
        "tunnel_tlvs": {"type": "BgpSrteV4TunnelTlvIter"},
        "name": {"type": str},
        "active": {"type": bool},
    }  # type: Dict[str, str]

    _REQUIRED = ("ipv4_endpoint", "name")  # type: tuple(str)

    _DEFAULTS = {
        "distinguisher": 1,
        "color": 100,
        "next_hop_mode": "local_ip",
        "next_hop_address_type": "ipv4",
        "active": True,
    }  # type: Dict[str, Union(type)]

    LOCAL_IP = "local_ip"  # type: str
    MANUAL = "manual"  # type: str

    IPV4 = "ipv4"  # type: str
    IPV6 = "ipv6"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        distinguisher=1,
        color=100,
        ipv4_endpoint=None,
        next_hop_mode="local_ip",
        next_hop_address_type="ipv4",
        next_hop_ipv4_address=None,
        next_hop_ipv6_address=None,
        name=None,
        active=True,
    ):
        super(BgpSrteV4Policy, self).__init__()
        self._parent = parent
        self._set_property("distinguisher", distinguisher)
        self._set_property("color", color)
        self._set_property("ipv4_endpoint", ipv4_endpoint)
        self._set_property("next_hop_mode", next_hop_mode)
        self._set_property("next_hop_address_type", next_hop_address_type)
        self._set_property("next_hop_ipv4_address", next_hop_ipv4_address)
        self._set_property("next_hop_ipv6_address", next_hop_ipv6_address)
        self._set_property("name", name)
        self._set_property("active", active)

    def set(
        self,
        distinguisher=None,
        color=None,
        ipv4_endpoint=None,
        next_hop_mode=None,
        next_hop_address_type=None,
        next_hop_ipv4_address=None,
        next_hop_ipv6_address=None,
        name=None,
        active=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def distinguisher(self):
        # type: () -> int
        """distinguisher getter

        4-octet value uniquely identifying the policy in the context of (color, endpoint) tuple. It is used by the SR Policy originator to make unique (from an NLRI perspective) both for multiple candidate paths of the same SR Policy as well as candidate paths of different SR Policies (i.e. with different segment list) with the same Color and Endpoint but meant for different head-ends.

        Returns: int
        """
        return self._get_property("distinguisher")

    @distinguisher.setter
    def distinguisher(self, value):
        """distinguisher setter

        4-octet value uniquely identifying the policy in the context of (color, endpoint) tuple. It is used by the SR Policy originator to make unique (from an NLRI perspective) both for multiple candidate paths of the same SR Policy as well as candidate paths of different SR Policies (i.e. with different segment list) with the same Color and Endpoint but meant for different head-ends.

        value: int
        """
        self._set_property("distinguisher", value)

    @property
    def color(self):
        # type: () -> int
        """color getter

        Policy color is used to match the color of the destination prefixes to steer traffic into the SR Policy.

        Returns: int
        """
        return self._get_property("color")

    @color.setter
    def color(self, value):
        """color setter

        Policy color is used to match the color of the destination prefixes to steer traffic into the SR Policy.

        value: int
        """
        self._set_property("color", value)

    @property
    def ipv4_endpoint(self):
        # type: () -> str
        """ipv4_endpoint getter

        Specifies single node or set of nodes (e.g. an anycast address). It is selected on the basis of the SR Policy type (AFI).

        Returns: str
        """
        return self._get_property("ipv4_endpoint")

    @ipv4_endpoint.setter
    def ipv4_endpoint(self, value):
        """ipv4_endpoint setter

        Specifies single node or set of nodes (e.g. an anycast address). It is selected on the basis of the SR Policy type (AFI).

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property ipv4_endpoint as None")
        self._set_property("ipv4_endpoint", value)

    @property
    def next_hop_mode(self):
        # type: () -> Union[Literal["local_ip"], Literal["manual"]]
        """next_hop_mode getter

        Mode for choosing the NextHop in MP REACH NLRI. Available modes are Local IP: Automatically fills the Nexthop with the Local IP of the BGP peer. For IPv6 BGP peer the Nexthop Encoding capability should be enabled. Manual: Override the Nexthop with any arbitrary IPv4/IPv6 address.

        Returns: Union[Literal["local_ip"], Literal["manual"]]
        """
        return self._get_property("next_hop_mode")

    @next_hop_mode.setter
    def next_hop_mode(self, value):
        """next_hop_mode setter

        Mode for choosing the NextHop in MP REACH NLRI. Available modes are Local IP: Automatically fills the Nexthop with the Local IP of the BGP peer. For IPv6 BGP peer the Nexthop Encoding capability should be enabled. Manual: Override the Nexthop with any arbitrary IPv4/IPv6 address.

        value: Union[Literal["local_ip"], Literal["manual"]]
        """
        self._set_property("next_hop_mode", value)

    @property
    def next_hop_address_type(self):
        # type: () -> Union[Literal["ipv4"], Literal["ipv6"]]
        """next_hop_address_type getter

        Type of next hop IP address to be used when 'next_hop_mode' is set to 'manual'.

        Returns: Union[Literal["ipv4"], Literal["ipv6"]]
        """
        return self._get_property("next_hop_address_type")

    @next_hop_address_type.setter
    def next_hop_address_type(self, value):
        """next_hop_address_type setter

        Type of next hop IP address to be used when 'next_hop_mode' is set to 'manual'.

        value: Union[Literal["ipv4"], Literal["ipv6"]]
        """
        self._set_property("next_hop_address_type", value)

    @property
    def next_hop_ipv4_address(self):
        # type: () -> str
        """next_hop_ipv4_address getter

        The IPv4 address of the next hop if the Nexthop type 'next_hop_mode' is 'manual' and the Nexthop type 'next_hop_address_type' is IPv4. If BGP peer is of type IPv6, Nexthop Encoding capability extended_next_hop_encoding should be enabled.

        Returns: str
        """
        return self._get_property("next_hop_ipv4_address")

    @next_hop_ipv4_address.setter
    def next_hop_ipv4_address(self, value):
        """next_hop_ipv4_address setter

        The IPv4 address of the next hop if the Nexthop type 'next_hop_mode' is 'manual' and the Nexthop type 'next_hop_address_type' is IPv4. If BGP peer is of type IPv6, Nexthop Encoding capability extended_next_hop_encoding should be enabled.

        value: str
        """
        self._set_property("next_hop_ipv4_address", value)

    @property
    def next_hop_ipv6_address(self):
        # type: () -> str
        """next_hop_ipv6_address getter

        The IPv6 address of the next hop if the Nexthop Mode 'next_hop_address_type' is 'manual' and the Nexthop type 'next_hop_address_type' is IPv6.

        Returns: str
        """
        return self._get_property("next_hop_ipv6_address")

    @next_hop_ipv6_address.setter
    def next_hop_ipv6_address(self, value):
        """next_hop_ipv6_address setter

        The IPv6 address of the next hop if the Nexthop Mode 'next_hop_address_type' is 'manual' and the Nexthop type 'next_hop_address_type' is IPv6.

        value: str
        """
        self._set_property("next_hop_ipv6_address", value)

    @property
    def advanced(self):
        # type: () -> BgpRouteAdvanced
        """advanced getter

        Configuration for advanced BGP route range settings.Configuration for advanced BGP route range settings.Configuration for advanced BGP route range settings.

        Returns: BgpRouteAdvanced
        """
        return self._get_property("advanced", BgpRouteAdvanced)

    @property
    def add_path(self):
        # type: () -> BgpAddPath
        """add_path getter

        The BGP Additional Paths feature is BGP extension that allows the advertisement of multiple paths for the same prefix without the new paths implicitly replacing any previous paths.The BGP Additional Paths feature is BGP extension that allows the advertisement of multiple paths for the same prefix without the new paths implicitly replacing any previous paths.The BGP Additional Paths feature is BGP extension that allows the advertisement of multiple paths for the same prefix without the new paths implicitly replacing any previous paths.

        Returns: BgpAddPath
        """
        return self._get_property("add_path", BgpAddPath)

    @property
    def as_path(self):
        # type: () -> BgpAsPath
        """as_path getter

        This attribute identifies the autonomous systems through which routing information carried in this UPDATE message has passed. This contains the configuration of how to include the Local AS in the AS path attribute of the MP REACH NLRI. It also contains optional configuration of additional AS Path Segments that can be included in the AS Path attribute. The AS Path consists of Set or Sequence of Autonomous Systems (AS) numbers that routing information passes through to reach the destination.This attribute identifies the autonomous systems through which routing information carried in this UPDATE message has passed. This contains the configuration of how to include the Local AS in the AS path attribute of the MP REACH NLRI. It also contains optional configuration of additional AS Path Segments that can be included in the AS Path attribute. The AS Path consists of Set or Sequence of Autonomous Systems (AS) numbers that routing information passes through to reach the destination.This attribute identifies the autonomous systems through which routing information carried in this UPDATE message has passed. This contains the configuration of how to include the Local AS in the AS path attribute of the MP REACH NLRI. It also contains optional configuration of additional AS Path Segments that can be included in the AS Path attribute. The AS Path consists of Set or Sequence of Autonomous Systems (AS) numbers that routing information passes through to reach the destination.

        Returns: BgpAsPath
        """
        return self._get_property("as_path", BgpAsPath)

    @property
    def communities(self):
        # type: () -> BgpCommunityIter
        """communities getter

        Optional Community settings.

        Returns: BgpCommunityIter
        """
        return self._get_property(
            "communities", BgpCommunityIter, self._parent, self._choice
        )

    @property
    def ext_communities(self):
        # type: () -> BgpExtCommunityIter
        """ext_communities getter

        Optional Extended Community settings. The Extended Communities Attribute is transitive optional BGP attribute, with the Type Code 16. Community and Extended Communities attributes are utilized to trigger routing decisions, such as acceptance, rejection, preference, or redistribution. An extended community is an 8-Bytes value. It is divided into two main parts. The first Bytes of the community encode type and sub-type fields and the last Bytes carry unique set of data in format defined by the type and sub-type field. Extended communities provide larger range for grouping or categorizing communities. When type is administrator_as_2octet or administrator_as_4octet, the valid sub types are route target and origin. The valid value for administrator_as_2octet and administrator_as_4octet type is either two byte AS followed by four byte local administrator id or four byte AS followed by two byte local administrator id. When type is administrator_ipv4_address the valid sub types are route target and origin. The valid value for administrator_ipv4_address is four byte IPv4 address followed by two byte local administrator id. When type is opaque, valid sub types are color and encapsulation. When sub type is color, first two bytes of the value field contain flags and last four bytes contains the value of the color. When sub type is encapsulation the first four bytes of value field are reserved and last two bytes carries the tunnel type from IANA's "ETHER TYPES" registry e.g IPv4 (protocol type 0x0800), IPv6 (protocol type 0x86dd), and MPLS (protocol type 0x8847). When type is administrator_as_2octet_link_bandwidth the valid sub type is extended_bandwidth. The first two bytes of the value field contains the AS number and the last four bytes contains the bandwidth in IEEE floating point format. When type is evpn the valid subtype is mac_address. In the value field the low-order bit of the first byte(Flags) is defined as the "Sticky/static" flag and may be set to 1, indicating the MAC address is static and cannot move. The second byte is reserved and the last four bytes contain the sequence number which is used to ensure that PEs retain the correct MAC/IP Advertisement route when multiple updates occur for the same MAC address.

        Returns: BgpExtCommunityIter
        """
        return self._get_property(
            "ext_communities", BgpExtCommunityIter, self._parent, self._choice
        )

    @property
    def tunnel_tlvs(self):
        # type: () -> BgpSrteV4TunnelTlvIter
        """tunnel_tlvs getter

        List Tunnel Encapsulation Attributes.

        Returns: BgpSrteV4TunnelTlvIter
        """
        return self._get_property(
            "tunnel_tlvs", BgpSrteV4TunnelTlvIter, self._parent, self._choice
        )

    @property
    def name(self):
        # type: () -> str
        """name getter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def active(self):
        # type: () -> bool
        """active getter

        If enabled means that this part of the configuration including any active 'children' nodes will be advertised to peer. If disabled, this means that though config is present, it is not taking any part of the test but can be activated at run-time to advertise just this part of the configuration to the peer.

        Returns: bool
        """
        return self._get_property("active")

    @active.setter
    def active(self, value):
        """active setter

        If enabled means that this part of the configuration including any active 'children' nodes will be advertised to peer. If disabled, this means that though config is present, it is not taking any part of the test but can be activated at run-time to advertise just this part of the configuration to the peer.

        value: bool
        """
        self._set_property("active", value)


class BgpSrteV4TunnelTlv(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "remote_endpoint_sub_tlv": {"type": "BgpSrteRemoteEndpointSubTlv"},
        "color_sub_tlv": {"type": "BgpSrteColorSubTlv"},
        "binding_sub_tlv": {"type": "BgpSrteBindingSubTlv"},
        "preference_sub_tlv": {"type": "BgpSrtePreferenceSubTlv"},
        "policy_priority_sub_tlv": {"type": "BgpSrtePolicyPrioritySubTlv"},
        "policy_name_sub_tlv": {"type": "BgpSrtePolicyNameSubTlv"},
        "explicit_null_label_policy_sub_tlv": {
            "type": "BgpSrteExplicitNullLabelPolicySubTlv"
        },
        "segment_lists": {"type": "BgpSrteSegmentListIter"},
        "name": {"type": str},
        "active": {"type": bool},
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "active": True,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, active=True):
        super(BgpSrteV4TunnelTlv, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("active", active)

    def set(self, name=None, active=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def remote_endpoint_sub_tlv(self):
        # type: () -> BgpSrteRemoteEndpointSubTlv
        """remote_endpoint_sub_tlv getter

        Configuration for the BGP remote endpoint sub TLV.Configuration for the BGP remote endpoint sub TLV.Configuration for the BGP remote endpoint sub TLV.

        Returns: BgpSrteRemoteEndpointSubTlv
        """
        return self._get_property(
            "remote_endpoint_sub_tlv", BgpSrteRemoteEndpointSubTlv
        )

    @property
    def color_sub_tlv(self):
        # type: () -> BgpSrteColorSubTlv
        """color_sub_tlv getter

        Configuration for the Policy Color attribute sub-TLV. The Color sub-TLV MAY be used as way to "color" the corresponding Tunnel TLV. The Value field of the sub-TLV is eight octets long and consists of Color Extended Community. First two octets of its Value field are 0x030b as type and subtype of extended community. Remaining six octets are are exposed to configure. Configuration for the Policy Color attribute sub-TLV. The Color sub-TLV MAY be used as way to "color" the corresponding Tunnel TLV. The Value field of the sub-TLV is eight octets long and consists of Color Extended Community. First two octets of its Value field are 0x030b as type and subtype of extended community. Remaining six octets are are exposed to configure. Configuration for the Policy Color attribute sub-TLV. The Color sub-TLV MAY be used as way to "color" the corresponding Tunnel TLV. The Value field of the sub-TLV is eight octets long and consists of Color Extended Community. First two octets of its Value field are 0x030b as type and subtype of extended community. Remaining six octets are are exposed to configure.

        Returns: BgpSrteColorSubTlv
        """
        return self._get_property("color_sub_tlv", BgpSrteColorSubTlv)

    @property
    def binding_sub_tlv(self):
        # type: () -> BgpSrteBindingSubTlv
        """binding_sub_tlv getter

        Configuration for the binding SID sub-TLV. This is used to signal the binding SID related information of the SR Policy candidate path.Configuration for the binding SID sub-TLV. This is used to signal the binding SID related information of the SR Policy candidate path.Configuration for the binding SID sub-TLV. This is used to signal the binding SID related information of the SR Policy candidate path.

        Returns: BgpSrteBindingSubTlv
        """
        return self._get_property("binding_sub_tlv", BgpSrteBindingSubTlv)

    @property
    def preference_sub_tlv(self):
        # type: () -> BgpSrtePreferenceSubTlv
        """preference_sub_tlv getter

        Configuration for BGP preference sub TLV of the SR Policy candidate path.Configuration for BGP preference sub TLV of the SR Policy candidate path.Configuration for BGP preference sub TLV of the SR Policy candidate path.

        Returns: BgpSrtePreferenceSubTlv
        """
        return self._get_property("preference_sub_tlv", BgpSrtePreferenceSubTlv)

    @property
    def policy_priority_sub_tlv(self):
        # type: () -> BgpSrtePolicyPrioritySubTlv
        """policy_priority_sub_tlv getter

        Configuration for the Policy Priority sub-TLV. The Policy Priority to indicate the order in which the SR policies are re-computed upon topological change.Configuration for the Policy Priority sub-TLV. The Policy Priority to indicate the order in which the SR policies are re-computed upon topological change.Configuration for the Policy Priority sub-TLV. The Policy Priority to indicate the order in which the SR policies are re-computed upon topological change.

        Returns: BgpSrtePolicyPrioritySubTlv
        """
        return self._get_property(
            "policy_priority_sub_tlv", BgpSrtePolicyPrioritySubTlv
        )

    @property
    def policy_name_sub_tlv(self):
        # type: () -> BgpSrtePolicyNameSubTlv
        """policy_name_sub_tlv getter

        Configuration for the Policy Name sub-TLV. The Policy Name sub-TLV is used to attach symbolic name to the SR Policy candidate path.Configuration for the Policy Name sub-TLV. The Policy Name sub-TLV is used to attach symbolic name to the SR Policy candidate path.Configuration for the Policy Name sub-TLV. The Policy Name sub-TLV is used to attach symbolic name to the SR Policy candidate path.

        Returns: BgpSrtePolicyNameSubTlv
        """
        return self._get_property("policy_name_sub_tlv", BgpSrtePolicyNameSubTlv)

    @property
    def explicit_null_label_policy_sub_tlv(self):
        # type: () -> BgpSrteExplicitNullLabelPolicySubTlv
        """explicit_null_label_policy_sub_tlv getter

        Configuration for BGP explicit null label policy sub TLV settings.Configuration for BGP explicit null label policy sub TLV settings.Configuration for BGP explicit null label policy sub TLV settings.

        Returns: BgpSrteExplicitNullLabelPolicySubTlv
        """
        return self._get_property(
            "explicit_null_label_policy_sub_tlv", BgpSrteExplicitNullLabelPolicySubTlv
        )

    @property
    def segment_lists(self):
        # type: () -> BgpSrteSegmentListIter
        """segment_lists getter

        TBD

        Returns: BgpSrteSegmentListIter
        """
        return self._get_property(
            "segment_lists", BgpSrteSegmentListIter, self._parent, self._choice
        )

    @property
    def name(self):
        # type: () -> str
        """name getter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def active(self):
        # type: () -> bool
        """active getter

        If enabled means that this part of the configuration including any active 'children' nodes will be advertised to peer. If disabled, this means that though config is present, it is not taking any part of the test but can be activated at run-time to advertise just this part of the configuration to the peer.

        Returns: bool
        """
        return self._get_property("active")

    @active.setter
    def active(self, value):
        """active setter

        If enabled means that this part of the configuration including any active 'children' nodes will be advertised to peer. If disabled, this means that though config is present, it is not taking any part of the test but can be activated at run-time to advertise just this part of the configuration to the peer.

        value: bool
        """
        self._set_property("active", value)


class BgpSrteRemoteEndpointSubTlv(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "as_number": {
            "type": int,
            "format": "uint32",
        },
        "address_family": {
            "type": str,
            "enum": [
                "ipv4",
                "ipv6",
            ],
        },
        "ipv4_address": {
            "type": str,
            "format": "ipv4",
        },
        "ipv6_address": {
            "type": str,
            "format": "ipv6",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "as_number": 0,
        "address_family": "ipv4",
        "ipv4_address": "0.0.0.0",
        "ipv6_address": "::0",
    }  # type: Dict[str, Union(type)]

    IPV4 = "ipv4"  # type: str
    IPV6 = "ipv6"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        as_number=0,
        address_family="ipv4",
        ipv4_address="0.0.0.0",
        ipv6_address="::0",
    ):
        super(BgpSrteRemoteEndpointSubTlv, self).__init__()
        self._parent = parent
        self._set_property("as_number", as_number)
        self._set_property("address_family", address_family)
        self._set_property("ipv4_address", ipv4_address)
        self._set_property("ipv6_address", ipv6_address)

    def set(
        self, as_number=None, address_family=None, ipv4_address=None, ipv6_address=None
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def as_number(self):
        # type: () -> int
        """as_number getter

        Autonomous system (AS) number

        Returns: int
        """
        return self._get_property("as_number")

    @as_number.setter
    def as_number(self, value):
        """as_number setter

        Autonomous system (AS) number

        value: int
        """
        self._set_property("as_number", value)

    @property
    def address_family(self):
        # type: () -> Union[Literal["ipv4"], Literal["ipv6"]]
        """address_family getter

        Determines the address type

        Returns: Union[Literal["ipv4"], Literal["ipv6"]]
        """
        return self._get_property("address_family")

    @address_family.setter
    def address_family(self, value):
        """address_family setter

        Determines the address type

        value: Union[Literal["ipv4"], Literal["ipv6"]]
        """
        self._set_property("address_family", value)

    @property
    def ipv4_address(self):
        # type: () -> str
        """ipv4_address getter

        The IPv4 address of the Remote Endpoint.

        Returns: str
        """
        return self._get_property("ipv4_address")

    @ipv4_address.setter
    def ipv4_address(self, value):
        """ipv4_address setter

        The IPv4 address of the Remote Endpoint.

        value: str
        """
        self._set_property("ipv4_address", value)

    @property
    def ipv6_address(self):
        # type: () -> str
        """ipv6_address getter

        The IPv6 address of the Remote Endpoint.

        Returns: str
        """
        return self._get_property("ipv6_address")

    @ipv6_address.setter
    def ipv6_address(self, value):
        """ipv6_address setter

        The IPv6 address of the Remote Endpoint.

        value: str
        """
        self._set_property("ipv6_address", value)


class BgpSrteColorSubTlv(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "color": {
            "type": str,
            "format": "hex",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, color=None):
        super(BgpSrteColorSubTlv, self).__init__()
        self._parent = parent
        self._set_property("color", color)

    def set(self, color=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def color(self):
        # type: () -> str
        """color getter

        Six octet values. Example: 000000000064 for color value 100.

        Returns: str
        """
        return self._get_property("color")

    @color.setter
    def color(self, value):
        """color setter

        Six octet values. Example: 000000000064 for color value 100.

        value: str
        """
        self._set_property("color", value)


class BgpSrteBindingSubTlv(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "binding_sid_type": {
            "type": str,
            "enum": [
                "no_binding",
                "four_octet_sid",
                "ipv6_sid",
            ],
        },
        "four_octet_sid": {
            "type": int,
            "format": "uint32",
        },
        "ipv6_sid": {
            "type": str,
            "format": "ipv6",
        },
        "s_flag": {"type": bool},
        "i_flag": {"type": bool},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "binding_sid_type": "no_binding",
        "s_flag": False,
        "i_flag": False,
    }  # type: Dict[str, Union(type)]

    NO_BINDING = "no_binding"  # type: str
    FOUR_OCTET_SID = "four_octet_sid"  # type: str
    IPV6_SID = "ipv6_sid"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        binding_sid_type="no_binding",
        four_octet_sid=None,
        ipv6_sid=None,
        s_flag=False,
        i_flag=False,
    ):
        super(BgpSrteBindingSubTlv, self).__init__()
        self._parent = parent
        self._set_property("binding_sid_type", binding_sid_type)
        self._set_property("four_octet_sid", four_octet_sid)
        self._set_property("ipv6_sid", ipv6_sid)
        self._set_property("s_flag", s_flag)
        self._set_property("i_flag", i_flag)

    def set(
        self,
        binding_sid_type=None,
        four_octet_sid=None,
        ipv6_sid=None,
        s_flag=None,
        i_flag=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def binding_sid_type(self):
        # type: () -> Union[Literal["four_octet_sid"], Literal["ipv6_sid"], Literal["no_binding"]]
        """binding_sid_type getter

        Type of the binding SID. Supported types are "No Binding SID" or "Four Octets Sid" or "IPv6 SID".

        Returns: Union[Literal["four_octet_sid"], Literal["ipv6_sid"], Literal["no_binding"]]
        """
        return self._get_property("binding_sid_type")

    @binding_sid_type.setter
    def binding_sid_type(self, value):
        """binding_sid_type setter

        Type of the binding SID. Supported types are "No Binding SID" or "Four Octets Sid" or "IPv6 SID".

        value: Union[Literal["four_octet_sid"], Literal["ipv6_sid"], Literal["no_binding"]]
        """
        self._set_property("binding_sid_type", value)

    @property
    def four_octet_sid(self):
        # type: () -> int
        """four_octet_sid getter

        Binding SID is encoded in octets.

        Returns: int
        """
        return self._get_property("four_octet_sid")

    @four_octet_sid.setter
    def four_octet_sid(self, value):
        """four_octet_sid setter

        Binding SID is encoded in octets.

        value: int
        """
        self._set_property("four_octet_sid", value)

    @property
    def ipv6_sid(self):
        # type: () -> str
        """ipv6_sid getter

        IPv6 SID value.

        Returns: str
        """
        return self._get_property("ipv6_sid")

    @ipv6_sid.setter
    def ipv6_sid(self, value):
        """ipv6_sid setter

        IPv6 SID value.

        value: str
        """
        self._set_property("ipv6_sid", value)

    @property
    def s_flag(self):
        # type: () -> bool
        """s_flag getter

        S-Flag encodes the "Specified-BSID-only" behavior.

        Returns: bool
        """
        return self._get_property("s_flag")

    @s_flag.setter
    def s_flag(self, value):
        """s_flag setter

        S-Flag encodes the "Specified-BSID-only" behavior.

        value: bool
        """
        self._set_property("s_flag", value)

    @property
    def i_flag(self):
        # type: () -> bool
        """i_flag getter

        I-Flag encodes the "Drop Upon Invalid" behavior.

        Returns: bool
        """
        return self._get_property("i_flag")

    @i_flag.setter
    def i_flag(self, value):
        """i_flag setter

        I-Flag encodes the "Drop Upon Invalid" behavior.

        value: bool
        """
        self._set_property("i_flag", value)


class BgpSrtePreferenceSubTlv(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "preference": {
            "type": int,
            "format": "uint32",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "preference": 0,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, preference=0):
        super(BgpSrtePreferenceSubTlv, self).__init__()
        self._parent = parent
        self._set_property("preference", preference)

    def set(self, preference=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def preference(self):
        # type: () -> int
        """preference getter

        The preference value of the SR Policy candidate path.

        Returns: int
        """
        return self._get_property("preference")

    @preference.setter
    def preference(self, value):
        """preference setter

        The preference value of the SR Policy candidate path.

        value: int
        """
        self._set_property("preference", value)


class BgpSrtePolicyPrioritySubTlv(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "policy_priority": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, policy_priority=None):
        super(BgpSrtePolicyPrioritySubTlv, self).__init__()
        self._parent = parent
        self._set_property("policy_priority", policy_priority)

    def set(self, policy_priority=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def policy_priority(self):
        # type: () -> int
        """policy_priority getter

        One-octet Priority value.

        Returns: int
        """
        return self._get_property("policy_priority")

    @policy_priority.setter
    def policy_priority(self, value):
        """policy_priority setter

        One-octet Priority value.

        value: int
        """
        self._set_property("policy_priority", value)


class BgpSrtePolicyNameSubTlv(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "policy_name": {
            "type": str,
            "minLength": 1,
            "maxLength": 32,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, policy_name=None):
        super(BgpSrtePolicyNameSubTlv, self).__init__()
        self._parent = parent
        self._set_property("policy_name", policy_name)

    def set(self, policy_name=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def policy_name(self):
        # type: () -> str
        """policy_name getter

        Symbolic name for the policy that should be string of printable ASCII characters, without NULL terminator.

        Returns: str
        """
        return self._get_property("policy_name")

    @policy_name.setter
    def policy_name(self, value):
        """policy_name setter

        Symbolic name for the policy that should be string of printable ASCII characters, without NULL terminator.

        value: str
        """
        self._set_property("policy_name", value)


class BgpSrteExplicitNullLabelPolicySubTlv(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "explicit_null_label_policy": {
            "type": str,
            "enum": [
                "reserved_enlp",
                "push_ipv4_enlp",
                "push_ipv6_enlp",
                "push_ipv4_ipv6_enlp",
                "do_not_push_enlp",
            ],
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "explicit_null_label_policy": "do_not_push_enlp",
    }  # type: Dict[str, Union(type)]

    RESERVED_ENLP = "reserved_enlp"  # type: str
    PUSH_IPV4_ENLP = "push_ipv4_enlp"  # type: str
    PUSH_IPV6_ENLP = "push_ipv6_enlp"  # type: str
    PUSH_IPV4_IPV6_ENLP = "push_ipv4_ipv6_enlp"  # type: str
    DO_NOT_PUSH_ENLP = "do_not_push_enlp"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, explicit_null_label_policy="do_not_push_enlp"):
        super(BgpSrteExplicitNullLabelPolicySubTlv, self).__init__()
        self._parent = parent
        self._set_property("explicit_null_label_policy", explicit_null_label_policy)

    def set(self, explicit_null_label_policy=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def explicit_null_label_policy(self):
        # type: () -> Union[Literal["do_not_push_enlp"], Literal["push_ipv4_enlp"], Literal["push_ipv4_ipv6_enlp"], Literal["push_ipv6_enlp"], Literal["reserved_enlp"]]
        """explicit_null_label_policy getter

        The value of the explicit null label policy

        Returns: Union[Literal["do_not_push_enlp"], Literal["push_ipv4_enlp"], Literal["push_ipv4_ipv6_enlp"], Literal["push_ipv6_enlp"], Literal["reserved_enlp"]]
        """
        return self._get_property("explicit_null_label_policy")

    @explicit_null_label_policy.setter
    def explicit_null_label_policy(self, value):
        """explicit_null_label_policy setter

        The value of the explicit null label policy

        value: Union[Literal["do_not_push_enlp"], Literal["push_ipv4_enlp"], Literal["push_ipv4_ipv6_enlp"], Literal["push_ipv6_enlp"], Literal["reserved_enlp"]]
        """
        self._set_property("explicit_null_label_policy", value)


class BgpSrteSegmentList(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "weight": {
            "type": int,
            "format": "uint32",
        },
        "segments": {"type": "BgpSrteSegmentIter"},
        "name": {"type": str},
        "active": {"type": bool},
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "weight": 0,
        "active": True,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, weight=0, name=None, active=True):
        super(BgpSrteSegmentList, self).__init__()
        self._parent = parent
        self._set_property("weight", weight)
        self._set_property("name", name)
        self._set_property("active", active)

    def set(self, weight=None, name=None, active=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def weight(self):
        # type: () -> int
        """weight getter

        The Weight associated with given path and the sub-TLV is optional.

        Returns: int
        """
        return self._get_property("weight")

    @weight.setter
    def weight(self, value):
        """weight setter

        The Weight associated with given path and the sub-TLV is optional.

        value: int
        """
        self._set_property("weight", value)

    @property
    def segments(self):
        # type: () -> BgpSrteSegmentIter
        """segments getter

        TBD

        Returns: BgpSrteSegmentIter
        """
        return self._get_property(
            "segments", BgpSrteSegmentIter, self._parent, self._choice
        )

    @property
    def name(self):
        # type: () -> str
        """name getter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def active(self):
        # type: () -> bool
        """active getter

        If enabled means that this part of the configuration including any active 'children' nodes will be advertised to peer. If disabled, this means that though config is present, it is not taking any part of the test but can be activated at run-time to advertise just this part of the configuration to the peer.

        Returns: bool
        """
        return self._get_property("active")

    @active.setter
    def active(self, value):
        """active setter

        If enabled means that this part of the configuration including any active 'children' nodes will be advertised to peer. If disabled, this means that though config is present, it is not taking any part of the test but can be activated at run-time to advertise just this part of the configuration to the peer.

        value: bool
        """
        self._set_property("active", value)


class BgpSrteSegment(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "segment_type": {
            "type": str,
            "enum": [
                "type_a",
                "type_b",
                "type_c",
                "type_d",
                "type_e",
                "type_f",
                "type_g",
                "type_h",
                "type_i",
                "type_j",
                "type_k",
            ],
        },
        "type_a": {"type": "BgpSrteSegmentATypeSubTlv"},
        "type_b": {"type": "BgpSrteSegmentBTypeSubTlv"},
        "type_c": {"type": "BgpSrteSegmentCTypeSubTlv"},
        "type_d": {"type": "BgpSrteSegmentDTypeSubTlv"},
        "type_e": {"type": "BgpSrteSegmentETypeSubTlv"},
        "type_f": {"type": "BgpSrteSegmentFTypeSubTlv"},
        "type_g": {"type": "BgpSrteSegmentGTypeSubTlv"},
        "type_h": {"type": "BgpSrteSegmentHTypeSubTlv"},
        "type_i": {"type": "BgpSrteSegmentITypeSubTlv"},
        "type_j": {"type": "BgpSrteSegmentJTypeSubTlv"},
        "type_k": {"type": "BgpSrteSegmentKTypeSubTlv"},
        "name": {"type": str},
        "active": {"type": bool},
    }  # type: Dict[str, str]

    _REQUIRED = ("segment_type", "name")  # type: tuple(str)

    _DEFAULTS = {
        "active": True,
    }  # type: Dict[str, Union(type)]

    TYPE_A = "type_a"  # type: str
    TYPE_B = "type_b"  # type: str
    TYPE_C = "type_c"  # type: str
    TYPE_D = "type_d"  # type: str
    TYPE_E = "type_e"  # type: str
    TYPE_F = "type_f"  # type: str
    TYPE_G = "type_g"  # type: str
    TYPE_H = "type_h"  # type: str
    TYPE_I = "type_i"  # type: str
    TYPE_J = "type_j"  # type: str
    TYPE_K = "type_k"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, segment_type=None, name=None, active=True):
        super(BgpSrteSegment, self).__init__()
        self._parent = parent
        self._set_property("segment_type", segment_type)
        self._set_property("name", name)
        self._set_property("active", active)

    def set(self, segment_type=None, name=None, active=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def segment_type(self):
        # type: () -> Union[Literal["type_a"], Literal["type_b"], Literal["type_c"], Literal["type_d"], Literal["type_e"], Literal["type_f"], Literal["type_g"], Literal["type_h"], Literal["type_i"], Literal["type_j"], Literal["type_k"]]
        """segment_type getter

        Specify one of the segment type.. https://datatracker.ietf.org/doc/html/draft-ietf-idr-segment-routing-te-policy-13. Type A: SID only, in the form of MPLS Label.. Type B: SID only, in the form of IPv6 Address.. Type C: IPv4 Node Address with optional SID.. Type D: IPv6 Node Address with optional SID for SR MPLS.. Type E: IPv4 Address and index with optional SID.. Type F: IPv4 Local and Remote addresses with optional SID.. Type G: IPv6 Address and index for local and remote pair with optional. SID for SR MPLS.. Type H: IPv6 Local and Remote addresses with optional SID for SR MPLS.. Type I: IPv6 Node Address with optional SID for SRv6.. Type J: IPv6 Address and index for local and remote pair with optional. SID for SRv6.. Type K: IPv6 Local and Remote addresses for SRv6.

        Returns: Union[Literal["type_a"], Literal["type_b"], Literal["type_c"], Literal["type_d"], Literal["type_e"], Literal["type_f"], Literal["type_g"], Literal["type_h"], Literal["type_i"], Literal["type_j"], Literal["type_k"]]
        """
        return self._get_property("segment_type")

    @segment_type.setter
    def segment_type(self, value):
        """segment_type setter

        Specify one of the segment type.. https://datatracker.ietf.org/doc/html/draft-ietf-idr-segment-routing-te-policy-13. Type A: SID only, in the form of MPLS Label.. Type B: SID only, in the form of IPv6 Address.. Type C: IPv4 Node Address with optional SID.. Type D: IPv6 Node Address with optional SID for SR MPLS.. Type E: IPv4 Address and index with optional SID.. Type F: IPv4 Local and Remote addresses with optional SID.. Type G: IPv6 Address and index for local and remote pair with optional. SID for SR MPLS.. Type H: IPv6 Local and Remote addresses with optional SID for SR MPLS.. Type I: IPv6 Node Address with optional SID for SRv6.. Type J: IPv6 Address and index for local and remote pair with optional. SID for SRv6.. Type K: IPv6 Local and Remote addresses for SRv6.

        value: Union[Literal["type_a"], Literal["type_b"], Literal["type_c"], Literal["type_d"], Literal["type_e"], Literal["type_f"], Literal["type_g"], Literal["type_h"], Literal["type_i"], Literal["type_j"], Literal["type_k"]]
        """
        if value is None:
            raise TypeError("Cannot set required property segment_type as None")
        self._set_property("segment_type", value)

    @property
    def type_a(self):
        # type: () -> BgpSrteSegmentATypeSubTlv
        """type_a getter

        Type A: SID only, in the form of MPLS Label.Type A: SID only, in the form of MPLS Label.Type A: SID only, in the form of MPLS Label.

        Returns: BgpSrteSegmentATypeSubTlv
        """
        return self._get_property("type_a", BgpSrteSegmentATypeSubTlv)

    @property
    def type_b(self):
        # type: () -> BgpSrteSegmentBTypeSubTlv
        """type_b getter

        Type B: SID only, in the form of IPv6 address.Type B: SID only, in the form of IPv6 address.Type B: SID only, in the form of IPv6 address.

        Returns: BgpSrteSegmentBTypeSubTlv
        """
        return self._get_property("type_b", BgpSrteSegmentBTypeSubTlv)

    @property
    def type_c(self):
        # type: () -> BgpSrteSegmentCTypeSubTlv
        """type_c getter

        Type C: IPv4 Node Address with optional SID.Type C: IPv4 Node Address with optional SID.Type C: IPv4 Node Address with optional SID.

        Returns: BgpSrteSegmentCTypeSubTlv
        """
        return self._get_property("type_c", BgpSrteSegmentCTypeSubTlv)

    @property
    def type_d(self):
        # type: () -> BgpSrteSegmentDTypeSubTlv
        """type_d getter

        Type D: IPv6 Node Address with optional SID for SR MPLS.Type D: IPv6 Node Address with optional SID for SR MPLS.Type D: IPv6 Node Address with optional SID for SR MPLS.

        Returns: BgpSrteSegmentDTypeSubTlv
        """
        return self._get_property("type_d", BgpSrteSegmentDTypeSubTlv)

    @property
    def type_e(self):
        # type: () -> BgpSrteSegmentETypeSubTlv
        """type_e getter

        Type E: IPv4 Address and Local Interface ID with optional SIDType E: IPv4 Address and Local Interface ID with optional SIDType E: IPv4 Address and Local Interface ID with optional SID

        Returns: BgpSrteSegmentETypeSubTlv
        """
        return self._get_property("type_e", BgpSrteSegmentETypeSubTlv)

    @property
    def type_f(self):
        # type: () -> BgpSrteSegmentFTypeSubTlv
        """type_f getter

        Type F: IPv4 Local and Remote addresses with optional SID.Type F: IPv4 Local and Remote addresses with optional SID.Type F: IPv4 Local and Remote addresses with optional SID.

        Returns: BgpSrteSegmentFTypeSubTlv
        """
        return self._get_property("type_f", BgpSrteSegmentFTypeSubTlv)

    @property
    def type_g(self):
        # type: () -> BgpSrteSegmentGTypeSubTlv
        """type_g getter

        Type G: IPv6 Address, Interface ID for local and remote pair with optional SID for SR MPLS.Type G: IPv6 Address, Interface ID for local and remote pair with optional SID for SR MPLS.Type G: IPv6 Address, Interface ID for local and remote pair with optional SID for SR MPLS.

        Returns: BgpSrteSegmentGTypeSubTlv
        """
        return self._get_property("type_g", BgpSrteSegmentGTypeSubTlv)

    @property
    def type_h(self):
        # type: () -> BgpSrteSegmentHTypeSubTlv
        """type_h getter

        Type H: IPv6 Local and Remote addresses with optional SID for SR MPLS.Type H: IPv6 Local and Remote addresses with optional SID for SR MPLS.Type H: IPv6 Local and Remote addresses with optional SID for SR MPLS.

        Returns: BgpSrteSegmentHTypeSubTlv
        """
        return self._get_property("type_h", BgpSrteSegmentHTypeSubTlv)

    @property
    def type_i(self):
        # type: () -> BgpSrteSegmentITypeSubTlv
        """type_i getter

        Type I: IPv6 Node Address with optional SRv6 SID.Type I: IPv6 Node Address with optional SRv6 SID.Type I: IPv6 Node Address with optional SRv6 SID.

        Returns: BgpSrteSegmentITypeSubTlv
        """
        return self._get_property("type_i", BgpSrteSegmentITypeSubTlv)

    @property
    def type_j(self):
        # type: () -> BgpSrteSegmentJTypeSubTlv
        """type_j getter

        Type J: IPv6 Address, Interface ID for local and remote pair for SRv6 with optional SID.Type J: IPv6 Address, Interface ID for local and remote pair for SRv6 with optional SID.Type J: IPv6 Address, Interface ID for local and remote pair for SRv6 with optional SID.

        Returns: BgpSrteSegmentJTypeSubTlv
        """
        return self._get_property("type_j", BgpSrteSegmentJTypeSubTlv)

    @property
    def type_k(self):
        # type: () -> BgpSrteSegmentKTypeSubTlv
        """type_k getter

        Type K: IPv6 Local and Remote addresses for SRv6 with optional SID.Type K: IPv6 Local and Remote addresses for SRv6 with optional SID.Type K: IPv6 Local and Remote addresses for SRv6 with optional SID.

        Returns: BgpSrteSegmentKTypeSubTlv
        """
        return self._get_property("type_k", BgpSrteSegmentKTypeSubTlv)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def active(self):
        # type: () -> bool
        """active getter

        If enabled means that this part of the configuration including any active 'children' nodes will be advertised to peer. If disabled, this means that though config is present, it is not taking any part of the test but can be activated at run-time to advertise just this part of the configuration to the peer.

        Returns: bool
        """
        return self._get_property("active")

    @active.setter
    def active(self, value):
        """active setter

        If enabled means that this part of the configuration including any active 'children' nodes will be advertised to peer. If disabled, this means that though config is present, it is not taking any part of the test but can be activated at run-time to advertise just this part of the configuration to the peer.

        value: bool
        """
        self._set_property("active", value)


class BgpSrteSegmentATypeSubTlv(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "flags": {
            "type": str,
            "format": "hex",
        },
        "label": {
            "type": int,
            "format": "uint32",
            "maximum": 1048575,
        },
        "tc": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "s_bit": {"type": bool},
        "ttl": {
            "type": int,
            "format": "uint32",
            "maximum": 225,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self, parent=None, flags=None, label=None, tc=None, s_bit=None, ttl=None
    ):
        super(BgpSrteSegmentATypeSubTlv, self).__init__()
        self._parent = parent
        self._set_property("flags", flags)
        self._set_property("label", label)
        self._set_property("tc", tc)
        self._set_property("s_bit", s_bit)
        self._set_property("ttl", ttl)

    def set(self, flags=None, label=None, tc=None, s_bit=None, ttl=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def flags(self):
        # type: () -> str
        """flags getter

        One octet bitmap for flags including V-Flag, A-Flag, S-Flag, B-Flag etc. as defined in https://datatracker.ietf.org/doc/html/draft-ietf-idr-segment-routing-te-policy-13#section-2.4.4.2.12

        Returns: str
        """
        return self._get_property("flags")

    @flags.setter
    def flags(self, value):
        """flags setter

        One octet bitmap for flags including V-Flag, A-Flag, S-Flag, B-Flag etc. as defined in https://datatracker.ietf.org/doc/html/draft-ietf-idr-segment-routing-te-policy-13#section-2.4.4.2.12

        value: str
        """
        self._set_property("flags", value)

    @property
    def label(self):
        # type: () -> int
        """label getter

        Label value in [0, 2^20 -1].

        Returns: int
        """
        return self._get_property("label")

    @label.setter
    def label(self, value):
        """label setter

        Label value in [0, 2^20 -1].

        value: int
        """
        self._set_property("label", value)

    @property
    def tc(self):
        # type: () -> int
        """tc getter

        Traffic class in bits.

        Returns: int
        """
        return self._get_property("tc")

    @tc.setter
    def tc(self, value):
        """tc setter

        Traffic class in bits.

        value: int
        """
        self._set_property("tc", value)

    @property
    def s_bit(self):
        # type: () -> bool
        """s_bit getter

        Bottom-of-Stack bit.

        Returns: bool
        """
        return self._get_property("s_bit")

    @s_bit.setter
    def s_bit(self, value):
        """s_bit setter

        Bottom-of-Stack bit.

        value: bool
        """
        self._set_property("s_bit", value)

    @property
    def ttl(self):
        # type: () -> int
        """ttl getter

        Time To Live.

        Returns: int
        """
        return self._get_property("ttl")

    @ttl.setter
    def ttl(self, value):
        """ttl setter

        Time To Live.

        value: int
        """
        self._set_property("ttl", value)


class BgpSrteSegmentBTypeSubTlv(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "flags": {
            "type": str,
            "format": "hex",
        },
        "srv6_sid": {
            "type": str,
            "format": "ipv6",
        },
        "srv6_sid_endpoint_behavior": {
            "type": "BgpSrteSRv6SIDEndpointBehaviorAndStructure"
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("srv6_sid",)  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, flags=None, srv6_sid=None):
        super(BgpSrteSegmentBTypeSubTlv, self).__init__()
        self._parent = parent
        self._set_property("flags", flags)
        self._set_property("srv6_sid", srv6_sid)

    def set(self, flags=None, srv6_sid=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def flags(self):
        # type: () -> str
        """flags getter

        One octet bitmap for flags including V-Flag, A-Flag, S-Flag, B-Flag etc. as defined in https://datatracker.ietf.org/doc/html/draft-ietf-idr-segment-routing-te-policy-13#section-2.4.4.2.12

        Returns: str
        """
        return self._get_property("flags")

    @flags.setter
    def flags(self, value):
        """flags setter

        One octet bitmap for flags including V-Flag, A-Flag, S-Flag, B-Flag etc. as defined in https://datatracker.ietf.org/doc/html/draft-ietf-idr-segment-routing-te-policy-13#section-2.4.4.2.12

        value: str
        """
        self._set_property("flags", value)

    @property
    def srv6_sid(self):
        # type: () -> str
        """srv6_sid getter

        SRv6 SID.

        Returns: str
        """
        return self._get_property("srv6_sid")

    @srv6_sid.setter
    def srv6_sid(self, value):
        """srv6_sid setter

        SRv6 SID.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property srv6_sid as None")
        self._set_property("srv6_sid", value)

    @property
    def srv6_sid_endpoint_behavior(self):
        # type: () -> BgpSrteSRv6SIDEndpointBehaviorAndStructure
        """srv6_sid_endpoint_behavior getter

        Configuration for SRv6 Endpoint Behavior and SID Structure. Its optional. Summation of lengths for Locator Block, Locator Node, Function, and Argument MUST be less than or equal to 128.Configuration for SRv6 Endpoint Behavior and SID Structure. Its optional. Summation of lengths for Locator Block, Locator Node, Function, and Argument MUST be less than or equal to 128.Configuration for SRv6 Endpoint Behavior and SID Structure. Its optional. Summation of lengths for Locator Block, Locator Node, Function, and Argument MUST be less than or equal to 128.Optional SRv6 Endpoint Behavior and SID Structure.

        Returns: BgpSrteSRv6SIDEndpointBehaviorAndStructure
        """
        return self._get_property(
            "srv6_sid_endpoint_behavior", BgpSrteSRv6SIDEndpointBehaviorAndStructure
        )


class BgpSrteSRv6SIDEndpointBehaviorAndStructure(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "lb_length": {
            "type": int,
            "format": "uint32",
            "maximum": 128,
        },
        "ln_length": {
            "type": int,
            "format": "uint32",
            "maximum": 128,
        },
        "func_length": {
            "type": int,
            "format": "uint32",
            "maximum": 128,
        },
        "arg_length": {
            "type": int,
            "format": "uint32",
            "maximum": 128,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "lb_length": 0,
        "ln_length": 0,
        "func_length": 0,
        "arg_length": 0,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self, parent=None, lb_length=0, ln_length=0, func_length=0, arg_length=0
    ):
        super(BgpSrteSRv6SIDEndpointBehaviorAndStructure, self).__init__()
        self._parent = parent
        self._set_property("lb_length", lb_length)
        self._set_property("ln_length", ln_length)
        self._set_property("func_length", func_length)
        self._set_property("arg_length", arg_length)

    def set(self, lb_length=None, ln_length=None, func_length=None, arg_length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def lb_length(self):
        # type: () -> int
        """lb_length getter

        SRv6 SID Locator Block length in bits.

        Returns: int
        """
        return self._get_property("lb_length")

    @lb_length.setter
    def lb_length(self, value):
        """lb_length setter

        SRv6 SID Locator Block length in bits.

        value: int
        """
        self._set_property("lb_length", value)

    @property
    def ln_length(self):
        # type: () -> int
        """ln_length getter

        SRv6 SID Locator Node length in bits.

        Returns: int
        """
        return self._get_property("ln_length")

    @ln_length.setter
    def ln_length(self, value):
        """ln_length setter

        SRv6 SID Locator Node length in bits.

        value: int
        """
        self._set_property("ln_length", value)

    @property
    def func_length(self):
        # type: () -> int
        """func_length getter

        SRv6 SID Function length in bits.

        Returns: int
        """
        return self._get_property("func_length")

    @func_length.setter
    def func_length(self, value):
        """func_length setter

        SRv6 SID Function length in bits.

        value: int
        """
        self._set_property("func_length", value)

    @property
    def arg_length(self):
        # type: () -> int
        """arg_length getter

        SRv6 SID Arguments length in bits.

        Returns: int
        """
        return self._get_property("arg_length")

    @arg_length.setter
    def arg_length(self, value):
        """arg_length setter

        SRv6 SID Arguments length in bits.

        value: int
        """
        self._set_property("arg_length", value)


class BgpSrteSegmentCTypeSubTlv(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "flags": {
            "type": str,
            "format": "hex",
        },
        "sr_algorithm": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "ipv4_node_address": {
            "type": str,
            "format": "ipv4",
        },
        "sr_mpls_sid": {"type": "BgpSrteSrMplsSid"},
    }  # type: Dict[str, str]

    _REQUIRED = ("ipv4_node_address",)  # type: tuple(str)

    _DEFAULTS = {
        "sr_algorithm": 0,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, flags=None, sr_algorithm=0, ipv4_node_address=None):
        super(BgpSrteSegmentCTypeSubTlv, self).__init__()
        self._parent = parent
        self._set_property("flags", flags)
        self._set_property("sr_algorithm", sr_algorithm)
        self._set_property("ipv4_node_address", ipv4_node_address)

    def set(self, flags=None, sr_algorithm=None, ipv4_node_address=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def flags(self):
        # type: () -> str
        """flags getter

        One octet bitmap for flags including V-Flag, A-Flag, S-Flag, B-Flag etc. as defined in https://datatracker.ietf.org/doc/html/draft-ietf-idr-segment-routing-te-policy-13#section-2.4.4.2.12

        Returns: str
        """
        return self._get_property("flags")

    @flags.setter
    def flags(self, value):
        """flags setter

        One octet bitmap for flags including V-Flag, A-Flag, S-Flag, B-Flag etc. as defined in https://datatracker.ietf.org/doc/html/draft-ietf-idr-segment-routing-te-policy-13#section-2.4.4.2.12

        value: str
        """
        self._set_property("flags", value)

    @property
    def sr_algorithm(self):
        # type: () -> int
        """sr_algorithm getter

        SR Algorithm identifier when A-Flag in on.

        Returns: int
        """
        return self._get_property("sr_algorithm")

    @sr_algorithm.setter
    def sr_algorithm(self, value):
        """sr_algorithm setter

        SR Algorithm identifier when A-Flag in on.

        value: int
        """
        self._set_property("sr_algorithm", value)

    @property
    def ipv4_node_address(self):
        # type: () -> str
        """ipv4_node_address getter

        IPv4 address representing node.

        Returns: str
        """
        return self._get_property("ipv4_node_address")

    @ipv4_node_address.setter
    def ipv4_node_address(self, value):
        """ipv4_node_address setter

        IPv4 address representing node.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property ipv4_node_address as None")
        self._set_property("ipv4_node_address", value)

    @property
    def sr_mpls_sid(self):
        # type: () -> BgpSrteSrMplsSid
        """sr_mpls_sid getter

        Configuration for SR-MPLS with Label, TC, Bottom-of-Stack and TTL.Configuration for SR-MPLS with Label, TC, Bottom-of-Stack and TTL.Configuration for SR-MPLS with Label, TC, Bottom-of-Stack and TTL.Optional SR-MPLS SID.

        Returns: BgpSrteSrMplsSid
        """
        return self._get_property("sr_mpls_sid", BgpSrteSrMplsSid)


class BgpSrteSrMplsSid(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "label": {
            "type": int,
            "format": "uint32",
            "maximum": 1048575,
        },
        "tc": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "s_bit": {"type": bool},
        "ttl": {
            "type": int,
            "format": "uint32",
            "maximum": 225,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, label=None, tc=None, s_bit=None, ttl=None):
        super(BgpSrteSrMplsSid, self).__init__()
        self._parent = parent
        self._set_property("label", label)
        self._set_property("tc", tc)
        self._set_property("s_bit", s_bit)
        self._set_property("ttl", ttl)

    def set(self, label=None, tc=None, s_bit=None, ttl=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def label(self):
        # type: () -> int
        """label getter

        Label value in [0, 2^20 -1].

        Returns: int
        """
        return self._get_property("label")

    @label.setter
    def label(self, value):
        """label setter

        Label value in [0, 2^20 -1].

        value: int
        """
        self._set_property("label", value)

    @property
    def tc(self):
        # type: () -> int
        """tc getter

        Traffic class in bits.

        Returns: int
        """
        return self._get_property("tc")

    @tc.setter
    def tc(self, value):
        """tc setter

        Traffic class in bits.

        value: int
        """
        self._set_property("tc", value)

    @property
    def s_bit(self):
        # type: () -> bool
        """s_bit getter

        Bottom-of-Stack bit.

        Returns: bool
        """
        return self._get_property("s_bit")

    @s_bit.setter
    def s_bit(self, value):
        """s_bit setter

        Bottom-of-Stack bit.

        value: bool
        """
        self._set_property("s_bit", value)

    @property
    def ttl(self):
        # type: () -> int
        """ttl getter

        Time To Live.

        Returns: int
        """
        return self._get_property("ttl")

    @ttl.setter
    def ttl(self, value):
        """ttl setter

        Time To Live.

        value: int
        """
        self._set_property("ttl", value)


class BgpSrteSegmentDTypeSubTlv(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "flags": {
            "type": str,
            "format": "hex",
        },
        "sr_algorithm": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "ipv6_node_address": {
            "type": str,
            "format": "ipv6",
        },
        "sr_mpls_sid": {"type": "BgpSrteSrMplsSid"},
    }  # type: Dict[str, str]

    _REQUIRED = ("ipv6_node_address",)  # type: tuple(str)

    _DEFAULTS = {
        "sr_algorithm": 0,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, flags=None, sr_algorithm=0, ipv6_node_address=None):
        super(BgpSrteSegmentDTypeSubTlv, self).__init__()
        self._parent = parent
        self._set_property("flags", flags)
        self._set_property("sr_algorithm", sr_algorithm)
        self._set_property("ipv6_node_address", ipv6_node_address)

    def set(self, flags=None, sr_algorithm=None, ipv6_node_address=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def flags(self):
        # type: () -> str
        """flags getter

        One octet bitmap for flags including V-Flag, A-Flag, S-Flag, B-Flag etc. as defined in https://datatracker.ietf.org/doc/html/draft-ietf-idr-segment-routing-te-policy-13#section-2.4.4.2.12

        Returns: str
        """
        return self._get_property("flags")

    @flags.setter
    def flags(self, value):
        """flags setter

        One octet bitmap for flags including V-Flag, A-Flag, S-Flag, B-Flag etc. as defined in https://datatracker.ietf.org/doc/html/draft-ietf-idr-segment-routing-te-policy-13#section-2.4.4.2.12

        value: str
        """
        self._set_property("flags", value)

    @property
    def sr_algorithm(self):
        # type: () -> int
        """sr_algorithm getter

        specifying SR Algorithm when when A-Flag as defined in above flags.

        Returns: int
        """
        return self._get_property("sr_algorithm")

    @sr_algorithm.setter
    def sr_algorithm(self, value):
        """sr_algorithm setter

        specifying SR Algorithm when when A-Flag as defined in above flags.

        value: int
        """
        self._set_property("sr_algorithm", value)

    @property
    def ipv6_node_address(self):
        # type: () -> str
        """ipv6_node_address getter

        IPv6 address representing node.

        Returns: str
        """
        return self._get_property("ipv6_node_address")

    @ipv6_node_address.setter
    def ipv6_node_address(self, value):
        """ipv6_node_address setter

        IPv6 address representing node.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property ipv6_node_address as None")
        self._set_property("ipv6_node_address", value)

    @property
    def sr_mpls_sid(self):
        # type: () -> BgpSrteSrMplsSid
        """sr_mpls_sid getter

        Configuration for SR-MPLS with Label, TC, Bottom-of-Stack and TTL.Configuration for SR-MPLS with Label, TC, Bottom-of-Stack and TTL.Configuration for SR-MPLS with Label, TC, Bottom-of-Stack and TTL.Optional SR-MPLS SID.

        Returns: BgpSrteSrMplsSid
        """
        return self._get_property("sr_mpls_sid", BgpSrteSrMplsSid)


class BgpSrteSegmentETypeSubTlv(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "flags": {
            "type": str,
            "format": "hex",
        },
        "local_interface_id": {
            "type": int,
            "format": "uint32",
        },
        "ipv4_node_address": {
            "type": str,
            "format": "ipv4",
        },
        "sr_mpls_sid": {"type": "BgpSrteSrMplsSid"},
    }  # type: Dict[str, str]

    _REQUIRED = ("ipv4_node_address",)  # type: tuple(str)

    _DEFAULTS = {
        "local_interface_id": 0,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self, parent=None, flags=None, local_interface_id=0, ipv4_node_address=None
    ):
        super(BgpSrteSegmentETypeSubTlv, self).__init__()
        self._parent = parent
        self._set_property("flags", flags)
        self._set_property("local_interface_id", local_interface_id)
        self._set_property("ipv4_node_address", ipv4_node_address)

    def set(self, flags=None, local_interface_id=None, ipv4_node_address=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def flags(self):
        # type: () -> str
        """flags getter

        One octet bitmap for flags including V-Flag, A-Flag, S-Flag, B-Flag etc. as defined in https://datatracker.ietf.org/doc/html/draft-ietf-idr-segment-routing-te-policy-13#section-2.4.4.2.12

        Returns: str
        """
        return self._get_property("flags")

    @flags.setter
    def flags(self, value):
        """flags setter

        One octet bitmap for flags including V-Flag, A-Flag, S-Flag, B-Flag etc. as defined in https://datatracker.ietf.org/doc/html/draft-ietf-idr-segment-routing-te-policy-13#section-2.4.4.2.12

        value: str
        """
        self._set_property("flags", value)

    @property
    def local_interface_id(self):
        # type: () -> int
        """local_interface_id getter

        Local Interface ID: The Interface Index as defined in [RFC8664].

        Returns: int
        """
        return self._get_property("local_interface_id")

    @local_interface_id.setter
    def local_interface_id(self, value):
        """local_interface_id setter

        Local Interface ID: The Interface Index as defined in [RFC8664].

        value: int
        """
        self._set_property("local_interface_id", value)

    @property
    def ipv4_node_address(self):
        # type: () -> str
        """ipv4_node_address getter

        IPv4 address representing node.

        Returns: str
        """
        return self._get_property("ipv4_node_address")

    @ipv4_node_address.setter
    def ipv4_node_address(self, value):
        """ipv4_node_address setter

        IPv4 address representing node.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property ipv4_node_address as None")
        self._set_property("ipv4_node_address", value)

    @property
    def sr_mpls_sid(self):
        # type: () -> BgpSrteSrMplsSid
        """sr_mpls_sid getter

        Configuration for SR-MPLS with Label, TC, Bottom-of-Stack and TTL.Configuration for SR-MPLS with Label, TC, Bottom-of-Stack and TTL.Configuration for SR-MPLS with Label, TC, Bottom-of-Stack and TTL.Optional SR-MPLS SID.

        Returns: BgpSrteSrMplsSid
        """
        return self._get_property("sr_mpls_sid", BgpSrteSrMplsSid)


class BgpSrteSegmentFTypeSubTlv(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "flags": {
            "type": str,
            "format": "hex",
        },
        "local_ipv4_address": {
            "type": str,
            "format": "ipv4",
        },
        "remote_ipv4_address": {
            "type": str,
            "format": "ipv4",
        },
        "sr_mpls_sid": {"type": "BgpSrteSrMplsSid"},
    }  # type: Dict[str, str]

    _REQUIRED = ("local_ipv4_address", "remote_ipv4_address")  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self, parent=None, flags=None, local_ipv4_address=None, remote_ipv4_address=None
    ):
        super(BgpSrteSegmentFTypeSubTlv, self).__init__()
        self._parent = parent
        self._set_property("flags", flags)
        self._set_property("local_ipv4_address", local_ipv4_address)
        self._set_property("remote_ipv4_address", remote_ipv4_address)

    def set(self, flags=None, local_ipv4_address=None, remote_ipv4_address=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def flags(self):
        # type: () -> str
        """flags getter

        One octet bitmap for flags including V-Flag, A-Flag, S-Flag, B-Flag etc. as defined in https://datatracker.ietf.org/doc/html/draft-ietf-idr-segment-routing-te-policy-13#section-2.4.4.2.12

        Returns: str
        """
        return self._get_property("flags")

    @flags.setter
    def flags(self, value):
        """flags setter

        One octet bitmap for flags including V-Flag, A-Flag, S-Flag, B-Flag etc. as defined in https://datatracker.ietf.org/doc/html/draft-ietf-idr-segment-routing-te-policy-13#section-2.4.4.2.12

        value: str
        """
        self._set_property("flags", value)

    @property
    def local_ipv4_address(self):
        # type: () -> str
        """local_ipv4_address getter

        Local IPv4 Address.

        Returns: str
        """
        return self._get_property("local_ipv4_address")

    @local_ipv4_address.setter
    def local_ipv4_address(self, value):
        """local_ipv4_address setter

        Local IPv4 Address.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property local_ipv4_address as None")
        self._set_property("local_ipv4_address", value)

    @property
    def remote_ipv4_address(self):
        # type: () -> str
        """remote_ipv4_address getter

        Remote IPv4 Address.

        Returns: str
        """
        return self._get_property("remote_ipv4_address")

    @remote_ipv4_address.setter
    def remote_ipv4_address(self, value):
        """remote_ipv4_address setter

        Remote IPv4 Address.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property remote_ipv4_address as None")
        self._set_property("remote_ipv4_address", value)

    @property
    def sr_mpls_sid(self):
        # type: () -> BgpSrteSrMplsSid
        """sr_mpls_sid getter

        Configuration for SR-MPLS with Label, TC, Bottom-of-Stack and TTL.Configuration for SR-MPLS with Label, TC, Bottom-of-Stack and TTL.Configuration for SR-MPLS with Label, TC, Bottom-of-Stack and TTL.Optional SR-MPLS SID.

        Returns: BgpSrteSrMplsSid
        """
        return self._get_property("sr_mpls_sid", BgpSrteSrMplsSid)


class BgpSrteSegmentGTypeSubTlv(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "flags": {
            "type": str,
            "format": "hex",
        },
        "local_interface_id": {
            "type": int,
            "format": "uint32",
        },
        "local_ipv6_node_address": {
            "type": str,
            "format": "ipv6",
        },
        "remote_interface_id": {
            "type": int,
            "format": "uint32",
        },
        "remote_ipv6_node_address": {
            "type": str,
            "format": "ipv6",
        },
        "sr_mpls_sid": {"type": "BgpSrteSrMplsSid"},
    }  # type: Dict[str, str]

    _REQUIRED = (
        "local_ipv6_node_address",
        "remote_ipv6_node_address",
    )  # type: tuple(str)

    _DEFAULTS = {
        "local_interface_id": 0,
        "remote_interface_id": 0,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        flags=None,
        local_interface_id=0,
        local_ipv6_node_address=None,
        remote_interface_id=0,
        remote_ipv6_node_address=None,
    ):
        super(BgpSrteSegmentGTypeSubTlv, self).__init__()
        self._parent = parent
        self._set_property("flags", flags)
        self._set_property("local_interface_id", local_interface_id)
        self._set_property("local_ipv6_node_address", local_ipv6_node_address)
        self._set_property("remote_interface_id", remote_interface_id)
        self._set_property("remote_ipv6_node_address", remote_ipv6_node_address)

    def set(
        self,
        flags=None,
        local_interface_id=None,
        local_ipv6_node_address=None,
        remote_interface_id=None,
        remote_ipv6_node_address=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def flags(self):
        # type: () -> str
        """flags getter

        One octet bitmap for flags including V-Flag, A-Flag, S-Flag, B-Flag etc. as defined in https://datatracker.ietf.org/doc/html/draft-ietf-idr-segment-routing-te-policy-13#section-2.4.4.2.12

        Returns: str
        """
        return self._get_property("flags")

    @flags.setter
    def flags(self, value):
        """flags setter

        One octet bitmap for flags including V-Flag, A-Flag, S-Flag, B-Flag etc. as defined in https://datatracker.ietf.org/doc/html/draft-ietf-idr-segment-routing-te-policy-13#section-2.4.4.2.12

        value: str
        """
        self._set_property("flags", value)

    @property
    def local_interface_id(self):
        # type: () -> int
        """local_interface_id getter

        Local Interface ID: The Interface Index as defined in [RFC8664].

        Returns: int
        """
        return self._get_property("local_interface_id")

    @local_interface_id.setter
    def local_interface_id(self, value):
        """local_interface_id setter

        Local Interface ID: The Interface Index as defined in [RFC8664].

        value: int
        """
        self._set_property("local_interface_id", value)

    @property
    def local_ipv6_node_address(self):
        # type: () -> str
        """local_ipv6_node_address getter

        IPv6 address representing node.

        Returns: str
        """
        return self._get_property("local_ipv6_node_address")

    @local_ipv6_node_address.setter
    def local_ipv6_node_address(self, value):
        """local_ipv6_node_address setter

        IPv6 address representing node.

        value: str
        """
        if value is None:
            raise TypeError(
                "Cannot set required property local_ipv6_node_address as None"
            )
        self._set_property("local_ipv6_node_address", value)

    @property
    def remote_interface_id(self):
        # type: () -> int
        """remote_interface_id getter

        Local Interface ID: The Interface Index as defined in [RFC8664].

        Returns: int
        """
        return self._get_property("remote_interface_id")

    @remote_interface_id.setter
    def remote_interface_id(self, value):
        """remote_interface_id setter

        Local Interface ID: The Interface Index as defined in [RFC8664].

        value: int
        """
        self._set_property("remote_interface_id", value)

    @property
    def remote_ipv6_node_address(self):
        # type: () -> str
        """remote_ipv6_node_address getter

        IPv6 address representing node.

        Returns: str
        """
        return self._get_property("remote_ipv6_node_address")

    @remote_ipv6_node_address.setter
    def remote_ipv6_node_address(self, value):
        """remote_ipv6_node_address setter

        IPv6 address representing node.

        value: str
        """
        if value is None:
            raise TypeError(
                "Cannot set required property remote_ipv6_node_address as None"
            )
        self._set_property("remote_ipv6_node_address", value)

    @property
    def sr_mpls_sid(self):
        # type: () -> BgpSrteSrMplsSid
        """sr_mpls_sid getter

        Configuration for SR-MPLS with Label, TC, Bottom-of-Stack and TTL.Configuration for SR-MPLS with Label, TC, Bottom-of-Stack and TTL.Configuration for SR-MPLS with Label, TC, Bottom-of-Stack and TTL.Optional SR-MPLS SID.

        Returns: BgpSrteSrMplsSid
        """
        return self._get_property("sr_mpls_sid", BgpSrteSrMplsSid)


class BgpSrteSegmentHTypeSubTlv(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "flags": {
            "type": str,
            "format": "hex",
        },
        "local_ipv6_address": {
            "type": str,
            "format": "ipv6",
        },
        "remote_ipv6_address": {
            "type": str,
            "format": "ipv6",
        },
        "sr_mpls_sid": {"type": "BgpSrteSrMplsSid"},
    }  # type: Dict[str, str]

    _REQUIRED = ("local_ipv6_address", "remote_ipv6_address")  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self, parent=None, flags=None, local_ipv6_address=None, remote_ipv6_address=None
    ):
        super(BgpSrteSegmentHTypeSubTlv, self).__init__()
        self._parent = parent
        self._set_property("flags", flags)
        self._set_property("local_ipv6_address", local_ipv6_address)
        self._set_property("remote_ipv6_address", remote_ipv6_address)

    def set(self, flags=None, local_ipv6_address=None, remote_ipv6_address=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def flags(self):
        # type: () -> str
        """flags getter

        One octet bitmap for flags including V-Flag, A-Flag, S-Flag, B-Flag etc. as defined in https://datatracker.ietf.org/doc/html/draft-ietf-idr-segment-routing-te-policy-13#section-2.4.4.2.12

        Returns: str
        """
        return self._get_property("flags")

    @flags.setter
    def flags(self, value):
        """flags setter

        One octet bitmap for flags including V-Flag, A-Flag, S-Flag, B-Flag etc. as defined in https://datatracker.ietf.org/doc/html/draft-ietf-idr-segment-routing-te-policy-13#section-2.4.4.2.12

        value: str
        """
        self._set_property("flags", value)

    @property
    def local_ipv6_address(self):
        # type: () -> str
        """local_ipv6_address getter

        Local IPv6 Address.

        Returns: str
        """
        return self._get_property("local_ipv6_address")

    @local_ipv6_address.setter
    def local_ipv6_address(self, value):
        """local_ipv6_address setter

        Local IPv6 Address.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property local_ipv6_address as None")
        self._set_property("local_ipv6_address", value)

    @property
    def remote_ipv6_address(self):
        # type: () -> str
        """remote_ipv6_address getter

        Remote IPv6 Address.

        Returns: str
        """
        return self._get_property("remote_ipv6_address")

    @remote_ipv6_address.setter
    def remote_ipv6_address(self, value):
        """remote_ipv6_address setter

        Remote IPv6 Address.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property remote_ipv6_address as None")
        self._set_property("remote_ipv6_address", value)

    @property
    def sr_mpls_sid(self):
        # type: () -> BgpSrteSrMplsSid
        """sr_mpls_sid getter

        Configuration for SR-MPLS with Label, TC, Bottom-of-Stack and TTL.Configuration for SR-MPLS with Label, TC, Bottom-of-Stack and TTL.Configuration for SR-MPLS with Label, TC, Bottom-of-Stack and TTL.Optional SR-MPLS SID.

        Returns: BgpSrteSrMplsSid
        """
        return self._get_property("sr_mpls_sid", BgpSrteSrMplsSid)


class BgpSrteSegmentITypeSubTlv(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "flags": {
            "type": str,
            "format": "hex",
        },
        "ipv6_node_address": {
            "type": str,
            "format": "ipv6",
        },
        "srv6_sid": {
            "type": str,
            "format": "ipv6",
        },
        "srv6_sid_endpoint_behavior": {
            "type": "BgpSrteSRv6SIDEndpointBehaviorAndStructure"
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("ipv6_node_address",)  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, flags=None, ipv6_node_address=None, srv6_sid=None):
        super(BgpSrteSegmentITypeSubTlv, self).__init__()
        self._parent = parent
        self._set_property("flags", flags)
        self._set_property("ipv6_node_address", ipv6_node_address)
        self._set_property("srv6_sid", srv6_sid)

    def set(self, flags=None, ipv6_node_address=None, srv6_sid=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def flags(self):
        # type: () -> str
        """flags getter

        One octet bitmap for flags including V-Flag, A-Flag, S-Flag, B-Flag etc. as defined in https://datatracker.ietf.org/doc/html/draft-ietf-idr-segment-routing-te-policy-13#section-2.4.4.2.12

        Returns: str
        """
        return self._get_property("flags")

    @flags.setter
    def flags(self, value):
        """flags setter

        One octet bitmap for flags including V-Flag, A-Flag, S-Flag, B-Flag etc. as defined in https://datatracker.ietf.org/doc/html/draft-ietf-idr-segment-routing-te-policy-13#section-2.4.4.2.12

        value: str
        """
        self._set_property("flags", value)

    @property
    def ipv6_node_address(self):
        # type: () -> str
        """ipv6_node_address getter

        IPv6 address representing node.

        Returns: str
        """
        return self._get_property("ipv6_node_address")

    @ipv6_node_address.setter
    def ipv6_node_address(self, value):
        """ipv6_node_address setter

        IPv6 address representing node.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property ipv6_node_address as None")
        self._set_property("ipv6_node_address", value)

    @property
    def srv6_sid(self):
        # type: () -> str
        """srv6_sid getter

        Optional SRv6 SID.

        Returns: str
        """
        return self._get_property("srv6_sid")

    @srv6_sid.setter
    def srv6_sid(self, value):
        """srv6_sid setter

        Optional SRv6 SID.

        value: str
        """
        self._set_property("srv6_sid", value)

    @property
    def srv6_sid_endpoint_behavior(self):
        # type: () -> BgpSrteSRv6SIDEndpointBehaviorAndStructure
        """srv6_sid_endpoint_behavior getter

        Configuration for SRv6 Endpoint Behavior and SID Structure. Its optional. Summation of lengths for Locator Block, Locator Node, Function, and Argument MUST be less than or equal to 128.Configuration for SRv6 Endpoint Behavior and SID Structure. Its optional. Summation of lengths for Locator Block, Locator Node, Function, and Argument MUST be less than or equal to 128.Configuration for SRv6 Endpoint Behavior and SID Structure. Its optional. Summation of lengths for Locator Block, Locator Node, Function, and Argument MUST be less than or equal to 128.Optional SRv6 Endpoint Behavior and SID Structure.

        Returns: BgpSrteSRv6SIDEndpointBehaviorAndStructure
        """
        return self._get_property(
            "srv6_sid_endpoint_behavior", BgpSrteSRv6SIDEndpointBehaviorAndStructure
        )


class BgpSrteSegmentJTypeSubTlv(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "flags": {
            "type": str,
            "format": "hex",
        },
        "sr_algorithm": {
            "type": int,
            "format": "uint32",
        },
        "local_interface_id": {
            "type": int,
            "format": "uint32",
        },
        "local_ipv6_node_address": {
            "type": str,
            "format": "ipv6",
        },
        "remote_interface_id": {
            "type": int,
            "format": "uint32",
        },
        "remote_ipv6_node_address": {
            "type": str,
            "format": "ipv6",
        },
        "srv6_sid": {
            "type": str,
            "format": "ipv6",
        },
        "srv6_sid_endpoint_behavior": {
            "type": "BgpSrteSRv6SIDEndpointBehaviorAndStructure"
        },
    }  # type: Dict[str, str]

    _REQUIRED = (
        "local_ipv6_node_address",
        "remote_ipv6_node_address",
    )  # type: tuple(str)

    _DEFAULTS = {
        "sr_algorithm": 0,
        "local_interface_id": 0,
        "remote_interface_id": 0,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        flags=None,
        sr_algorithm=0,
        local_interface_id=0,
        local_ipv6_node_address=None,
        remote_interface_id=0,
        remote_ipv6_node_address=None,
        srv6_sid=None,
    ):
        super(BgpSrteSegmentJTypeSubTlv, self).__init__()
        self._parent = parent
        self._set_property("flags", flags)
        self._set_property("sr_algorithm", sr_algorithm)
        self._set_property("local_interface_id", local_interface_id)
        self._set_property("local_ipv6_node_address", local_ipv6_node_address)
        self._set_property("remote_interface_id", remote_interface_id)
        self._set_property("remote_ipv6_node_address", remote_ipv6_node_address)
        self._set_property("srv6_sid", srv6_sid)

    def set(
        self,
        flags=None,
        sr_algorithm=None,
        local_interface_id=None,
        local_ipv6_node_address=None,
        remote_interface_id=None,
        remote_ipv6_node_address=None,
        srv6_sid=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def flags(self):
        # type: () -> str
        """flags getter

        One octet bitmap for flags including V-Flag, A-Flag, S-Flag, B-Flag etc. as defined in https://datatracker.ietf.org/doc/html/draft-ietf-idr-segment-routing-te-policy-13#section-2.4.4.2.12

        Returns: str
        """
        return self._get_property("flags")

    @flags.setter
    def flags(self, value):
        """flags setter

        One octet bitmap for flags including V-Flag, A-Flag, S-Flag, B-Flag etc. as defined in https://datatracker.ietf.org/doc/html/draft-ietf-idr-segment-routing-te-policy-13#section-2.4.4.2.12

        value: str
        """
        self._set_property("flags", value)

    @property
    def sr_algorithm(self):
        # type: () -> int
        """sr_algorithm getter

        SR Algorithm identifier when A-Flag in on.

        Returns: int
        """
        return self._get_property("sr_algorithm")

    @sr_algorithm.setter
    def sr_algorithm(self, value):
        """sr_algorithm setter

        SR Algorithm identifier when A-Flag in on.

        value: int
        """
        self._set_property("sr_algorithm", value)

    @property
    def local_interface_id(self):
        # type: () -> int
        """local_interface_id getter

        Local Interface ID: The Interface Index as defined in [RFC8664].

        Returns: int
        """
        return self._get_property("local_interface_id")

    @local_interface_id.setter
    def local_interface_id(self, value):
        """local_interface_id setter

        Local Interface ID: The Interface Index as defined in [RFC8664].

        value: int
        """
        self._set_property("local_interface_id", value)

    @property
    def local_ipv6_node_address(self):
        # type: () -> str
        """local_ipv6_node_address getter

        IPv6 address representing node.

        Returns: str
        """
        return self._get_property("local_ipv6_node_address")

    @local_ipv6_node_address.setter
    def local_ipv6_node_address(self, value):
        """local_ipv6_node_address setter

        IPv6 address representing node.

        value: str
        """
        if value is None:
            raise TypeError(
                "Cannot set required property local_ipv6_node_address as None"
            )
        self._set_property("local_ipv6_node_address", value)

    @property
    def remote_interface_id(self):
        # type: () -> int
        """remote_interface_id getter

        Local Interface ID: The Interface Index as defined in [RFC8664].

        Returns: int
        """
        return self._get_property("remote_interface_id")

    @remote_interface_id.setter
    def remote_interface_id(self, value):
        """remote_interface_id setter

        Local Interface ID: The Interface Index as defined in [RFC8664].

        value: int
        """
        self._set_property("remote_interface_id", value)

    @property
    def remote_ipv6_node_address(self):
        # type: () -> str
        """remote_ipv6_node_address getter

        IPv6 address representing node.

        Returns: str
        """
        return self._get_property("remote_ipv6_node_address")

    @remote_ipv6_node_address.setter
    def remote_ipv6_node_address(self, value):
        """remote_ipv6_node_address setter

        IPv6 address representing node.

        value: str
        """
        if value is None:
            raise TypeError(
                "Cannot set required property remote_ipv6_node_address as None"
            )
        self._set_property("remote_ipv6_node_address", value)

    @property
    def srv6_sid(self):
        # type: () -> str
        """srv6_sid getter

        Optional SRv6 SID.

        Returns: str
        """
        return self._get_property("srv6_sid")

    @srv6_sid.setter
    def srv6_sid(self, value):
        """srv6_sid setter

        Optional SRv6 SID.

        value: str
        """
        self._set_property("srv6_sid", value)

    @property
    def srv6_sid_endpoint_behavior(self):
        # type: () -> BgpSrteSRv6SIDEndpointBehaviorAndStructure
        """srv6_sid_endpoint_behavior getter

        Configuration for SRv6 Endpoint Behavior and SID Structure. Its optional. Summation of lengths for Locator Block, Locator Node, Function, and Argument MUST be less than or equal to 128.Configuration for SRv6 Endpoint Behavior and SID Structure. Its optional. Summation of lengths for Locator Block, Locator Node, Function, and Argument MUST be less than or equal to 128.Configuration for SRv6 Endpoint Behavior and SID Structure. Its optional. Summation of lengths for Locator Block, Locator Node, Function, and Argument MUST be less than or equal to 128.Optional SRv6 Endpoint Behavior and SID Structure.

        Returns: BgpSrteSRv6SIDEndpointBehaviorAndStructure
        """
        return self._get_property(
            "srv6_sid_endpoint_behavior", BgpSrteSRv6SIDEndpointBehaviorAndStructure
        )


class BgpSrteSegmentKTypeSubTlv(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "flags": {
            "type": str,
            "format": "hex",
        },
        "sr_algorithm": {
            "type": int,
            "format": "uint32",
        },
        "local_ipv6_address": {
            "type": str,
            "format": "ipv6",
        },
        "remote_ipv6_address": {
            "type": str,
            "format": "ipv6",
        },
        "srv6_sid": {
            "type": str,
            "format": "ipv6",
        },
        "srv6_sid_endpoint_behavior": {
            "type": "BgpSrteSRv6SIDEndpointBehaviorAndStructure"
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("local_ipv6_address", "remote_ipv6_address")  # type: tuple(str)

    _DEFAULTS = {
        "sr_algorithm": 0,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        flags=None,
        sr_algorithm=0,
        local_ipv6_address=None,
        remote_ipv6_address=None,
        srv6_sid=None,
    ):
        super(BgpSrteSegmentKTypeSubTlv, self).__init__()
        self._parent = parent
        self._set_property("flags", flags)
        self._set_property("sr_algorithm", sr_algorithm)
        self._set_property("local_ipv6_address", local_ipv6_address)
        self._set_property("remote_ipv6_address", remote_ipv6_address)
        self._set_property("srv6_sid", srv6_sid)

    def set(
        self,
        flags=None,
        sr_algorithm=None,
        local_ipv6_address=None,
        remote_ipv6_address=None,
        srv6_sid=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def flags(self):
        # type: () -> str
        """flags getter

        One octet bitmap for flags including V-Flag, A-Flag, S-Flag, B-Flag etc. as defined in https://datatracker.ietf.org/doc/html/draft-ietf-idr-segment-routing-te-policy-13#section-2.4.4.2.12

        Returns: str
        """
        return self._get_property("flags")

    @flags.setter
    def flags(self, value):
        """flags setter

        One octet bitmap for flags including V-Flag, A-Flag, S-Flag, B-Flag etc. as defined in https://datatracker.ietf.org/doc/html/draft-ietf-idr-segment-routing-te-policy-13#section-2.4.4.2.12

        value: str
        """
        self._set_property("flags", value)

    @property
    def sr_algorithm(self):
        # type: () -> int
        """sr_algorithm getter

        SR Algorithm identifier when A-Flag in on.

        Returns: int
        """
        return self._get_property("sr_algorithm")

    @sr_algorithm.setter
    def sr_algorithm(self, value):
        """sr_algorithm setter

        SR Algorithm identifier when A-Flag in on.

        value: int
        """
        self._set_property("sr_algorithm", value)

    @property
    def local_ipv6_address(self):
        # type: () -> str
        """local_ipv6_address getter

        IPv6 address representing node.

        Returns: str
        """
        return self._get_property("local_ipv6_address")

    @local_ipv6_address.setter
    def local_ipv6_address(self, value):
        """local_ipv6_address setter

        IPv6 address representing node.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property local_ipv6_address as None")
        self._set_property("local_ipv6_address", value)

    @property
    def remote_ipv6_address(self):
        # type: () -> str
        """remote_ipv6_address getter

        IPv6 address representing node.

        Returns: str
        """
        return self._get_property("remote_ipv6_address")

    @remote_ipv6_address.setter
    def remote_ipv6_address(self, value):
        """remote_ipv6_address setter

        IPv6 address representing node.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property remote_ipv6_address as None")
        self._set_property("remote_ipv6_address", value)

    @property
    def srv6_sid(self):
        # type: () -> str
        """srv6_sid getter

        Optional SRv6 SID.

        Returns: str
        """
        return self._get_property("srv6_sid")

    @srv6_sid.setter
    def srv6_sid(self, value):
        """srv6_sid setter

        Optional SRv6 SID.

        value: str
        """
        self._set_property("srv6_sid", value)

    @property
    def srv6_sid_endpoint_behavior(self):
        # type: () -> BgpSrteSRv6SIDEndpointBehaviorAndStructure
        """srv6_sid_endpoint_behavior getter

        Configuration for SRv6 Endpoint Behavior and SID Structure. Its optional. Summation of lengths for Locator Block, Locator Node, Function, and Argument MUST be less than or equal to 128.Configuration for SRv6 Endpoint Behavior and SID Structure. Its optional. Summation of lengths for Locator Block, Locator Node, Function, and Argument MUST be less than or equal to 128.Configuration for SRv6 Endpoint Behavior and SID Structure. Its optional. Summation of lengths for Locator Block, Locator Node, Function, and Argument MUST be less than or equal to 128.Optional SRv6 Endpoint Behavior and SID Structure.

        Returns: BgpSrteSRv6SIDEndpointBehaviorAndStructure
        """
        return self._get_property(
            "srv6_sid_endpoint_behavior", BgpSrteSRv6SIDEndpointBehaviorAndStructure
        )


class BgpSrteSegmentIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(BgpSrteSegmentIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[BgpSrteSegment]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> BgpSrteSegmentIter
        return self._iter()

    def __next__(self):
        # type: () -> BgpSrteSegment
        return self._next()

    def next(self):
        # type: () -> BgpSrteSegment
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, BgpSrteSegment):
            raise Exception("Item is not an instance of BgpSrteSegment")

    def segment(self, segment_type=None, name=None, active=True):
        # type: (Union[Literal["type_a"], Literal["type_b"], Literal["type_c"], Literal["type_d"], Literal["type_e"], Literal["type_f"], Literal["type_g"], Literal["type_h"], Literal["type_i"], Literal["type_j"], Literal["type_k"]],str,bool) -> BgpSrteSegmentIter
        """Factory method that creates an instance of the BgpSrteSegment class

        A Segment sub-TLV describes single segment in segment list i.e., single element of the explicit path. The Segment sub-TLVs are optional.

        Returns: BgpSrteSegmentIter
        """
        item = BgpSrteSegment(
            parent=self._parent, segment_type=segment_type, name=name, active=active
        )
        self._add(item)
        return self

    def add(self, segment_type=None, name=None, active=True):
        # type: (Union[Literal["type_a"], Literal["type_b"], Literal["type_c"], Literal["type_d"], Literal["type_e"], Literal["type_f"], Literal["type_g"], Literal["type_h"], Literal["type_i"], Literal["type_j"], Literal["type_k"]],str,bool) -> BgpSrteSegment
        """Add method that creates and returns an instance of the BgpSrteSegment class

        A Segment sub-TLV describes single segment in segment list i.e., single element of the explicit path. The Segment sub-TLVs are optional.

        Returns: BgpSrteSegment
        """
        item = BgpSrteSegment(
            parent=self._parent, segment_type=segment_type, name=name, active=active
        )
        self._add(item)
        return item


class BgpSrteSegmentListIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(BgpSrteSegmentListIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[BgpSrteSegmentList]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> BgpSrteSegmentListIter
        return self._iter()

    def __next__(self):
        # type: () -> BgpSrteSegmentList
        return self._next()

    def next(self):
        # type: () -> BgpSrteSegmentList
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, BgpSrteSegmentList):
            raise Exception("Item is not an instance of BgpSrteSegmentList")

    def segmentlist(self, weight=0, name=None, active=True):
        # type: (int,str,bool) -> BgpSrteSegmentListIter
        """Factory method that creates an instance of the BgpSrteSegmentList class

        Optional configuration for BGP SR TE Policy segment list. The Segment List sub-TLV encodes single explicit path towards the Endpoint.

        Returns: BgpSrteSegmentListIter
        """
        item = BgpSrteSegmentList(
            parent=self._parent, weight=weight, name=name, active=active
        )
        self._add(item)
        return self

    def add(self, weight=0, name=None, active=True):
        # type: (int,str,bool) -> BgpSrteSegmentList
        """Add method that creates and returns an instance of the BgpSrteSegmentList class

        Optional configuration for BGP SR TE Policy segment list. The Segment List sub-TLV encodes single explicit path towards the Endpoint.

        Returns: BgpSrteSegmentList
        """
        item = BgpSrteSegmentList(
            parent=self._parent, weight=weight, name=name, active=active
        )
        self._add(item)
        return item


class BgpSrteV4TunnelTlvIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(BgpSrteV4TunnelTlvIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[BgpSrteV4TunnelTlv]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> BgpSrteV4TunnelTlvIter
        return self._iter()

    def __next__(self):
        # type: () -> BgpSrteV4TunnelTlv
        return self._next()

    def next(self):
        # type: () -> BgpSrteV4TunnelTlv
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, BgpSrteV4TunnelTlv):
            raise Exception("Item is not an instance of BgpSrteV4TunnelTlv")

    def v4tunneltlv(self, name=None, active=True):
        # type: (str,bool) -> BgpSrteV4TunnelTlvIter
        """Factory method that creates an instance of the BgpSrteV4TunnelTlv class

        Configuration for BGP SRTE Tunnel TLV.

        Returns: BgpSrteV4TunnelTlvIter
        """
        item = BgpSrteV4TunnelTlv(parent=self._parent, name=name, active=active)
        self._add(item)
        return self

    def add(self, name=None, active=True):
        # type: (str,bool) -> BgpSrteV4TunnelTlv
        """Add method that creates and returns an instance of the BgpSrteV4TunnelTlv class

        Configuration for BGP SRTE Tunnel TLV.

        Returns: BgpSrteV4TunnelTlv
        """
        item = BgpSrteV4TunnelTlv(parent=self._parent, name=name, active=active)
        self._add(item)
        return item


class BgpSrteV4PolicyIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(BgpSrteV4PolicyIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[BgpSrteV4Policy]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> BgpSrteV4PolicyIter
        return self._iter()

    def __next__(self):
        # type: () -> BgpSrteV4Policy
        return self._next()

    def next(self):
        # type: () -> BgpSrteV4Policy
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, BgpSrteV4Policy):
            raise Exception("Item is not an instance of BgpSrteV4Policy")

    def v4policy(
        self,
        distinguisher=1,
        color=100,
        ipv4_endpoint=None,
        next_hop_mode="local_ip",
        next_hop_address_type="ipv4",
        next_hop_ipv4_address=None,
        next_hop_ipv6_address=None,
        name=None,
        active=True,
    ):
        # type: (int,int,str,Union[Literal["local_ip"], Literal["manual"]],Union[Literal["ipv4"], Literal["ipv6"]],str,str,str,bool) -> BgpSrteV4PolicyIter
        """Factory method that creates an instance of the BgpSrteV4Policy class

        Configuration for BGP Segment Routing Traffic Engineering(SRTE) policy..

        Returns: BgpSrteV4PolicyIter
        """
        item = BgpSrteV4Policy(
            parent=self._parent,
            distinguisher=distinguisher,
            color=color,
            ipv4_endpoint=ipv4_endpoint,
            next_hop_mode=next_hop_mode,
            next_hop_address_type=next_hop_address_type,
            next_hop_ipv4_address=next_hop_ipv4_address,
            next_hop_ipv6_address=next_hop_ipv6_address,
            name=name,
            active=active,
        )
        self._add(item)
        return self

    def add(
        self,
        distinguisher=1,
        color=100,
        ipv4_endpoint=None,
        next_hop_mode="local_ip",
        next_hop_address_type="ipv4",
        next_hop_ipv4_address=None,
        next_hop_ipv6_address=None,
        name=None,
        active=True,
    ):
        # type: (int,int,str,Union[Literal["local_ip"], Literal["manual"]],Union[Literal["ipv4"], Literal["ipv6"]],str,str,str,bool) -> BgpSrteV4Policy
        """Add method that creates and returns an instance of the BgpSrteV4Policy class

        Configuration for BGP Segment Routing Traffic Engineering(SRTE) policy..

        Returns: BgpSrteV4Policy
        """
        item = BgpSrteV4Policy(
            parent=self._parent,
            distinguisher=distinguisher,
            color=color,
            ipv4_endpoint=ipv4_endpoint,
            next_hop_mode=next_hop_mode,
            next_hop_address_type=next_hop_address_type,
            next_hop_ipv4_address=next_hop_ipv4_address,
            next_hop_ipv6_address=next_hop_ipv6_address,
            name=name,
            active=active,
        )
        self._add(item)
        return item


class BgpSrteV6Policy(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "distinguisher": {
            "type": int,
            "format": "uint32",
        },
        "color": {
            "type": int,
            "format": "uint32",
        },
        "ipv6_endpoint": {
            "type": str,
            "format": "ipv6",
        },
        "next_hop_mode": {
            "type": str,
            "enum": [
                "local_ip",
                "manual",
            ],
        },
        "next_hop_address_type": {
            "type": str,
            "enum": [
                "ipv4",
                "ipv6",
            ],
        },
        "next_hop_ipv4_address": {
            "type": str,
            "format": "ipv4",
        },
        "next_hop_ipv6_address": {
            "type": str,
            "format": "ipv6",
        },
        "advanced": {"type": "BgpRouteAdvanced"},
        "add_path": {"type": "BgpAddPath"},
        "as_path": {"type": "BgpAsPath"},
        "communities": {"type": "BgpCommunityIter"},
        "extcommunities": {"type": "BgpExtCommunityIter"},
        "tunnel_tlvs": {"type": "BgpSrteV6TunnelTlvIter"},
        "name": {"type": str},
        "active": {"type": bool},
    }  # type: Dict[str, str]

    _REQUIRED = ("ipv6_endpoint", "name")  # type: tuple(str)

    _DEFAULTS = {
        "distinguisher": 1,
        "color": 100,
        "next_hop_mode": "local_ip",
        "next_hop_address_type": "ipv6",
        "next_hop_ipv4_address": "0.0.0.0",
        "next_hop_ipv6_address": "::0",
        "active": True,
    }  # type: Dict[str, Union(type)]

    LOCAL_IP = "local_ip"  # type: str
    MANUAL = "manual"  # type: str

    IPV4 = "ipv4"  # type: str
    IPV6 = "ipv6"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        distinguisher=1,
        color=100,
        ipv6_endpoint=None,
        next_hop_mode="local_ip",
        next_hop_address_type="ipv6",
        next_hop_ipv4_address="0.0.0.0",
        next_hop_ipv6_address="::0",
        name=None,
        active=True,
    ):
        super(BgpSrteV6Policy, self).__init__()
        self._parent = parent
        self._set_property("distinguisher", distinguisher)
        self._set_property("color", color)
        self._set_property("ipv6_endpoint", ipv6_endpoint)
        self._set_property("next_hop_mode", next_hop_mode)
        self._set_property("next_hop_address_type", next_hop_address_type)
        self._set_property("next_hop_ipv4_address", next_hop_ipv4_address)
        self._set_property("next_hop_ipv6_address", next_hop_ipv6_address)
        self._set_property("name", name)
        self._set_property("active", active)

    def set(
        self,
        distinguisher=None,
        color=None,
        ipv6_endpoint=None,
        next_hop_mode=None,
        next_hop_address_type=None,
        next_hop_ipv4_address=None,
        next_hop_ipv6_address=None,
        name=None,
        active=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def distinguisher(self):
        # type: () -> int
        """distinguisher getter

        Identifies the policy in the context of (color and endpoint) tuple. It is used by the SR Policy originator to make unique multiple occurrences of the same SR Policy.

        Returns: int
        """
        return self._get_property("distinguisher")

    @distinguisher.setter
    def distinguisher(self, value):
        """distinguisher setter

        Identifies the policy in the context of (color and endpoint) tuple. It is used by the SR Policy originator to make unique multiple occurrences of the same SR Policy.

        value: int
        """
        self._set_property("distinguisher", value)

    @property
    def color(self):
        # type: () -> int
        """color getter

        Identifies the policy. It is used to match the color of the destination prefixes to steer traffic into the SR Policy.

        Returns: int
        """
        return self._get_property("color")

    @color.setter
    def color(self, value):
        """color setter

        Identifies the policy. It is used to match the color of the destination prefixes to steer traffic into the SR Policy.

        value: int
        """
        self._set_property("color", value)

    @property
    def ipv6_endpoint(self):
        # type: () -> str
        """ipv6_endpoint getter

        Specifies single node or set of nodes (e.g., an anycast address). It is selected on the basis of the SR Policy type (AFI).

        Returns: str
        """
        return self._get_property("ipv6_endpoint")

    @ipv6_endpoint.setter
    def ipv6_endpoint(self, value):
        """ipv6_endpoint setter

        Specifies single node or set of nodes (e.g., an anycast address). It is selected on the basis of the SR Policy type (AFI).

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property ipv6_endpoint as None")
        self._set_property("ipv6_endpoint", value)

    @property
    def next_hop_mode(self):
        # type: () -> Union[Literal["local_ip"], Literal["manual"]]
        """next_hop_mode getter

        Mode for choosing the NextHop in MP REACH NLRI. Available modes are Local IP: Automatically fills the Nexthop with the Local IP of the BGP peer. For IPv6 BGP peer the Nexthop Encoding capability should be enabled. Manual: Override the Nexthop with any arbitrary IPv4/IPv6 address.

        Returns: Union[Literal["local_ip"], Literal["manual"]]
        """
        return self._get_property("next_hop_mode")

    @next_hop_mode.setter
    def next_hop_mode(self, value):
        """next_hop_mode setter

        Mode for choosing the NextHop in MP REACH NLRI. Available modes are Local IP: Automatically fills the Nexthop with the Local IP of the BGP peer. For IPv6 BGP peer the Nexthop Encoding capability should be enabled. Manual: Override the Nexthop with any arbitrary IPv4/IPv6 address.

        value: Union[Literal["local_ip"], Literal["manual"]]
        """
        self._set_property("next_hop_mode", value)

    @property
    def next_hop_address_type(self):
        # type: () -> Union[Literal["ipv4"], Literal["ipv6"]]
        """next_hop_address_type getter

        Type of next hop IP address to be used when 'next_hop_mode' is set to 'manual'.

        Returns: Union[Literal["ipv4"], Literal["ipv6"]]
        """
        return self._get_property("next_hop_address_type")

    @next_hop_address_type.setter
    def next_hop_address_type(self, value):
        """next_hop_address_type setter

        Type of next hop IP address to be used when 'next_hop_mode' is set to 'manual'.

        value: Union[Literal["ipv4"], Literal["ipv6"]]
        """
        self._set_property("next_hop_address_type", value)

    @property
    def next_hop_ipv4_address(self):
        # type: () -> str
        """next_hop_ipv4_address getter

        The IPv4 address of the Nexthop if the 'next_hop_mode' is 'manual' and the Nexthop type 'next_hop_address_type' is IPv4. If BGP peer is of type IPv6, Nexthop Encoding capability extended_next_hop_encoding should be enabled.

        Returns: str
        """
        return self._get_property("next_hop_ipv4_address")

    @next_hop_ipv4_address.setter
    def next_hop_ipv4_address(self, value):
        """next_hop_ipv4_address setter

        The IPv4 address of the Nexthop if the 'next_hop_mode' is 'manual' and the Nexthop type 'next_hop_address_type' is IPv4. If BGP peer is of type IPv6, Nexthop Encoding capability extended_next_hop_encoding should be enabled.

        value: str
        """
        self._set_property("next_hop_ipv4_address", value)

    @property
    def next_hop_ipv6_address(self):
        # type: () -> str
        """next_hop_ipv6_address getter

        The IPv6 address of the next hop if the Nexthop Mode 'next_hop_address_type' is 'manual' and the Nexthop type 'next_hop_address_type' is IPv6.

        Returns: str
        """
        return self._get_property("next_hop_ipv6_address")

    @next_hop_ipv6_address.setter
    def next_hop_ipv6_address(self, value):
        """next_hop_ipv6_address setter

        The IPv6 address of the next hop if the Nexthop Mode 'next_hop_address_type' is 'manual' and the Nexthop type 'next_hop_address_type' is IPv6.

        value: str
        """
        self._set_property("next_hop_ipv6_address", value)

    @property
    def advanced(self):
        # type: () -> BgpRouteAdvanced
        """advanced getter

        Configuration for advanced BGP route range settings.Configuration for advanced BGP route range settings.Configuration for advanced BGP route range settings.

        Returns: BgpRouteAdvanced
        """
        return self._get_property("advanced", BgpRouteAdvanced)

    @property
    def add_path(self):
        # type: () -> BgpAddPath
        """add_path getter

        The BGP Additional Paths feature is BGP extension that allows the advertisement of multiple paths for the same prefix without the new paths implicitly replacing any previous paths.The BGP Additional Paths feature is BGP extension that allows the advertisement of multiple paths for the same prefix without the new paths implicitly replacing any previous paths.The BGP Additional Paths feature is BGP extension that allows the advertisement of multiple paths for the same prefix without the new paths implicitly replacing any previous paths.

        Returns: BgpAddPath
        """
        return self._get_property("add_path", BgpAddPath)

    @property
    def as_path(self):
        # type: () -> BgpAsPath
        """as_path getter

        This attribute identifies the autonomous systems through which routing information carried in this UPDATE message has passed. This contains the configuration of how to include the Local AS in the AS path attribute of the MP REACH NLRI. It also contains optional configuration of additional AS Path Segments that can be included in the AS Path attribute. The AS Path consists of Set or Sequence of Autonomous Systems (AS) numbers that routing information passes through to reach the destination.This attribute identifies the autonomous systems through which routing information carried in this UPDATE message has passed. This contains the configuration of how to include the Local AS in the AS path attribute of the MP REACH NLRI. It also contains optional configuration of additional AS Path Segments that can be included in the AS Path attribute. The AS Path consists of Set or Sequence of Autonomous Systems (AS) numbers that routing information passes through to reach the destination.This attribute identifies the autonomous systems through which routing information carried in this UPDATE message has passed. This contains the configuration of how to include the Local AS in the AS path attribute of the MP REACH NLRI. It also contains optional configuration of additional AS Path Segments that can be included in the AS Path attribute. The AS Path consists of Set or Sequence of Autonomous Systems (AS) numbers that routing information passes through to reach the destination.

        Returns: BgpAsPath
        """
        return self._get_property("as_path", BgpAsPath)

    @property
    def communities(self):
        # type: () -> BgpCommunityIter
        """communities getter

        Optional community settings.

        Returns: BgpCommunityIter
        """
        return self._get_property(
            "communities", BgpCommunityIter, self._parent, self._choice
        )

    @property
    def extcommunities(self):
        # type: () -> BgpExtCommunityIter
        """extcommunities getter

        Optional Extended Community settings. The Extended Communities Attribute is transitive optional BGP attribute, with the Type Code 16. Community and Extended Communities attributes are utilized to trigger routing decisions, such as acceptance, rejection, preference, or redistribution. An extended community is an 8-Bytes value. It is divided into two main parts. The first Bytes of the community encode type and sub-type fields and the last Bytes carry unique set of data in format defined by the type and sub-type field. Extended communities provide larger range for grouping or categorizing communities. When type is administrator_as_2octet or administrator_as_4octet, the valid sub types are route target and origin. The valid value for administrator_as_2octet and administrator_as_4octet type is either two byte AS followed by four byte local administrator id or four byte AS followed by two byte local administrator id. When type is administrator_ipv4_address the valid sub types are route target and origin. The valid value for administrator_ipv4_address is four byte IPv4 address followed by two byte local administrator id. When type is opaque, valid sub types are color and encapsulation. When sub type is color, first two bytes of the value field contain flags and last four bytes contains the value of the color. When sub type is encapsulation the first four bytes of value field are reserved and last two bytes carries the tunnel type from IANA's "ETHER TYPES" registry e.g IPv4 (protocol type 0x0800), IPv6 (protocol type 0x86dd), and MPLS (protocol type 0x8847). When type is administrator_as_2octet_link_bandwidth the valid sub type is extended_bandwidth. The first two bytes of the value field contains the AS number and the last four bytes contains the bandwidth in IEEE floating point format. When type is evpn the valid subtype is mac_address. In the value field the low-order bit of the first byte(Flags) is defined as the "Sticky/static" flag and may be set to 1, indicating the MAC address is static and cannot move. The second byte is reserved and the last four bytes contain the sequence number which is used to ensure that PEs retain the correct MAC/IP Advertisement route when multiple updates occur for the same MAC address.

        Returns: BgpExtCommunityIter
        """
        return self._get_property(
            "extcommunities", BgpExtCommunityIter, self._parent, self._choice
        )

    @property
    def tunnel_tlvs(self):
        # type: () -> BgpSrteV6TunnelTlvIter
        """tunnel_tlvs getter

        List of optional tunnel TLV settings.

        Returns: BgpSrteV6TunnelTlvIter
        """
        return self._get_property(
            "tunnel_tlvs", BgpSrteV6TunnelTlvIter, self._parent, self._choice
        )

    @property
    def name(self):
        # type: () -> str
        """name getter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def active(self):
        # type: () -> bool
        """active getter

        If enabled means that this part of the configuration including any active 'children' nodes will be advertised to peer. If disabled, this means that though config is present, it is not taking any part of the test but can be activated at run-time to advertise just this part of the configuration to the peer.

        Returns: bool
        """
        return self._get_property("active")

    @active.setter
    def active(self, value):
        """active setter

        If enabled means that this part of the configuration including any active 'children' nodes will be advertised to peer. If disabled, this means that though config is present, it is not taking any part of the test but can be activated at run-time to advertise just this part of the configuration to the peer.

        value: bool
        """
        self._set_property("active", value)


class BgpSrteV6TunnelTlv(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "remote_endpoint_sub_tlv": {"type": "BgpSrteRemoteEndpointSubTlv"},
        "color_sub_tlv": {"type": "BgpSrteColorSubTlv"},
        "binding_sub_tlv": {"type": "BgpSrteBindingSubTlv"},
        "preference_sub_tlv": {"type": "BgpSrtePreferenceSubTlv"},
        "policy_priority_sub_tlv": {"type": "BgpSrtePolicyPrioritySubTlv"},
        "policy_name_sub_tlv": {"type": "BgpSrtePolicyNameSubTlv"},
        "explicit_null_label_policy_sub_tlv": {
            "type": "BgpSrteExplicitNullLabelPolicySubTlv"
        },
        "segment_lists": {"type": "BgpSrteSegmentListIter"},
        "name": {"type": str},
        "active": {"type": bool},
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "active": True,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, active=True):
        super(BgpSrteV6TunnelTlv, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("active", active)

    def set(self, name=None, active=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def remote_endpoint_sub_tlv(self):
        # type: () -> BgpSrteRemoteEndpointSubTlv
        """remote_endpoint_sub_tlv getter

        Configuration for the BGP remote endpoint sub TLV.Configuration for the BGP remote endpoint sub TLV.Configuration for the BGP remote endpoint sub TLV.

        Returns: BgpSrteRemoteEndpointSubTlv
        """
        return self._get_property(
            "remote_endpoint_sub_tlv", BgpSrteRemoteEndpointSubTlv
        )

    @property
    def color_sub_tlv(self):
        # type: () -> BgpSrteColorSubTlv
        """color_sub_tlv getter

        Configuration for the Policy Color attribute sub-TLV. The Color sub-TLV MAY be used as way to "color" the corresponding Tunnel TLV. The Value field of the sub-TLV is eight octets long and consists of Color Extended Community. First two octets of its Value field are 0x030b as type and subtype of extended community. Remaining six octets are are exposed to configure. Configuration for the Policy Color attribute sub-TLV. The Color sub-TLV MAY be used as way to "color" the corresponding Tunnel TLV. The Value field of the sub-TLV is eight octets long and consists of Color Extended Community. First two octets of its Value field are 0x030b as type and subtype of extended community. Remaining six octets are are exposed to configure. Configuration for the Policy Color attribute sub-TLV. The Color sub-TLV MAY be used as way to "color" the corresponding Tunnel TLV. The Value field of the sub-TLV is eight octets long and consists of Color Extended Community. First two octets of its Value field are 0x030b as type and subtype of extended community. Remaining six octets are are exposed to configure.

        Returns: BgpSrteColorSubTlv
        """
        return self._get_property("color_sub_tlv", BgpSrteColorSubTlv)

    @property
    def binding_sub_tlv(self):
        # type: () -> BgpSrteBindingSubTlv
        """binding_sub_tlv getter

        Configuration for the binding SID sub-TLV. This is used to signal the binding SID related information of the SR Policy candidate path.Configuration for the binding SID sub-TLV. This is used to signal the binding SID related information of the SR Policy candidate path.Configuration for the binding SID sub-TLV. This is used to signal the binding SID related information of the SR Policy candidate path.

        Returns: BgpSrteBindingSubTlv
        """
        return self._get_property("binding_sub_tlv", BgpSrteBindingSubTlv)

    @property
    def preference_sub_tlv(self):
        # type: () -> BgpSrtePreferenceSubTlv
        """preference_sub_tlv getter

        Configuration for BGP preference sub TLV of the SR Policy candidate path.Configuration for BGP preference sub TLV of the SR Policy candidate path.Configuration for BGP preference sub TLV of the SR Policy candidate path.

        Returns: BgpSrtePreferenceSubTlv
        """
        return self._get_property("preference_sub_tlv", BgpSrtePreferenceSubTlv)

    @property
    def policy_priority_sub_tlv(self):
        # type: () -> BgpSrtePolicyPrioritySubTlv
        """policy_priority_sub_tlv getter

        Configuration for the Policy Priority sub-TLV. The Policy Priority to indicate the order in which the SR policies are re-computed upon topological change.Configuration for the Policy Priority sub-TLV. The Policy Priority to indicate the order in which the SR policies are re-computed upon topological change.Configuration for the Policy Priority sub-TLV. The Policy Priority to indicate the order in which the SR policies are re-computed upon topological change.

        Returns: BgpSrtePolicyPrioritySubTlv
        """
        return self._get_property(
            "policy_priority_sub_tlv", BgpSrtePolicyPrioritySubTlv
        )

    @property
    def policy_name_sub_tlv(self):
        # type: () -> BgpSrtePolicyNameSubTlv
        """policy_name_sub_tlv getter

        Configuration for the Policy Name sub-TLV. The Policy Name sub-TLV is used to attach symbolic name to the SR Policy candidate path.Configuration for the Policy Name sub-TLV. The Policy Name sub-TLV is used to attach symbolic name to the SR Policy candidate path.Configuration for the Policy Name sub-TLV. The Policy Name sub-TLV is used to attach symbolic name to the SR Policy candidate path.

        Returns: BgpSrtePolicyNameSubTlv
        """
        return self._get_property("policy_name_sub_tlv", BgpSrtePolicyNameSubTlv)

    @property
    def explicit_null_label_policy_sub_tlv(self):
        # type: () -> BgpSrteExplicitNullLabelPolicySubTlv
        """explicit_null_label_policy_sub_tlv getter

        Configuration for BGP explicit null label policy sub TLV settings.Configuration for BGP explicit null label policy sub TLV settings.Configuration for BGP explicit null label policy sub TLV settings.

        Returns: BgpSrteExplicitNullLabelPolicySubTlv
        """
        return self._get_property(
            "explicit_null_label_policy_sub_tlv", BgpSrteExplicitNullLabelPolicySubTlv
        )

    @property
    def segment_lists(self):
        # type: () -> BgpSrteSegmentListIter
        """segment_lists getter

        TBD

        Returns: BgpSrteSegmentListIter
        """
        return self._get_property(
            "segment_lists", BgpSrteSegmentListIter, self._parent, self._choice
        )

    @property
    def name(self):
        # type: () -> str
        """name getter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def active(self):
        # type: () -> bool
        """active getter

        If enabled means that this part of the configuration including any active 'children' nodes will be advertised to peer. If disabled, this means that though config is present, it is not taking any part of the test but can be activated at run-time to advertise just this part of the configuration to the peer.

        Returns: bool
        """
        return self._get_property("active")

    @active.setter
    def active(self, value):
        """active setter

        If enabled means that this part of the configuration including any active 'children' nodes will be advertised to peer. If disabled, this means that though config is present, it is not taking any part of the test but can be activated at run-time to advertise just this part of the configuration to the peer.

        value: bool
        """
        self._set_property("active", value)


class BgpSrteV6TunnelTlvIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(BgpSrteV6TunnelTlvIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[BgpSrteV6TunnelTlv]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> BgpSrteV6TunnelTlvIter
        return self._iter()

    def __next__(self):
        # type: () -> BgpSrteV6TunnelTlv
        return self._next()

    def next(self):
        # type: () -> BgpSrteV6TunnelTlv
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, BgpSrteV6TunnelTlv):
            raise Exception("Item is not an instance of BgpSrteV6TunnelTlv")

    def v6tunneltlv(self, name=None, active=True):
        # type: (str,bool) -> BgpSrteV6TunnelTlvIter
        """Factory method that creates an instance of the BgpSrteV6TunnelTlv class

        Configuration for BGP SRTE Tunnel TLV.

        Returns: BgpSrteV6TunnelTlvIter
        """
        item = BgpSrteV6TunnelTlv(parent=self._parent, name=name, active=active)
        self._add(item)
        return self

    def add(self, name=None, active=True):
        # type: (str,bool) -> BgpSrteV6TunnelTlv
        """Add method that creates and returns an instance of the BgpSrteV6TunnelTlv class

        Configuration for BGP SRTE Tunnel TLV.

        Returns: BgpSrteV6TunnelTlv
        """
        item = BgpSrteV6TunnelTlv(parent=self._parent, name=name, active=active)
        self._add(item)
        return item


class BgpSrteV6PolicyIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(BgpSrteV6PolicyIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[BgpSrteV6Policy]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> BgpSrteV6PolicyIter
        return self._iter()

    def __next__(self):
        # type: () -> BgpSrteV6Policy
        return self._next()

    def next(self):
        # type: () -> BgpSrteV6Policy
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, BgpSrteV6Policy):
            raise Exception("Item is not an instance of BgpSrteV6Policy")

    def v6policy(
        self,
        distinguisher=1,
        color=100,
        ipv6_endpoint=None,
        next_hop_mode="local_ip",
        next_hop_address_type="ipv6",
        next_hop_ipv4_address="0.0.0.0",
        next_hop_ipv6_address="::0",
        name=None,
        active=True,
    ):
        # type: (int,int,str,Union[Literal["local_ip"], Literal["manual"]],Union[Literal["ipv4"], Literal["ipv6"]],str,str,str,bool) -> BgpSrteV6PolicyIter
        """Factory method that creates an instance of the BgpSrteV6Policy class

        Configuration for BGP Segment Routing Traffic Engineering policy..

        Returns: BgpSrteV6PolicyIter
        """
        item = BgpSrteV6Policy(
            parent=self._parent,
            distinguisher=distinguisher,
            color=color,
            ipv6_endpoint=ipv6_endpoint,
            next_hop_mode=next_hop_mode,
            next_hop_address_type=next_hop_address_type,
            next_hop_ipv4_address=next_hop_ipv4_address,
            next_hop_ipv6_address=next_hop_ipv6_address,
            name=name,
            active=active,
        )
        self._add(item)
        return self

    def add(
        self,
        distinguisher=1,
        color=100,
        ipv6_endpoint=None,
        next_hop_mode="local_ip",
        next_hop_address_type="ipv6",
        next_hop_ipv4_address="0.0.0.0",
        next_hop_ipv6_address="::0",
        name=None,
        active=True,
    ):
        # type: (int,int,str,Union[Literal["local_ip"], Literal["manual"]],Union[Literal["ipv4"], Literal["ipv6"]],str,str,str,bool) -> BgpSrteV6Policy
        """Add method that creates and returns an instance of the BgpSrteV6Policy class

        Configuration for BGP Segment Routing Traffic Engineering policy..

        Returns: BgpSrteV6Policy
        """
        item = BgpSrteV6Policy(
            parent=self._parent,
            distinguisher=distinguisher,
            color=color,
            ipv6_endpoint=ipv6_endpoint,
            next_hop_mode=next_hop_mode,
            next_hop_address_type=next_hop_address_type,
            next_hop_ipv4_address=next_hop_ipv4_address,
            next_hop_ipv6_address=next_hop_ipv6_address,
            name=name,
            active=active,
        )
        self._add(item)
        return item


class BgpGracefulRestart(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "enable_gr": {"type": bool},
        "restart_time": {
            "type": int,
            "format": "uint32",
            "maximum": 4096,
        },
        "enable_llgr": {"type": bool},
        "stale_time": {
            "type": int,
            "format": "uint32",
            "maximum": 16777215,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "enable_gr": False,
        "restart_time": 45,
        "enable_llgr": False,
        "stale_time": 10,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        enable_gr=False,
        restart_time=45,
        enable_llgr=False,
        stale_time=10,
    ):
        super(BgpGracefulRestart, self).__init__()
        self._parent = parent
        self._set_property("enable_gr", enable_gr)
        self._set_property("restart_time", restart_time)
        self._set_property("enable_llgr", enable_llgr)
        self._set_property("stale_time", stale_time)

    def set(self, enable_gr=None, restart_time=None, enable_llgr=None, stale_time=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def enable_gr(self):
        # type: () -> bool
        """enable_gr getter

        If enabled, Graceful Restart capability is advertised in BGP OPEN messages.

        Returns: bool
        """
        return self._get_property("enable_gr")

    @enable_gr.setter
    def enable_gr(self, value):
        """enable_gr setter

        If enabled, Graceful Restart capability is advertised in BGP OPEN messages.

        value: bool
        """
        self._set_property("enable_gr", value)

    @property
    def restart_time(self):
        # type: () -> int
        """restart_time getter

        This is the estimated duration (in seconds) it will take for the BGP session to be re-established after restart. This can be used to speed up routing convergence by its peer in case the BGP speaker does not come back after restart.

        Returns: int
        """
        return self._get_property("restart_time")

    @restart_time.setter
    def restart_time(self, value):
        """restart_time setter

        This is the estimated duration (in seconds) it will take for the BGP session to be re-established after restart. This can be used to speed up routing convergence by its peer in case the BGP speaker does not come back after restart.

        value: int
        """
        self._set_property("restart_time", value)

    @property
    def enable_llgr(self):
        # type: () -> bool
        """enable_llgr getter

        If enabled, the "Long-lived Graceful Restart Capability", or "LLGR Capability". will be advertised.. This capability MUST be advertised in conjunction with the Graceful Restart capability.

        Returns: bool
        """
        return self._get_property("enable_llgr")

    @enable_llgr.setter
    def enable_llgr(self, value):
        """enable_llgr setter

        If enabled, the "Long-lived Graceful Restart Capability", or "LLGR Capability". will be advertised.. This capability MUST be advertised in conjunction with the Graceful Restart capability.

        value: bool
        """
        self._set_property("enable_llgr", value)

    @property
    def stale_time(self):
        # type: () -> int
        """stale_time getter

        Duration (in seconds) specifying how long stale information (for the AFI/SAFI) may be retained. This is three byte field and is applicable only if 'enable_llgr' is set to 'true'.

        Returns: int
        """
        return self._get_property("stale_time")

    @stale_time.setter
    def stale_time(self, value):
        """stale_time setter

        Duration (in seconds) specifying how long stale information (for the AFI/SAFI) may be retained. This is three byte field and is applicable only if 'enable_llgr' is set to 'true'.

        value: int
        """
        self._set_property("stale_time", value)


class BgpV4PeerIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(BgpV4PeerIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[BgpV4Peer]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> BgpV4PeerIter
        return self._iter()

    def __next__(self):
        # type: () -> BgpV4Peer
        return self._next()

    def next(self):
        # type: () -> BgpV4Peer
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, BgpV4Peer):
            raise Exception("Item is not an instance of BgpV4Peer")

    def v4peer(
        self,
        peer_address=None,
        as_type=None,
        as_number=None,
        as_number_width="four",
        name=None,
    ):
        # type: (str,Union[Literal["ebgp"], Literal["ibgp"]],int,Union[Literal["four"], Literal["two"]],str) -> BgpV4PeerIter
        """Factory method that creates an instance of the BgpV4Peer class

        Configuration for emulated BGPv4 peers and routes.

        Returns: BgpV4PeerIter
        """
        item = BgpV4Peer(
            parent=self._parent,
            peer_address=peer_address,
            as_type=as_type,
            as_number=as_number,
            as_number_width=as_number_width,
            name=name,
        )
        self._add(item)
        return self

    def add(
        self,
        peer_address=None,
        as_type=None,
        as_number=None,
        as_number_width="four",
        name=None,
    ):
        # type: (str,Union[Literal["ebgp"], Literal["ibgp"]],int,Union[Literal["four"], Literal["two"]],str) -> BgpV4Peer
        """Add method that creates and returns an instance of the BgpV4Peer class

        Configuration for emulated BGPv4 peers and routes.

        Returns: BgpV4Peer
        """
        item = BgpV4Peer(
            parent=self._parent,
            peer_address=peer_address,
            as_type=as_type,
            as_number=as_number,
            as_number_width=as_number_width,
            name=name,
        )
        self._add(item)
        return item


class BgpV4InterfaceIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(BgpV4InterfaceIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[BgpV4Interface]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> BgpV4InterfaceIter
        return self._iter()

    def __next__(self):
        # type: () -> BgpV4Interface
        return self._next()

    def next(self):
        # type: () -> BgpV4Interface
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, BgpV4Interface):
            raise Exception("Item is not an instance of BgpV4Interface")

    def v4interface(self, ipv4_name=None):
        # type: (str) -> BgpV4InterfaceIter
        """Factory method that creates an instance of the BgpV4Interface class

        Configuration for emulated BGPv4 peers and routes on single IPv4 interface.

        Returns: BgpV4InterfaceIter
        """
        item = BgpV4Interface(parent=self._parent, ipv4_name=ipv4_name)
        self._add(item)
        return self

    def add(self, ipv4_name=None):
        # type: (str) -> BgpV4Interface
        """Add method that creates and returns an instance of the BgpV4Interface class

        Configuration for emulated BGPv4 peers and routes on single IPv4 interface.

        Returns: BgpV4Interface
        """
        item = BgpV4Interface(parent=self._parent, ipv4_name=ipv4_name)
        self._add(item)
        return item


class BgpV6Interface(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "ipv6_name": {"type": str},
        "peers": {"type": "BgpV6PeerIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ("ipv6_name",)  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, ipv6_name=None):
        super(BgpV6Interface, self).__init__()
        self._parent = parent
        self._set_property("ipv6_name", ipv6_name)

    def set(self, ipv6_name=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def ipv6_name(self):
        # type: () -> str
        """ipv6_name getter

        The unique name of IPv6 or Loopback IPv6 interface used as the source IP for this list of BGP peers.. x-constraint:. /components/schemas/Device.Ipv6/properties/name. /components/schemas/Device.Ipv6Loopback/properties/name. . x-constraint:. /components/schemas/Device.Ipv6/properties/name. /components/schemas/Device.Ipv6Loopback/properties/name.

        Returns: str
        """
        return self._get_property("ipv6_name")

    @ipv6_name.setter
    def ipv6_name(self, value):
        """ipv6_name setter

        The unique name of IPv6 or Loopback IPv6 interface used as the source IP for this list of BGP peers.. x-constraint:. /components/schemas/Device.Ipv6/properties/name. /components/schemas/Device.Ipv6Loopback/properties/name. . x-constraint:. /components/schemas/Device.Ipv6/properties/name. /components/schemas/Device.Ipv6Loopback/properties/name.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property ipv6_name as None")
        self._set_property("ipv6_name", value)

    @property
    def peers(self):
        # type: () -> BgpV6PeerIter
        """peers getter

        This contains the list of BGPv6 peers configured on this interface.

        Returns: BgpV6PeerIter
        """
        return self._get_property("peers", BgpV6PeerIter, self._parent, self._choice)


class BgpV6Peer(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "peer_address": {
            "type": str,
            "format": "ipv6",
        },
        "segment_routing": {"type": "BgpV6SegmentRouting"},
        "evpn_ethernet_segments": {"type": "BgpV6EthernetSegmentIter"},
        "as_type": {
            "type": str,
            "enum": [
                "ibgp",
                "ebgp",
            ],
        },
        "as_number": {
            "type": int,
            "format": "uint32",
        },
        "as_number_width": {
            "type": str,
            "enum": [
                "two",
                "four",
            ],
        },
        "advanced": {"type": "BgpAdvanced"},
        "capability": {"type": "BgpCapability"},
        "learned_information_filter": {"type": "BgpLearnedInformationFilter"},
        "v4_routes": {"type": "BgpV4RouteRangeIter"},
        "v6_routes": {"type": "BgpV6RouteRangeIter"},
        "v4_srte_policies": {"type": "BgpSrteV4PolicyIter"},
        "v6_srte_policies": {"type": "BgpSrteV6PolicyIter"},
        "name": {"type": str},
        "graceful_restart": {"type": "BgpGracefulRestart"},
    }  # type: Dict[str, str]

    _REQUIRED = ("peer_address", "as_type", "as_number", "name")  # type: tuple(str)

    _DEFAULTS = {
        "as_number_width": "four",
    }  # type: Dict[str, Union(type)]

    IBGP = "ibgp"  # type: str
    EBGP = "ebgp"  # type: str

    TWO = "two"  # type: str
    FOUR = "four"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        peer_address=None,
        as_type=None,
        as_number=None,
        as_number_width="four",
        name=None,
    ):
        super(BgpV6Peer, self).__init__()
        self._parent = parent
        self._set_property("peer_address", peer_address)
        self._set_property("as_type", as_type)
        self._set_property("as_number", as_number)
        self._set_property("as_number_width", as_number_width)
        self._set_property("name", name)

    def set(
        self,
        peer_address=None,
        as_type=None,
        as_number=None,
        as_number_width=None,
        name=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def peer_address(self):
        # type: () -> str
        """peer_address getter

        IPv6 address of the BGP peer for the session

        Returns: str
        """
        return self._get_property("peer_address")

    @peer_address.setter
    def peer_address(self, value):
        """peer_address setter

        IPv6 address of the BGP peer for the session

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property peer_address as None")
        self._set_property("peer_address", value)

    @property
    def segment_routing(self):
        # type: () -> BgpV6SegmentRouting
        """segment_routing getter

        Configuration for BGPv6 segment routing settings.Configuration for BGPv6 segment routing settings.Configuration for BGPv6 segment routing settings.

        Returns: BgpV6SegmentRouting
        """
        return self._get_property("segment_routing", BgpV6SegmentRouting)

    @property
    def evpn_ethernet_segments(self):
        # type: () -> BgpV6EthernetSegmentIter
        """evpn_ethernet_segments getter

        This contains the list of Ethernet Virtual Private Network (EVPN) Ethernet Segments (ES) Per BGP Peer for IPv6 Address Family Identifier (AFI).. Each Ethernet Segment contains list of EVPN Instances (EVIs) . Each EVI contains list of Broadcast Domains. Each Broadcast Domain contains list of MAC/IP Ranges. . <Ethernet Segment, EVI, Broadcast Domain> is responsible for advertising Ethernet Auto-discovery Route Per EVI (Type 1).. <Ethernet Segment, EVI> is responsible for advertising Ethernet Auto-discovery Route Per Ethernet Segment (Type 1).. <Ethernet Segment, EVI, Broadcast Domain, MAC/IP> is responsible for advertising MAC/IP Advertisement Route (Type 2).. <Ethernet Segment, EVI, Broadcast Domain> is responsible for advertising Inclusive Multicast Ethernet Tag Route (Type 3).. Ethernet Segment is responsible for advertising Ethernet Segment Route (Type 4).

        Returns: BgpV6EthernetSegmentIter
        """
        return self._get_property(
            "evpn_ethernet_segments",
            BgpV6EthernetSegmentIter,
            self._parent,
            self._choice,
        )

    @property
    def as_type(self):
        # type: () -> Union[Literal["ebgp"], Literal["ibgp"]]
        """as_type getter

        The type of BGP autonomous system. External BGP is used for BGP links between two or more autonomous systems (ebgp). Internal BGP is used within single autonomous system (ibgp). BGP property defaults are aligned with this object defined as an internal BGP peer. If the as_type is specified as 'ebgp' then other properties will need to be specified as per an external BGP peer. Specifically, for 'ebgp', 'as_set_mode' attribute in 'as_path' field in any Route Range should be changed from default value 'do_not_include_local_as' to any other value.

        Returns: Union[Literal["ebgp"], Literal["ibgp"]]
        """
        return self._get_property("as_type")

    @as_type.setter
    def as_type(self, value):
        """as_type setter

        The type of BGP autonomous system. External BGP is used for BGP links between two or more autonomous systems (ebgp). Internal BGP is used within single autonomous system (ibgp). BGP property defaults are aligned with this object defined as an internal BGP peer. If the as_type is specified as 'ebgp' then other properties will need to be specified as per an external BGP peer. Specifically, for 'ebgp', 'as_set_mode' attribute in 'as_path' field in any Route Range should be changed from default value 'do_not_include_local_as' to any other value.

        value: Union[Literal["ebgp"], Literal["ibgp"]]
        """
        if value is None:
            raise TypeError("Cannot set required property as_type as None")
        self._set_property("as_type", value)

    @property
    def as_number(self):
        # type: () -> int
        """as_number getter

        Autonomous System Number (AS number or ASN)

        Returns: int
        """
        return self._get_property("as_number")

    @as_number.setter
    def as_number(self, value):
        """as_number setter

        Autonomous System Number (AS number or ASN)

        value: int
        """
        if value is None:
            raise TypeError("Cannot set required property as_number as None")
        self._set_property("as_number", value)

    @property
    def as_number_width(self):
        # type: () -> Union[Literal["four"], Literal["two"]]
        """as_number_width getter

        The width in bytes of the as_number values. Any as_number values that exceeds the width MUST result in an error.

        Returns: Union[Literal["four"], Literal["two"]]
        """
        return self._get_property("as_number_width")

    @as_number_width.setter
    def as_number_width(self, value):
        """as_number_width setter

        The width in bytes of the as_number values. Any as_number values that exceeds the width MUST result in an error.

        value: Union[Literal["four"], Literal["two"]]
        """
        self._set_property("as_number_width", value)

    @property
    def advanced(self):
        # type: () -> BgpAdvanced
        """advanced getter

        Configuration for BGP advanced settings.Configuration for BGP advanced settings.Configuration for BGP advanced settings.

        Returns: BgpAdvanced
        """
        return self._get_property("advanced", BgpAdvanced)

    @property
    def capability(self):
        # type: () -> BgpCapability
        """capability getter

        Configuration for BGP capability settings.Configuration for BGP capability settings.Configuration for BGP capability settings.

        Returns: BgpCapability
        """
        return self._get_property("capability", BgpCapability)

    @property
    def learned_information_filter(self):
        # type: () -> BgpLearnedInformationFilter
        """learned_information_filter getter

        Configuration for controlling storage of BGP learned information recieved from the peer.Configuration for controlling storage of BGP learned information recieved from the peer.Configuration for controlling storage of BGP learned information recieved from the peer.

        Returns: BgpLearnedInformationFilter
        """
        return self._get_property(
            "learned_information_filter", BgpLearnedInformationFilter
        )

    @property
    def v4_routes(self):
        # type: () -> BgpV4RouteRangeIter
        """v4_routes getter

        Emulated BGPv4 route ranges.

        Returns: BgpV4RouteRangeIter
        """
        return self._get_property(
            "v4_routes", BgpV4RouteRangeIter, self._parent, self._choice
        )

    @property
    def v6_routes(self):
        # type: () -> BgpV6RouteRangeIter
        """v6_routes getter

        Emulated BGPv6 route ranges.

        Returns: BgpV6RouteRangeIter
        """
        return self._get_property(
            "v6_routes", BgpV6RouteRangeIter, self._parent, self._choice
        )

    @property
    def v4_srte_policies(self):
        # type: () -> BgpSrteV4PolicyIter
        """v4_srte_policies getter

        Segment Routing Traffic Engineering (SR TE) Policies for IPv4 Address Family Identifier (AFI).

        Returns: BgpSrteV4PolicyIter
        """
        return self._get_property(
            "v4_srte_policies", BgpSrteV4PolicyIter, self._parent, self._choice
        )

    @property
    def v6_srte_policies(self):
        # type: () -> BgpSrteV6PolicyIter
        """v6_srte_policies getter

        Segment Routing Traffic Engineering (SR TE) Policies for IPv6 Address Family Identifier (AFI).

        Returns: BgpSrteV6PolicyIter
        """
        return self._get_property(
            "v6_srte_policies", BgpSrteV6PolicyIter, self._parent, self._choice
        )

    @property
    def name(self):
        # type: () -> str
        """name getter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.. Globally unique name of an object. It also serves as the primary key for arrays of objects.

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.. Globally unique name of an object. It also serves as the primary key for arrays of objects.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def graceful_restart(self):
        # type: () -> BgpGracefulRestart
        """graceful_restart getter

        The Graceful Restart Capability (RFC 4724) is BGP capability that can be used by BGP speaker to indicate its ability to preserve its forwarding state during BGP restart. The Graceful Restart (GR) capability is advertised in OPEN messages sent between BGP peers. After BGP session has been established, and the initial routing update has been completed, an End-of-RIB (Routing Information Base) marker is sent in an UPDATE message to convey information about routing convergence.The Graceful Restart Capability (RFC 4724) is BGP capability that can be used by BGP speaker to indicate its ability to preserve its forwarding state during BGP restart. The Graceful Restart (GR) capability is advertised in OPEN messages sent between BGP peers. After BGP session has been established, and the initial routing update has been completed, an End-of-RIB (Routing Information Base) marker is sent in an UPDATE message to convey information about routing convergence.The Graceful Restart Capability (RFC 4724) is BGP capability that can be used by BGP speaker to indicate its ability to preserve its forwarding state during BGP restart. The Graceful Restart (GR) capability is advertised in OPEN messages sent between BGP peers. After BGP session has been established, and the initial routing update has been completed, an End-of-RIB (Routing Information Base) marker is sent in an UPDATE message to convey information about routing convergence.

        Returns: BgpGracefulRestart
        """
        return self._get_property("graceful_restart", BgpGracefulRestart)


class BgpV6SegmentRouting(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "ingress_supports_vpn": {"type": bool},
        "reduced_encapsulation": {"type": bool},
        "copy_time_to_live": {"type": bool},
        "time_to_live": {
            "type": int,
            "format": "uint32",
        },
        "max_sids_per_srh": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "auto_generate_segment_left_value": {"type": bool},
        "segment_left_value": {
            "type": int,
            "format": "uint32",
        },
        "advertise_sr_te_policy": {"type": bool},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "ingress_supports_vpn": False,
        "reduced_encapsulation": False,
        "copy_time_to_live": False,
        "time_to_live": 0,
        "max_sids_per_srh": 0,
        "auto_generate_segment_left_value": False,
        "segment_left_value": 0,
        "advertise_sr_te_policy": False,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        ingress_supports_vpn=False,
        reduced_encapsulation=False,
        copy_time_to_live=False,
        time_to_live=0,
        max_sids_per_srh=0,
        auto_generate_segment_left_value=False,
        segment_left_value=0,
        advertise_sr_te_policy=False,
    ):
        super(BgpV6SegmentRouting, self).__init__()
        self._parent = parent
        self._set_property("ingress_supports_vpn", ingress_supports_vpn)
        self._set_property("reduced_encapsulation", reduced_encapsulation)
        self._set_property("copy_time_to_live", copy_time_to_live)
        self._set_property("time_to_live", time_to_live)
        self._set_property("max_sids_per_srh", max_sids_per_srh)
        self._set_property(
            "auto_generate_segment_left_value", auto_generate_segment_left_value
        )
        self._set_property("segment_left_value", segment_left_value)
        self._set_property("advertise_sr_te_policy", advertise_sr_te_policy)

    def set(
        self,
        ingress_supports_vpn=None,
        reduced_encapsulation=None,
        copy_time_to_live=None,
        time_to_live=None,
        max_sids_per_srh=None,
        auto_generate_segment_left_value=None,
        segment_left_value=None,
        advertise_sr_te_policy=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def ingress_supports_vpn(self):
        # type: () -> bool
        """ingress_supports_vpn getter

        TBD

        Returns: bool
        """
        return self._get_property("ingress_supports_vpn")

    @ingress_supports_vpn.setter
    def ingress_supports_vpn(self, value):
        """ingress_supports_vpn setter

        TBD

        value: bool
        """
        self._set_property("ingress_supports_vpn", value)

    @property
    def reduced_encapsulation(self):
        # type: () -> bool
        """reduced_encapsulation getter

        TBD

        Returns: bool
        """
        return self._get_property("reduced_encapsulation")

    @reduced_encapsulation.setter
    def reduced_encapsulation(self, value):
        """reduced_encapsulation setter

        TBD

        value: bool
        """
        self._set_property("reduced_encapsulation", value)

    @property
    def copy_time_to_live(self):
        # type: () -> bool
        """copy_time_to_live getter

        TBD

        Returns: bool
        """
        return self._get_property("copy_time_to_live")

    @copy_time_to_live.setter
    def copy_time_to_live(self, value):
        """copy_time_to_live setter

        TBD

        value: bool
        """
        self._set_property("copy_time_to_live", value)

    @property
    def time_to_live(self):
        # type: () -> int
        """time_to_live getter

        TBD

        Returns: int
        """
        return self._get_property("time_to_live")

    @time_to_live.setter
    def time_to_live(self, value):
        """time_to_live setter

        TBD

        value: int
        """
        self._set_property("time_to_live", value)

    @property
    def max_sids_per_srh(self):
        # type: () -> int
        """max_sids_per_srh getter

        TBD

        Returns: int
        """
        return self._get_property("max_sids_per_srh")

    @max_sids_per_srh.setter
    def max_sids_per_srh(self, value):
        """max_sids_per_srh setter

        TBD

        value: int
        """
        self._set_property("max_sids_per_srh", value)

    @property
    def auto_generate_segment_left_value(self):
        # type: () -> bool
        """auto_generate_segment_left_value getter

        TBD

        Returns: bool
        """
        return self._get_property("auto_generate_segment_left_value")

    @auto_generate_segment_left_value.setter
    def auto_generate_segment_left_value(self, value):
        """auto_generate_segment_left_value setter

        TBD

        value: bool
        """
        self._set_property("auto_generate_segment_left_value", value)

    @property
    def segment_left_value(self):
        # type: () -> int
        """segment_left_value getter

        TBD

        Returns: int
        """
        return self._get_property("segment_left_value")

    @segment_left_value.setter
    def segment_left_value(self, value):
        """segment_left_value setter

        TBD

        value: int
        """
        self._set_property("segment_left_value", value)

    @property
    def advertise_sr_te_policy(self):
        # type: () -> bool
        """advertise_sr_te_policy getter

        TBD

        Returns: bool
        """
        return self._get_property("advertise_sr_te_policy")

    @advertise_sr_te_policy.setter
    def advertise_sr_te_policy(self, value):
        """advertise_sr_te_policy setter

        TBD

        value: bool
        """
        self._set_property("advertise_sr_te_policy", value)


class BgpV6EthernetSegment(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "df_election": {"type": "BgpEthernetSegmentDfElection"},
        "evis": {"type": "BgpV6EvpnEvisIter"},
        "esi": {
            "type": str,
            "format": "hex",
        },
        "active_mode": {
            "type": str,
            "enum": [
                "single_active",
                "all_active",
            ],
        },
        "esi_label": {
            "type": int,
            "format": "uint32",
            "maximum": 16777215,
        },
        "advanced": {"type": "BgpRouteAdvanced"},
        "communities": {"type": "BgpCommunityIter"},
        "ext_communities": {"type": "BgpExtCommunityIter"},
        "as_path": {"type": "BgpAsPath"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "esi": "00000000000000000000",
        "active_mode": "all_active",
        "esi_label": 0,
    }  # type: Dict[str, Union(type)]

    SINGLE_ACTIVE = "single_active"  # type: str
    ALL_ACTIVE = "all_active"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        esi="00000000000000000000",
        active_mode="all_active",
        esi_label=0,
    ):
        super(BgpV6EthernetSegment, self).__init__()
        self._parent = parent
        self._set_property("esi", esi)
        self._set_property("active_mode", active_mode)
        self._set_property("esi_label", esi_label)

    def set(self, esi=None, active_mode=None, esi_label=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def df_election(self):
        # type: () -> BgpEthernetSegmentDfElection
        """df_election getter

        Configuration for Designated Forwarder (DF) election among the Provider Edge (PE) routers on the same Ethernet Segment.Configuration for Designated Forwarder (DF) election among the Provider Edge (PE) routers on the same Ethernet Segment.Configuration for Designated Forwarder (DF) election among the Provider Edge (PE) routers on the same Ethernet Segment.Designated Forwarder (DF) election configuration.

        Returns: BgpEthernetSegmentDfElection
        """
        return self._get_property("df_election", BgpEthernetSegmentDfElection)

    @property
    def evis(self):
        # type: () -> BgpV6EvpnEvisIter
        """evis getter

        This contains the list of EVIs.

        Returns: BgpV6EvpnEvisIter
        """
        return self._get_property("evis", BgpV6EvpnEvisIter, self._parent, self._choice)

    @property
    def esi(self):
        # type: () -> str
        """esi getter

        10-octet Ethernet Segment Identifier (ESI) Example For multi-home scenario nonZero ESI is '10000000000000000000' .

        Returns: str
        """
        return self._get_property("esi")

    @esi.setter
    def esi(self, value):
        """esi setter

        10-octet Ethernet Segment Identifier (ESI) Example For multi-home scenario nonZero ESI is '10000000000000000000' .

        value: str
        """
        self._set_property("esi", value)

    @property
    def active_mode(self):
        # type: () -> Union[Literal["all_active"], Literal["single_active"]]
        """active_mode getter

        Single Active or All Active mode Redundancy mode selection for Multi-home.

        Returns: Union[Literal["all_active"], Literal["single_active"]]
        """
        return self._get_property("active_mode")

    @active_mode.setter
    def active_mode(self, value):
        """active_mode setter

        Single Active or All Active mode Redundancy mode selection for Multi-home.

        value: Union[Literal["all_active"], Literal["single_active"]]
        """
        self._set_property("active_mode", value)

    @property
    def esi_label(self):
        # type: () -> int
        """esi_label getter

        The label value to be advertised as ESI Label in ESI Label Extended Community. This is included in Ethernet Auto-discovery per ES Routes advertised by router.

        Returns: int
        """
        return self._get_property("esi_label")

    @esi_label.setter
    def esi_label(self, value):
        """esi_label setter

        The label value to be advertised as ESI Label in ESI Label Extended Community. This is included in Ethernet Auto-discovery per ES Routes advertised by router.

        value: int
        """
        self._set_property("esi_label", value)

    @property
    def advanced(self):
        # type: () -> BgpRouteAdvanced
        """advanced getter

        Configuration for advanced BGP route range settings.Configuration for advanced BGP route range settings.Configuration for advanced BGP route range settings.

        Returns: BgpRouteAdvanced
        """
        return self._get_property("advanced", BgpRouteAdvanced)

    @property
    def communities(self):
        # type: () -> BgpCommunityIter
        """communities getter

        Optional community settings.

        Returns: BgpCommunityIter
        """
        return self._get_property(
            "communities", BgpCommunityIter, self._parent, self._choice
        )

    @property
    def ext_communities(self):
        # type: () -> BgpExtCommunityIter
        """ext_communities getter

        Optional Extended Community settings. The Extended Communities Attribute is transitive optional BGP attribute, with the Type Code 16. Community and Extended Communities attributes are utilized to trigger routing decisions, such as acceptance, rejection, preference, or redistribution. An extended community is an 8-Bytes value. It is divided into two main parts. The first Bytes of the community encode type and sub-type fields and the last Bytes carry unique set of data in format defined by the type and sub-type field. Extended communities provide larger range for grouping or categorizing communities. When type is administrator_as_2octet or administrator_as_4octet, the valid sub types are route target and origin. The valid value for administrator_as_2octet and administrator_as_4octet type is either two byte AS followed by four byte local administrator id or four byte AS followed by two byte local administrator id. When type is administrator_ipv4_address the valid sub types are route target and origin. The valid value for administrator_ipv4_address is four byte IPv4 address followed by two byte local administrator id. When type is opaque, valid sub types are color and encapsulation. When sub type is color, first two bytes of the value field contain flags and last four bytes contains the value of the color. When sub type is encapsulation the first four bytes of value field are reserved and last two bytes carries the tunnel type from IANA's "ETHER TYPES" registry e.g IPv4 (protocol type 0x0800), IPv6 (protocol type 0x86dd), and MPLS (protocol type 0x8847). When type is administrator_as_2octet_link_bandwidth the valid sub type is extended_bandwidth. The first two bytes of the value field contains the AS number and the last four bytes contains the bandwidth in IEEE floating point format. When type is evpn the valid subtype is mac_address. In the value field the low-order bit of the first byte(Flags) is defined as the "Sticky/static" flag and may be set to 1, indicating the MAC address is static and cannot move. The second byte is reserved and the last four bytes contain the sequence number which is used to ensure that PEs retain the correct MAC/IP Advertisement route when multiple updates occur for the same MAC address.

        Returns: BgpExtCommunityIter
        """
        return self._get_property(
            "ext_communities", BgpExtCommunityIter, self._parent, self._choice
        )

    @property
    def as_path(self):
        # type: () -> BgpAsPath
        """as_path getter

        This attribute identifies the autonomous systems through which routing information carried in this UPDATE message has passed. This contains the configuration of how to include the Local AS in the AS path attribute of the MP REACH NLRI. It also contains optional configuration of additional AS Path Segments that can be included in the AS Path attribute. The AS Path consists of Set or Sequence of Autonomous Systems (AS) numbers that routing information passes through to reach the destination.This attribute identifies the autonomous systems through which routing information carried in this UPDATE message has passed. This contains the configuration of how to include the Local AS in the AS path attribute of the MP REACH NLRI. It also contains optional configuration of additional AS Path Segments that can be included in the AS Path attribute. The AS Path consists of Set or Sequence of Autonomous Systems (AS) numbers that routing information passes through to reach the destination.This attribute identifies the autonomous systems through which routing information carried in this UPDATE message has passed. This contains the configuration of how to include the Local AS in the AS path attribute of the MP REACH NLRI. It also contains optional configuration of additional AS Path Segments that can be included in the AS Path attribute. The AS Path consists of Set or Sequence of Autonomous Systems (AS) numbers that routing information passes through to reach the destination.Optional AS PATH settings.

        Returns: BgpAsPath
        """
        return self._get_property("as_path", BgpAsPath)


class BgpV6EvpnEvis(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "evi_vxlan",
            ],
        },
        "evi_vxlan": {"type": "BgpV6EviVxlan"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "evi_vxlan",
    }  # type: Dict[str, Union(type)]

    EVI_VXLAN = "evi_vxlan"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None):
        super(BgpV6EvpnEvis, self).__init__()
        self._parent = parent
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    @property
    def evi_vxlan(self):
        # type: () -> BgpV6EviVxlan
        """Factory property that returns an instance of the BgpV6EviVxlan class

        Configuration for BGP EVPN EVI. Advertises following routes -. Type - Inclusive Multicast Ethernet Tag Route. Type - Ethernet Auto-discovery Route (Per EVI). Type - Ethernet Auto-discovery Route (Per ES)

        Returns: BgpV6EviVxlan
        """
        return self._get_property("evi_vxlan", BgpV6EviVxlan, self, "evi_vxlan")

    @property
    def choice(self):
        # type: () -> Union[Literal["evi_vxlan"]]
        """choice getter

        TBD

        Returns: Union[Literal["evi_vxlan"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["evi_vxlan"]]
        """
        self._set_property("choice", value)


class BgpV6EviVxlan(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "broadcast_domains": {"type": "BgpV6EviVxlanBroadcastDomainIter"},
        "replication_type": {
            "type": str,
            "enum": [
                "ingress_replication",
            ],
        },
        "pmsi_label": {
            "type": int,
            "format": "uint32",
            "maximum": 16777215,
        },
        "ad_label": {
            "type": int,
            "format": "uint32",
            "maximum": 16777215,
        },
        "route_distinguisher": {"type": "BgpRouteDistinguisher"},
        "route_target_export": {"type": "BgpRouteTargetIter"},
        "route_target_import": {"type": "BgpRouteTargetIter"},
        "l3_route_target_export": {"type": "BgpRouteTargetIter"},
        "l3_route_target_import": {"type": "BgpRouteTargetIter"},
        "advanced": {"type": "BgpRouteAdvanced"},
        "communities": {"type": "BgpCommunityIter"},
        "ext_communities": {"type": "BgpExtCommunityIter"},
        "as_path": {"type": "BgpAsPath"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "replication_type": "ingress_replication",
        "pmsi_label": 16,
        "ad_label": 0,
    }  # type: Dict[str, Union(type)]

    INGRESS_REPLICATION = "ingress_replication"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        replication_type="ingress_replication",
        pmsi_label=16,
        ad_label=0,
    ):
        super(BgpV6EviVxlan, self).__init__()
        self._parent = parent
        self._set_property("replication_type", replication_type)
        self._set_property("pmsi_label", pmsi_label)
        self._set_property("ad_label", ad_label)

    def set(self, replication_type=None, pmsi_label=None, ad_label=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def broadcast_domains(self):
        # type: () -> BgpV6EviVxlanBroadcastDomainIter
        """broadcast_domains getter

        This contains the list of Broadcast Domains to be configured per EVI.

        Returns: BgpV6EviVxlanBroadcastDomainIter
        """
        return self._get_property(
            "broadcast_domains",
            BgpV6EviVxlanBroadcastDomainIter,
            self._parent,
            self._choice,
        )

    @property
    def replication_type(self):
        # type: () -> Union[Literal["ingress_replication"]]
        """replication_type getter

        This model only supports Ingress Replication

        Returns: Union[Literal["ingress_replication"]]
        """
        return self._get_property("replication_type")

    @replication_type.setter
    def replication_type(self, value):
        """replication_type setter

        This model only supports Ingress Replication

        value: Union[Literal["ingress_replication"]]
        """
        self._set_property("replication_type", value)

    @property
    def pmsi_label(self):
        # type: () -> int
        """pmsi_label getter

        Downstream assigned VNI to be carried as Part of P-Multicast Service Interface Tunnel attribute (PMSI Tunnel Attribute) in Type Inclusive Multicast Ethernet Tag Route.

        Returns: int
        """
        return self._get_property("pmsi_label")

    @pmsi_label.setter
    def pmsi_label(self, value):
        """pmsi_label setter

        Downstream assigned VNI to be carried as Part of P-Multicast Service Interface Tunnel attribute (PMSI Tunnel Attribute) in Type Inclusive Multicast Ethernet Tag Route.

        value: int
        """
        self._set_property("pmsi_label", value)

    @property
    def ad_label(self):
        # type: () -> int
        """ad_label getter

        The Auto-discovery Route label (AD label) value, which gets advertised in the Ethernet Auto-discovery Route per <EVI, ESI>

        Returns: int
        """
        return self._get_property("ad_label")

    @ad_label.setter
    def ad_label(self, value):
        """ad_label setter

        The Auto-discovery Route label (AD label) value, which gets advertised in the Ethernet Auto-discovery Route per <EVI, ESI>

        value: int
        """
        self._set_property("ad_label", value)

    @property
    def route_distinguisher(self):
        # type: () -> BgpRouteDistinguisher
        """route_distinguisher getter

        BGP Route Distinguisher.BGP Route Distinguisher.BGP Route Distinguisher.BGP Route Distinguisher.Colon separated Extended Community value of Bytes "AS number: Value" identifying an EVI. Example for the as_2octet "60005:100".

        Returns: BgpRouteDistinguisher
        """
        return self._get_property("route_distinguisher", BgpRouteDistinguisher)

    @property
    def route_target_export(self):
        # type: () -> BgpRouteTargetIter
        """route_target_export getter

        List of Layer Virtual Network Identifier (L2VNI) export targets associated with this EVI.

        Returns: BgpRouteTargetIter
        """
        return self._get_property(
            "route_target_export", BgpRouteTargetIter, self._parent, self._choice
        )

    @property
    def route_target_import(self):
        # type: () -> BgpRouteTargetIter
        """route_target_import getter

        List of L2VNI import targets associated with this EVI.

        Returns: BgpRouteTargetIter
        """
        return self._get_property(
            "route_target_import", BgpRouteTargetIter, self._parent, self._choice
        )

    @property
    def l3_route_target_export(self):
        # type: () -> BgpRouteTargetIter
        """l3_route_target_export getter

        List of Layer Virtual Network Identifier (L3VNI) Export Route Targets.

        Returns: BgpRouteTargetIter
        """
        return self._get_property(
            "l3_route_target_export", BgpRouteTargetIter, self._parent, self._choice
        )

    @property
    def l3_route_target_import(self):
        # type: () -> BgpRouteTargetIter
        """l3_route_target_import getter

        List of L3VNI Import Route Targets.

        Returns: BgpRouteTargetIter
        """
        return self._get_property(
            "l3_route_target_import", BgpRouteTargetIter, self._parent, self._choice
        )

    @property
    def advanced(self):
        # type: () -> BgpRouteAdvanced
        """advanced getter

        Configuration for advanced BGP route range settings.Configuration for advanced BGP route range settings.Configuration for advanced BGP route range settings.Configuration for advanced BGP route range settings.

        Returns: BgpRouteAdvanced
        """
        return self._get_property("advanced", BgpRouteAdvanced)

    @property
    def communities(self):
        # type: () -> BgpCommunityIter
        """communities getter

        Optional community settings.

        Returns: BgpCommunityIter
        """
        return self._get_property(
            "communities", BgpCommunityIter, self._parent, self._choice
        )

    @property
    def ext_communities(self):
        # type: () -> BgpExtCommunityIter
        """ext_communities getter

        Optional Extended Community settings. The Extended Communities Attribute is transitive optional BGP attribute, with the Type Code 16. Community and Extended Communities attributes are utilized to trigger routing decisions, such as acceptance, rejection, preference, or redistribution. An extended community is an 8-Bytes value. It is divided into two main parts. The first Bytes of the community encode type and sub-type fields and the last Bytes carry unique set of data in format defined by the type and sub-type field. Extended communities provide larger range for grouping or categorizing communities. When type is administrator_as_2octet or administrator_as_4octet, the valid sub types are route target and origin. The valid value for administrator_as_2octet and administrator_as_4octet type is either two byte AS followed by four byte local administrator id or four byte AS followed by two byte local administrator id. When type is administrator_ipv4_address the valid sub types are route target and origin. The valid value for administrator_ipv4_address is four byte IPv4 address followed by two byte local administrator id. When type is opaque, valid sub types are color and encapsulation. When sub type is color, first two bytes of the value field contain flags and last four bytes contains the value of the color. When sub type is encapsulation the first four bytes of value field are reserved and last two bytes carries the tunnel type from IANA's "ETHER TYPES" registry e.g IPv4 (protocol type 0x0800), IPv6 (protocol type 0x86dd), and MPLS (protocol type 0x8847). When type is administrator_as_2octet_link_bandwidth the valid sub type is extended_bandwidth. The first two bytes of the value field contains the AS number and the last four bytes contains the bandwidth in IEEE floating point format. When type is evpn the valid subtype is mac_address. In the value field the low-order bit of the first byte(Flags) is defined as the "Sticky/static" flag and may be set to 1, indicating the MAC address is static and cannot move. The second byte is reserved and the last four bytes contain the sequence number which is used to ensure that PEs retain the correct MAC/IP Advertisement route when multiple updates occur for the same MAC address.

        Returns: BgpExtCommunityIter
        """
        return self._get_property(
            "ext_communities", BgpExtCommunityIter, self._parent, self._choice
        )

    @property
    def as_path(self):
        # type: () -> BgpAsPath
        """as_path getter

        This attribute identifies the autonomous systems through which routing information carried in this UPDATE message has passed. This contains the configuration of how to include the Local AS in the AS path attribute of the MP REACH NLRI. It also contains optional configuration of additional AS Path Segments that can be included in the AS Path attribute. The AS Path consists of Set or Sequence of Autonomous Systems (AS) numbers that routing information passes through to reach the destination.This attribute identifies the autonomous systems through which routing information carried in this UPDATE message has passed. This contains the configuration of how to include the Local AS in the AS path attribute of the MP REACH NLRI. It also contains optional configuration of additional AS Path Segments that can be included in the AS Path attribute. The AS Path consists of Set or Sequence of Autonomous Systems (AS) numbers that routing information passes through to reach the destination.This attribute identifies the autonomous systems through which routing information carried in this UPDATE message has passed. This contains the configuration of how to include the Local AS in the AS path attribute of the MP REACH NLRI. It also contains optional configuration of additional AS Path Segments that can be included in the AS Path attribute. The AS Path consists of Set or Sequence of Autonomous Systems (AS) numbers that routing information passes through to reach the destination.This attribute identifies the autonomous systems through which routing information carried in this UPDATE message has passed. This contains the configuration of how to include the Local AS in the AS path attribute of the MP REACH NLRI. It also contains optional configuration of additional AS Path Segments that can be included in the AS Path attribute. The AS Path consists of Set or Sequence of Autonomous Systems (AS) numbers that routing information passes through to reach the destination.Optional AS PATH settings.

        Returns: BgpAsPath
        """
        return self._get_property("as_path", BgpAsPath)


class BgpV6EviVxlanBroadcastDomain(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "cmac_ip_range": {"type": "BgpCMacIpRangeIter"},
        "ethernet_tag_id": {
            "type": int,
            "format": "uint32",
        },
        "vlan_aware_service": {"type": bool},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "ethernet_tag_id": 0,
        "vlan_aware_service": False,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, ethernet_tag_id=0, vlan_aware_service=False):
        super(BgpV6EviVxlanBroadcastDomain, self).__init__()
        self._parent = parent
        self._set_property("ethernet_tag_id", ethernet_tag_id)
        self._set_property("vlan_aware_service", vlan_aware_service)

    def set(self, ethernet_tag_id=None, vlan_aware_service=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def cmac_ip_range(self):
        # type: () -> BgpCMacIpRangeIter
        """cmac_ip_range getter

        This contains the list of Customer MAC/IP Ranges to be configured per Broadcast Domain. . Advertises following route . Type - MAC/IP Advertisement Route.

        Returns: BgpCMacIpRangeIter
        """
        return self._get_property(
            "cmac_ip_range", BgpCMacIpRangeIter, self._parent, self._choice
        )

    @property
    def ethernet_tag_id(self):
        # type: () -> int
        """ethernet_tag_id getter

        The Ethernet Tag ID of the Broadcast Domain.

        Returns: int
        """
        return self._get_property("ethernet_tag_id")

    @ethernet_tag_id.setter
    def ethernet_tag_id(self, value):
        """ethernet_tag_id setter

        The Ethernet Tag ID of the Broadcast Domain.

        value: int
        """
        self._set_property("ethernet_tag_id", value)

    @property
    def vlan_aware_service(self):
        # type: () -> bool
        """vlan_aware_service getter

        VLAN-Aware service to be enabled or disabled.

        Returns: bool
        """
        return self._get_property("vlan_aware_service")

    @vlan_aware_service.setter
    def vlan_aware_service(self, value):
        """vlan_aware_service setter

        VLAN-Aware service to be enabled or disabled.

        value: bool
        """
        self._set_property("vlan_aware_service", value)


class BgpV6EviVxlanBroadcastDomainIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(BgpV6EviVxlanBroadcastDomainIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[BgpV6EviVxlanBroadcastDomain]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> BgpV6EviVxlanBroadcastDomainIter
        return self._iter()

    def __next__(self):
        # type: () -> BgpV6EviVxlanBroadcastDomain
        return self._next()

    def next(self):
        # type: () -> BgpV6EviVxlanBroadcastDomain
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, BgpV6EviVxlanBroadcastDomain):
            raise Exception("Item is not an instance of BgpV6EviVxlanBroadcastDomain")

    def broadcastdomain(self, ethernet_tag_id=0, vlan_aware_service=False):
        # type: (int,bool) -> BgpV6EviVxlanBroadcastDomainIter
        """Factory method that creates an instance of the BgpV6EviVxlanBroadcastDomain class

        Configuration for Broadcast Domains per EVI.

        Returns: BgpV6EviVxlanBroadcastDomainIter
        """
        item = BgpV6EviVxlanBroadcastDomain(
            parent=self._parent,
            ethernet_tag_id=ethernet_tag_id,
            vlan_aware_service=vlan_aware_service,
        )
        self._add(item)
        return self

    def add(self, ethernet_tag_id=0, vlan_aware_service=False):
        # type: (int,bool) -> BgpV6EviVxlanBroadcastDomain
        """Add method that creates and returns an instance of the BgpV6EviVxlanBroadcastDomain class

        Configuration for Broadcast Domains per EVI.

        Returns: BgpV6EviVxlanBroadcastDomain
        """
        item = BgpV6EviVxlanBroadcastDomain(
            parent=self._parent,
            ethernet_tag_id=ethernet_tag_id,
            vlan_aware_service=vlan_aware_service,
        )
        self._add(item)
        return item


class BgpV6EvpnEvisIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = True

    def __init__(self, parent=None, choice=None):
        super(BgpV6EvpnEvisIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[BgpV6EviVxlan, BgpV6EvpnEvis]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> BgpV6EvpnEvisIter
        return self._iter()

    def __next__(self):
        # type: () -> BgpV6EvpnEvis
        return self._next()

    def next(self):
        # type: () -> BgpV6EvpnEvis
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, BgpV6EvpnEvis):
            raise Exception("Item is not an instance of BgpV6EvpnEvis")

    def evpnevis(self):
        # type: () -> BgpV6EvpnEvisIter
        """Factory method that creates an instance of the BgpV6EvpnEvis class

        This contains list of different flavors of EVPN. For example EVPN over VXLAN or EVPN over MPLS etc to be configured per Ethernet segment. Need to instantiate correct type of EVPN instance as per requirement.

        Returns: BgpV6EvpnEvisIter
        """
        item = BgpV6EvpnEvis(parent=self._parent, choice=self._choice)
        self._add(item)
        return self

    def add(self):
        # type: () -> BgpV6EvpnEvis
        """Add method that creates and returns an instance of the BgpV6EvpnEvis class

        This contains list of different flavors of EVPN. For example EVPN over VXLAN or EVPN over MPLS etc to be configured per Ethernet segment. Need to instantiate correct type of EVPN instance as per requirement.

        Returns: BgpV6EvpnEvis
        """
        item = BgpV6EvpnEvis(parent=self._parent, choice=self._choice)
        self._add(item)
        return item

    def evi_vxlan(
        self, replication_type="ingress_replication", pmsi_label=16, ad_label=0
    ):
        # type: (Union[Literal["ingress_replication"]],int,int) -> BgpV6EvpnEvisIter
        """Factory method that creates an instance of the BgpV6EviVxlan class

        Configuration for BGP EVPN EVI. Advertises following routes -. Type - Inclusive Multicast Ethernet Tag Route. Type - Ethernet Auto-discovery Route (Per EVI). Type - Ethernet Auto-discovery Route (Per ES)

        Returns: BgpV6EvpnEvisIter
        """
        item = BgpV6EvpnEvis()
        item.evi_vxlan
        item.choice = "evi_vxlan"
        self._add(item)
        return self


class BgpV6EthernetSegmentIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(BgpV6EthernetSegmentIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[BgpV6EthernetSegment]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> BgpV6EthernetSegmentIter
        return self._iter()

    def __next__(self):
        # type: () -> BgpV6EthernetSegment
        return self._next()

    def next(self):
        # type: () -> BgpV6EthernetSegment
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, BgpV6EthernetSegment):
            raise Exception("Item is not an instance of BgpV6EthernetSegment")

    def ethernetsegment(
        self, esi="00000000000000000000", active_mode="all_active", esi_label=0
    ):
        # type: (str,Union[Literal["all_active"], Literal["single_active"]],int) -> BgpV6EthernetSegmentIter
        """Factory method that creates an instance of the BgpV6EthernetSegment class

        Configuration for BGP Ethernet Segment ranges. Advertises following routes -. Type - Ethernet Segment Route

        Returns: BgpV6EthernetSegmentIter
        """
        item = BgpV6EthernetSegment(
            parent=self._parent, esi=esi, active_mode=active_mode, esi_label=esi_label
        )
        self._add(item)
        return self

    def add(self, esi="00000000000000000000", active_mode="all_active", esi_label=0):
        # type: (str,Union[Literal["all_active"], Literal["single_active"]],int) -> BgpV6EthernetSegment
        """Add method that creates and returns an instance of the BgpV6EthernetSegment class

        Configuration for BGP Ethernet Segment ranges. Advertises following routes -. Type - Ethernet Segment Route

        Returns: BgpV6EthernetSegment
        """
        item = BgpV6EthernetSegment(
            parent=self._parent, esi=esi, active_mode=active_mode, esi_label=esi_label
        )
        self._add(item)
        return item


class BgpV6PeerIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(BgpV6PeerIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[BgpV6Peer]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> BgpV6PeerIter
        return self._iter()

    def __next__(self):
        # type: () -> BgpV6Peer
        return self._next()

    def next(self):
        # type: () -> BgpV6Peer
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, BgpV6Peer):
            raise Exception("Item is not an instance of BgpV6Peer")

    def v6peer(
        self,
        peer_address=None,
        as_type=None,
        as_number=None,
        as_number_width="four",
        name=None,
    ):
        # type: (str,Union[Literal["ebgp"], Literal["ibgp"]],int,Union[Literal["four"], Literal["two"]],str) -> BgpV6PeerIter
        """Factory method that creates an instance of the BgpV6Peer class

        Configuration for BGPv6 peer settings and routes.

        Returns: BgpV6PeerIter
        """
        item = BgpV6Peer(
            parent=self._parent,
            peer_address=peer_address,
            as_type=as_type,
            as_number=as_number,
            as_number_width=as_number_width,
            name=name,
        )
        self._add(item)
        return self

    def add(
        self,
        peer_address=None,
        as_type=None,
        as_number=None,
        as_number_width="four",
        name=None,
    ):
        # type: (str,Union[Literal["ebgp"], Literal["ibgp"]],int,Union[Literal["four"], Literal["two"]],str) -> BgpV6Peer
        """Add method that creates and returns an instance of the BgpV6Peer class

        Configuration for BGPv6 peer settings and routes.

        Returns: BgpV6Peer
        """
        item = BgpV6Peer(
            parent=self._parent,
            peer_address=peer_address,
            as_type=as_type,
            as_number=as_number,
            as_number_width=as_number_width,
            name=name,
        )
        self._add(item)
        return item


class BgpV6InterfaceIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(BgpV6InterfaceIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[BgpV6Interface]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> BgpV6InterfaceIter
        return self._iter()

    def __next__(self):
        # type: () -> BgpV6Interface
        return self._next()

    def next(self):
        # type: () -> BgpV6Interface
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, BgpV6Interface):
            raise Exception("Item is not an instance of BgpV6Interface")

    def v6interface(self, ipv6_name=None):
        # type: (str) -> BgpV6InterfaceIter
        """Factory method that creates an instance of the BgpV6Interface class

        Configuration for emulated BGPv6 peers and routes on single IPv6 interface.

        Returns: BgpV6InterfaceIter
        """
        item = BgpV6Interface(parent=self._parent, ipv6_name=ipv6_name)
        self._add(item)
        return self

    def add(self, ipv6_name=None):
        # type: (str) -> BgpV6Interface
        """Add method that creates and returns an instance of the BgpV6Interface class

        Configuration for emulated BGPv6 peers and routes on single IPv6 interface.

        Returns: BgpV6Interface
        """
        item = BgpV6Interface(parent=self._parent, ipv6_name=ipv6_name)
        self._add(item)
        return item


class DeviceVxlan(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "v4_tunnels": {"type": "VxlanV4TunnelIter"},
        "v6_tunnels": {"type": "VxlanV6TunnelIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None):
        super(DeviceVxlan, self).__init__()
        self._parent = parent

    @property
    def v4_tunnels(self):
        # type: () -> VxlanV4TunnelIter
        """v4_tunnels getter

        IPv4 VXLAN Tunnels

        Returns: VxlanV4TunnelIter
        """
        return self._get_property(
            "v4_tunnels", VxlanV4TunnelIter, self._parent, self._choice
        )

    @property
    def v6_tunnels(self):
        # type: () -> VxlanV6TunnelIter
        """v6_tunnels getter

        IPv6 VXLAN Tunnels

        Returns: VxlanV6TunnelIter
        """
        return self._get_property(
            "v6_tunnels", VxlanV6TunnelIter, self._parent, self._choice
        )


class VxlanV4Tunnel(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "source_interface": {"type": str},
        "destination_ip_mode": {"type": "VxlanV4TunnelDestinationIPMode"},
        "vni": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 16777215,
        },
        "name": {"type": str},
    }  # type: Dict[str, str]

    _REQUIRED = ("source_interface", "vni", "name")  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, source_interface=None, vni=None, name=None):
        super(VxlanV4Tunnel, self).__init__()
        self._parent = parent
        self._set_property("source_interface", source_interface)
        self._set_property("vni", vni)
        self._set_property("name", name)

    def set(self, source_interface=None, vni=None, name=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def source_interface(self):
        # type: () -> str
        """source_interface getter

        Determines the source interface.. x-constraint:. /components/schemas/Device.Ipv4/properties/name. /components/schemas/Device.Ipv4Loopback/properties/name. . x-constraint:. /components/schemas/Device.Ipv4/properties/name. /components/schemas/Device.Ipv4Loopback/properties/name.

        Returns: str
        """
        return self._get_property("source_interface")

    @source_interface.setter
    def source_interface(self, value):
        """source_interface setter

        Determines the source interface.. x-constraint:. /components/schemas/Device.Ipv4/properties/name. /components/schemas/Device.Ipv4Loopback/properties/name. . x-constraint:. /components/schemas/Device.Ipv4/properties/name. /components/schemas/Device.Ipv4Loopback/properties/name.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property source_interface as None")
        self._set_property("source_interface", value)

    @property
    def destination_ip_mode(self):
        # type: () -> VxlanV4TunnelDestinationIPMode
        """destination_ip_mode getter

        Communication mode between the VTEPs, either unicast or multicast.Communication mode between the VTEPs, either unicast or multicast.Communication mode between the VTEPs, either unicast or multicast.

        Returns: VxlanV4TunnelDestinationIPMode
        """
        return self._get_property("destination_ip_mode", VxlanV4TunnelDestinationIPMode)

    @property
    def vni(self):
        # type: () -> int
        """vni getter

        VXLAN Network Identifier (VNI) to distinguish network instances on the wire

        Returns: int
        """
        return self._get_property("vni")

    @vni.setter
    def vni(self, value):
        """vni setter

        VXLAN Network Identifier (VNI) to distinguish network instances on the wire

        value: int
        """
        if value is None:
            raise TypeError("Cannot set required property vni as None")
        self._set_property("vni", value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.. Globally unique name of an object. It also serves as the primary key for arrays of objects.

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.. Globally unique name of an object. It also serves as the primary key for arrays of objects.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)


class VxlanV4TunnelDestinationIPMode(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "unicast",
                "multicast",
            ],
        },
        "unicast": {"type": "VxlanV4TunnelDestinationIPModeUnicast"},
        "multicast": {"type": "VxlanV4TunnelDestinationIPModeMulticast"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "multicast",
    }  # type: Dict[str, Union(type)]

    UNICAST = "unicast"  # type: str
    MULTICAST = "multicast"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None):
        super(VxlanV4TunnelDestinationIPMode, self).__init__()
        self._parent = parent
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    @property
    def unicast(self):
        # type: () -> VxlanV4TunnelDestinationIPModeUnicast
        """Factory property that returns an instance of the VxlanV4TunnelDestinationIPModeUnicast class

        TBD

        Returns: VxlanV4TunnelDestinationIPModeUnicast
        """
        return self._get_property(
            "unicast", VxlanV4TunnelDestinationIPModeUnicast, self, "unicast"
        )

    @property
    def multicast(self):
        # type: () -> VxlanV4TunnelDestinationIPModeMulticast
        """Factory property that returns an instance of the VxlanV4TunnelDestinationIPModeMulticast class

        Multicast Group address for member VNI(VXLAN Network Identifier)

        Returns: VxlanV4TunnelDestinationIPModeMulticast
        """
        return self._get_property(
            "multicast", VxlanV4TunnelDestinationIPModeMulticast, self, "multicast"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["multicast"], Literal["unicast"]]
        """choice getter

        unicast or multicast

        Returns: Union[Literal["multicast"], Literal["unicast"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        unicast or multicast

        value: Union[Literal["multicast"], Literal["unicast"]]
        """
        self._set_property("choice", value)


class VxlanV4TunnelDestinationIPModeUnicast(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "vteps": {"type": "VxlanV4TunnelDestinationIPModeUnicastVtepIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None):
        super(VxlanV4TunnelDestinationIPModeUnicast, self).__init__()
        self._parent = parent

    @property
    def vteps(self):
        # type: () -> VxlanV4TunnelDestinationIPModeUnicastVtepIter
        """vteps getter

        List of VTEPs for member VNI(VXLAN Network Identifier)

        Returns: VxlanV4TunnelDestinationIPModeUnicastVtepIter
        """
        return self._get_property(
            "vteps",
            VxlanV4TunnelDestinationIPModeUnicastVtepIter,
            self._parent,
            self._choice,
        )


class VxlanV4TunnelDestinationIPModeUnicastVtep(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "remote_vtep_address": {
            "type": str,
            "format": "ipv4",
        },
        "arp_suppression_cache": {
            "type": "VxlanTunnelDestinationIPModeUnicastArpSuppressionCacheIter"
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, remote_vtep_address=None):
        super(VxlanV4TunnelDestinationIPModeUnicastVtep, self).__init__()
        self._parent = parent
        self._set_property("remote_vtep_address", remote_vtep_address)

    def set(self, remote_vtep_address=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def remote_vtep_address(self):
        # type: () -> str
        """remote_vtep_address getter

        Remote VXLAN Tunnel End Point address

        Returns: str
        """
        return self._get_property("remote_vtep_address")

    @remote_vtep_address.setter
    def remote_vtep_address(self, value):
        """remote_vtep_address setter

        Remote VXLAN Tunnel End Point address

        value: str
        """
        self._set_property("remote_vtep_address", value)

    @property
    def arp_suppression_cache(self):
        # type: () -> VxlanTunnelDestinationIPModeUnicastArpSuppressionCacheIter
        """arp_suppression_cache getter

        Each VTEP maintains an ARP suppression cache table for known IP hosts and their associated MAC addresses in the VNI segment. When an end host in the VNI sends an ARP request for another end-host IP address, its local VTEP intercepts the ARP request and checks for the ARP-resolved IP address in its ARP suppression cache table. If it finds match, the local VTEP sends an ARP response on behalf of the remote end host.

        Returns: VxlanTunnelDestinationIPModeUnicastArpSuppressionCacheIter
        """
        return self._get_property(
            "arp_suppression_cache",
            VxlanTunnelDestinationIPModeUnicastArpSuppressionCacheIter,
            self._parent,
            self._choice,
        )


class VxlanTunnelDestinationIPModeUnicastArpSuppressionCache(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "remote_vm_mac": {
            "type": str,
            "format": "mac",
        },
        "remote_vm_ipv4": {
            "type": str,
            "format": "ipv4",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, remote_vm_mac=None, remote_vm_ipv4=None):
        super(VxlanTunnelDestinationIPModeUnicastArpSuppressionCache, self).__init__()
        self._parent = parent
        self._set_property("remote_vm_mac", remote_vm_mac)
        self._set_property("remote_vm_ipv4", remote_vm_ipv4)

    def set(self, remote_vm_mac=None, remote_vm_ipv4=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def remote_vm_mac(self):
        # type: () -> str
        """remote_vm_mac getter

        Remote VM MAC address bound to Remote VM IPv4 address

        Returns: str
        """
        return self._get_property("remote_vm_mac")

    @remote_vm_mac.setter
    def remote_vm_mac(self, value):
        """remote_vm_mac setter

        Remote VM MAC address bound to Remote VM IPv4 address

        value: str
        """
        self._set_property("remote_vm_mac", value)

    @property
    def remote_vm_ipv4(self):
        # type: () -> str
        """remote_vm_ipv4 getter

        Remote VM IPv4 address

        Returns: str
        """
        return self._get_property("remote_vm_ipv4")

    @remote_vm_ipv4.setter
    def remote_vm_ipv4(self, value):
        """remote_vm_ipv4 setter

        Remote VM IPv4 address

        value: str
        """
        self._set_property("remote_vm_ipv4", value)


class VxlanTunnelDestinationIPModeUnicastArpSuppressionCacheIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(
            VxlanTunnelDestinationIPModeUnicastArpSuppressionCacheIter, self
        ).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[VxlanTunnelDestinationIPModeUnicastArpSuppressionCache]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> VxlanTunnelDestinationIPModeUnicastArpSuppressionCacheIter
        return self._iter()

    def __next__(self):
        # type: () -> VxlanTunnelDestinationIPModeUnicastArpSuppressionCache
        return self._next()

    def next(self):
        # type: () -> VxlanTunnelDestinationIPModeUnicastArpSuppressionCache
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, VxlanTunnelDestinationIPModeUnicastArpSuppressionCache):
            raise Exception(
                "Item is not an instance of VxlanTunnelDestinationIPModeUnicastArpSuppressionCache"
            )

    def arpsuppressioncache(self, remote_vm_mac=None, remote_vm_ipv4=None):
        # type: (str,str) -> VxlanTunnelDestinationIPModeUnicastArpSuppressionCacheIter
        """Factory method that creates an instance of the VxlanTunnelDestinationIPModeUnicastArpSuppressionCache class

        Each VTEP maintains an ARP suppression cache table for known IP hosts and their associated MAC addresses in the VNI segment. When an end host in the VNI sends an ARP request for another end-host IP address, its local VTEP intercepts the ARP request and checks for the ARP-resolved IP address in its ARP suppression cache table. If it finds match, the local VTEP sends an ARP response on behalf of the remote end host.

        Returns: VxlanTunnelDestinationIPModeUnicastArpSuppressionCacheIter
        """
        item = VxlanTunnelDestinationIPModeUnicastArpSuppressionCache(
            parent=self._parent,
            remote_vm_mac=remote_vm_mac,
            remote_vm_ipv4=remote_vm_ipv4,
        )
        self._add(item)
        return self

    def add(self, remote_vm_mac=None, remote_vm_ipv4=None):
        # type: (str,str) -> VxlanTunnelDestinationIPModeUnicastArpSuppressionCache
        """Add method that creates and returns an instance of the VxlanTunnelDestinationIPModeUnicastArpSuppressionCache class

        Each VTEP maintains an ARP suppression cache table for known IP hosts and their associated MAC addresses in the VNI segment. When an end host in the VNI sends an ARP request for another end-host IP address, its local VTEP intercepts the ARP request and checks for the ARP-resolved IP address in its ARP suppression cache table. If it finds match, the local VTEP sends an ARP response on behalf of the remote end host.

        Returns: VxlanTunnelDestinationIPModeUnicastArpSuppressionCache
        """
        item = VxlanTunnelDestinationIPModeUnicastArpSuppressionCache(
            parent=self._parent,
            remote_vm_mac=remote_vm_mac,
            remote_vm_ipv4=remote_vm_ipv4,
        )
        self._add(item)
        return item


class VxlanV4TunnelDestinationIPModeUnicastVtepIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(VxlanV4TunnelDestinationIPModeUnicastVtepIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[VxlanV4TunnelDestinationIPModeUnicastVtep]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> VxlanV4TunnelDestinationIPModeUnicastVtepIter
        return self._iter()

    def __next__(self):
        # type: () -> VxlanV4TunnelDestinationIPModeUnicastVtep
        return self._next()

    def next(self):
        # type: () -> VxlanV4TunnelDestinationIPModeUnicastVtep
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, VxlanV4TunnelDestinationIPModeUnicastVtep):
            raise Exception(
                "Item is not an instance of VxlanV4TunnelDestinationIPModeUnicastVtep"
            )

    def vtep(self, remote_vtep_address=None):
        # type: (str) -> VxlanV4TunnelDestinationIPModeUnicastVtepIter
        """Factory method that creates an instance of the VxlanV4TunnelDestinationIPModeUnicastVtep class

        VTEP (VXLAN Tunnel End Point (VTEP)) parameters

        Returns: VxlanV4TunnelDestinationIPModeUnicastVtepIter
        """
        item = VxlanV4TunnelDestinationIPModeUnicastVtep(
            parent=self._parent, remote_vtep_address=remote_vtep_address
        )
        self._add(item)
        return self

    def add(self, remote_vtep_address=None):
        # type: (str) -> VxlanV4TunnelDestinationIPModeUnicastVtep
        """Add method that creates and returns an instance of the VxlanV4TunnelDestinationIPModeUnicastVtep class

        VTEP (VXLAN Tunnel End Point (VTEP)) parameters

        Returns: VxlanV4TunnelDestinationIPModeUnicastVtep
        """
        item = VxlanV4TunnelDestinationIPModeUnicastVtep(
            parent=self._parent, remote_vtep_address=remote_vtep_address
        )
        self._add(item)
        return item


class VxlanV4TunnelDestinationIPModeMulticast(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "address": {
            "type": str,
            "format": "ipv4",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, address=None):
        super(VxlanV4TunnelDestinationIPModeMulticast, self).__init__()
        self._parent = parent
        self._set_property("address", address)

    def set(self, address=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def address(self):
        # type: () -> str
        """address getter

        IPv4 Multicast address

        Returns: str
        """
        return self._get_property("address")

    @address.setter
    def address(self, value):
        """address setter

        IPv4 Multicast address

        value: str
        """
        self._set_property("address", value)


class VxlanV4TunnelIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(VxlanV4TunnelIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[VxlanV4Tunnel]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> VxlanV4TunnelIter
        return self._iter()

    def __next__(self):
        # type: () -> VxlanV4Tunnel
        return self._next()

    def next(self):
        # type: () -> VxlanV4Tunnel
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, VxlanV4Tunnel):
            raise Exception("Item is not an instance of VxlanV4Tunnel")

    def v4tunnel(self, source_interface=None, vni=None, name=None):
        # type: (str,int,str) -> VxlanV4TunnelIter
        """Factory method that creates an instance of the VxlanV4Tunnel class

        Configuration and operational state parameters relating to IPv4 VXLAN tunnel end-point interface.

        Returns: VxlanV4TunnelIter
        """
        item = VxlanV4Tunnel(
            parent=self._parent, source_interface=source_interface, vni=vni, name=name
        )
        self._add(item)
        return self

    def add(self, source_interface=None, vni=None, name=None):
        # type: (str,int,str) -> VxlanV4Tunnel
        """Add method that creates and returns an instance of the VxlanV4Tunnel class

        Configuration and operational state parameters relating to IPv4 VXLAN tunnel end-point interface.

        Returns: VxlanV4Tunnel
        """
        item = VxlanV4Tunnel(
            parent=self._parent, source_interface=source_interface, vni=vni, name=name
        )
        self._add(item)
        return item


class VxlanV6Tunnel(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "source_interface": {"type": str},
        "destination_ip_mode": {"type": "VxlanV6TunnelDestinationIPMode"},
        "vni": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 16777215,
        },
        "name": {"type": str},
    }  # type: Dict[str, str]

    _REQUIRED = ("source_interface", "vni", "name")  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, source_interface=None, vni=None, name=None):
        super(VxlanV6Tunnel, self).__init__()
        self._parent = parent
        self._set_property("source_interface", source_interface)
        self._set_property("vni", vni)
        self._set_property("name", name)

    def set(self, source_interface=None, vni=None, name=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def source_interface(self):
        # type: () -> str
        """source_interface getter

        Determines the source interface.. x-constraint:. /components/schemas/Device.Ipv6/properties/name. /components/schemas/Device.Ipv6Loopback/properties/name. . x-constraint:. /components/schemas/Device.Ipv6/properties/name. /components/schemas/Device.Ipv6Loopback/properties/name.

        Returns: str
        """
        return self._get_property("source_interface")

    @source_interface.setter
    def source_interface(self, value):
        """source_interface setter

        Determines the source interface.. x-constraint:. /components/schemas/Device.Ipv6/properties/name. /components/schemas/Device.Ipv6Loopback/properties/name. . x-constraint:. /components/schemas/Device.Ipv6/properties/name. /components/schemas/Device.Ipv6Loopback/properties/name.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property source_interface as None")
        self._set_property("source_interface", value)

    @property
    def destination_ip_mode(self):
        # type: () -> VxlanV6TunnelDestinationIPMode
        """destination_ip_mode getter

        Communication mode between the VTEPs, either unicast or multicast.Communication mode between the VTEPs, either unicast or multicast.Communication mode between the VTEPs, either unicast or multicast.

        Returns: VxlanV6TunnelDestinationIPMode
        """
        return self._get_property("destination_ip_mode", VxlanV6TunnelDestinationIPMode)

    @property
    def vni(self):
        # type: () -> int
        """vni getter

        VXLAN Network Identifier (VNI) to distinguish network instances on the wire

        Returns: int
        """
        return self._get_property("vni")

    @vni.setter
    def vni(self, value):
        """vni setter

        VXLAN Network Identifier (VNI) to distinguish network instances on the wire

        value: int
        """
        if value is None:
            raise TypeError("Cannot set required property vni as None")
        self._set_property("vni", value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.. Globally unique name of an object. It also serves as the primary key for arrays of objects.

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.. Globally unique name of an object. It also serves as the primary key for arrays of objects.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)


class VxlanV6TunnelDestinationIPMode(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "unicast",
                "multicast",
            ],
        },
        "unicast": {"type": "VxlanV6TunnelDestinationIPModeUnicast"},
        "multicast": {"type": "VxlanV6TunnelDestinationIPModeMulticast"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "multicast",
    }  # type: Dict[str, Union(type)]

    UNICAST = "unicast"  # type: str
    MULTICAST = "multicast"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None):
        super(VxlanV6TunnelDestinationIPMode, self).__init__()
        self._parent = parent
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    @property
    def unicast(self):
        # type: () -> VxlanV6TunnelDestinationIPModeUnicast
        """Factory property that returns an instance of the VxlanV6TunnelDestinationIPModeUnicast class

        TBD

        Returns: VxlanV6TunnelDestinationIPModeUnicast
        """
        return self._get_property(
            "unicast", VxlanV6TunnelDestinationIPModeUnicast, self, "unicast"
        )

    @property
    def multicast(self):
        # type: () -> VxlanV6TunnelDestinationIPModeMulticast
        """Factory property that returns an instance of the VxlanV6TunnelDestinationIPModeMulticast class

        Multicast Group address for member VNI(VXLAN Network Identifier)

        Returns: VxlanV6TunnelDestinationIPModeMulticast
        """
        return self._get_property(
            "multicast", VxlanV6TunnelDestinationIPModeMulticast, self, "multicast"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["multicast"], Literal["unicast"]]
        """choice getter

        unicast or multicast

        Returns: Union[Literal["multicast"], Literal["unicast"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        unicast or multicast

        value: Union[Literal["multicast"], Literal["unicast"]]
        """
        self._set_property("choice", value)


class VxlanV6TunnelDestinationIPModeUnicast(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "vteps": {"type": "VxlanV6TunnelDestinationIPModeUnicastVtepIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None):
        super(VxlanV6TunnelDestinationIPModeUnicast, self).__init__()
        self._parent = parent

    @property
    def vteps(self):
        # type: () -> VxlanV6TunnelDestinationIPModeUnicastVtepIter
        """vteps getter

        List of VTEPs for member VNI(VXLAN Network Identifier)

        Returns: VxlanV6TunnelDestinationIPModeUnicastVtepIter
        """
        return self._get_property(
            "vteps",
            VxlanV6TunnelDestinationIPModeUnicastVtepIter,
            self._parent,
            self._choice,
        )


class VxlanV6TunnelDestinationIPModeUnicastVtep(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "remote_vtep_address": {
            "type": str,
            "format": "ipv6",
        },
        "arp_suppression_cache": {
            "type": "VxlanTunnelDestinationIPModeUnicastArpSuppressionCacheIter"
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, remote_vtep_address=None):
        super(VxlanV6TunnelDestinationIPModeUnicastVtep, self).__init__()
        self._parent = parent
        self._set_property("remote_vtep_address", remote_vtep_address)

    def set(self, remote_vtep_address=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def remote_vtep_address(self):
        # type: () -> str
        """remote_vtep_address getter

        Remote VXLAN Tunnel End Point address

        Returns: str
        """
        return self._get_property("remote_vtep_address")

    @remote_vtep_address.setter
    def remote_vtep_address(self, value):
        """remote_vtep_address setter

        Remote VXLAN Tunnel End Point address

        value: str
        """
        self._set_property("remote_vtep_address", value)

    @property
    def arp_suppression_cache(self):
        # type: () -> VxlanTunnelDestinationIPModeUnicastArpSuppressionCacheIter
        """arp_suppression_cache getter

        Each VTEP maintains an ARP suppression cache table for known IP hosts and their associated MAC addresses in the VNI segment. When an end host in the VNI sends an ARP request for another end-host IP address, its local VTEP intercepts the ARP request and checks for the ARP-resolved IP address in its ARP suppression cache table. If it finds match, the local VTEP sends an ARP response on behalf of the remote end host.

        Returns: VxlanTunnelDestinationIPModeUnicastArpSuppressionCacheIter
        """
        return self._get_property(
            "arp_suppression_cache",
            VxlanTunnelDestinationIPModeUnicastArpSuppressionCacheIter,
            self._parent,
            self._choice,
        )


class VxlanV6TunnelDestinationIPModeUnicastVtepIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(VxlanV6TunnelDestinationIPModeUnicastVtepIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[VxlanV6TunnelDestinationIPModeUnicastVtep]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> VxlanV6TunnelDestinationIPModeUnicastVtepIter
        return self._iter()

    def __next__(self):
        # type: () -> VxlanV6TunnelDestinationIPModeUnicastVtep
        return self._next()

    def next(self):
        # type: () -> VxlanV6TunnelDestinationIPModeUnicastVtep
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, VxlanV6TunnelDestinationIPModeUnicastVtep):
            raise Exception(
                "Item is not an instance of VxlanV6TunnelDestinationIPModeUnicastVtep"
            )

    def vtep(self, remote_vtep_address=None):
        # type: (str) -> VxlanV6TunnelDestinationIPModeUnicastVtepIter
        """Factory method that creates an instance of the VxlanV6TunnelDestinationIPModeUnicastVtep class

        VTEP (VXLAN Tunnel End Point (VTEP)) parameters

        Returns: VxlanV6TunnelDestinationIPModeUnicastVtepIter
        """
        item = VxlanV6TunnelDestinationIPModeUnicastVtep(
            parent=self._parent, remote_vtep_address=remote_vtep_address
        )
        self._add(item)
        return self

    def add(self, remote_vtep_address=None):
        # type: (str) -> VxlanV6TunnelDestinationIPModeUnicastVtep
        """Add method that creates and returns an instance of the VxlanV6TunnelDestinationIPModeUnicastVtep class

        VTEP (VXLAN Tunnel End Point (VTEP)) parameters

        Returns: VxlanV6TunnelDestinationIPModeUnicastVtep
        """
        item = VxlanV6TunnelDestinationIPModeUnicastVtep(
            parent=self._parent, remote_vtep_address=remote_vtep_address
        )
        self._add(item)
        return item


class VxlanV6TunnelDestinationIPModeMulticast(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "address": {
            "type": str,
            "format": "ipv6",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, address=None):
        super(VxlanV6TunnelDestinationIPModeMulticast, self).__init__()
        self._parent = parent
        self._set_property("address", address)

    def set(self, address=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def address(self):
        # type: () -> str
        """address getter

        IPv6 Multicast address

        Returns: str
        """
        return self._get_property("address")

    @address.setter
    def address(self, value):
        """address setter

        IPv6 Multicast address

        value: str
        """
        self._set_property("address", value)


class VxlanV6TunnelIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(VxlanV6TunnelIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[VxlanV6Tunnel]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> VxlanV6TunnelIter
        return self._iter()

    def __next__(self):
        # type: () -> VxlanV6Tunnel
        return self._next()

    def next(self):
        # type: () -> VxlanV6Tunnel
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, VxlanV6Tunnel):
            raise Exception("Item is not an instance of VxlanV6Tunnel")

    def v6tunnel(self, source_interface=None, vni=None, name=None):
        # type: (str,int,str) -> VxlanV6TunnelIter
        """Factory method that creates an instance of the VxlanV6Tunnel class

        Configuration and operational state parameters relating to IPv6 VXLAN tunnel end-point interface.

        Returns: VxlanV6TunnelIter
        """
        item = VxlanV6Tunnel(
            parent=self._parent, source_interface=source_interface, vni=vni, name=name
        )
        self._add(item)
        return self

    def add(self, source_interface=None, vni=None, name=None):
        # type: (str,int,str) -> VxlanV6Tunnel
        """Add method that creates and returns an instance of the VxlanV6Tunnel class

        Configuration and operational state parameters relating to IPv6 VXLAN tunnel end-point interface.

        Returns: VxlanV6Tunnel
        """
        item = VxlanV6Tunnel(
            parent=self._parent, source_interface=source_interface, vni=vni, name=name
        )
        self._add(item)
        return item


class DeviceRsvp(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "ipv4_interfaces": {"type": "RsvpIpv4InterfaceIter"},
        "lsp_ipv4_interfaces": {"type": "RsvpLspIpv4InterfaceIter"},
        "name": {"type": str},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None):
        super(DeviceRsvp, self).__init__()
        self._parent = parent
        self._set_property("name", name)

    def set(self, name=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def ipv4_interfaces(self):
        # type: () -> RsvpIpv4InterfaceIter
        """ipv4_interfaces getter

        List of IPv4 RSVP connected interfaces. At least one interface should be present for device connected to the DUT. For unconnected devices, this array must be empty.

        Returns: RsvpIpv4InterfaceIter
        """
        return self._get_property(
            "ipv4_interfaces", RsvpIpv4InterfaceIter, self._parent, self._choice
        )

    @property
    def lsp_ipv4_interfaces(self):
        # type: () -> RsvpLspIpv4InterfaceIter
        """lsp_ipv4_interfaces getter

        List of IPv4 Loopback or IPv4 connected interfaces acting as RSVP ingress and egress endpoints.

        Returns: RsvpLspIpv4InterfaceIter
        """
        return self._get_property(
            "lsp_ipv4_interfaces", RsvpLspIpv4InterfaceIter, self._parent, self._choice
        )

    @property
    def name(self):
        # type: () -> str
        """name getter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        value: str
        """
        self._set_property("name", value)


class RsvpIpv4Interface(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "ipv4_name": {"type": str},
        "neighbor_ip": {
            "type": str,
            "format": "ipv4",
        },
        "label_space_start": {
            "type": int,
            "format": "uint32",
            "maximum": 1048575,
        },
        "label_space_end": {
            "type": int,
            "format": "uint32",
            "maximum": 1048575,
        },
        "enable_refresh_reduction": {"type": bool},
        "summary_refresh_interval": {
            "type": int,
            "format": "uint32",
            "maximum": 3600,
        },
        "send_bundle": {"type": bool},
        "bundle_threshold": {
            "type": int,
            "format": "uint32",
            "maximum": 1000,
        },
        "enable_hello": {"type": bool},
        "hello_interval": {
            "type": int,
            "format": "uint32",
            "maximum": 3600,
        },
        "timeout_multiplier": {
            "type": int,
            "format": "uint32",
            "maximum": 10,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("ipv4_name", "neighbor_ip")  # type: tuple(str)

    _DEFAULTS = {
        "label_space_start": 1000,
        "label_space_end": 100000,
        "enable_refresh_reduction": False,
        "summary_refresh_interval": 30,
        "send_bundle": False,
        "bundle_threshold": 50,
        "enable_hello": False,
        "hello_interval": 9,
        "timeout_multiplier": 3,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        ipv4_name=None,
        neighbor_ip=None,
        label_space_start=1000,
        label_space_end=100000,
        enable_refresh_reduction=False,
        summary_refresh_interval=30,
        send_bundle=False,
        bundle_threshold=50,
        enable_hello=False,
        hello_interval=9,
        timeout_multiplier=3,
    ):
        super(RsvpIpv4Interface, self).__init__()
        self._parent = parent
        self._set_property("ipv4_name", ipv4_name)
        self._set_property("neighbor_ip", neighbor_ip)
        self._set_property("label_space_start", label_space_start)
        self._set_property("label_space_end", label_space_end)
        self._set_property("enable_refresh_reduction", enable_refresh_reduction)
        self._set_property("summary_refresh_interval", summary_refresh_interval)
        self._set_property("send_bundle", send_bundle)
        self._set_property("bundle_threshold", bundle_threshold)
        self._set_property("enable_hello", enable_hello)
        self._set_property("hello_interval", hello_interval)
        self._set_property("timeout_multiplier", timeout_multiplier)

    def set(
        self,
        ipv4_name=None,
        neighbor_ip=None,
        label_space_start=None,
        label_space_end=None,
        enable_refresh_reduction=None,
        summary_refresh_interval=None,
        send_bundle=None,
        bundle_threshold=None,
        enable_hello=None,
        hello_interval=None,
        timeout_multiplier=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def ipv4_name(self):
        # type: () -> str
        """ipv4_name getter

        The globally unique name of the IPv4 interface connected to the DUT. This name must match the "name" field of the "ipv4_addresses" on top which this RSVP interface is configured. . x-constraint:. /components/schemas/Device.Ipv4/properties/name. . x-constraint:. /components/schemas/Device.Ipv4/properties/name.

        Returns: str
        """
        return self._get_property("ipv4_name")

    @ipv4_name.setter
    def ipv4_name(self, value):
        """ipv4_name setter

        The globally unique name of the IPv4 interface connected to the DUT. This name must match the "name" field of the "ipv4_addresses" on top which this RSVP interface is configured. . x-constraint:. /components/schemas/Device.Ipv4/properties/name. . x-constraint:. /components/schemas/Device.Ipv4/properties/name.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property ipv4_name as None")
        self._set_property("ipv4_name", value)

    @property
    def neighbor_ip(self):
        # type: () -> str
        """neighbor_ip getter

        IPv4 address of the RSVP neighbor on this interface.

        Returns: str
        """
        return self._get_property("neighbor_ip")

    @neighbor_ip.setter
    def neighbor_ip(self, value):
        """neighbor_ip setter

        IPv4 address of the RSVP neighbor on this interface.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property neighbor_ip as None")
        self._set_property("neighbor_ip", value)

    @property
    def label_space_start(self):
        # type: () -> int
        """label_space_start getter

        The user-defined label space start value. The LSPs for which this router acts as egress are assigned labels from this label pool.The"label_space_start" and "label_space_end" together defines this label-pool.

        Returns: int
        """
        return self._get_property("label_space_start")

    @label_space_start.setter
    def label_space_start(self, value):
        """label_space_start setter

        The user-defined label space start value. The LSPs for which this router acts as egress are assigned labels from this label pool.The"label_space_start" and "label_space_end" together defines this label-pool.

        value: int
        """
        self._set_property("label_space_start", value)

    @property
    def label_space_end(self):
        # type: () -> int
        """label_space_end getter

        The user-defined label space end value.The last label value that can be assigned to the LSPs for which this router acts as egress.

        Returns: int
        """
        return self._get_property("label_space_end")

    @label_space_end.setter
    def label_space_end(self, value):
        """label_space_end setter

        The user-defined label space end value.The last label value that can be assigned to the LSPs for which this router acts as egress.

        value: int
        """
        self._set_property("label_space_end", value)

    @property
    def enable_refresh_reduction(self):
        # type: () -> bool
        """enable_refresh_reduction getter

        Enables sending of Refresh Reduction as described in RFC2961.

        Returns: bool
        """
        return self._get_property("enable_refresh_reduction")

    @enable_refresh_reduction.setter
    def enable_refresh_reduction(self, value):
        """enable_refresh_reduction setter

        Enables sending of Refresh Reduction as described in RFC2961.

        value: bool
        """
        self._set_property("enable_refresh_reduction", value)

    @property
    def summary_refresh_interval(self):
        # type: () -> int
        """summary_refresh_interval getter

        The number of seconds between transmissions of successive Summary Refreshes. There is no specification specified maximum value. For clarity, setting the maximum to hour.

        Returns: int
        """
        return self._get_property("summary_refresh_interval")

    @summary_refresh_interval.setter
    def summary_refresh_interval(self, value):
        """summary_refresh_interval setter

        The number of seconds between transmissions of successive Summary Refreshes. There is no specification specified maximum value. For clarity, setting the maximum to hour.

        value: int
        """
        self._set_property("summary_refresh_interval", value)

    @property
    def send_bundle(self):
        # type: () -> bool
        """send_bundle getter

        Enables aggregration of different RSVP messages within single PDU.

        Returns: bool
        """
        return self._get_property("send_bundle")

    @send_bundle.setter
    def send_bundle(self, value):
        """send_bundle setter

        Enables aggregration of different RSVP messages within single PDU.

        value: bool
        """
        self._set_property("send_bundle", value)

    @property
    def bundle_threshold(self):
        # type: () -> int
        """bundle_threshold getter

        The number of milliseconds to wait after which RSVP will bundle different RSVP messages and transmit Bundle messages.

        Returns: int
        """
        return self._get_property("bundle_threshold")

    @bundle_threshold.setter
    def bundle_threshold(self, value):
        """bundle_threshold setter

        The number of milliseconds to wait after which RSVP will bundle different RSVP messages and transmit Bundle messages.

        value: int
        """
        self._set_property("bundle_threshold", value)

    @property
    def enable_hello(self):
        # type: () -> bool
        """enable_hello getter

        Enables sending of Hello Messages as per RFC3209.

        Returns: bool
        """
        return self._get_property("enable_hello")

    @enable_hello.setter
    def enable_hello(self, value):
        """enable_hello setter

        Enables sending of Hello Messages as per RFC3209.

        value: bool
        """
        self._set_property("enable_hello", value)

    @property
    def hello_interval(self):
        # type: () -> int
        """hello_interval getter

        If enable_hello is set to 'true', this specifies the minimum hello interval in seconds at which successive Hello Messages are sent as per RFC3209. There is no specification specified maximum value. For clarity, setting the maximum to hour.

        Returns: int
        """
        return self._get_property("hello_interval")

    @hello_interval.setter
    def hello_interval(self, value):
        """hello_interval setter

        If enable_hello is set to 'true', this specifies the minimum hello interval in seconds at which successive Hello Messages are sent as per RFC3209. There is no specification specified maximum value. For clarity, setting the maximum to hour.

        value: int
        """
        self._set_property("hello_interval", value)

    @property
    def timeout_multiplier(self):
        # type: () -> int
        """timeout_multiplier getter

        The number of missed hellos after which the node should consider RSVP Neighbor to have timed out. There is no specification specified maximum value. Setting the maximum allowed value to 10.

        Returns: int
        """
        return self._get_property("timeout_multiplier")

    @timeout_multiplier.setter
    def timeout_multiplier(self, value):
        """timeout_multiplier setter

        The number of missed hellos after which the node should consider RSVP Neighbor to have timed out. There is no specification specified maximum value. Setting the maximum allowed value to 10.

        value: int
        """
        self._set_property("timeout_multiplier", value)


class RsvpIpv4InterfaceIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(RsvpIpv4InterfaceIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[RsvpIpv4Interface]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> RsvpIpv4InterfaceIter
        return self._iter()

    def __next__(self):
        # type: () -> RsvpIpv4Interface
        return self._next()

    def next(self):
        # type: () -> RsvpIpv4Interface
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, RsvpIpv4Interface):
            raise Exception("Item is not an instance of RsvpIpv4Interface")

    def ipv4interface(
        self,
        ipv4_name=None,
        neighbor_ip=None,
        label_space_start=1000,
        label_space_end=100000,
        enable_refresh_reduction=False,
        summary_refresh_interval=30,
        send_bundle=False,
        bundle_threshold=50,
        enable_hello=False,
        hello_interval=9,
        timeout_multiplier=3,
    ):
        # type: (str,str,int,int,bool,int,bool,int,bool,int,int) -> RsvpIpv4InterfaceIter
        """Factory method that creates an instance of the RsvpIpv4Interface class

        Configuration for RSVP Interface.

        Returns: RsvpIpv4InterfaceIter
        """
        item = RsvpIpv4Interface(
            parent=self._parent,
            ipv4_name=ipv4_name,
            neighbor_ip=neighbor_ip,
            label_space_start=label_space_start,
            label_space_end=label_space_end,
            enable_refresh_reduction=enable_refresh_reduction,
            summary_refresh_interval=summary_refresh_interval,
            send_bundle=send_bundle,
            bundle_threshold=bundle_threshold,
            enable_hello=enable_hello,
            hello_interval=hello_interval,
            timeout_multiplier=timeout_multiplier,
        )
        self._add(item)
        return self

    def add(
        self,
        ipv4_name=None,
        neighbor_ip=None,
        label_space_start=1000,
        label_space_end=100000,
        enable_refresh_reduction=False,
        summary_refresh_interval=30,
        send_bundle=False,
        bundle_threshold=50,
        enable_hello=False,
        hello_interval=9,
        timeout_multiplier=3,
    ):
        # type: (str,str,int,int,bool,int,bool,int,bool,int,int) -> RsvpIpv4Interface
        """Add method that creates and returns an instance of the RsvpIpv4Interface class

        Configuration for RSVP Interface.

        Returns: RsvpIpv4Interface
        """
        item = RsvpIpv4Interface(
            parent=self._parent,
            ipv4_name=ipv4_name,
            neighbor_ip=neighbor_ip,
            label_space_start=label_space_start,
            label_space_end=label_space_end,
            enable_refresh_reduction=enable_refresh_reduction,
            summary_refresh_interval=summary_refresh_interval,
            send_bundle=send_bundle,
            bundle_threshold=bundle_threshold,
            enable_hello=enable_hello,
            hello_interval=hello_interval,
            timeout_multiplier=timeout_multiplier,
        )
        self._add(item)
        return item


class RsvpLspIpv4Interface(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "ipv4_name": {"type": str},
        "p2p_egress_ipv4_lsps": {"type": "RsvpLspIpv4InterfaceP2PEgressIpv4Lsp"},
        "p2p_ingress_ipv4_lsps": {"type": "RsvpLspIpv4InterfaceP2PIngressIpv4LspIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ("ipv4_name",)  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, ipv4_name=None):
        super(RsvpLspIpv4Interface, self).__init__()
        self._parent = parent
        self._set_property("ipv4_name", ipv4_name)

    def set(self, ipv4_name=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def ipv4_name(self):
        # type: () -> str
        """ipv4_name getter

        The globally unique name of the IPv4 or Loopback IPv4 interface acting as the RSVP ingress and egress endpoint for the LSPs configured on this interface. This must match the "name" field of either "ipv4_addresses" or "ipv4_loopbacks" on which this LSP interface is configured.. x-constraint:. /components/schemas/Device.Ipv4/properties/name. /components/schemas/Device.Ipv4Loopback/properties/name. . x-constraint:. /components/schemas/Device.Ipv4/properties/name. /components/schemas/Device.Ipv4Loopback/properties/name.

        Returns: str
        """
        return self._get_property("ipv4_name")

    @ipv4_name.setter
    def ipv4_name(self, value):
        """ipv4_name setter

        The globally unique name of the IPv4 or Loopback IPv4 interface acting as the RSVP ingress and egress endpoint for the LSPs configured on this interface. This must match the "name" field of either "ipv4_addresses" or "ipv4_loopbacks" on which this LSP interface is configured.. x-constraint:. /components/schemas/Device.Ipv4/properties/name. /components/schemas/Device.Ipv4Loopback/properties/name. . x-constraint:. /components/schemas/Device.Ipv4/properties/name. /components/schemas/Device.Ipv4Loopback/properties/name.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property ipv4_name as None")
        self._set_property("ipv4_name", value)

    @property
    def p2p_egress_ipv4_lsps(self):
        # type: () -> RsvpLspIpv4InterfaceP2PEgressIpv4Lsp
        """p2p_egress_ipv4_lsps getter

        Configuration for RSVP Egress Point-to-Point(P2P) IPv4 LSPs.Configuration for RSVP Egress Point-to-Point(P2P) IPv4 LSPs.Configuration for RSVP Egress Point-to-Point(P2P) IPv4 LSPs.Contains properties of Tail(Egress) LSPs.

        Returns: RsvpLspIpv4InterfaceP2PEgressIpv4Lsp
        """
        return self._get_property(
            "p2p_egress_ipv4_lsps", RsvpLspIpv4InterfaceP2PEgressIpv4Lsp
        )

    @property
    def p2p_ingress_ipv4_lsps(self):
        # type: () -> RsvpLspIpv4InterfaceP2PIngressIpv4LspIter
        """p2p_ingress_ipv4_lsps getter

        Array of point-to-point RSVP-TE P2P LSPs originating from this interface.

        Returns: RsvpLspIpv4InterfaceP2PIngressIpv4LspIter
        """
        return self._get_property(
            "p2p_ingress_ipv4_lsps",
            RsvpLspIpv4InterfaceP2PIngressIpv4LspIter,
            self._parent,
            self._choice,
        )


class RsvpLspIpv4InterfaceP2PEgressIpv4Lsp(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "refresh_interval": {
            "type": int,
            "format": "uint32",
            "maximum": 3600,
        },
        "timeout_multiplier": {
            "type": int,
            "format": "uint32",
            "maximum": 10,
        },
        "reservation_style": {
            "type": str,
            "enum": [
                "shared_explicit",
                "fixed_filter",
                "auto",
            ],
        },
        "enable_fixed_label": {"type": bool},
        "fixed_label_value": {
            "type": int,
            "format": "uint32",
            "maximum": 1048575,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "refresh_interval": 30,
        "timeout_multiplier": 3,
        "reservation_style": "shared_explicit",
        "enable_fixed_label": False,
        "fixed_label_value": 0,
    }  # type: Dict[str, Union(type)]

    SHARED_EXPLICIT = "shared_explicit"  # type: str
    FIXED_FILTER = "fixed_filter"  # type: str
    AUTO = "auto"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        name=None,
        refresh_interval=30,
        timeout_multiplier=3,
        reservation_style="shared_explicit",
        enable_fixed_label=False,
        fixed_label_value=0,
    ):
        super(RsvpLspIpv4InterfaceP2PEgressIpv4Lsp, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("refresh_interval", refresh_interval)
        self._set_property("timeout_multiplier", timeout_multiplier)
        self._set_property("reservation_style", reservation_style)
        self._set_property("enable_fixed_label", enable_fixed_label)
        self._set_property("fixed_label_value", fixed_label_value)

    def set(
        self,
        name=None,
        refresh_interval=None,
        timeout_multiplier=None,
        reservation_style=None,
        enable_fixed_label=None,
        fixed_label_value=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def refresh_interval(self):
        # type: () -> int
        """refresh_interval getter

        The time in seconds between successive transmissions of RESV Refreshes. The actual refresh interval is jittered by upto 50%. There is no specification specified maximum value. For clarity, setting the maximum to hour.

        Returns: int
        """
        return self._get_property("refresh_interval")

    @refresh_interval.setter
    def refresh_interval(self, value):
        """refresh_interval setter

        The time in seconds between successive transmissions of RESV Refreshes. The actual refresh interval is jittered by upto 50%. There is no specification specified maximum value. For clarity, setting the maximum to hour.

        value: int
        """
        self._set_property("refresh_interval", value)

    @property
    def timeout_multiplier(self):
        # type: () -> int
        """timeout_multiplier getter

        The number of missed PATH refreshes after which recieving node should consider the LSP state to have timed out. There is no specification specified maximum value. Setting the maximum allowed value to 10.

        Returns: int
        """
        return self._get_property("timeout_multiplier")

    @timeout_multiplier.setter
    def timeout_multiplier(self, value):
        """timeout_multiplier setter

        The number of missed PATH refreshes after which recieving node should consider the LSP state to have timed out. There is no specification specified maximum value. Setting the maximum allowed value to 10.

        value: int
        """
        self._set_property("timeout_multiplier", value)

    @property
    def reservation_style(self):
        # type: () -> Union[Literal["auto"], Literal["fixed_filter"], Literal["shared_explicit"]]
        """reservation_style getter

        It determines how RSVP-TE enabled network devices set up reservations along the path between an end-to-end QOS-enabled connection. If 'auto' is enabled, the style is chosen based on whether the incoming Path has 'SE Desired' flag set. Otherwise, the style is chosen based on the value selected for this attribute.

        Returns: Union[Literal["auto"], Literal["fixed_filter"], Literal["shared_explicit"]]
        """
        return self._get_property("reservation_style")

    @reservation_style.setter
    def reservation_style(self, value):
        """reservation_style setter

        It determines how RSVP-TE enabled network devices set up reservations along the path between an end-to-end QOS-enabled connection. If 'auto' is enabled, the style is chosen based on whether the incoming Path has 'SE Desired' flag set. Otherwise, the style is chosen based on the value selected for this attribute.

        value: Union[Literal["auto"], Literal["fixed_filter"], Literal["shared_explicit"]]
        """
        self._set_property("reservation_style", value)

    @property
    def enable_fixed_label(self):
        # type: () -> bool
        """enable_fixed_label getter

        If enabled, specific fixed label will be advertised by the egress or tail end for all Path messages received by this egress. This can be leveraged to advertise Explicit or Implicit null labels.

        Returns: bool
        """
        return self._get_property("enable_fixed_label")

    @enable_fixed_label.setter
    def enable_fixed_label(self, value):
        """enable_fixed_label setter

        If enabled, specific fixed label will be advertised by the egress or tail end for all Path messages received by this egress. This can be leveraged to advertise Explicit or Implicit null labels.

        value: bool
        """
        self._set_property("enable_fixed_label", value)

    @property
    def fixed_label_value(self):
        # type: () -> int
        """fixed_label_value getter

        The fixed label value as advertised by egress in RESV message. Applicable only if 'fixed_label' is set to 'true'. Special values are '0 IPv4 Explicit NULL', '2 IPv6 Explicit NULL' and '3 Implicit NULL'. Outside of this, labels are expected to have minimum value of 16.

        Returns: int
        """
        return self._get_property("fixed_label_value")

    @fixed_label_value.setter
    def fixed_label_value(self, value):
        """fixed_label_value setter

        The fixed label value as advertised by egress in RESV message. Applicable only if 'fixed_label' is set to 'true'. Special values are '0 IPv4 Explicit NULL', '2 IPv6 Explicit NULL' and '3 Implicit NULL'. Outside of this, labels are expected to have minimum value of 16.

        value: int
        """
        self._set_property("fixed_label_value", value)


class RsvpLspIpv4InterfaceP2PIngressIpv4Lsp(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "remote_address": {
            "type": str,
            "format": "ipv4",
        },
        "tunnel_id": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 65535,
        },
        "lsp_id": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 65535,
        },
        "refresh_interval": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 3600,
        },
        "timeout_multiplier": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 10,
        },
        "backup_lsp_id": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 65535,
        },
        "lsp_switchover_delay": {
            "type": int,
            "format": "uint32",
            "minimum": 0,
            "maximum": 60000,
        },
        "session_attribute": {"type": "RsvpSessionAttribute"},
        "tspec": {"type": "RsvpTspec"},
        "fast_reroute": {"type": "RsvpFastReroute"},
        "ero": {"type": "RsvpEro"},
    }  # type: Dict[str, str]

    _REQUIRED = ("remote_address", "name")  # type: tuple(str)

    _DEFAULTS = {
        "tunnel_id": 1,
        "lsp_id": 1,
        "refresh_interval": 30,
        "timeout_multiplier": 3,
        "backup_lsp_id": 2,
        "lsp_switchover_delay": 0,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        name=None,
        remote_address=None,
        tunnel_id=1,
        lsp_id=1,
        refresh_interval=30,
        timeout_multiplier=3,
        backup_lsp_id=2,
        lsp_switchover_delay=0,
    ):
        super(RsvpLspIpv4InterfaceP2PIngressIpv4Lsp, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("remote_address", remote_address)
        self._set_property("tunnel_id", tunnel_id)
        self._set_property("lsp_id", lsp_id)
        self._set_property("refresh_interval", refresh_interval)
        self._set_property("timeout_multiplier", timeout_multiplier)
        self._set_property("backup_lsp_id", backup_lsp_id)
        self._set_property("lsp_switchover_delay", lsp_switchover_delay)

    def set(
        self,
        name=None,
        remote_address=None,
        tunnel_id=None,
        lsp_id=None,
        refresh_interval=None,
        timeout_multiplier=None,
        backup_lsp_id=None,
        lsp_switchover_delay=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def remote_address(self):
        # type: () -> str
        """remote_address getter

        IPv4 address of the remote endpoint of the LSP.

        Returns: str
        """
        return self._get_property("remote_address")

    @remote_address.setter
    def remote_address(self, value):
        """remote_address setter

        IPv4 address of the remote endpoint of the LSP.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property remote_address as None")
        self._set_property("remote_address", value)

    @property
    def tunnel_id(self):
        # type: () -> int
        """tunnel_id getter

        The Tunnel ID of the RSVP LSP. Carried in the SESSION object in Path Messages.

        Returns: int
        """
        return self._get_property("tunnel_id")

    @tunnel_id.setter
    def tunnel_id(self, value):
        """tunnel_id setter

        The Tunnel ID of the RSVP LSP. Carried in the SESSION object in Path Messages.

        value: int
        """
        self._set_property("tunnel_id", value)

    @property
    def lsp_id(self):
        # type: () -> int
        """lsp_id getter

        The LSP ID of the RSVP LSP. Carried in the SENDER_TEMPLATE object in Path Messages.

        Returns: int
        """
        return self._get_property("lsp_id")

    @lsp_id.setter
    def lsp_id(self, value):
        """lsp_id setter

        The LSP ID of the RSVP LSP. Carried in the SENDER_TEMPLATE object in Path Messages.

        value: int
        """
        self._set_property("lsp_id", value)

    @property
    def refresh_interval(self):
        # type: () -> int
        """refresh_interval getter

        The time in seconds between successive transmissions of PATH Refreshes. The actual refresh interval is jittered by upto 50%. There is no specification specified maximum value. For clarity, setting the maximum to hour.

        Returns: int
        """
        return self._get_property("refresh_interval")

    @refresh_interval.setter
    def refresh_interval(self, value):
        """refresh_interval setter

        The time in seconds between successive transmissions of PATH Refreshes. The actual refresh interval is jittered by upto 50%. There is no specification specified maximum value. For clarity, setting the maximum to hour.

        value: int
        """
        self._set_property("refresh_interval", value)

    @property
    def timeout_multiplier(self):
        # type: () -> int
        """timeout_multiplier getter

        The number of missed RESV refreshes after which recieving node should consider the LSP state to have timed out. There is no specification specified maximum value. Setting the maximum allowed value to 10.

        Returns: int
        """
        return self._get_property("timeout_multiplier")

    @timeout_multiplier.setter
    def timeout_multiplier(self, value):
        """timeout_multiplier setter

        The number of missed RESV refreshes after which recieving node should consider the LSP state to have timed out. There is no specification specified maximum value. Setting the maximum allowed value to 10.

        value: int
        """
        self._set_property("timeout_multiplier", value)

    @property
    def backup_lsp_id(self):
        # type: () -> int
        """backup_lsp_id getter

        The LSP id that will be used when creating Make-Before-Break LSP when the active LSP is using lsp_id. If the active LSP on which Make-Before-Break is being done is using the backup_lsp_id, the new LSP created will toggle to use the lsp_id instead.

        Returns: int
        """
        return self._get_property("backup_lsp_id")

    @backup_lsp_id.setter
    def backup_lsp_id(self, value):
        """backup_lsp_id setter

        The LSP id that will be used when creating Make-Before-Break LSP when the active LSP is using lsp_id. If the active LSP on which Make-Before-Break is being done is using the backup_lsp_id, the new LSP created will toggle to use the lsp_id instead.

        value: int
        """
        self._set_property("backup_lsp_id", value)

    @property
    def lsp_switchover_delay(self):
        # type: () -> int
        """lsp_switchover_delay getter

        The amount of delay in milliseconds that an implementation should wait for before switching traffic to the new LSP created after Make-Before-Break is done on an LSP. The default value is which means to switch immediately. An implementation should support minimum delay value of at least 50ms There is no specification specified maximum value. Setting maximum allowed value to minute. If delay value is supplied which is lesser than the minimum delay value supported, warning should be provided indicating that the minimum value of LSP switchover delay is automatically increased to the supported minimum value. This warning should be included in the list of warnings in the 'Response.Warning' attribute sent in the SetConfig 'Success' Response.

        Returns: int
        """
        return self._get_property("lsp_switchover_delay")

    @lsp_switchover_delay.setter
    def lsp_switchover_delay(self, value):
        """lsp_switchover_delay setter

        The amount of delay in milliseconds that an implementation should wait for before switching traffic to the new LSP created after Make-Before-Break is done on an LSP. The default value is which means to switch immediately. An implementation should support minimum delay value of at least 50ms There is no specification specified maximum value. Setting maximum allowed value to minute. If delay value is supplied which is lesser than the minimum delay value supported, warning should be provided indicating that the minimum value of LSP switchover delay is automatically increased to the supported minimum value. This warning should be included in the list of warnings in the 'Response.Warning' attribute sent in the SetConfig 'Success' Response.

        value: int
        """
        self._set_property("lsp_switchover_delay", value)

    @property
    def session_attribute(self):
        # type: () -> RsvpSessionAttribute
        """session_attribute getter

        Configuration for RSVP-TE SESSION_ATTRIBUTE object included in Path Messages as defined in RFC3209. The bandwidth_protection_desired and node_protection_desired flags are defined in RFC4090 (Fast Reroute).Configuration for RSVP-TE SESSION_ATTRIBUTE object included in Path Messages as defined in RFC3209. The bandwidth_protection_desired and node_protection_desired flags are defined in RFC4090 (Fast Reroute).Configuration for RSVP-TE SESSION_ATTRIBUTE object included in Path Messages as defined in RFC3209. The bandwidth_protection_desired and node_protection_desired flags are defined in RFC4090 (Fast Reroute).This contains the values of the fields to be included in the SESSION_ATTRIBUTE object in the Path Message sent for the LSP.

        Returns: RsvpSessionAttribute
        """
        return self._get_property("session_attribute", RsvpSessionAttribute)

    @property
    def tspec(self):
        # type: () -> RsvpTspec
        """tspec getter

        Configuration for RSVP-TE TSPEC object included in Path Messages. The usage of these parameters is defined in RFC2215.Configuration for RSVP-TE TSPEC object included in Path Messages. The usage of these parameters is defined in RFC2215.Configuration for RSVP-TE TSPEC object included in Path Messages. The usage of these parameters is defined in RFC2215.This contains the values of the fields to be included in the TSPEC object in the Path Message sent for the LSP.

        Returns: RsvpTspec
        """
        return self._get_property("tspec", RsvpTspec)

    @property
    def fast_reroute(self):
        # type: () -> RsvpFastReroute
        """fast_reroute getter

        Configuration for the optional RSVP-TE FAST_REROUTE object included in Path Messages as defined in RFC4090. Configuration for the optional RSVP-TE FAST_REROUTE object included in Path Messages as defined in RFC4090. Configuration for the optional RSVP-TE FAST_REROUTE object included in Path Messages as defined in RFC4090. This contains the values of the fields to be included in the FAST_REROUTE object in the Path Message sent for the LSP. This is an optional object If this attribute is not included the FAST_REROUTE object will not be included.

        Returns: RsvpFastReroute
        """
        return self._get_property("fast_reroute", RsvpFastReroute)

    @property
    def ero(self):
        # type: () -> RsvpEro
        """ero getter

        Configuration for the optional RSVP-TE explicit route object(ERO) object included in Path Messages. Configuration for the optional RSVP-TE explicit route object(ERO) object included in Path Messages. Configuration for the optional RSVP-TE explicit route object(ERO) object included in Path Messages. This contains the values of the fields to be included in the ERO object in the Path Message sent for the LSP. This is an optional object If this attribute is not included the ERO object will not be included.

        Returns: RsvpEro
        """
        return self._get_property("ero", RsvpEro)


class RsvpSessionAttribute(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "auto_generate_session_name": {"type": bool},
        "session_name": {
            "type": str,
            "minLength": 0,
            "maxLength": 254,
        },
        "setup_priority": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "holding_priority": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "local_protection_desired": {"type": bool},
        "label_recording_desired": {"type": bool},
        "se_style_desired": {"type": bool},
        "bandwidth_protection_desired": {"type": bool},
        "node_protection_desired": {"type": bool},
        "resource_affinities": {"type": "RsvpResourceAffinities"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "auto_generate_session_name": True,
        "setup_priority": 7,
        "holding_priority": 7,
        "local_protection_desired": False,
        "label_recording_desired": False,
        "se_style_desired": False,
        "bandwidth_protection_desired": False,
        "node_protection_desired": False,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        auto_generate_session_name=True,
        session_name=None,
        setup_priority=7,
        holding_priority=7,
        local_protection_desired=False,
        label_recording_desired=False,
        se_style_desired=False,
        bandwidth_protection_desired=False,
        node_protection_desired=False,
    ):
        super(RsvpSessionAttribute, self).__init__()
        self._parent = parent
        self._set_property("auto_generate_session_name", auto_generate_session_name)
        self._set_property("session_name", session_name)
        self._set_property("setup_priority", setup_priority)
        self._set_property("holding_priority", holding_priority)
        self._set_property("local_protection_desired", local_protection_desired)
        self._set_property("label_recording_desired", label_recording_desired)
        self._set_property("se_style_desired", se_style_desired)
        self._set_property("bandwidth_protection_desired", bandwidth_protection_desired)
        self._set_property("node_protection_desired", node_protection_desired)

    def set(
        self,
        auto_generate_session_name=None,
        session_name=None,
        setup_priority=None,
        holding_priority=None,
        local_protection_desired=None,
        label_recording_desired=None,
        se_style_desired=None,
        bandwidth_protection_desired=None,
        node_protection_desired=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def auto_generate_session_name(self):
        # type: () -> bool
        """auto_generate_session_name getter

        If this is enabled, an auto-generated Session Name is included in the SESSION_ATTRIBUTE object in the Path Message for this LSP.

        Returns: bool
        """
        return self._get_property("auto_generate_session_name")

    @auto_generate_session_name.setter
    def auto_generate_session_name(self, value):
        """auto_generate_session_name setter

        If this is enabled, an auto-generated Session Name is included in the SESSION_ATTRIBUTE object in the Path Message for this LSP.

        value: bool
        """
        self._set_property("auto_generate_session_name", value)

    @property
    def session_name(self):
        # type: () -> str
        """session_name getter

        If auto_generate_session_name is set to 'false', then the value of this field is used to fill the Session Name field of the SESSION_ATTRIBUTE object in the Path Message for this LSP. It is suggested to include the Local IP, Remote IP, Tunnel ID and LSP ID in the auto-generated Session Name to ensure uniqueness of the name in the test. The maximum length of session name is 254 bytes.

        Returns: str
        """
        return self._get_property("session_name")

    @session_name.setter
    def session_name(self, value):
        """session_name setter

        If auto_generate_session_name is set to 'false', then the value of this field is used to fill the Session Name field of the SESSION_ATTRIBUTE object in the Path Message for this LSP. It is suggested to include the Local IP, Remote IP, Tunnel ID and LSP ID in the auto-generated Session Name to ensure uniqueness of the name in the test. The maximum length of session name is 254 bytes.

        value: str
        """
        self._set_property("session_name", value)

    @property
    def setup_priority(self):
        # type: () -> int
        """setup_priority getter

        Specifies the value of the Setup Priority field. This controls whether the LSP should pre-empt existing LSP setup with certain Holding Priority if resource limitation is encountered when setting up the LSP. (e.g. bandwidth availability). The value is the highest priority while is the lowest.

        Returns: int
        """
        return self._get_property("setup_priority")

    @setup_priority.setter
    def setup_priority(self, value):
        """setup_priority setter

        Specifies the value of the Setup Priority field. This controls whether the LSP should pre-empt existing LSP setup with certain Holding Priority if resource limitation is encountered when setting up the LSP. (e.g. bandwidth availability). The value is the highest priority while is the lowest.

        value: int
        """
        self._set_property("setup_priority", value)

    @property
    def holding_priority(self):
        # type: () -> int
        """holding_priority getter

        Specifies the value of the Holding Priority field. This controls whether new LSP being created with certain Setup Priority should pre-empt this LSP if resource limitation is encountered when setting up the LSP. (e.g. bandwidth availability). The value is the highest priority while is the lowest.

        Returns: int
        """
        return self._get_property("holding_priority")

    @holding_priority.setter
    def holding_priority(self, value):
        """holding_priority setter

        Specifies the value of the Holding Priority field. This controls whether new LSP being created with certain Setup Priority should pre-empt this LSP if resource limitation is encountered when setting up the LSP. (e.g. bandwidth availability). The value is the highest priority while is the lowest.

        value: int
        """
        self._set_property("holding_priority", value)

    @property
    def local_protection_desired(self):
        # type: () -> bool
        """local_protection_desired getter

        This flag permits transit routers to use local repair mechanism which may result in violation of the explicit route object. When fault is detected on an adjacent downstream link or node, transit router can reroute traffic for fast service restoration.

        Returns: bool
        """
        return self._get_property("local_protection_desired")

    @local_protection_desired.setter
    def local_protection_desired(self, value):
        """local_protection_desired setter

        This flag permits transit routers to use local repair mechanism which may result in violation of the explicit route object. When fault is detected on an adjacent downstream link or node, transit router can reroute traffic for fast service restoration.

        value: bool
        """
        self._set_property("local_protection_desired", value)

    @property
    def label_recording_desired(self):
        # type: () -> bool
        """label_recording_desired getter

        This flag indicates that label information should be included when doing route record.

        Returns: bool
        """
        return self._get_property("label_recording_desired")

    @label_recording_desired.setter
    def label_recording_desired(self, value):
        """label_recording_desired setter

        This flag indicates that label information should be included when doing route record.

        value: bool
        """
        self._set_property("label_recording_desired", value)

    @property
    def se_style_desired(self):
        # type: () -> bool
        """se_style_desired getter

        This flag indicates that the tunnel ingress node may choose to reroute this tunnel without tearing it down. tunnel egress node SHOULD use the Shared Explicit(SE) Style when responding with Resv message.

        Returns: bool
        """
        return self._get_property("se_style_desired")

    @se_style_desired.setter
    def se_style_desired(self, value):
        """se_style_desired setter

        This flag indicates that the tunnel ingress node may choose to reroute this tunnel without tearing it down. tunnel egress node SHOULD use the Shared Explicit(SE) Style when responding with Resv message.

        value: bool
        """
        self._set_property("se_style_desired", value)

    @property
    def bandwidth_protection_desired(self):
        # type: () -> bool
        """bandwidth_protection_desired getter

        This flag in the SESSION_ATTRIBUTE object in the Path Message indicates to the PLRs along the protected LSP path that backup path with bandwidth guarantee is desired. This bandwidth has to be guaranteed for the protected LSP, if no FAST_REROUTE object is included in the PATH message. If FAST_REROUTE object is present in the Path message, then the bandwidth specified therein is to be guaranteed.

        Returns: bool
        """
        return self._get_property("bandwidth_protection_desired")

    @bandwidth_protection_desired.setter
    def bandwidth_protection_desired(self, value):
        """bandwidth_protection_desired setter

        This flag in the SESSION_ATTRIBUTE object in the Path Message indicates to the PLRs along the protected LSP path that backup path with bandwidth guarantee is desired. This bandwidth has to be guaranteed for the protected LSP, if no FAST_REROUTE object is included in the PATH message. If FAST_REROUTE object is present in the Path message, then the bandwidth specified therein is to be guaranteed.

        value: bool
        """
        self._set_property("bandwidth_protection_desired", value)

    @property
    def node_protection_desired(self):
        # type: () -> bool
        """node_protection_desired getter

        This flag in the SESSION_ATTRIBUTE object in the Path Message indicates to the PLRs along protected LSP path that it is desired to have backup path that bypasses at least the next node of the protected LSP.

        Returns: bool
        """
        return self._get_property("node_protection_desired")

    @node_protection_desired.setter
    def node_protection_desired(self, value):
        """node_protection_desired setter

        This flag in the SESSION_ATTRIBUTE object in the Path Message indicates to the PLRs along protected LSP path that it is desired to have backup path that bypasses at least the next node of the protected LSP.

        value: bool
        """
        self._set_property("node_protection_desired", value)

    @property
    def resource_affinities(self):
        # type: () -> RsvpResourceAffinities
        """resource_affinities getter

        This is an optional object. If included, the extended SESSION_ATTRIBUTE object is sent in the Path message containing the additional fields included in this object. This contains set of three bitmaps using which further constraints can be. set on the path calculated for the LSP based on the Admin Group settings in the IGP (e.g ISIS or OSPF interface).This is an optional object. If included, the extended SESSION_ATTRIBUTE object is sent in the Path message containing the additional fields included in this object. This contains set of three bitmaps using which further constraints can be. set on the path calculated for the LSP based on the Admin Group settings in the IGP (e.g ISIS or OSPF interface).This is an optional object. If included, the extended SESSION_ATTRIBUTE object is sent in the Path message containing the additional fields included in this object. This contains set of three bitmaps using which further constraints can be. set on the path calculated for the LSP based on the Admin Group settings in the IGP (e.g ISIS or OSPF interface).This is an optional object. If included the extended SESSION_ATTRIBUTE object is sent in the Path message containing the additional fields included in this object. This contains set of three bitmaps using which further constraints can be. set on the path calculated for the LSP based on the Admin Group settings in the IGP (e.g ISIS or OSPF interface).

        Returns: RsvpResourceAffinities
        """
        return self._get_property("resource_affinities", RsvpResourceAffinities)


class RsvpResourceAffinities(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "exclude_any": {
            "type": str,
            "format": "hex",
            "minLength": 0,
            "maxLength": 8,
        },
        "include_any": {
            "type": str,
            "format": "hex",
            "minLength": 0,
            "maxLength": 8,
        },
        "include_all": {
            "type": str,
            "format": "hex",
            "minLength": 0,
            "maxLength": 8,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "exclude_any": "0",
        "include_any": "0",
        "include_all": "0",
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, exclude_any="0", include_any="0", include_all="0"):
        super(RsvpResourceAffinities, self).__init__()
        self._parent = parent
        self._set_property("exclude_any", exclude_any)
        self._set_property("include_any", include_any)
        self._set_property("include_all", include_all)

    def set(self, exclude_any=None, include_any=None, include_all=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def exclude_any(self):
        # type: () -> str
        """exclude_any getter

        A 32-bit vector representing set of attribute filters associated with tunnel any of which renders link unacceptable. null set (all bits set to zero) doesn't render the link unacceptable. The most significant byte in the hex-string is the farthest to the left in the byte sequence. Leading zero bytes in the configured value may be omitted for brevity.

        Returns: str
        """
        return self._get_property("exclude_any")

    @exclude_any.setter
    def exclude_any(self, value):
        """exclude_any setter

        A 32-bit vector representing set of attribute filters associated with tunnel any of which renders link unacceptable. null set (all bits set to zero) doesn't render the link unacceptable. The most significant byte in the hex-string is the farthest to the left in the byte sequence. Leading zero bytes in the configured value may be omitted for brevity.

        value: str
        """
        self._set_property("exclude_any", value)

    @property
    def include_any(self):
        # type: () -> str
        """include_any getter

        A 32-bit vector representing set of attribute filters associated with tunnel any of which renders link acceptable. null set (all bits set to zero) automatically passes. The most significant byte in the hex-string is the farthest to the left in the byte sequence. Leading zero bytes in the configured value may be omitted for brevity.

        Returns: str
        """
        return self._get_property("include_any")

    @include_any.setter
    def include_any(self, value):
        """include_any setter

        A 32-bit vector representing set of attribute filters associated with tunnel any of which renders link acceptable. null set (all bits set to zero) automatically passes. The most significant byte in the hex-string is the farthest to the left in the byte sequence. Leading zero bytes in the configured value may be omitted for brevity.

        value: str
        """
        self._set_property("include_any", value)

    @property
    def include_all(self):
        # type: () -> str
        """include_all getter

        A 32-bit vector representing set of attribute filters associated with tunnel all of which must be present for link to be acceptable. null set (all bits set to zero) automatically passes. The most significant byte in the hex-string is the farthest to the left in the byte sequence. Leading zero bytes in the configured value may be omitted for brevity.

        Returns: str
        """
        return self._get_property("include_all")

    @include_all.setter
    def include_all(self, value):
        """include_all setter

        A 32-bit vector representing set of attribute filters associated with tunnel all of which must be present for link to be acceptable. null set (all bits set to zero) automatically passes. The most significant byte in the hex-string is the farthest to the left in the byte sequence. Leading zero bytes in the configured value may be omitted for brevity.

        value: str
        """
        self._set_property("include_all", value)


class RsvpTspec(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "token_bucket_rate": {
            "type": float,
            "format": "float",
        },
        "token_bucket_size": {
            "type": float,
            "format": "float",
        },
        "peak_data_rate": {
            "type": float,
            "format": "float",
        },
        "minimum_policed_unit": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "maximum_policed_unit": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "token_bucket_rate": 0.0,
        "token_bucket_size": 0.0,
        "peak_data_rate": 0.0,
        "minimum_policed_unit": 0,
        "maximum_policed_unit": 0,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        token_bucket_rate=0,
        token_bucket_size=0,
        peak_data_rate=0,
        minimum_policed_unit=0,
        maximum_policed_unit=0,
    ):
        super(RsvpTspec, self).__init__()
        self._parent = parent
        self._set_property("token_bucket_rate", token_bucket_rate)
        self._set_property("token_bucket_size", token_bucket_size)
        self._set_property("peak_data_rate", peak_data_rate)
        self._set_property("minimum_policed_unit", minimum_policed_unit)
        self._set_property("maximum_policed_unit", maximum_policed_unit)

    def set(
        self,
        token_bucket_rate=None,
        token_bucket_size=None,
        peak_data_rate=None,
        minimum_policed_unit=None,
        maximum_policed_unit=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def token_bucket_rate(self):
        # type: () -> float
        """token_bucket_rate getter

        The rate of the traffic to be carried in this LSP in bytes per second. This is part of the Token Bucket specification defined for traffic flow defined in RFC2215.

        Returns: float
        """
        return self._get_property("token_bucket_rate")

    @token_bucket_rate.setter
    def token_bucket_rate(self, value):
        """token_bucket_rate setter

        The rate of the traffic to be carried in this LSP in bytes per second. This is part of the Token Bucket specification defined for traffic flow defined in RFC2215.

        value: float
        """
        self._set_property("token_bucket_rate", value)

    @property
    def token_bucket_size(self):
        # type: () -> float
        """token_bucket_size getter

        The depth of the token bucket in bytes used to specify the Token Bucket characteristics of the traffic to be carried in the LSP. This is part of the Token Bucket specification defined for traffic flow defined in RFC2215.

        Returns: float
        """
        return self._get_property("token_bucket_size")

    @token_bucket_size.setter
    def token_bucket_size(self, value):
        """token_bucket_size setter

        The depth of the token bucket in bytes used to specify the Token Bucket characteristics of the traffic to be carried in the LSP. This is part of the Token Bucket specification defined for traffic flow defined in RFC2215.

        value: float
        """
        self._set_property("token_bucket_size", value)

    @property
    def peak_data_rate(self):
        # type: () -> float
        """peak_data_rate getter

        The peak data rate of the traffic in bytes per second used to specify the Token Bucket characteristics of the traffic to be carried in the LSP. This is part of the Token Bucket specification defined for traffic flow defined in RFC2215.

        Returns: float
        """
        return self._get_property("peak_data_rate")

    @peak_data_rate.setter
    def peak_data_rate(self, value):
        """peak_data_rate setter

        The peak data rate of the traffic in bytes per second used to specify the Token Bucket characteristics of the traffic to be carried in the LSP. This is part of the Token Bucket specification defined for traffic flow defined in RFC2215.

        value: float
        """
        self._set_property("peak_data_rate", value)

    @property
    def minimum_policed_unit(self):
        # type: () -> int
        """minimum_policed_unit getter

        Specifies the minium length of packet frames that will be policed.

        Returns: int
        """
        return self._get_property("minimum_policed_unit")

    @minimum_policed_unit.setter
    def minimum_policed_unit(self, value):
        """minimum_policed_unit setter

        Specifies the minium length of packet frames that will be policed.

        value: int
        """
        self._set_property("minimum_policed_unit", value)

    @property
    def maximum_policed_unit(self):
        # type: () -> int
        """maximum_policed_unit getter

        Specifies the maximum length of packet frames that will be policed.

        Returns: int
        """
        return self._get_property("maximum_policed_unit")

    @maximum_policed_unit.setter
    def maximum_policed_unit(self, value):
        """maximum_policed_unit setter

        Specifies the maximum length of packet frames that will be policed.

        value: int
        """
        self._set_property("maximum_policed_unit", value)


class RsvpFastReroute(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "setup_priority": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "holding_priority": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "hop_limit": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "bandwidth": {
            "type": float,
            "format": "float",
        },
        "exclude_any": {
            "type": str,
            "format": "hex",
            "minLength": 0,
            "maxLength": 8,
        },
        "include_any": {
            "type": str,
            "format": "hex",
            "minLength": 0,
            "maxLength": 8,
        },
        "include_all": {
            "type": str,
            "format": "hex",
            "minLength": 0,
            "maxLength": 8,
        },
        "one_to_one_backup_desired": {"type": bool},
        "facility_backup_desired": {"type": bool},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "setup_priority": 7,
        "holding_priority": 7,
        "hop_limit": 3,
        "bandwidth": 0.0,
        "exclude_any": "0",
        "include_any": "0",
        "include_all": "0",
        "one_to_one_backup_desired": False,
        "facility_backup_desired": False,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        setup_priority=7,
        holding_priority=7,
        hop_limit=3,
        bandwidth=0,
        exclude_any="0",
        include_any="0",
        include_all="0",
        one_to_one_backup_desired=False,
        facility_backup_desired=False,
    ):
        super(RsvpFastReroute, self).__init__()
        self._parent = parent
        self._set_property("setup_priority", setup_priority)
        self._set_property("holding_priority", holding_priority)
        self._set_property("hop_limit", hop_limit)
        self._set_property("bandwidth", bandwidth)
        self._set_property("exclude_any", exclude_any)
        self._set_property("include_any", include_any)
        self._set_property("include_all", include_all)
        self._set_property("one_to_one_backup_desired", one_to_one_backup_desired)
        self._set_property("facility_backup_desired", facility_backup_desired)

    def set(
        self,
        setup_priority=None,
        holding_priority=None,
        hop_limit=None,
        bandwidth=None,
        exclude_any=None,
        include_any=None,
        include_all=None,
        one_to_one_backup_desired=None,
        facility_backup_desired=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def setup_priority(self):
        # type: () -> int
        """setup_priority getter

        Specifies the value of the Setup Priority field. This controls whether the backup LSP should pre-empt existing LSP that is setup with certain Holding Priority. While setting up backup LSP, preemption of existing LSP can happen if resource limitation is encountered (e.g bandwidth availability).

        Returns: int
        """
        return self._get_property("setup_priority")

    @setup_priority.setter
    def setup_priority(self, value):
        """setup_priority setter

        Specifies the value of the Setup Priority field. This controls whether the backup LSP should pre-empt existing LSP that is setup with certain Holding Priority. While setting up backup LSP, preemption of existing LSP can happen if resource limitation is encountered (e.g bandwidth availability).

        value: int
        """
        self._set_property("setup_priority", value)

    @property
    def holding_priority(self):
        # type: () -> int
        """holding_priority getter

        Specifies the value of the Holding Priority field. This controls whether new LSP being created with certain Setup Priority should pre-empt this LSP set up with this Holding Priority. While setting up new LSP, preemption of existing LSP can happen if resource limitation is encountered (e.g bandwidth availability).

        Returns: int
        """
        return self._get_property("holding_priority")

    @holding_priority.setter
    def holding_priority(self, value):
        """holding_priority setter

        Specifies the value of the Holding Priority field. This controls whether new LSP being created with certain Setup Priority should pre-empt this LSP set up with this Holding Priority. While setting up new LSP, preemption of existing LSP can happen if resource limitation is encountered (e.g bandwidth availability).

        value: int
        """
        self._set_property("holding_priority", value)

    @property
    def hop_limit(self):
        # type: () -> int
        """hop_limit getter

        Specifies the value of the Hop Limit field. This controls the maximum number of hops the LSP should traverse to reach the LSP end-point.

        Returns: int
        """
        return self._get_property("hop_limit")

    @hop_limit.setter
    def hop_limit(self, value):
        """hop_limit setter

        Specifies the value of the Hop Limit field. This controls the maximum number of hops the LSP should traverse to reach the LSP end-point.

        value: int
        """
        self._set_property("hop_limit", value)

    @property
    def bandwidth(self):
        # type: () -> float
        """bandwidth getter

        Specifies the value of the Bandwidth field as 32-bit IEEE floating point integer, in bytes per second, as desired for the LSP.

        Returns: float
        """
        return self._get_property("bandwidth")

    @bandwidth.setter
    def bandwidth(self, value):
        """bandwidth setter

        Specifies the value of the Bandwidth field as 32-bit IEEE floating point integer, in bytes per second, as desired for the LSP.

        value: float
        """
        self._set_property("bandwidth", value)

    @property
    def exclude_any(self):
        # type: () -> str
        """exclude_any getter

        A 32-bit vector representing set of attribute filters associated with tunnel any of which renders link unacceptable. null set (all bits set to zero) doesn't render the link unacceptable. The most significant byte in the hex-string is the farthest to the left in the byte sequence. Leading zero bytes in the configured value may be omitted for brevity.

        Returns: str
        """
        return self._get_property("exclude_any")

    @exclude_any.setter
    def exclude_any(self, value):
        """exclude_any setter

        A 32-bit vector representing set of attribute filters associated with tunnel any of which renders link unacceptable. null set (all bits set to zero) doesn't render the link unacceptable. The most significant byte in the hex-string is the farthest to the left in the byte sequence. Leading zero bytes in the configured value may be omitted for brevity.

        value: str
        """
        self._set_property("exclude_any", value)

    @property
    def include_any(self):
        # type: () -> str
        """include_any getter

        A 32-bit vector representing set of attribute filters associated with tunnel any of which renders link acceptable. null set (all bits set to zero) automatically passes. The most significant byte in the hex-string is the farthest to the left in the byte sequence. Leading zero bytes in the configured value may be omitted for brevity.

        Returns: str
        """
        return self._get_property("include_any")

    @include_any.setter
    def include_any(self, value):
        """include_any setter

        A 32-bit vector representing set of attribute filters associated with tunnel any of which renders link acceptable. null set (all bits set to zero) automatically passes. The most significant byte in the hex-string is the farthest to the left in the byte sequence. Leading zero bytes in the configured value may be omitted for brevity.

        value: str
        """
        self._set_property("include_any", value)

    @property
    def include_all(self):
        # type: () -> str
        """include_all getter

        A 32-bit vector representing set of attribute filters associated with tunnel all of which must be present for link to be acceptable. null set (all bits set to zero) automatically passes. The most significant byte in the hex-string is the farthest to the left in the byte sequence. Leading zero bytes in the configured value may be omitted for brevity.

        Returns: str
        """
        return self._get_property("include_all")

    @include_all.setter
    def include_all(self, value):
        """include_all setter

        A 32-bit vector representing set of attribute filters associated with tunnel all of which must be present for link to be acceptable. null set (all bits set to zero) automatically passes. The most significant byte in the hex-string is the farthest to the left in the byte sequence. Leading zero bytes in the configured value may be omitted for brevity.

        value: str
        """
        self._set_property("include_all", value)

    @property
    def one_to_one_backup_desired(self):
        # type: () -> bool
        """one_to_one_backup_desired getter

        Requests protection via the one-to-one backup method.

        Returns: bool
        """
        return self._get_property("one_to_one_backup_desired")

    @one_to_one_backup_desired.setter
    def one_to_one_backup_desired(self, value):
        """one_to_one_backup_desired setter

        Requests protection via the one-to-one backup method.

        value: bool
        """
        self._set_property("one_to_one_backup_desired", value)

    @property
    def facility_backup_desired(self):
        # type: () -> bool
        """facility_backup_desired getter

        Requests protection via the facility backup method.

        Returns: bool
        """
        return self._get_property("facility_backup_desired")

    @facility_backup_desired.setter
    def facility_backup_desired(self, value):
        """facility_backup_desired setter

        Requests protection via the facility backup method.

        value: bool
        """
        self._set_property("facility_backup_desired", value)


class RsvpEro(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "prepend_neighbor_ip": {
            "type": str,
            "enum": [
                "dont_prepend",
                "prepend_loose",
                "prepend_strict",
            ],
        },
        "prefix_length": {
            "type": int,
            "format": "uint32",
            "maximum": 32,
        },
        "subobjects": {"type": "RsvpEroSubobjectIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "prepend_neighbor_ip": "prepend_loose",
        "prefix_length": 32,
    }  # type: Dict[str, Union(type)]

    DONT_PREPEND = "dont_prepend"  # type: str
    PREPEND_LOOSE = "prepend_loose"  # type: str
    PREPEND_STRICT = "prepend_strict"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self, parent=None, prepend_neighbor_ip="prepend_loose", prefix_length=32
    ):
        super(RsvpEro, self).__init__()
        self._parent = parent
        self._set_property("prepend_neighbor_ip", prepend_neighbor_ip)
        self._set_property("prefix_length", prefix_length)

    def set(self, prepend_neighbor_ip=None, prefix_length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def prepend_neighbor_ip(self):
        # type: () -> Union[Literal["dont_prepend"], Literal["prepend_loose"], Literal["prepend_strict"]]
        """prepend_neighbor_ip getter

        Determines whether the IP address of the RSVP neighbor should be added as an ERO sub-object. If it is to be included, it can be included as Loose hop or as Strict hop.

        Returns: Union[Literal["dont_prepend"], Literal["prepend_loose"], Literal["prepend_strict"]]
        """
        return self._get_property("prepend_neighbor_ip")

    @prepend_neighbor_ip.setter
    def prepend_neighbor_ip(self, value):
        """prepend_neighbor_ip setter

        Determines whether the IP address of the RSVP neighbor should be added as an ERO sub-object. If it is to be included, it can be included as Loose hop or as Strict hop.

        value: Union[Literal["dont_prepend"], Literal["prepend_loose"], Literal["prepend_strict"]]
        """
        self._set_property("prepend_neighbor_ip", value)

    @property
    def prefix_length(self):
        # type: () -> int
        """prefix_length getter

        If prepend_egress_ip is set to one of 'prepend_loose' or 'prepend_strict', then set this value as the prefix length of the ERO sub-object containing egress IP address.

        Returns: int
        """
        return self._get_property("prefix_length")

    @prefix_length.setter
    def prefix_length(self, value):
        """prefix_length setter

        If prepend_egress_ip is set to one of 'prepend_loose' or 'prepend_strict', then set this value as the prefix length of the ERO sub-object containing egress IP address.

        value: int
        """
        self._set_property("prefix_length", value)

    @property
    def subobjects(self):
        # type: () -> RsvpEroSubobjectIter
        """subobjects getter

        Array of sub-objects to be included in the ERO. These sub-objects contain the intermediate hops to be traversed by the LSP while being forwarded towards the egress endpoint. These sub-objects are included after the optional sub-object containing IP address of egress endpoint of the LSP (when present).

        Returns: RsvpEroSubobjectIter
        """
        return self._get_property(
            "subobjects", RsvpEroSubobjectIter, self._parent, self._choice
        )


class RsvpEroSubobject(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "type": {
            "type": str,
            "enum": [
                "ipv4",
                "as_number",
            ],
        },
        "ipv4_address": {
            "type": str,
            "format": "ipv4",
        },
        "prefix_length": {
            "type": int,
            "format": "uint32",
            "maximum": 32,
        },
        "as_number": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "hop_type": {
            "type": str,
            "enum": [
                "strict",
                "loose",
            ],
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "type": "ipv4",
        "ipv4_address": "0.0.0.0",
        "prefix_length": 32,
        "as_number": 0,
        "hop_type": "loose",
    }  # type: Dict[str, Union(type)]

    IPV4 = "ipv4"  # type: str
    AS_NUMBER = "as_number"  # type: str

    STRICT = "strict"  # type: str
    LOOSE = "loose"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        type="ipv4",
        ipv4_address="0.0.0.0",
        prefix_length=32,
        as_number=0,
        hop_type="loose",
    ):
        super(RsvpEroSubobject, self).__init__()
        self._parent = parent
        self._set_property("type", type)
        self._set_property("ipv4_address", ipv4_address)
        self._set_property("prefix_length", prefix_length)
        self._set_property("as_number", as_number)
        self._set_property("hop_type", hop_type)

    def set(
        self,
        type=None,
        ipv4_address=None,
        prefix_length=None,
        as_number=None,
        hop_type=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def type(self):
        # type: () -> Union[Literal["as_number"], Literal["ipv4"]]
        """type getter

        The type of the ERO sub-object, one of IPv4 Address or AS Number.

        Returns: Union[Literal["as_number"], Literal["ipv4"]]
        """
        return self._get_property("type")

    @type.setter
    def type(self, value):
        """type setter

        The type of the ERO sub-object, one of IPv4 Address or AS Number.

        value: Union[Literal["as_number"], Literal["ipv4"]]
        """
        self._set_property("type", value)

    @property
    def ipv4_address(self):
        # type: () -> str
        """ipv4_address getter

        IPv4 address that this LSP should traverse through. This field is applicable only if the value of 'type' is set to 'ipv4'.

        Returns: str
        """
        return self._get_property("ipv4_address")

    @ipv4_address.setter
    def ipv4_address(self, value):
        """ipv4_address setter

        IPv4 address that this LSP should traverse through. This field is applicable only if the value of 'type' is set to 'ipv4'.

        value: str
        """
        self._set_property("ipv4_address", value)

    @property
    def prefix_length(self):
        # type: () -> int
        """prefix_length getter

        Prefix length for the IPv4 address in the ERO sub-object. This field is applicable only if the value of 'type' is set to 'ipv4'.

        Returns: int
        """
        return self._get_property("prefix_length")

    @prefix_length.setter
    def prefix_length(self, value):
        """prefix_length setter

        Prefix length for the IPv4 address in the ERO sub-object. This field is applicable only if the value of 'type' is set to 'ipv4'.

        value: int
        """
        self._set_property("prefix_length", value)

    @property
    def as_number(self):
        # type: () -> int
        """as_number getter

        Autonomous System number to be set in the ERO sub-object that this LSP should traverse through. This field is applicable only if the value of 'type' is set to 'as_number'. Note that as per RFC3209, 4-byte AS encoding is not supported.

        Returns: int
        """
        return self._get_property("as_number")

    @as_number.setter
    def as_number(self, value):
        """as_number setter

        Autonomous System number to be set in the ERO sub-object that this LSP should traverse through. This field is applicable only if the value of 'type' is set to 'as_number'. Note that as per RFC3209, 4-byte AS encoding is not supported.

        value: int
        """
        self._set_property("as_number", value)

    @property
    def hop_type(self):
        # type: () -> Union[Literal["loose"], Literal["strict"]]
        """hop_type getter

        The hop type of the ERO sub-object, one of Strict or Loose.

        Returns: Union[Literal["loose"], Literal["strict"]]
        """
        return self._get_property("hop_type")

    @hop_type.setter
    def hop_type(self, value):
        """hop_type setter

        The hop type of the ERO sub-object, one of Strict or Loose.

        value: Union[Literal["loose"], Literal["strict"]]
        """
        self._set_property("hop_type", value)


class RsvpEroSubobjectIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(RsvpEroSubobjectIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[RsvpEroSubobject]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> RsvpEroSubobjectIter
        return self._iter()

    def __next__(self):
        # type: () -> RsvpEroSubobject
        return self._next()

    def next(self):
        # type: () -> RsvpEroSubobject
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, RsvpEroSubobject):
            raise Exception("Item is not an instance of RsvpEroSubobject")

    def subobject(
        self,
        type="ipv4",
        ipv4_address="0.0.0.0",
        prefix_length=32,
        as_number=0,
        hop_type="loose",
    ):
        # type: (Union[Literal["as_number"], Literal["ipv4"]],str,int,int,Union[Literal["loose"], Literal["strict"]]) -> RsvpEroSubobjectIter
        """Factory method that creates an instance of the RsvpEroSubobject class

        Configuration for the ERO sub-object.

        Returns: RsvpEroSubobjectIter
        """
        item = RsvpEroSubobject(
            parent=self._parent,
            type=type,
            ipv4_address=ipv4_address,
            prefix_length=prefix_length,
            as_number=as_number,
            hop_type=hop_type,
        )
        self._add(item)
        return self

    def add(
        self,
        type="ipv4",
        ipv4_address="0.0.0.0",
        prefix_length=32,
        as_number=0,
        hop_type="loose",
    ):
        # type: (Union[Literal["as_number"], Literal["ipv4"]],str,int,int,Union[Literal["loose"], Literal["strict"]]) -> RsvpEroSubobject
        """Add method that creates and returns an instance of the RsvpEroSubobject class

        Configuration for the ERO sub-object.

        Returns: RsvpEroSubobject
        """
        item = RsvpEroSubobject(
            parent=self._parent,
            type=type,
            ipv4_address=ipv4_address,
            prefix_length=prefix_length,
            as_number=as_number,
            hop_type=hop_type,
        )
        self._add(item)
        return item


class RsvpLspIpv4InterfaceP2PIngressIpv4LspIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(RsvpLspIpv4InterfaceP2PIngressIpv4LspIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[RsvpLspIpv4InterfaceP2PIngressIpv4Lsp]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> RsvpLspIpv4InterfaceP2PIngressIpv4LspIter
        return self._iter()

    def __next__(self):
        # type: () -> RsvpLspIpv4InterfaceP2PIngressIpv4Lsp
        return self._next()

    def next(self):
        # type: () -> RsvpLspIpv4InterfaceP2PIngressIpv4Lsp
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, RsvpLspIpv4InterfaceP2PIngressIpv4Lsp):
            raise Exception(
                "Item is not an instance of RsvpLspIpv4InterfaceP2PIngressIpv4Lsp"
            )

    def p2pingressipv4lsp(
        self,
        name=None,
        remote_address=None,
        tunnel_id=1,
        lsp_id=1,
        refresh_interval=30,
        timeout_multiplier=3,
        backup_lsp_id=2,
        lsp_switchover_delay=0,
    ):
        # type: (str,str,int,int,int,int,int,int) -> RsvpLspIpv4InterfaceP2PIngressIpv4LspIter
        """Factory method that creates an instance of the RsvpLspIpv4InterfaceP2PIngressIpv4Lsp class

        Configuration for an RSVP Ingress point-to-point LSP.

        Returns: RsvpLspIpv4InterfaceP2PIngressIpv4LspIter
        """
        item = RsvpLspIpv4InterfaceP2PIngressIpv4Lsp(
            parent=self._parent,
            name=name,
            remote_address=remote_address,
            tunnel_id=tunnel_id,
            lsp_id=lsp_id,
            refresh_interval=refresh_interval,
            timeout_multiplier=timeout_multiplier,
            backup_lsp_id=backup_lsp_id,
            lsp_switchover_delay=lsp_switchover_delay,
        )
        self._add(item)
        return self

    def add(
        self,
        name=None,
        remote_address=None,
        tunnel_id=1,
        lsp_id=1,
        refresh_interval=30,
        timeout_multiplier=3,
        backup_lsp_id=2,
        lsp_switchover_delay=0,
    ):
        # type: (str,str,int,int,int,int,int,int) -> RsvpLspIpv4InterfaceP2PIngressIpv4Lsp
        """Add method that creates and returns an instance of the RsvpLspIpv4InterfaceP2PIngressIpv4Lsp class

        Configuration for an RSVP Ingress point-to-point LSP.

        Returns: RsvpLspIpv4InterfaceP2PIngressIpv4Lsp
        """
        item = RsvpLspIpv4InterfaceP2PIngressIpv4Lsp(
            parent=self._parent,
            name=name,
            remote_address=remote_address,
            tunnel_id=tunnel_id,
            lsp_id=lsp_id,
            refresh_interval=refresh_interval,
            timeout_multiplier=timeout_multiplier,
            backup_lsp_id=backup_lsp_id,
            lsp_switchover_delay=lsp_switchover_delay,
        )
        self._add(item)
        return item


class RsvpLspIpv4InterfaceIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(RsvpLspIpv4InterfaceIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[RsvpLspIpv4Interface]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> RsvpLspIpv4InterfaceIter
        return self._iter()

    def __next__(self):
        # type: () -> RsvpLspIpv4Interface
        return self._next()

    def next(self):
        # type: () -> RsvpLspIpv4Interface
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, RsvpLspIpv4Interface):
            raise Exception("Item is not an instance of RsvpLspIpv4Interface")

    def lspipv4interface(self, ipv4_name=None):
        # type: (str) -> RsvpLspIpv4InterfaceIter
        """Factory method that creates an instance of the RsvpLspIpv4Interface class

        Configuration for RSVP LSP IPv4 Interface.

        Returns: RsvpLspIpv4InterfaceIter
        """
        item = RsvpLspIpv4Interface(parent=self._parent, ipv4_name=ipv4_name)
        self._add(item)
        return self

    def add(self, ipv4_name=None):
        # type: (str) -> RsvpLspIpv4Interface
        """Add method that creates and returns an instance of the RsvpLspIpv4Interface class

        Configuration for RSVP LSP IPv4 Interface.

        Returns: RsvpLspIpv4Interface
        """
        item = RsvpLspIpv4Interface(parent=self._parent, ipv4_name=ipv4_name)
        self._add(item)
        return item


class DeviceIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(DeviceIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[Device]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> DeviceIter
        return self._iter()

    def __next__(self):
        # type: () -> Device
        return self._next()

    def next(self):
        # type: () -> Device
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, Device):
            raise Exception("Item is not an instance of Device")

    def device(self, name=None):
        # type: (str) -> DeviceIter
        """Factory method that creates an instance of the Device class

        A container for emulated interfaces, loopback interfaces and protocol configurations.

        Returns: DeviceIter
        """
        item = Device(parent=self._parent, name=name)
        self._add(item)
        return self

    def add(self, name=None):
        # type: (str) -> Device
        """Add method that creates and returns an instance of the Device class

        A container for emulated interfaces, loopback interfaces and protocol configurations.

        Returns: Device
        """
        item = Device(parent=self._parent, name=name)
        self._add(item)
        return item


class Flow(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "tx_rx": {"type": "FlowTxRx"},
        "packet": {"type": "FlowHeaderIter"},
        "egress_packet": {"type": "FlowHeaderIter"},
        "size": {"type": "FlowSize"},
        "rate": {"type": "FlowRate"},
        "duration": {"type": "FlowDuration"},
        "metrics": {"type": "FlowMetrics"},
        "name": {"type": str},
    }  # type: Dict[str, str]

    _REQUIRED = ("tx_rx", "name")  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {
        "egress_packet": "egress_packet property in schema Flow is under-review, The packet header schema for egress tracking currently exposes unwanted fields. The query structure for tagged metrics inside flows metrics requires documenting expected response format.",
    }  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None):
        super(Flow, self).__init__()
        self._parent = parent
        self._set_property("name", name)

    def set(self, name=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def tx_rx(self):
        # type: () -> FlowTxRx
        """tx_rx getter

        A container for different types of transmit and receive endpoint containers.A container for different types of transmit and receive endpoint containers.A container for different types of transmit and receive endpoint containers.The transmit and receive endpoints.

        Returns: FlowTxRx
        """
        return self._get_property("tx_rx", FlowTxRx)

    @property
    def packet(self):
        # type: () -> FlowHeaderIter
        """packet getter

        The list of protocol headers defining the shape of all intended packets in corresponding flow as it is transmitted. by traffic-generator port.. The order of protocol headers assigned to the list is the. order they will appear on the wire.. In the case of an empty list the keyword/value of minItems: . indicates that an implementation MUST provide at least one Flow.Header object.. The default value for the Flow.Header choice property is ethernet which will result in an implementation by default providing at least one ethernet packet header.

        Returns: FlowHeaderIter
        """
        return self._get_property("packet", FlowHeaderIter, self._parent, self._choice)

    @property
    def egress_packet(self):
        # type: () -> FlowHeaderIter
        """egress_packet getter

        Under Review: The packet header schema for egress tracking currently exposes unwanted fields. The query structure for tagged metrics inside flows metrics requires documenting expected response format.. Under Review: The packet header schema for egress tracking currently exposes unwanted fields. The query structure for tagged metrics inside flows metrics requires documenting expected response format.. The list of protocol headers defining the shape of all intended packets in corresponding flow as it is received. by traffic-generator port.. For all protocol headers, only the `metric_tags` property is configurable.

        Returns: FlowHeaderIter
        """
        return self._get_property(
            "egress_packet", FlowHeaderIter, self._parent, self._choice
        )

    @property
    def size(self):
        # type: () -> FlowSize
        """size getter

        The frame size which overrides the total length of the packetThe frame size which overrides the total length of the packetThe frame size which overrides the total length of the packetThe size of the packets.

        Returns: FlowSize
        """
        return self._get_property("size", FlowSize)

    @property
    def rate(self):
        # type: () -> FlowRate
        """rate getter

        The rate of packet transmissionThe rate of packet transmissionThe rate of packet transmissionThe transmit rate of the packets.

        Returns: FlowRate
        """
        return self._get_property("rate", FlowRate)

    @property
    def duration(self):
        # type: () -> FlowDuration
        """duration getter

        A container for different transmit durations. container for different transmit durations. container for different transmit durations. The transmit duration of the packets.

        Returns: FlowDuration
        """
        return self._get_property("duration", FlowDuration)

    @property
    def metrics(self):
        # type: () -> FlowMetrics
        """metrics getter

        The optional container for configuring flow metrics.The optional container for configuring flow metrics.The optional container for configuring flow metrics.Flow metrics.

        Returns: FlowMetrics
        """
        return self._get_property("metrics", FlowMetrics)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)


class FlowTxRx(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "port",
                "device",
            ],
        },
        "port": {"type": "FlowPort"},
        "device": {"type": "FlowRouter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "port",
    }  # type: Dict[str, Union(type)]

    PORT = "port"  # type: str
    DEVICE = "device"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None):
        super(FlowTxRx, self).__init__()
        self._parent = parent
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    @property
    def port(self):
        # type: () -> FlowPort
        """Factory property that returns an instance of the FlowPort class

        A container for transmit port and 0..n intended receive ports.. When assigning this container to flow the flows's packet headers will not be populated with any address resolution information such as source and/or destination addresses. For example Flow.Ethernet dst mac address values will be defaulted to 0. For full control over the Flow.properties.packet header contents use this container.

        Returns: FlowPort
        """
        return self._get_property("port", FlowPort, self, "port")

    @property
    def device(self):
        # type: () -> FlowRouter
        """Factory property that returns an instance of the FlowRouter class

        A container for declaring map of 1..n transmit devices to 1..n receive devices. This allows for single flow to have different tx to rx device flows such as single one to one map or many to many map.

        Returns: FlowRouter
        """
        return self._get_property("device", FlowRouter, self, "device")

    @property
    def choice(self):
        # type: () -> Union[Literal["device"], Literal["port"]]
        """choice getter

        The type of transmit and receive container used by the flow.

        Returns: Union[Literal["device"], Literal["port"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        The type of transmit and receive container used by the flow.

        value: Union[Literal["device"], Literal["port"]]
        """
        self._set_property("choice", value)


class FlowPort(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "tx_name": {"type": str},
        "rx_name": {"type": str},
        "rx_names": {
            "type": list,
            "itemtype": str,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("tx_name",)  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {
        "rx_name": "rx_name property in schema FlowPort is deprecated, This property is deprecated in favor of property rx_names",
    }  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, tx_name=None, rx_name=None, rx_names=None):
        super(FlowPort, self).__init__()
        self._parent = parent
        self._set_property("tx_name", tx_name)
        self._set_property("rx_name", rx_name)
        self._set_property("rx_names", rx_names)

    def set(self, tx_name=None, rx_name=None, rx_names=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def tx_name(self):
        # type: () -> str
        """tx_name getter

        The unique name of port that is the transmit port.. x-constraint:. /components/schemas/Port/properties/name. /components/schemas/Lag/properties/name. . x-constraint:. /components/schemas/Port/properties/name. /components/schemas/Lag/properties/name.

        Returns: str
        """
        return self._get_property("tx_name")

    @tx_name.setter
    def tx_name(self, value):
        """tx_name setter

        The unique name of port that is the transmit port.. x-constraint:. /components/schemas/Port/properties/name. /components/schemas/Lag/properties/name. . x-constraint:. /components/schemas/Port/properties/name. /components/schemas/Lag/properties/name.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property tx_name as None")
        self._set_property("tx_name", value)

    @property
    def rx_name(self):
        # type: () -> str
        """rx_name getter

        Deprecated: This property is deprecated in favor of property rx_names. Deprecated: This property is deprecated in favor of property rx_names. The unique name of port that is the intended receive port.. x-constraint:. /components/schemas/Port/properties/name. /components/schemas/Lag/properties/name. . x-constraint:. /components/schemas/Port/properties/name. /components/schemas/Lag/properties/name.

        Returns: str
        """
        return self._get_property("rx_name")

    @rx_name.setter
    def rx_name(self, value):
        """rx_name setter

        Deprecated: This property is deprecated in favor of property rx_names. Deprecated: This property is deprecated in favor of property rx_names. The unique name of port that is the intended receive port.. x-constraint:. /components/schemas/Port/properties/name. /components/schemas/Lag/properties/name. . x-constraint:. /components/schemas/Port/properties/name. /components/schemas/Lag/properties/name.

        value: str
        """
        self._set_property("rx_name", value)

    @property
    def rx_names(self):
        # type: () -> List[str]
        """rx_names getter

        Unique name of ports or lags that are intended receive endpoints.. x-constraint:. /components/schemas/Port/properties/name. /components/schemas/Lag/properties/name. . x-constraint:. /components/schemas/Port/properties/name. /components/schemas/Lag/properties/name.

        Returns: List[str]
        """
        return self._get_property("rx_names")

    @rx_names.setter
    def rx_names(self, value):
        """rx_names setter

        Unique name of ports or lags that are intended receive endpoints.. x-constraint:. /components/schemas/Port/properties/name. /components/schemas/Lag/properties/name. . x-constraint:. /components/schemas/Port/properties/name. /components/schemas/Lag/properties/name.

        value: List[str]
        """
        self._set_property("rx_names", value)


class FlowRouter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "mode": {
            "type": str,
            "enum": [
                "mesh",
                "one_to_one",
            ],
        },
        "tx_names": {
            "type": list,
            "itemtype": str,
        },
        "rx_names": {
            "type": list,
            "itemtype": str,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("tx_names", "rx_names")  # type: tuple(str)

    _DEFAULTS = {
        "mode": "mesh",
    }  # type: Dict[str, Union(type)]

    MESH = "mesh"  # type: str
    ONE_TO_ONE = "one_to_one"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, mode="mesh", tx_names=None, rx_names=None):
        super(FlowRouter, self).__init__()
        self._parent = parent
        self._set_property("mode", mode)
        self._set_property("tx_names", tx_names)
        self._set_property("rx_names", rx_names)

    def set(self, mode=None, tx_names=None, rx_names=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def mode(self):
        # type: () -> Union[Literal["mesh"], Literal["one_to_one"]]
        """mode getter

        Determines the intent of creating traffic sub-flow(s) between the device endpoints, from the entities of <b>tx_names</b> to the entities of <b>rx_names</b> to derive how <b>auto</b> packet fields can be populated with the actual value(s) by the implementation.. The <b>one_to_one</b> mode creates traffic sub-flow(s) between each device endpoint pair in tx_names to rx_names by index.. The length of tx_names and rx_names MUST be the same.. The same device name can be repeated multiple times in tx_names or rx_names, in any order to create desired meshing between device(s).. For values in tx_names and values in rx_names, device endpoint pairs would be generated (each pair representing traffic sub-flow).. The <b>mesh</b> mode creates traffic sub-flow(s) between each value in tx_names to. every value in rx_names, forming the device endpoint pair(s).. For values in tx_names and values in rx_names, generated device endpoint pairs would be 2x3=6. . generated device endpoint pair with same device endpoint name for both transmit receive device endpoint MUST raise an error.. Packet fields of type <b>auto</b> would be populated with one value for each device endpoint pair (representing the traffic sub-flow). The value would be determined considering transmit receive device of the sub-flow. And the sequence of the populated value(s) would be in the order of generated device endpoint pair(s).. If device endpoint pairs are generated (based on mode, tx_names and rx_names), say (d1 to d3) and (d2 to d3), and ethernet.dst is set as <b>auto</b>, then the auto field would be <b>replaced</b> by the implementation with sequence of values, [v1,v2] where v1 is determined using context (d1,d3) and v2 using context (d2,d3).. The final outcome is that packets generated on the wire will contain the values v1,v2,v1,... for ethernet.dst field. Any non-auto packet fields should be configured accordingly. For example, non-auto packet field ethernet.src can be configured with values [u1, u2], where u1 u2 are source MAC of the connected interface of device d1 and d2 respectively. Then packets on the wire will contain correct value pairs (u1,v1),(u2,v2),(u1,v1),... for (ethernet.src,ethernet.dst) fields.

        Returns: Union[Literal["mesh"], Literal["one_to_one"]]
        """
        return self._get_property("mode")

    @mode.setter
    def mode(self, value):
        """mode setter

        Determines the intent of creating traffic sub-flow(s) between the device endpoints, from the entities of <b>tx_names</b> to the entities of <b>rx_names</b> to derive how <b>auto</b> packet fields can be populated with the actual value(s) by the implementation.. The <b>one_to_one</b> mode creates traffic sub-flow(s) between each device endpoint pair in tx_names to rx_names by index.. The length of tx_names and rx_names MUST be the same.. The same device name can be repeated multiple times in tx_names or rx_names, in any order to create desired meshing between device(s).. For values in tx_names and values in rx_names, device endpoint pairs would be generated (each pair representing traffic sub-flow).. The <b>mesh</b> mode creates traffic sub-flow(s) between each value in tx_names to. every value in rx_names, forming the device endpoint pair(s).. For values in tx_names and values in rx_names, generated device endpoint pairs would be 2x3=6. . generated device endpoint pair with same device endpoint name for both transmit receive device endpoint MUST raise an error.. Packet fields of type <b>auto</b> would be populated with one value for each device endpoint pair (representing the traffic sub-flow). The value would be determined considering transmit receive device of the sub-flow. And the sequence of the populated value(s) would be in the order of generated device endpoint pair(s).. If device endpoint pairs are generated (based on mode, tx_names and rx_names), say (d1 to d3) and (d2 to d3), and ethernet.dst is set as <b>auto</b>, then the auto field would be <b>replaced</b> by the implementation with sequence of values, [v1,v2] where v1 is determined using context (d1,d3) and v2 using context (d2,d3).. The final outcome is that packets generated on the wire will contain the values v1,v2,v1,... for ethernet.dst field. Any non-auto packet fields should be configured accordingly. For example, non-auto packet field ethernet.src can be configured with values [u1, u2], where u1 u2 are source MAC of the connected interface of device d1 and d2 respectively. Then packets on the wire will contain correct value pairs (u1,v1),(u2,v2),(u1,v1),... for (ethernet.src,ethernet.dst) fields.

        value: Union[Literal["mesh"], Literal["one_to_one"]]
        """
        self._set_property("mode", value)

    @property
    def tx_names(self):
        # type: () -> List[str]
        """tx_names getter

        TBD. x-constraint:. /components/schemas/Device.Ethernet/properties/name. /components/schemas/Device.Ipv4/properties/name. /components/schemas/Device.Ipv6/properties/name. /components/schemas/Bgp.V4RouteRange/properties/name. /components/schemas/Bgp.V6RouteRange/properties/name. /components/schemas/Bgp.CMacIpRange/properties/name. /components/schemas/Rsvp.LspIpv4Interface.P2PIngressIpv4Lsp/properties/name. /components/schemas/Isis.V4RouteRange/properties/name. /components/schemas/Isis.V6RouteRange/properties/name. . x-constraint:. /components/schemas/Device.Ethernet/properties/name. /components/schemas/Device.Ipv4/properties/name. /components/schemas/Device.Ipv6/properties/name. /components/schemas/Bgp.V4RouteRange/properties/name. /components/schemas/Bgp.V6RouteRange/properties/name. /components/schemas/Bgp.CMacIpRange/properties/name. /components/schemas/Rsvp.LspIpv4Interface.P2PIngressIpv4Lsp/properties/name. /components/schemas/Isis.V4RouteRange/properties/name. /components/schemas/Isis.V6RouteRange/properties/name.

        Returns: List[str]
        """
        return self._get_property("tx_names")

    @tx_names.setter
    def tx_names(self, value):
        """tx_names setter

        TBD. x-constraint:. /components/schemas/Device.Ethernet/properties/name. /components/schemas/Device.Ipv4/properties/name. /components/schemas/Device.Ipv6/properties/name. /components/schemas/Bgp.V4RouteRange/properties/name. /components/schemas/Bgp.V6RouteRange/properties/name. /components/schemas/Bgp.CMacIpRange/properties/name. /components/schemas/Rsvp.LspIpv4Interface.P2PIngressIpv4Lsp/properties/name. /components/schemas/Isis.V4RouteRange/properties/name. /components/schemas/Isis.V6RouteRange/properties/name. . x-constraint:. /components/schemas/Device.Ethernet/properties/name. /components/schemas/Device.Ipv4/properties/name. /components/schemas/Device.Ipv6/properties/name. /components/schemas/Bgp.V4RouteRange/properties/name. /components/schemas/Bgp.V6RouteRange/properties/name. /components/schemas/Bgp.CMacIpRange/properties/name. /components/schemas/Rsvp.LspIpv4Interface.P2PIngressIpv4Lsp/properties/name. /components/schemas/Isis.V4RouteRange/properties/name. /components/schemas/Isis.V6RouteRange/properties/name.

        value: List[str]
        """
        if value is None:
            raise TypeError("Cannot set required property tx_names as None")
        self._set_property("tx_names", value)

    @property
    def rx_names(self):
        # type: () -> List[str]
        """rx_names getter

        TBD. x-constraint:. /components/schemas/Device.Ethernet/properties/name. /components/schemas/Device.Ipv4/properties/name. /components/schemas/Device.Ipv6/properties/name. /components/schemas/Bgp.V4RouteRange/properties/name. /components/schemas/Bgp.V6RouteRange/properties/name. /components/schemas/Bgp.CMacIpRange/properties/name. /components/schemas/Rsvp.LspIpv4Interface.P2PEgressIpv4Lsp/properties/name. /components/schemas/Isis.V4RouteRange/properties/name. /components/schemas/Isis.V6RouteRange/properties/name. . x-constraint:. /components/schemas/Device.Ethernet/properties/name. /components/schemas/Device.Ipv4/properties/name. /components/schemas/Device.Ipv6/properties/name. /components/schemas/Bgp.V4RouteRange/properties/name. /components/schemas/Bgp.V6RouteRange/properties/name. /components/schemas/Bgp.CMacIpRange/properties/name. /components/schemas/Rsvp.LspIpv4Interface.P2PEgressIpv4Lsp/properties/name. /components/schemas/Isis.V4RouteRange/properties/name. /components/schemas/Isis.V6RouteRange/properties/name.

        Returns: List[str]
        """
        return self._get_property("rx_names")

    @rx_names.setter
    def rx_names(self, value):
        """rx_names setter

        TBD. x-constraint:. /components/schemas/Device.Ethernet/properties/name. /components/schemas/Device.Ipv4/properties/name. /components/schemas/Device.Ipv6/properties/name. /components/schemas/Bgp.V4RouteRange/properties/name. /components/schemas/Bgp.V6RouteRange/properties/name. /components/schemas/Bgp.CMacIpRange/properties/name. /components/schemas/Rsvp.LspIpv4Interface.P2PEgressIpv4Lsp/properties/name. /components/schemas/Isis.V4RouteRange/properties/name. /components/schemas/Isis.V6RouteRange/properties/name. . x-constraint:. /components/schemas/Device.Ethernet/properties/name. /components/schemas/Device.Ipv4/properties/name. /components/schemas/Device.Ipv6/properties/name. /components/schemas/Bgp.V4RouteRange/properties/name. /components/schemas/Bgp.V6RouteRange/properties/name. /components/schemas/Bgp.CMacIpRange/properties/name. /components/schemas/Rsvp.LspIpv4Interface.P2PEgressIpv4Lsp/properties/name. /components/schemas/Isis.V4RouteRange/properties/name. /components/schemas/Isis.V6RouteRange/properties/name.

        value: List[str]
        """
        if value is None:
            raise TypeError("Cannot set required property rx_names as None")
        self._set_property("rx_names", value)


class FlowHeader(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "custom",
                "ethernet",
                "vlan",
                "vxlan",
                "ipv4",
                "ipv6",
                "pfcpause",
                "ethernetpause",
                "tcp",
                "udp",
                "gre",
                "gtpv1",
                "gtpv2",
                "arp",
                "icmp",
                "icmpv6",
                "ppp",
                "igmpv1",
                "mpls",
            ],
        },
        "custom": {"type": "FlowCustom"},
        "ethernet": {"type": "FlowEthernet"},
        "vlan": {"type": "FlowVlan"},
        "vxlan": {"type": "FlowVxlan"},
        "ipv4": {"type": "FlowIpv4"},
        "ipv6": {"type": "FlowIpv6"},
        "pfcpause": {"type": "FlowPfcPause"},
        "ethernetpause": {"type": "FlowEthernetPause"},
        "tcp": {"type": "FlowTcp"},
        "udp": {"type": "FlowUdp"},
        "gre": {"type": "FlowGre"},
        "gtpv1": {"type": "FlowGtpv1"},
        "gtpv2": {"type": "FlowGtpv2"},
        "arp": {"type": "FlowArp"},
        "icmp": {"type": "FlowIcmp"},
        "icmpv6": {"type": "FlowIcmpv6"},
        "ppp": {"type": "FlowPpp"},
        "igmpv1": {"type": "FlowIgmpv1"},
        "mpls": {"type": "FlowMpls"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "ethernet",
    }  # type: Dict[str, Union(type)]

    CUSTOM = "custom"  # type: str
    ETHERNET = "ethernet"  # type: str
    VLAN = "vlan"  # type: str
    VXLAN = "vxlan"  # type: str
    IPV4 = "ipv4"  # type: str
    IPV6 = "ipv6"  # type: str
    PFCPAUSE = "pfcpause"  # type: str
    ETHERNETPAUSE = "ethernetpause"  # type: str
    TCP = "tcp"  # type: str
    UDP = "udp"  # type: str
    GRE = "gre"  # type: str
    GTPV1 = "gtpv1"  # type: str
    GTPV2 = "gtpv2"  # type: str
    ARP = "arp"  # type: str
    ICMP = "icmp"  # type: str
    ICMPV6 = "icmpv6"  # type: str
    PPP = "ppp"  # type: str
    IGMPV1 = "igmpv1"  # type: str
    MPLS = "mpls"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None):
        super(FlowHeader, self).__init__()
        self._parent = parent
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    @property
    def custom(self):
        # type: () -> FlowCustom
        """Factory property that returns an instance of the FlowCustom class

        Custom packet header

        Returns: FlowCustom
        """
        return self._get_property("custom", FlowCustom, self, "custom")

    @property
    def ethernet(self):
        # type: () -> FlowEthernet
        """Factory property that returns an instance of the FlowEthernet class

        Ethernet packet header

        Returns: FlowEthernet
        """
        return self._get_property("ethernet", FlowEthernet, self, "ethernet")

    @property
    def vlan(self):
        # type: () -> FlowVlan
        """Factory property that returns an instance of the FlowVlan class

        VLAN packet header

        Returns: FlowVlan
        """
        return self._get_property("vlan", FlowVlan, self, "vlan")

    @property
    def vxlan(self):
        # type: () -> FlowVxlan
        """Factory property that returns an instance of the FlowVxlan class

        VXLAN packet header

        Returns: FlowVxlan
        """
        return self._get_property("vxlan", FlowVxlan, self, "vxlan")

    @property
    def ipv4(self):
        # type: () -> FlowIpv4
        """Factory property that returns an instance of the FlowIpv4 class

        IPv4 packet header

        Returns: FlowIpv4
        """
        return self._get_property("ipv4", FlowIpv4, self, "ipv4")

    @property
    def ipv6(self):
        # type: () -> FlowIpv6
        """Factory property that returns an instance of the FlowIpv6 class

        IPv6 packet header

        Returns: FlowIpv6
        """
        return self._get_property("ipv6", FlowIpv6, self, "ipv6")

    @property
    def pfcpause(self):
        # type: () -> FlowPfcPause
        """Factory property that returns an instance of the FlowPfcPause class

        IEEE 802.1Qbb PFC Pause packet header.

        Returns: FlowPfcPause
        """
        return self._get_property("pfcpause", FlowPfcPause, self, "pfcpause")

    @property
    def ethernetpause(self):
        # type: () -> FlowEthernetPause
        """Factory property that returns an instance of the FlowEthernetPause class

        IEEE 802.3x global ethernet pause packet header

        Returns: FlowEthernetPause
        """
        return self._get_property(
            "ethernetpause", FlowEthernetPause, self, "ethernetpause"
        )

    @property
    def tcp(self):
        # type: () -> FlowTcp
        """Factory property that returns an instance of the FlowTcp class

        TCP packet header

        Returns: FlowTcp
        """
        return self._get_property("tcp", FlowTcp, self, "tcp")

    @property
    def udp(self):
        # type: () -> FlowUdp
        """Factory property that returns an instance of the FlowUdp class

        UDP packet header

        Returns: FlowUdp
        """
        return self._get_property("udp", FlowUdp, self, "udp")

    @property
    def gre(self):
        # type: () -> FlowGre
        """Factory property that returns an instance of the FlowGre class

        Standard GRE packet header (RFC2784)

        Returns: FlowGre
        """
        return self._get_property("gre", FlowGre, self, "gre")

    @property
    def gtpv1(self):
        # type: () -> FlowGtpv1
        """Factory property that returns an instance of the FlowGtpv1 class

        GTPv1 packet header

        Returns: FlowGtpv1
        """
        return self._get_property("gtpv1", FlowGtpv1, self, "gtpv1")

    @property
    def gtpv2(self):
        # type: () -> FlowGtpv2
        """Factory property that returns an instance of the FlowGtpv2 class

        GTPv2 packet header

        Returns: FlowGtpv2
        """
        return self._get_property("gtpv2", FlowGtpv2, self, "gtpv2")

    @property
    def arp(self):
        # type: () -> FlowArp
        """Factory property that returns an instance of the FlowArp class

        ARP packet header

        Returns: FlowArp
        """
        return self._get_property("arp", FlowArp, self, "arp")

    @property
    def icmp(self):
        # type: () -> FlowIcmp
        """Factory property that returns an instance of the FlowIcmp class

        ICMP packet header

        Returns: FlowIcmp
        """
        return self._get_property("icmp", FlowIcmp, self, "icmp")

    @property
    def icmpv6(self):
        # type: () -> FlowIcmpv6
        """Factory property that returns an instance of the FlowIcmpv6 class

        ICMPv6 packet header

        Returns: FlowIcmpv6
        """
        return self._get_property("icmpv6", FlowIcmpv6, self, "icmpv6")

    @property
    def ppp(self):
        # type: () -> FlowPpp
        """Factory property that returns an instance of the FlowPpp class

        PPP packet header

        Returns: FlowPpp
        """
        return self._get_property("ppp", FlowPpp, self, "ppp")

    @property
    def igmpv1(self):
        # type: () -> FlowIgmpv1
        """Factory property that returns an instance of the FlowIgmpv1 class

        IGMPv1 packet header

        Returns: FlowIgmpv1
        """
        return self._get_property("igmpv1", FlowIgmpv1, self, "igmpv1")

    @property
    def mpls(self):
        # type: () -> FlowMpls
        """Factory property that returns an instance of the FlowMpls class

        MPLS packet header; When configuring multiple such headers, the count shall not exceed 20.

        Returns: FlowMpls
        """
        return self._get_property("mpls", FlowMpls, self, "mpls")

    @property
    def choice(self):
        # type: () -> Union[Literal["arp"], Literal["custom"], Literal["ethernet"], Literal["ethernetpause"], Literal["gre"], Literal["gtpv1"], Literal["gtpv2"], Literal["icmp"], Literal["icmpv6"], Literal["igmpv1"], Literal["ipv4"], Literal["ipv6"], Literal["mpls"], Literal["pfcpause"], Literal["ppp"], Literal["tcp"], Literal["udp"], Literal["vlan"], Literal["vxlan"]]
        """choice getter

        The available types of flow headers. If one is not provided the default ethernet packet header MUST be provided.

        Returns: Union[Literal["arp"], Literal["custom"], Literal["ethernet"], Literal["ethernetpause"], Literal["gre"], Literal["gtpv1"], Literal["gtpv2"], Literal["icmp"], Literal["icmpv6"], Literal["igmpv1"], Literal["ipv4"], Literal["ipv6"], Literal["mpls"], Literal["pfcpause"], Literal["ppp"], Literal["tcp"], Literal["udp"], Literal["vlan"], Literal["vxlan"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        The available types of flow headers. If one is not provided the default ethernet packet header MUST be provided.

        value: Union[Literal["arp"], Literal["custom"], Literal["ethernet"], Literal["ethernetpause"], Literal["gre"], Literal["gtpv1"], Literal["gtpv2"], Literal["icmp"], Literal["icmpv6"], Literal["igmpv1"], Literal["ipv4"], Literal["ipv6"], Literal["mpls"], Literal["pfcpause"], Literal["ppp"], Literal["tcp"], Literal["udp"], Literal["vlan"], Literal["vxlan"]]
        """
        self._set_property("choice", value)


class FlowCustom(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "bytes": {"type": str},
        "metric_tags": {"type": "FlowCustomMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ("bytes",)  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, bytes=None):
        super(FlowCustom, self).__init__()
        self._parent = parent
        self._set_property("bytes", bytes)

    def set(self, bytes=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def bytes(self):
        # type: () -> str
        """bytes getter

        A custom packet header defined as string of hex bytes. The string MUST contain sequence of valid hex bytes. Spaces or colons can be part of the bytes but will be discarded. This packet header can be used in multiple places in the packet.

        Returns: str
        """
        return self._get_property("bytes")

    @bytes.setter
    def bytes(self, value):
        """bytes setter

        A custom packet header defined as string of hex bytes. The string MUST contain sequence of valid hex bytes. Spaces or colons can be part of the bytes but will be discarded. This packet header can be used in multiple places in the packet.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property bytes as None")
        self._set_property("bytes", value)

    @property
    def metric_tags(self):
        # type: () -> FlowCustomMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits. in corresponding header field for metrics per each applicable value.. These would appear as tagged metrics in corresponding flow metrics.

        Returns: FlowCustomMetricTagIter
        """
        return self._get_property(
            "metric_tags", FlowCustomMetricTagIter, self._parent, self._choice
        )


class FlowCustomMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=1):
        super(FlowCustomMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable. for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable. for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset. of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset. of corresponding header field

        value: int
        """
        self._set_property("length", value)


class FlowCustomMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(FlowCustomMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[FlowCustomMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> FlowCustomMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> FlowCustomMetricTag
        return self._next()

    def next(self):
        # type: () -> FlowCustomMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, FlowCustomMetricTag):
            raise Exception("Item is not an instance of FlowCustomMetricTag")

    def metrictag(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> FlowCustomMetricTagIter
        """Factory method that creates an instance of the FlowCustomMetricTag class

        Metric Tag can be used to enable tracking portion of or all bits. in corresponding header field for metrics per each applicable value.. These would appear as tagged metrics in corresponding flow metrics.

        Returns: FlowCustomMetricTagIter
        """
        item = FlowCustomMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> FlowCustomMetricTag
        """Add method that creates and returns an instance of the FlowCustomMetricTag class

        Metric Tag can be used to enable tracking portion of or all bits. in corresponding header field for metrics per each applicable value.. These would appear as tagged metrics in corresponding flow metrics.

        Returns: FlowCustomMetricTag
        """
        item = FlowCustomMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class FlowEthernet(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "dst": {"type": "PatternFlowEthernetDst"},
        "src": {"type": "PatternFlowEthernetSrc"},
        "ether_type": {"type": "PatternFlowEthernetEtherType"},
        "pfc_queue": {"type": "PatternFlowEthernetPfcQueue"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None):
        super(FlowEthernet, self).__init__()
        self._parent = parent

    @property
    def dst(self):
        # type: () -> PatternFlowEthernetDst
        """dst getter

        Destination MAC addressDestination MAC addressDestination MAC addressDestination MAC address

        Returns: PatternFlowEthernetDst
        """
        return self._get_property("dst", PatternFlowEthernetDst)

    @property
    def src(self):
        # type: () -> PatternFlowEthernetSrc
        """src getter

        Source MAC addressSource MAC addressSource MAC addressSource MAC address

        Returns: PatternFlowEthernetSrc
        """
        return self._get_property("src", PatternFlowEthernetSrc)

    @property
    def ether_type(self):
        # type: () -> PatternFlowEthernetEtherType
        """ether_type getter

        Ethernet typeEthernet typeEthernet typeEthernet type

        Returns: PatternFlowEthernetEtherType
        """
        return self._get_property("ether_type", PatternFlowEthernetEtherType)

    @property
    def pfc_queue(self):
        # type: () -> PatternFlowEthernetPfcQueue
        """pfc_queue getter

        Priority flow control queuePriority flow control queuePriority flow control queuePriority flow control queue

        Returns: PatternFlowEthernetPfcQueue
        """
        return self._get_property("pfc_queue", PatternFlowEthernetPfcQueue)


class PatternFlowEthernetDst(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "auto",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": str,
            "format": "mac",
        },
        "values": {
            "type": list,
            "itemtype": str,
            "itemformat": "mac",
        },
        "auto": {
            "type": str,
            "format": "mac",
        },
        "increment": {"type": "PatternFlowEthernetDstCounter"},
        "decrement": {"type": "PatternFlowEthernetDstCounter"},
        "metric_tags": {"type": "PatternFlowEthernetDstMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "auto",
        "value": "00:00:00:00:00:00",
        "values": ["00:00:00:00:00:00"],
        "auto": "00:00:00:00:00:00",
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    AUTO = "auto"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        choice=None,
        value="00:00:00:00:00:00",
        values=["00:00:00:00:00:00"],
        auto="00:00:00:00:00:00",
    ):
        super(PatternFlowEthernetDst, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        self._set_property("auto", auto)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None, auto=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowEthernetDstCounter
        """Factory property that returns an instance of the PatternFlowEthernetDstCounter class

        mac counter pattern

        Returns: PatternFlowEthernetDstCounter
        """
        return self._get_property(
            "increment", PatternFlowEthernetDstCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowEthernetDstCounter
        """Factory property that returns an instance of the PatternFlowEthernetDstCounter class

        mac counter pattern

        Returns: PatternFlowEthernetDstCounter
        """
        return self._get_property(
            "decrement", PatternFlowEthernetDstCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["auto"], Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["auto"], Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["auto"], Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> str
        """value getter

        TBD

        Returns: str
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: str
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[str]
        """values getter

        TBD

        Returns: List[str]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[str]
        """
        self._set_property("values", value, "values")

    @property
    def auto(self):
        # type: () -> str
        """auto getter

        The OTG implementation can provide system generated. value for this property. If the OTG is unable to generate value. the default value must be used.

        Returns: str
        """
        return self._get_property("auto")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowEthernetDstMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowEthernetDstMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowEthernetDstMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowEthernetDstCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": str,
            "format": "mac",
        },
        "step": {
            "type": str,
            "format": "mac",
        },
        "count": {
            "type": int,
            "format": "uint32",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": "00:00:00:00:00:00",
        "step": "00:00:00:00:00:01",
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self, parent=None, start="00:00:00:00:00:00", step="00:00:00:00:00:01", count=1
    ):
        super(PatternFlowEthernetDstCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> str
        """start getter

        TBD

        Returns: str
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: str
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> str
        """step getter

        TBD

        Returns: str
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: str
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowEthernetDstMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 47,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 48,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 48,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=48):
        super(PatternFlowEthernetDstMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowEthernetDstMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowEthernetDstMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowEthernetDstMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowEthernetDstMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowEthernetDstMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowEthernetDstMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowEthernetDstMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowEthernetDstMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=48):
        # type: (str,int,int) -> PatternFlowEthernetDstMetricTagIter
        """Factory method that creates an instance of the PatternFlowEthernetDstMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowEthernetDstMetricTagIter
        """
        item = PatternFlowEthernetDstMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=48):
        # type: (str,int,int) -> PatternFlowEthernetDstMetricTag
        """Add method that creates and returns an instance of the PatternFlowEthernetDstMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowEthernetDstMetricTag
        """
        item = PatternFlowEthernetDstMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowEthernetSrc(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": str,
            "format": "mac",
        },
        "values": {
            "type": list,
            "itemtype": str,
            "itemformat": "mac",
        },
        "increment": {"type": "PatternFlowEthernetSrcCounter"},
        "decrement": {"type": "PatternFlowEthernetSrcCounter"},
        "metric_tags": {"type": "PatternFlowEthernetSrcMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": "00:00:00:00:00:00",
        "values": ["00:00:00:00:00:00"],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        choice=None,
        value="00:00:00:00:00:00",
        values=["00:00:00:00:00:00"],
    ):
        super(PatternFlowEthernetSrc, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowEthernetSrcCounter
        """Factory property that returns an instance of the PatternFlowEthernetSrcCounter class

        mac counter pattern

        Returns: PatternFlowEthernetSrcCounter
        """
        return self._get_property(
            "increment", PatternFlowEthernetSrcCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowEthernetSrcCounter
        """Factory property that returns an instance of the PatternFlowEthernetSrcCounter class

        mac counter pattern

        Returns: PatternFlowEthernetSrcCounter
        """
        return self._get_property(
            "decrement", PatternFlowEthernetSrcCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> str
        """value getter

        TBD

        Returns: str
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: str
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[str]
        """values getter

        TBD

        Returns: List[str]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[str]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowEthernetSrcMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowEthernetSrcMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowEthernetSrcMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowEthernetSrcCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": str,
            "format": "mac",
        },
        "step": {
            "type": str,
            "format": "mac",
        },
        "count": {
            "type": int,
            "format": "uint32",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": "00:00:00:00:00:00",
        "step": "00:00:00:00:00:01",
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self, parent=None, start="00:00:00:00:00:00", step="00:00:00:00:00:01", count=1
    ):
        super(PatternFlowEthernetSrcCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> str
        """start getter

        TBD

        Returns: str
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: str
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> str
        """step getter

        TBD

        Returns: str
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: str
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowEthernetSrcMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 47,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 48,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 48,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=48):
        super(PatternFlowEthernetSrcMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowEthernetSrcMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowEthernetSrcMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowEthernetSrcMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowEthernetSrcMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowEthernetSrcMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowEthernetSrcMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowEthernetSrcMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowEthernetSrcMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=48):
        # type: (str,int,int) -> PatternFlowEthernetSrcMetricTagIter
        """Factory method that creates an instance of the PatternFlowEthernetSrcMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowEthernetSrcMetricTagIter
        """
        item = PatternFlowEthernetSrcMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=48):
        # type: (str,int,int) -> PatternFlowEthernetSrcMetricTag
        """Add method that creates and returns an instance of the PatternFlowEthernetSrcMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowEthernetSrcMetricTag
        """
        item = PatternFlowEthernetSrcMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowEthernetEtherType(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "auto",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 65535,
        },
        "auto": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "increment": {"type": "PatternFlowEthernetEtherTypeCounter"},
        "decrement": {"type": "PatternFlowEthernetEtherTypeCounter"},
        "metric_tags": {"type": "PatternFlowEthernetEtherTypeMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "auto",
        "value": 65535,
        "values": [65535],
        "auto": 65535,
    }  # type: Dict[str, Union(type)]

    IPV4 = 2048  #
    IPV6 = 34525  #
    ARP = 2054  #
    VLAN_802_1_Q = 33024  #
    RESERVED = 65535  #

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    AUTO = "auto"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self, parent=None, choice=None, value=65535, values=[65535], auto=65535
    ):
        super(PatternFlowEthernetEtherType, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        self._set_property("auto", auto)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None, auto=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowEthernetEtherTypeCounter
        """Factory property that returns an instance of the PatternFlowEthernetEtherTypeCounter class

        integer counter pattern

        Returns: PatternFlowEthernetEtherTypeCounter
        """
        return self._get_property(
            "increment", PatternFlowEthernetEtherTypeCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowEthernetEtherTypeCounter
        """Factory property that returns an instance of the PatternFlowEthernetEtherTypeCounter class

        integer counter pattern

        Returns: PatternFlowEthernetEtherTypeCounter
        """
        return self._get_property(
            "decrement", PatternFlowEthernetEtherTypeCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["auto"], Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["auto"], Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["auto"], Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def auto(self):
        # type: () -> int
        """auto getter

        The OTG implementation can provide system generated. value for this property. If the OTG is unable to generate value. the default value must be used.

        Returns: int
        """
        return self._get_property("auto")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowEthernetEtherTypeMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowEthernetEtherTypeMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowEthernetEtherTypeMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowEthernetEtherTypeCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 65535,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    IPV4 = 2048  #
    IPV6 = 34525  #
    ARP = 2054  #
    VLAN_802_1_Q = 33024  #
    RESERVED = 65535  #

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=65535, step=1, count=1):
        super(PatternFlowEthernetEtherTypeCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowEthernetEtherTypeMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 16,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 16,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=16):
        super(PatternFlowEthernetEtherTypeMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowEthernetEtherTypeMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowEthernetEtherTypeMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowEthernetEtherTypeMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowEthernetEtherTypeMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowEthernetEtherTypeMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowEthernetEtherTypeMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowEthernetEtherTypeMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowEthernetEtherTypeMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowEthernetEtherTypeMetricTagIter
        """Factory method that creates an instance of the PatternFlowEthernetEtherTypeMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowEthernetEtherTypeMetricTagIter
        """
        item = PatternFlowEthernetEtherTypeMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowEthernetEtherTypeMetricTag
        """Add method that creates and returns an instance of the PatternFlowEthernetEtherTypeMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowEthernetEtherTypeMetricTag
        """
        item = PatternFlowEthernetEtherTypeMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowEthernetPfcQueue(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 7,
        },
        "increment": {"type": "PatternFlowEthernetPfcQueueCounter"},
        "decrement": {"type": "PatternFlowEthernetPfcQueueCounter"},
        "metric_tags": {"type": "PatternFlowEthernetPfcQueueMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowEthernetPfcQueue, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowEthernetPfcQueueCounter
        """Factory property that returns an instance of the PatternFlowEthernetPfcQueueCounter class

        integer counter pattern

        Returns: PatternFlowEthernetPfcQueueCounter
        """
        return self._get_property(
            "increment", PatternFlowEthernetPfcQueueCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowEthernetPfcQueueCounter
        """Factory property that returns an instance of the PatternFlowEthernetPfcQueueCounter class

        integer counter pattern

        Returns: PatternFlowEthernetPfcQueueCounter
        """
        return self._get_property(
            "decrement", PatternFlowEthernetPfcQueueCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowEthernetPfcQueueMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowEthernetPfcQueueMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowEthernetPfcQueueMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowEthernetPfcQueueCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowEthernetPfcQueueCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowEthernetPfcQueueMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 2,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 3,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 3,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=3):
        super(PatternFlowEthernetPfcQueueMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowEthernetPfcQueueMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowEthernetPfcQueueMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowEthernetPfcQueueMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowEthernetPfcQueueMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowEthernetPfcQueueMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowEthernetPfcQueueMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowEthernetPfcQueueMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowEthernetPfcQueueMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=3):
        # type: (str,int,int) -> PatternFlowEthernetPfcQueueMetricTagIter
        """Factory method that creates an instance of the PatternFlowEthernetPfcQueueMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowEthernetPfcQueueMetricTagIter
        """
        item = PatternFlowEthernetPfcQueueMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=3):
        # type: (str,int,int) -> PatternFlowEthernetPfcQueueMetricTag
        """Add method that creates and returns an instance of the PatternFlowEthernetPfcQueueMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowEthernetPfcQueueMetricTag
        """
        item = PatternFlowEthernetPfcQueueMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class FlowVlan(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "priority": {"type": "PatternFlowVlanPriority"},
        "cfi": {"type": "PatternFlowVlanCfi"},
        "id": {"type": "PatternFlowVlanId"},
        "tpid": {"type": "PatternFlowVlanTpid"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None):
        super(FlowVlan, self).__init__()
        self._parent = parent

    @property
    def priority(self):
        # type: () -> PatternFlowVlanPriority
        """priority getter

        Priority code pointPriority code pointPriority code pointPriority code point

        Returns: PatternFlowVlanPriority
        """
        return self._get_property("priority", PatternFlowVlanPriority)

    @property
    def cfi(self):
        # type: () -> PatternFlowVlanCfi
        """cfi getter

        Canonical format indicator or drop elegible indicatorCanonical format indicator or drop elegible indicatorCanonical format indicator or drop elegible indicatorCanonical format indicator or drop elegible indicator

        Returns: PatternFlowVlanCfi
        """
        return self._get_property("cfi", PatternFlowVlanCfi)

    @property
    def id(self):
        # type: () -> PatternFlowVlanId
        """id getter

        Vlan identifierVlan identifierVlan identifierVlan identifier

        Returns: PatternFlowVlanId
        """
        return self._get_property("id", PatternFlowVlanId)

    @property
    def tpid(self):
        # type: () -> PatternFlowVlanTpid
        """tpid getter

        Protocol identifierProtocol identifierProtocol identifierProtocol identifier

        Returns: PatternFlowVlanTpid
        """
        return self._get_property("tpid", PatternFlowVlanTpid)


class PatternFlowVlanPriority(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 7,
        },
        "increment": {"type": "PatternFlowVlanPriorityCounter"},
        "decrement": {"type": "PatternFlowVlanPriorityCounter"},
        "metric_tags": {"type": "PatternFlowVlanPriorityMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowVlanPriority, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowVlanPriorityCounter
        """Factory property that returns an instance of the PatternFlowVlanPriorityCounter class

        integer counter pattern

        Returns: PatternFlowVlanPriorityCounter
        """
        return self._get_property(
            "increment", PatternFlowVlanPriorityCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowVlanPriorityCounter
        """Factory property that returns an instance of the PatternFlowVlanPriorityCounter class

        integer counter pattern

        Returns: PatternFlowVlanPriorityCounter
        """
        return self._get_property(
            "decrement", PatternFlowVlanPriorityCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowVlanPriorityMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowVlanPriorityMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowVlanPriorityMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowVlanPriorityCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowVlanPriorityCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowVlanPriorityMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 2,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 3,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 3,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=3):
        super(PatternFlowVlanPriorityMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowVlanPriorityMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowVlanPriorityMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowVlanPriorityMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowVlanPriorityMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowVlanPriorityMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowVlanPriorityMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowVlanPriorityMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowVlanPriorityMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=3):
        # type: (str,int,int) -> PatternFlowVlanPriorityMetricTagIter
        """Factory method that creates an instance of the PatternFlowVlanPriorityMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowVlanPriorityMetricTagIter
        """
        item = PatternFlowVlanPriorityMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=3):
        # type: (str,int,int) -> PatternFlowVlanPriorityMetricTag
        """Add method that creates and returns an instance of the PatternFlowVlanPriorityMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowVlanPriorityMetricTag
        """
        item = PatternFlowVlanPriorityMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowVlanCfi(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 1,
        },
        "increment": {"type": "PatternFlowVlanCfiCounter"},
        "decrement": {"type": "PatternFlowVlanCfiCounter"},
        "metric_tags": {"type": "PatternFlowVlanCfiMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowVlanCfi, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowVlanCfiCounter
        """Factory property that returns an instance of the PatternFlowVlanCfiCounter class

        integer counter pattern

        Returns: PatternFlowVlanCfiCounter
        """
        return self._get_property(
            "increment", PatternFlowVlanCfiCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowVlanCfiCounter
        """Factory property that returns an instance of the PatternFlowVlanCfiCounter class

        integer counter pattern

        Returns: PatternFlowVlanCfiCounter
        """
        return self._get_property(
            "decrement", PatternFlowVlanCfiCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowVlanCfiMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowVlanCfiMetricTagIter
        """
        return self._get_property(
            "metric_tags", PatternFlowVlanCfiMetricTagIter, self._parent, self._choice
        )


class PatternFlowVlanCfiCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowVlanCfiCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowVlanCfiMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 0,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=1):
        super(PatternFlowVlanCfiMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowVlanCfiMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowVlanCfiMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowVlanCfiMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowVlanCfiMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowVlanCfiMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowVlanCfiMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowVlanCfiMetricTag):
            raise Exception("Item is not an instance of PatternFlowVlanCfiMetricTag")

    def metrictag(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowVlanCfiMetricTagIter
        """Factory method that creates an instance of the PatternFlowVlanCfiMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowVlanCfiMetricTagIter
        """
        item = PatternFlowVlanCfiMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowVlanCfiMetricTag
        """Add method that creates and returns an instance of the PatternFlowVlanCfiMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowVlanCfiMetricTag
        """
        item = PatternFlowVlanCfiMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowVlanId(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 4095,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 4095,
        },
        "increment": {"type": "PatternFlowVlanIdCounter"},
        "decrement": {"type": "PatternFlowVlanIdCounter"},
        "metric_tags": {"type": "PatternFlowVlanIdMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowVlanId, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowVlanIdCounter
        """Factory property that returns an instance of the PatternFlowVlanIdCounter class

        integer counter pattern

        Returns: PatternFlowVlanIdCounter
        """
        return self._get_property(
            "increment", PatternFlowVlanIdCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowVlanIdCounter
        """Factory property that returns an instance of the PatternFlowVlanIdCounter class

        integer counter pattern

        Returns: PatternFlowVlanIdCounter
        """
        return self._get_property(
            "decrement", PatternFlowVlanIdCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowVlanIdMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowVlanIdMetricTagIter
        """
        return self._get_property(
            "metric_tags", PatternFlowVlanIdMetricTagIter, self._parent, self._choice
        )


class PatternFlowVlanIdCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 4095,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 4095,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 4095,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowVlanIdCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowVlanIdMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 11,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 12,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 12,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=12):
        super(PatternFlowVlanIdMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowVlanIdMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowVlanIdMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowVlanIdMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowVlanIdMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowVlanIdMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowVlanIdMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowVlanIdMetricTag):
            raise Exception("Item is not an instance of PatternFlowVlanIdMetricTag")

    def metrictag(self, name=None, offset=0, length=12):
        # type: (str,int,int) -> PatternFlowVlanIdMetricTagIter
        """Factory method that creates an instance of the PatternFlowVlanIdMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowVlanIdMetricTagIter
        """
        item = PatternFlowVlanIdMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=12):
        # type: (str,int,int) -> PatternFlowVlanIdMetricTag
        """Add method that creates and returns an instance of the PatternFlowVlanIdMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowVlanIdMetricTag
        """
        item = PatternFlowVlanIdMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowVlanTpid(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 65535,
        },
        "increment": {"type": "PatternFlowVlanTpidCounter"},
        "decrement": {"type": "PatternFlowVlanTpidCounter"},
        "metric_tags": {"type": "PatternFlowVlanTpidMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 65535,
        "values": [65535],
    }  # type: Dict[str, Union(type)]

    X8100 = 33024  #
    X88A8 = 34984  #
    X9100 = 37120  #
    X9200 = 37376  #
    X9300 = 37632  #

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=65535, values=[65535]):
        super(PatternFlowVlanTpid, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowVlanTpidCounter
        """Factory property that returns an instance of the PatternFlowVlanTpidCounter class

        integer counter pattern

        Returns: PatternFlowVlanTpidCounter
        """
        return self._get_property(
            "increment", PatternFlowVlanTpidCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowVlanTpidCounter
        """Factory property that returns an instance of the PatternFlowVlanTpidCounter class

        integer counter pattern

        Returns: PatternFlowVlanTpidCounter
        """
        return self._get_property(
            "decrement", PatternFlowVlanTpidCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowVlanTpidMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowVlanTpidMetricTagIter
        """
        return self._get_property(
            "metric_tags", PatternFlowVlanTpidMetricTagIter, self._parent, self._choice
        )


class PatternFlowVlanTpidCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 65535,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    X8100 = 33024  #
    X88A8 = 34984  #
    X9100 = 37120  #
    X9200 = 37376  #
    X9300 = 37632  #

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=65535, step=1, count=1):
        super(PatternFlowVlanTpidCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowVlanTpidMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 16,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 16,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=16):
        super(PatternFlowVlanTpidMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowVlanTpidMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowVlanTpidMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowVlanTpidMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowVlanTpidMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowVlanTpidMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowVlanTpidMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowVlanTpidMetricTag):
            raise Exception("Item is not an instance of PatternFlowVlanTpidMetricTag")

    def metrictag(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowVlanTpidMetricTagIter
        """Factory method that creates an instance of the PatternFlowVlanTpidMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowVlanTpidMetricTagIter
        """
        item = PatternFlowVlanTpidMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowVlanTpidMetricTag
        """Add method that creates and returns an instance of the PatternFlowVlanTpidMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowVlanTpidMetricTag
        """
        item = PatternFlowVlanTpidMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class FlowVxlan(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "flags": {"type": "PatternFlowVxlanFlags"},
        "reserved0": {"type": "PatternFlowVxlanReserved0"},
        "vni": {"type": "PatternFlowVxlanVni"},
        "reserved1": {"type": "PatternFlowVxlanReserved1"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None):
        super(FlowVxlan, self).__init__()
        self._parent = parent

    @property
    def flags(self):
        # type: () -> PatternFlowVxlanFlags
        """flags getter

        Flags field with bit format of RRRRIRRR. The flag MUST be set to for valid vxlan network id (VNI). The other bits (designated "R") are reserved fields and MUST be set to zero on transmission and ignored on receipt.Flags field with bit format of RRRRIRRR. The flag MUST be set to for valid vxlan network id (VNI). The other bits (designated "R") are reserved fields and MUST be set to zero on transmission and ignored on receipt.Flags field with bit format of RRRRIRRR. The flag MUST be set to for valid vxlan network id (VNI). The other bits (designated "R") are reserved fields and MUST be set to zero on transmission and ignored on receipt.Flags field with bit format of RRRRIRRR. The flag MUST be set to for valid vxlan network id (VNI). The other bits (designated "R") are reserved fields and MUST be set to zero on transmission and ignored on receipt.

        Returns: PatternFlowVxlanFlags
        """
        return self._get_property("flags", PatternFlowVxlanFlags)

    @property
    def reserved0(self):
        # type: () -> PatternFlowVxlanReserved0
        """reserved0 getter

        Reserved fieldReserved fieldReserved fieldReserved field

        Returns: PatternFlowVxlanReserved0
        """
        return self._get_property("reserved0", PatternFlowVxlanReserved0)

    @property
    def vni(self):
        # type: () -> PatternFlowVxlanVni
        """vni getter

        VXLAN network idVXLAN network idVXLAN network idVXLAN network id

        Returns: PatternFlowVxlanVni
        """
        return self._get_property("vni", PatternFlowVxlanVni)

    @property
    def reserved1(self):
        # type: () -> PatternFlowVxlanReserved1
        """reserved1 getter

        Reserved fieldReserved fieldReserved fieldReserved field

        Returns: PatternFlowVxlanReserved1
        """
        return self._get_property("reserved1", PatternFlowVxlanReserved1)


class PatternFlowVxlanFlags(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 255,
        },
        "increment": {"type": "PatternFlowVxlanFlagsCounter"},
        "decrement": {"type": "PatternFlowVxlanFlagsCounter"},
        "metric_tags": {"type": "PatternFlowVxlanFlagsMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 8,
        "values": [8],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=8, values=[8]):
        super(PatternFlowVxlanFlags, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowVxlanFlagsCounter
        """Factory property that returns an instance of the PatternFlowVxlanFlagsCounter class

        integer counter pattern

        Returns: PatternFlowVxlanFlagsCounter
        """
        return self._get_property(
            "increment", PatternFlowVxlanFlagsCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowVxlanFlagsCounter
        """Factory property that returns an instance of the PatternFlowVxlanFlagsCounter class

        integer counter pattern

        Returns: PatternFlowVxlanFlagsCounter
        """
        return self._get_property(
            "decrement", PatternFlowVxlanFlagsCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowVxlanFlagsMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowVxlanFlagsMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowVxlanFlagsMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowVxlanFlagsCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 8,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=8, step=1, count=1):
        super(PatternFlowVxlanFlagsCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowVxlanFlagsMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 8,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 8,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=8):
        super(PatternFlowVxlanFlagsMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowVxlanFlagsMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowVxlanFlagsMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowVxlanFlagsMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowVxlanFlagsMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowVxlanFlagsMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowVxlanFlagsMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowVxlanFlagsMetricTag):
            raise Exception("Item is not an instance of PatternFlowVxlanFlagsMetricTag")

    def metrictag(self, name=None, offset=0, length=8):
        # type: (str,int,int) -> PatternFlowVxlanFlagsMetricTagIter
        """Factory method that creates an instance of the PatternFlowVxlanFlagsMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowVxlanFlagsMetricTagIter
        """
        item = PatternFlowVxlanFlagsMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=8):
        # type: (str,int,int) -> PatternFlowVxlanFlagsMetricTag
        """Add method that creates and returns an instance of the PatternFlowVxlanFlagsMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowVxlanFlagsMetricTag
        """
        item = PatternFlowVxlanFlagsMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowVxlanReserved0(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 16777215,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 16777215,
        },
        "increment": {"type": "PatternFlowVxlanReserved0Counter"},
        "decrement": {"type": "PatternFlowVxlanReserved0Counter"},
        "metric_tags": {"type": "PatternFlowVxlanReserved0MetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowVxlanReserved0, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowVxlanReserved0Counter
        """Factory property that returns an instance of the PatternFlowVxlanReserved0Counter class

        integer counter pattern

        Returns: PatternFlowVxlanReserved0Counter
        """
        return self._get_property(
            "increment", PatternFlowVxlanReserved0Counter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowVxlanReserved0Counter
        """Factory property that returns an instance of the PatternFlowVxlanReserved0Counter class

        integer counter pattern

        Returns: PatternFlowVxlanReserved0Counter
        """
        return self._get_property(
            "decrement", PatternFlowVxlanReserved0Counter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowVxlanReserved0MetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowVxlanReserved0MetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowVxlanReserved0MetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowVxlanReserved0Counter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 16777215,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 16777215,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 16777215,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowVxlanReserved0Counter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowVxlanReserved0MetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 23,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 24,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 24,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=24):
        super(PatternFlowVxlanReserved0MetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowVxlanReserved0MetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowVxlanReserved0MetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowVxlanReserved0MetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowVxlanReserved0MetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowVxlanReserved0MetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowVxlanReserved0MetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowVxlanReserved0MetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowVxlanReserved0MetricTag"
            )

    def metrictag(self, name=None, offset=0, length=24):
        # type: (str,int,int) -> PatternFlowVxlanReserved0MetricTagIter
        """Factory method that creates an instance of the PatternFlowVxlanReserved0MetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowVxlanReserved0MetricTagIter
        """
        item = PatternFlowVxlanReserved0MetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=24):
        # type: (str,int,int) -> PatternFlowVxlanReserved0MetricTag
        """Add method that creates and returns an instance of the PatternFlowVxlanReserved0MetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowVxlanReserved0MetricTag
        """
        item = PatternFlowVxlanReserved0MetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowVxlanVni(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "auto",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 16777215,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 16777215,
        },
        "auto": {
            "type": int,
            "format": "uint32",
            "maximum": 16777215,
        },
        "increment": {"type": "PatternFlowVxlanVniCounter"},
        "decrement": {"type": "PatternFlowVxlanVniCounter"},
        "metric_tags": {"type": "PatternFlowVxlanVniMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "auto",
        "value": 0,
        "values": [0],
        "auto": 0,
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    AUTO = "auto"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0], auto=0):
        super(PatternFlowVxlanVni, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        self._set_property("auto", auto)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None, auto=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowVxlanVniCounter
        """Factory property that returns an instance of the PatternFlowVxlanVniCounter class

        integer counter pattern

        Returns: PatternFlowVxlanVniCounter
        """
        return self._get_property(
            "increment", PatternFlowVxlanVniCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowVxlanVniCounter
        """Factory property that returns an instance of the PatternFlowVxlanVniCounter class

        integer counter pattern

        Returns: PatternFlowVxlanVniCounter
        """
        return self._get_property(
            "decrement", PatternFlowVxlanVniCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["auto"], Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["auto"], Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["auto"], Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def auto(self):
        # type: () -> int
        """auto getter

        The OTG implementation can provide system generated. value for this property. If the OTG is unable to generate value. the default value must be used.

        Returns: int
        """
        return self._get_property("auto")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowVxlanVniMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowVxlanVniMetricTagIter
        """
        return self._get_property(
            "metric_tags", PatternFlowVxlanVniMetricTagIter, self._parent, self._choice
        )


class PatternFlowVxlanVniCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 16777215,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 16777215,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 16777215,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowVxlanVniCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowVxlanVniMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 23,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 24,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 24,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=24):
        super(PatternFlowVxlanVniMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowVxlanVniMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowVxlanVniMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowVxlanVniMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowVxlanVniMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowVxlanVniMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowVxlanVniMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowVxlanVniMetricTag):
            raise Exception("Item is not an instance of PatternFlowVxlanVniMetricTag")

    def metrictag(self, name=None, offset=0, length=24):
        # type: (str,int,int) -> PatternFlowVxlanVniMetricTagIter
        """Factory method that creates an instance of the PatternFlowVxlanVniMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowVxlanVniMetricTagIter
        """
        item = PatternFlowVxlanVniMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=24):
        # type: (str,int,int) -> PatternFlowVxlanVniMetricTag
        """Add method that creates and returns an instance of the PatternFlowVxlanVniMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowVxlanVniMetricTag
        """
        item = PatternFlowVxlanVniMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowVxlanReserved1(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 255,
        },
        "increment": {"type": "PatternFlowVxlanReserved1Counter"},
        "decrement": {"type": "PatternFlowVxlanReserved1Counter"},
        "metric_tags": {"type": "PatternFlowVxlanReserved1MetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowVxlanReserved1, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowVxlanReserved1Counter
        """Factory property that returns an instance of the PatternFlowVxlanReserved1Counter class

        integer counter pattern

        Returns: PatternFlowVxlanReserved1Counter
        """
        return self._get_property(
            "increment", PatternFlowVxlanReserved1Counter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowVxlanReserved1Counter
        """Factory property that returns an instance of the PatternFlowVxlanReserved1Counter class

        integer counter pattern

        Returns: PatternFlowVxlanReserved1Counter
        """
        return self._get_property(
            "decrement", PatternFlowVxlanReserved1Counter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowVxlanReserved1MetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowVxlanReserved1MetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowVxlanReserved1MetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowVxlanReserved1Counter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowVxlanReserved1Counter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowVxlanReserved1MetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 8,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 8,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=8):
        super(PatternFlowVxlanReserved1MetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowVxlanReserved1MetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowVxlanReserved1MetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowVxlanReserved1MetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowVxlanReserved1MetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowVxlanReserved1MetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowVxlanReserved1MetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowVxlanReserved1MetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowVxlanReserved1MetricTag"
            )

    def metrictag(self, name=None, offset=0, length=8):
        # type: (str,int,int) -> PatternFlowVxlanReserved1MetricTagIter
        """Factory method that creates an instance of the PatternFlowVxlanReserved1MetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowVxlanReserved1MetricTagIter
        """
        item = PatternFlowVxlanReserved1MetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=8):
        # type: (str,int,int) -> PatternFlowVxlanReserved1MetricTag
        """Add method that creates and returns an instance of the PatternFlowVxlanReserved1MetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowVxlanReserved1MetricTag
        """
        item = PatternFlowVxlanReserved1MetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class FlowIpv4(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "version": {"type": "PatternFlowIpv4Version"},
        "header_length": {"type": "PatternFlowIpv4HeaderLength"},
        "priority": {"type": "FlowIpv4Priority"},
        "total_length": {"type": "PatternFlowIpv4TotalLength"},
        "identification": {"type": "PatternFlowIpv4Identification"},
        "reserved": {"type": "PatternFlowIpv4Reserved"},
        "dont_fragment": {"type": "PatternFlowIpv4DontFragment"},
        "more_fragments": {"type": "PatternFlowIpv4MoreFragments"},
        "fragment_offset": {"type": "PatternFlowIpv4FragmentOffset"},
        "time_to_live": {"type": "PatternFlowIpv4TimeToLive"},
        "protocol": {"type": "PatternFlowIpv4Protocol"},
        "header_checksum": {"type": "PatternFlowIpv4HeaderChecksum"},
        "src": {"type": "PatternFlowIpv4Src"},
        "dst": {"type": "PatternFlowIpv4Dst"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None):
        super(FlowIpv4, self).__init__()
        self._parent = parent

    @property
    def version(self):
        # type: () -> PatternFlowIpv4Version
        """version getter

        VersionVersionVersionVersion

        Returns: PatternFlowIpv4Version
        """
        return self._get_property("version", PatternFlowIpv4Version)

    @property
    def header_length(self):
        # type: () -> PatternFlowIpv4HeaderLength
        """header_length getter

        Header lengthHeader lengthHeader lengthHeader length

        Returns: PatternFlowIpv4HeaderLength
        """
        return self._get_property("header_length", PatternFlowIpv4HeaderLength)

    @property
    def priority(self):
        # type: () -> FlowIpv4Priority
        """priority getter

        A container for ipv4 raw, tos, dscp ip priorities.A container for ipv4 raw, tos, dscp ip priorities.A container for ipv4 raw, tos, dscp ip priorities.A container for ipv4 raw, tos, dscp ip priorities.

        Returns: FlowIpv4Priority
        """
        return self._get_property("priority", FlowIpv4Priority)

    @property
    def total_length(self):
        # type: () -> PatternFlowIpv4TotalLength
        """total_length getter

        Total lengthTotal lengthTotal lengthTotal length

        Returns: PatternFlowIpv4TotalLength
        """
        return self._get_property("total_length", PatternFlowIpv4TotalLength)

    @property
    def identification(self):
        # type: () -> PatternFlowIpv4Identification
        """identification getter

        IdentificationIdentificationIdentificationIdentification

        Returns: PatternFlowIpv4Identification
        """
        return self._get_property("identification", PatternFlowIpv4Identification)

    @property
    def reserved(self):
        # type: () -> PatternFlowIpv4Reserved
        """reserved getter

        Reserved flag.Reserved flag.Reserved flag.Reserved flag.

        Returns: PatternFlowIpv4Reserved
        """
        return self._get_property("reserved", PatternFlowIpv4Reserved)

    @property
    def dont_fragment(self):
        # type: () -> PatternFlowIpv4DontFragment
        """dont_fragment getter

        Dont fragment flag If the dont_fragment flag is set and fragmentation is required to route the packet then the packet is dropped.Dont fragment flag If the dont_fragment flag is set and fragmentation is required to route the packet then the packet is dropped.Dont fragment flag If the dont_fragment flag is set and fragmentation is required to route the packet then the packet is dropped.Dont fragment flag If the dont_fragment flag is set and fragmentation is required to route the packet then the packet is dropped.

        Returns: PatternFlowIpv4DontFragment
        """
        return self._get_property("dont_fragment", PatternFlowIpv4DontFragment)

    @property
    def more_fragments(self):
        # type: () -> PatternFlowIpv4MoreFragments
        """more_fragments getter

        More fragments flagMore fragments flagMore fragments flagMore fragments flag

        Returns: PatternFlowIpv4MoreFragments
        """
        return self._get_property("more_fragments", PatternFlowIpv4MoreFragments)

    @property
    def fragment_offset(self):
        # type: () -> PatternFlowIpv4FragmentOffset
        """fragment_offset getter

        Fragment offsetFragment offsetFragment offsetFragment offset

        Returns: PatternFlowIpv4FragmentOffset
        """
        return self._get_property("fragment_offset", PatternFlowIpv4FragmentOffset)

    @property
    def time_to_live(self):
        # type: () -> PatternFlowIpv4TimeToLive
        """time_to_live getter

        Time to liveTime to liveTime to liveTime to live

        Returns: PatternFlowIpv4TimeToLive
        """
        return self._get_property("time_to_live", PatternFlowIpv4TimeToLive)

    @property
    def protocol(self):
        # type: () -> PatternFlowIpv4Protocol
        """protocol getter

        Protocol, default is 61 any host internal protocolProtocol, default is 61 any host internal protocolProtocol, default is 61 any host internal protocolProtocol, default is 61 any host internal protocol

        Returns: PatternFlowIpv4Protocol
        """
        return self._get_property("protocol", PatternFlowIpv4Protocol)

    @property
    def header_checksum(self):
        # type: () -> PatternFlowIpv4HeaderChecksum
        """header_checksum getter

        Header checksumHeader checksumHeader checksumHeader checksum

        Returns: PatternFlowIpv4HeaderChecksum
        """
        return self._get_property("header_checksum", PatternFlowIpv4HeaderChecksum)

    @property
    def src(self):
        # type: () -> PatternFlowIpv4Src
        """src getter

        Source addressSource addressSource addressSource address

        Returns: PatternFlowIpv4Src
        """
        return self._get_property("src", PatternFlowIpv4Src)

    @property
    def dst(self):
        # type: () -> PatternFlowIpv4Dst
        """dst getter

        Destination addressDestination addressDestination addressDestination address

        Returns: PatternFlowIpv4Dst
        """
        return self._get_property("dst", PatternFlowIpv4Dst)


class PatternFlowIpv4Version(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 15,
        },
        "increment": {"type": "PatternFlowIpv4VersionCounter"},
        "decrement": {"type": "PatternFlowIpv4VersionCounter"},
        "metric_tags": {"type": "PatternFlowIpv4VersionMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 4,
        "values": [4],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=4, values=[4]):
        super(PatternFlowIpv4Version, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowIpv4VersionCounter
        """Factory property that returns an instance of the PatternFlowIpv4VersionCounter class

        integer counter pattern

        Returns: PatternFlowIpv4VersionCounter
        """
        return self._get_property(
            "increment", PatternFlowIpv4VersionCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowIpv4VersionCounter
        """Factory property that returns an instance of the PatternFlowIpv4VersionCounter class

        integer counter pattern

        Returns: PatternFlowIpv4VersionCounter
        """
        return self._get_property(
            "decrement", PatternFlowIpv4VersionCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowIpv4VersionMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4VersionMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowIpv4VersionMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowIpv4VersionCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 4,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=4, step=1, count=1):
        super(PatternFlowIpv4VersionCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowIpv4VersionMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 3,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 4,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 4,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=4):
        super(PatternFlowIpv4VersionMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowIpv4VersionMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowIpv4VersionMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowIpv4VersionMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowIpv4VersionMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowIpv4VersionMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowIpv4VersionMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowIpv4VersionMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowIpv4VersionMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=4):
        # type: (str,int,int) -> PatternFlowIpv4VersionMetricTagIter
        """Factory method that creates an instance of the PatternFlowIpv4VersionMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4VersionMetricTagIter
        """
        item = PatternFlowIpv4VersionMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=4):
        # type: (str,int,int) -> PatternFlowIpv4VersionMetricTag
        """Add method that creates and returns an instance of the PatternFlowIpv4VersionMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4VersionMetricTag
        """
        item = PatternFlowIpv4VersionMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowIpv4HeaderLength(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "auto",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 15,
        },
        "auto": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "increment": {"type": "PatternFlowIpv4HeaderLengthCounter"},
        "decrement": {"type": "PatternFlowIpv4HeaderLengthCounter"},
        "metric_tags": {"type": "PatternFlowIpv4HeaderLengthMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "auto",
        "value": 5,
        "values": [5],
        "auto": 5,
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    AUTO = "auto"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=5, values=[5], auto=5):
        super(PatternFlowIpv4HeaderLength, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        self._set_property("auto", auto)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None, auto=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowIpv4HeaderLengthCounter
        """Factory property that returns an instance of the PatternFlowIpv4HeaderLengthCounter class

        integer counter pattern

        Returns: PatternFlowIpv4HeaderLengthCounter
        """
        return self._get_property(
            "increment", PatternFlowIpv4HeaderLengthCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowIpv4HeaderLengthCounter
        """Factory property that returns an instance of the PatternFlowIpv4HeaderLengthCounter class

        integer counter pattern

        Returns: PatternFlowIpv4HeaderLengthCounter
        """
        return self._get_property(
            "decrement", PatternFlowIpv4HeaderLengthCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["auto"], Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["auto"], Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["auto"], Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def auto(self):
        # type: () -> int
        """auto getter

        The OTG implementation can provide system generated. value for this property. If the OTG is unable to generate value. the default value must be used.

        Returns: int
        """
        return self._get_property("auto")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowIpv4HeaderLengthMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4HeaderLengthMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowIpv4HeaderLengthMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowIpv4HeaderLengthCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 5,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=5, step=1, count=1):
        super(PatternFlowIpv4HeaderLengthCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowIpv4HeaderLengthMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 3,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 4,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 4,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=4):
        super(PatternFlowIpv4HeaderLengthMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowIpv4HeaderLengthMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowIpv4HeaderLengthMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowIpv4HeaderLengthMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowIpv4HeaderLengthMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowIpv4HeaderLengthMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowIpv4HeaderLengthMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowIpv4HeaderLengthMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowIpv4HeaderLengthMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=4):
        # type: (str,int,int) -> PatternFlowIpv4HeaderLengthMetricTagIter
        """Factory method that creates an instance of the PatternFlowIpv4HeaderLengthMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4HeaderLengthMetricTagIter
        """
        item = PatternFlowIpv4HeaderLengthMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=4):
        # type: (str,int,int) -> PatternFlowIpv4HeaderLengthMetricTag
        """Add method that creates and returns an instance of the PatternFlowIpv4HeaderLengthMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4HeaderLengthMetricTag
        """
        item = PatternFlowIpv4HeaderLengthMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class FlowIpv4Priority(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "raw",
                "tos",
                "dscp",
            ],
        },
        "raw": {"type": "PatternFlowIpv4PriorityRaw"},
        "tos": {"type": "FlowIpv4Tos"},
        "dscp": {"type": "FlowIpv4Dscp"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "dscp",
    }  # type: Dict[str, Union(type)]

    RAW = "raw"  # type: str
    TOS = "tos"  # type: str
    DSCP = "dscp"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None):
        super(FlowIpv4Priority, self).__init__()
        self._parent = parent
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    @property
    def raw(self):
        # type: () -> PatternFlowIpv4PriorityRaw
        """Factory property that returns an instance of the PatternFlowIpv4PriorityRaw class

        Raw priority

        Returns: PatternFlowIpv4PriorityRaw
        """
        return self._get_property("raw", PatternFlowIpv4PriorityRaw, self, "raw")

    @property
    def tos(self):
        # type: () -> FlowIpv4Tos
        """Factory property that returns an instance of the FlowIpv4Tos class

        Type of service (TOS) packet field.

        Returns: FlowIpv4Tos
        """
        return self._get_property("tos", FlowIpv4Tos, self, "tos")

    @property
    def dscp(self):
        # type: () -> FlowIpv4Dscp
        """Factory property that returns an instance of the FlowIpv4Dscp class

        Differentiated services code point (DSCP) packet field.

        Returns: FlowIpv4Dscp
        """
        return self._get_property("dscp", FlowIpv4Dscp, self, "dscp")

    @property
    def choice(self):
        # type: () -> Union[Literal["dscp"], Literal["raw"], Literal["tos"]]
        """choice getter

        TBD

        Returns: Union[Literal["dscp"], Literal["raw"], Literal["tos"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["dscp"], Literal["raw"], Literal["tos"]]
        """
        self._set_property("choice", value)


class PatternFlowIpv4PriorityRaw(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 255,
        },
        "increment": {"type": "PatternFlowIpv4PriorityRawCounter"},
        "decrement": {"type": "PatternFlowIpv4PriorityRawCounter"},
        "metric_tags": {"type": "PatternFlowIpv4PriorityRawMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowIpv4PriorityRaw, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowIpv4PriorityRawCounter
        """Factory property that returns an instance of the PatternFlowIpv4PriorityRawCounter class

        integer counter pattern

        Returns: PatternFlowIpv4PriorityRawCounter
        """
        return self._get_property(
            "increment", PatternFlowIpv4PriorityRawCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowIpv4PriorityRawCounter
        """Factory property that returns an instance of the PatternFlowIpv4PriorityRawCounter class

        integer counter pattern

        Returns: PatternFlowIpv4PriorityRawCounter
        """
        return self._get_property(
            "decrement", PatternFlowIpv4PriorityRawCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowIpv4PriorityRawMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4PriorityRawMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowIpv4PriorityRawMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowIpv4PriorityRawCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowIpv4PriorityRawCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowIpv4PriorityRawMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 8,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 8,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=8):
        super(PatternFlowIpv4PriorityRawMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowIpv4PriorityRawMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowIpv4PriorityRawMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowIpv4PriorityRawMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowIpv4PriorityRawMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowIpv4PriorityRawMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowIpv4PriorityRawMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowIpv4PriorityRawMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowIpv4PriorityRawMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=8):
        # type: (str,int,int) -> PatternFlowIpv4PriorityRawMetricTagIter
        """Factory method that creates an instance of the PatternFlowIpv4PriorityRawMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4PriorityRawMetricTagIter
        """
        item = PatternFlowIpv4PriorityRawMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=8):
        # type: (str,int,int) -> PatternFlowIpv4PriorityRawMetricTag
        """Add method that creates and returns an instance of the PatternFlowIpv4PriorityRawMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4PriorityRawMetricTag
        """
        item = PatternFlowIpv4PriorityRawMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class FlowIpv4Tos(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "precedence": {"type": "PatternFlowIpv4TosPrecedence"},
        "delay": {"type": "PatternFlowIpv4TosDelay"},
        "throughput": {"type": "PatternFlowIpv4TosThroughput"},
        "reliability": {"type": "PatternFlowIpv4TosReliability"},
        "monetary": {"type": "PatternFlowIpv4TosMonetary"},
        "unused": {"type": "PatternFlowIpv4TosUnused"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None):
        super(FlowIpv4Tos, self).__init__()
        self._parent = parent

    @property
    def precedence(self):
        # type: () -> PatternFlowIpv4TosPrecedence
        """precedence getter

        PrecedencePrecedencePrecedencePrecedence

        Returns: PatternFlowIpv4TosPrecedence
        """
        return self._get_property("precedence", PatternFlowIpv4TosPrecedence)

    @property
    def delay(self):
        # type: () -> PatternFlowIpv4TosDelay
        """delay getter

        DelayDelayDelayDelay

        Returns: PatternFlowIpv4TosDelay
        """
        return self._get_property("delay", PatternFlowIpv4TosDelay)

    @property
    def throughput(self):
        # type: () -> PatternFlowIpv4TosThroughput
        """throughput getter

        ThroughputThroughputThroughputThroughput

        Returns: PatternFlowIpv4TosThroughput
        """
        return self._get_property("throughput", PatternFlowIpv4TosThroughput)

    @property
    def reliability(self):
        # type: () -> PatternFlowIpv4TosReliability
        """reliability getter

        ReliabilityReliabilityReliabilityReliability

        Returns: PatternFlowIpv4TosReliability
        """
        return self._get_property("reliability", PatternFlowIpv4TosReliability)

    @property
    def monetary(self):
        # type: () -> PatternFlowIpv4TosMonetary
        """monetary getter

        MonetaryMonetaryMonetaryMonetary

        Returns: PatternFlowIpv4TosMonetary
        """
        return self._get_property("monetary", PatternFlowIpv4TosMonetary)

    @property
    def unused(self):
        # type: () -> PatternFlowIpv4TosUnused
        """unused getter

        UnusedUnusedUnusedUnused

        Returns: PatternFlowIpv4TosUnused
        """
        return self._get_property("unused", PatternFlowIpv4TosUnused)


class PatternFlowIpv4TosPrecedence(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 7,
        },
        "increment": {"type": "PatternFlowIpv4TosPrecedenceCounter"},
        "decrement": {"type": "PatternFlowIpv4TosPrecedenceCounter"},
        "metric_tags": {"type": "PatternFlowIpv4TosPrecedenceMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    ROUTINE = 0  #
    PRIORITY = 1  #
    IMMEDIATE = 2  #
    FLASH = 3  #
    FLASH_OVERRIDE = 4  #
    CRITIC_ECP = 5  #
    INTERNETWORK_CONTROL = 6  #
    NETWORK_CONTROL = 7  #

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowIpv4TosPrecedence, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowIpv4TosPrecedenceCounter
        """Factory property that returns an instance of the PatternFlowIpv4TosPrecedenceCounter class

        integer counter pattern

        Returns: PatternFlowIpv4TosPrecedenceCounter
        """
        return self._get_property(
            "increment", PatternFlowIpv4TosPrecedenceCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowIpv4TosPrecedenceCounter
        """Factory property that returns an instance of the PatternFlowIpv4TosPrecedenceCounter class

        integer counter pattern

        Returns: PatternFlowIpv4TosPrecedenceCounter
        """
        return self._get_property(
            "decrement", PatternFlowIpv4TosPrecedenceCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowIpv4TosPrecedenceMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4TosPrecedenceMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowIpv4TosPrecedenceMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowIpv4TosPrecedenceCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    ROUTINE = 0  #
    PRIORITY = 1  #
    IMMEDIATE = 2  #
    FLASH = 3  #
    FLASH_OVERRIDE = 4  #
    CRITIC_ECP = 5  #
    INTERNETWORK_CONTROL = 6  #
    NETWORK_CONTROL = 7  #

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowIpv4TosPrecedenceCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowIpv4TosPrecedenceMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 2,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 3,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 3,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=3):
        super(PatternFlowIpv4TosPrecedenceMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowIpv4TosPrecedenceMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowIpv4TosPrecedenceMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowIpv4TosPrecedenceMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowIpv4TosPrecedenceMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowIpv4TosPrecedenceMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowIpv4TosPrecedenceMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowIpv4TosPrecedenceMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowIpv4TosPrecedenceMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=3):
        # type: (str,int,int) -> PatternFlowIpv4TosPrecedenceMetricTagIter
        """Factory method that creates an instance of the PatternFlowIpv4TosPrecedenceMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4TosPrecedenceMetricTagIter
        """
        item = PatternFlowIpv4TosPrecedenceMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=3):
        # type: (str,int,int) -> PatternFlowIpv4TosPrecedenceMetricTag
        """Add method that creates and returns an instance of the PatternFlowIpv4TosPrecedenceMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4TosPrecedenceMetricTag
        """
        item = PatternFlowIpv4TosPrecedenceMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowIpv4TosDelay(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 1,
        },
        "increment": {"type": "PatternFlowIpv4TosDelayCounter"},
        "decrement": {"type": "PatternFlowIpv4TosDelayCounter"},
        "metric_tags": {"type": "PatternFlowIpv4TosDelayMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    NORMAL = 0  #
    LOW = 1  #

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowIpv4TosDelay, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowIpv4TosDelayCounter
        """Factory property that returns an instance of the PatternFlowIpv4TosDelayCounter class

        integer counter pattern

        Returns: PatternFlowIpv4TosDelayCounter
        """
        return self._get_property(
            "increment", PatternFlowIpv4TosDelayCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowIpv4TosDelayCounter
        """Factory property that returns an instance of the PatternFlowIpv4TosDelayCounter class

        integer counter pattern

        Returns: PatternFlowIpv4TosDelayCounter
        """
        return self._get_property(
            "decrement", PatternFlowIpv4TosDelayCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowIpv4TosDelayMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4TosDelayMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowIpv4TosDelayMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowIpv4TosDelayCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    NORMAL = 0  #
    LOW = 1  #

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowIpv4TosDelayCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowIpv4TosDelayMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 0,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=1):
        super(PatternFlowIpv4TosDelayMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowIpv4TosDelayMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowIpv4TosDelayMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowIpv4TosDelayMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowIpv4TosDelayMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowIpv4TosDelayMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowIpv4TosDelayMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowIpv4TosDelayMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowIpv4TosDelayMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowIpv4TosDelayMetricTagIter
        """Factory method that creates an instance of the PatternFlowIpv4TosDelayMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4TosDelayMetricTagIter
        """
        item = PatternFlowIpv4TosDelayMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowIpv4TosDelayMetricTag
        """Add method that creates and returns an instance of the PatternFlowIpv4TosDelayMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4TosDelayMetricTag
        """
        item = PatternFlowIpv4TosDelayMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowIpv4TosThroughput(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 1,
        },
        "increment": {"type": "PatternFlowIpv4TosThroughputCounter"},
        "decrement": {"type": "PatternFlowIpv4TosThroughputCounter"},
        "metric_tags": {"type": "PatternFlowIpv4TosThroughputMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    NORMAL = 0  #
    LOW = 1  #

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowIpv4TosThroughput, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowIpv4TosThroughputCounter
        """Factory property that returns an instance of the PatternFlowIpv4TosThroughputCounter class

        integer counter pattern

        Returns: PatternFlowIpv4TosThroughputCounter
        """
        return self._get_property(
            "increment", PatternFlowIpv4TosThroughputCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowIpv4TosThroughputCounter
        """Factory property that returns an instance of the PatternFlowIpv4TosThroughputCounter class

        integer counter pattern

        Returns: PatternFlowIpv4TosThroughputCounter
        """
        return self._get_property(
            "decrement", PatternFlowIpv4TosThroughputCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowIpv4TosThroughputMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4TosThroughputMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowIpv4TosThroughputMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowIpv4TosThroughputCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    NORMAL = 0  #
    LOW = 1  #

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowIpv4TosThroughputCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowIpv4TosThroughputMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 0,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=1):
        super(PatternFlowIpv4TosThroughputMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowIpv4TosThroughputMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowIpv4TosThroughputMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowIpv4TosThroughputMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowIpv4TosThroughputMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowIpv4TosThroughputMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowIpv4TosThroughputMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowIpv4TosThroughputMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowIpv4TosThroughputMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowIpv4TosThroughputMetricTagIter
        """Factory method that creates an instance of the PatternFlowIpv4TosThroughputMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4TosThroughputMetricTagIter
        """
        item = PatternFlowIpv4TosThroughputMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowIpv4TosThroughputMetricTag
        """Add method that creates and returns an instance of the PatternFlowIpv4TosThroughputMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4TosThroughputMetricTag
        """
        item = PatternFlowIpv4TosThroughputMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowIpv4TosReliability(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 1,
        },
        "increment": {"type": "PatternFlowIpv4TosReliabilityCounter"},
        "decrement": {"type": "PatternFlowIpv4TosReliabilityCounter"},
        "metric_tags": {"type": "PatternFlowIpv4TosReliabilityMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    NORMAL = 0  #
    LOW = 1  #

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowIpv4TosReliability, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowIpv4TosReliabilityCounter
        """Factory property that returns an instance of the PatternFlowIpv4TosReliabilityCounter class

        integer counter pattern

        Returns: PatternFlowIpv4TosReliabilityCounter
        """
        return self._get_property(
            "increment", PatternFlowIpv4TosReliabilityCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowIpv4TosReliabilityCounter
        """Factory property that returns an instance of the PatternFlowIpv4TosReliabilityCounter class

        integer counter pattern

        Returns: PatternFlowIpv4TosReliabilityCounter
        """
        return self._get_property(
            "decrement", PatternFlowIpv4TosReliabilityCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowIpv4TosReliabilityMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4TosReliabilityMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowIpv4TosReliabilityMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowIpv4TosReliabilityCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    NORMAL = 0  #
    LOW = 1  #

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowIpv4TosReliabilityCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowIpv4TosReliabilityMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 0,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=1):
        super(PatternFlowIpv4TosReliabilityMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowIpv4TosReliabilityMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowIpv4TosReliabilityMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowIpv4TosReliabilityMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowIpv4TosReliabilityMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowIpv4TosReliabilityMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowIpv4TosReliabilityMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowIpv4TosReliabilityMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowIpv4TosReliabilityMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowIpv4TosReliabilityMetricTagIter
        """Factory method that creates an instance of the PatternFlowIpv4TosReliabilityMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4TosReliabilityMetricTagIter
        """
        item = PatternFlowIpv4TosReliabilityMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowIpv4TosReliabilityMetricTag
        """Add method that creates and returns an instance of the PatternFlowIpv4TosReliabilityMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4TosReliabilityMetricTag
        """
        item = PatternFlowIpv4TosReliabilityMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowIpv4TosMonetary(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 1,
        },
        "increment": {"type": "PatternFlowIpv4TosMonetaryCounter"},
        "decrement": {"type": "PatternFlowIpv4TosMonetaryCounter"},
        "metric_tags": {"type": "PatternFlowIpv4TosMonetaryMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    NORMAL = 0  #
    LOW = 1  #

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowIpv4TosMonetary, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowIpv4TosMonetaryCounter
        """Factory property that returns an instance of the PatternFlowIpv4TosMonetaryCounter class

        integer counter pattern

        Returns: PatternFlowIpv4TosMonetaryCounter
        """
        return self._get_property(
            "increment", PatternFlowIpv4TosMonetaryCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowIpv4TosMonetaryCounter
        """Factory property that returns an instance of the PatternFlowIpv4TosMonetaryCounter class

        integer counter pattern

        Returns: PatternFlowIpv4TosMonetaryCounter
        """
        return self._get_property(
            "decrement", PatternFlowIpv4TosMonetaryCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowIpv4TosMonetaryMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4TosMonetaryMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowIpv4TosMonetaryMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowIpv4TosMonetaryCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    NORMAL = 0  #
    LOW = 1  #

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowIpv4TosMonetaryCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowIpv4TosMonetaryMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 0,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=1):
        super(PatternFlowIpv4TosMonetaryMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowIpv4TosMonetaryMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowIpv4TosMonetaryMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowIpv4TosMonetaryMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowIpv4TosMonetaryMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowIpv4TosMonetaryMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowIpv4TosMonetaryMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowIpv4TosMonetaryMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowIpv4TosMonetaryMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowIpv4TosMonetaryMetricTagIter
        """Factory method that creates an instance of the PatternFlowIpv4TosMonetaryMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4TosMonetaryMetricTagIter
        """
        item = PatternFlowIpv4TosMonetaryMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowIpv4TosMonetaryMetricTag
        """Add method that creates and returns an instance of the PatternFlowIpv4TosMonetaryMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4TosMonetaryMetricTag
        """
        item = PatternFlowIpv4TosMonetaryMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowIpv4TosUnused(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 1,
        },
        "increment": {"type": "PatternFlowIpv4TosUnusedCounter"},
        "decrement": {"type": "PatternFlowIpv4TosUnusedCounter"},
        "metric_tags": {"type": "PatternFlowIpv4TosUnusedMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowIpv4TosUnused, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowIpv4TosUnusedCounter
        """Factory property that returns an instance of the PatternFlowIpv4TosUnusedCounter class

        integer counter pattern

        Returns: PatternFlowIpv4TosUnusedCounter
        """
        return self._get_property(
            "increment", PatternFlowIpv4TosUnusedCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowIpv4TosUnusedCounter
        """Factory property that returns an instance of the PatternFlowIpv4TosUnusedCounter class

        integer counter pattern

        Returns: PatternFlowIpv4TosUnusedCounter
        """
        return self._get_property(
            "decrement", PatternFlowIpv4TosUnusedCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowIpv4TosUnusedMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4TosUnusedMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowIpv4TosUnusedMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowIpv4TosUnusedCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowIpv4TosUnusedCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowIpv4TosUnusedMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 0,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=1):
        super(PatternFlowIpv4TosUnusedMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowIpv4TosUnusedMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowIpv4TosUnusedMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowIpv4TosUnusedMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowIpv4TosUnusedMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowIpv4TosUnusedMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowIpv4TosUnusedMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowIpv4TosUnusedMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowIpv4TosUnusedMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowIpv4TosUnusedMetricTagIter
        """Factory method that creates an instance of the PatternFlowIpv4TosUnusedMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4TosUnusedMetricTagIter
        """
        item = PatternFlowIpv4TosUnusedMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowIpv4TosUnusedMetricTag
        """Add method that creates and returns an instance of the PatternFlowIpv4TosUnusedMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4TosUnusedMetricTag
        """
        item = PatternFlowIpv4TosUnusedMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class FlowIpv4Dscp(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "phb": {"type": "PatternFlowIpv4DscpPhb"},
        "ecn": {"type": "PatternFlowIpv4DscpEcn"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None):
        super(FlowIpv4Dscp, self).__init__()
        self._parent = parent

    @property
    def phb(self):
        # type: () -> PatternFlowIpv4DscpPhb
        """phb getter

        Per hop behaviorPer hop behaviorPer hop behaviorPer hop behavior

        Returns: PatternFlowIpv4DscpPhb
        """
        return self._get_property("phb", PatternFlowIpv4DscpPhb)

    @property
    def ecn(self):
        # type: () -> PatternFlowIpv4DscpEcn
        """ecn getter

        Explicit congestion notificationExplicit congestion notificationExplicit congestion notificationExplicit congestion notification

        Returns: PatternFlowIpv4DscpEcn
        """
        return self._get_property("ecn", PatternFlowIpv4DscpEcn)


class PatternFlowIpv4DscpPhb(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 63,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 63,
        },
        "increment": {"type": "PatternFlowIpv4DscpPhbCounter"},
        "decrement": {"type": "PatternFlowIpv4DscpPhbCounter"},
        "metric_tags": {"type": "PatternFlowIpv4DscpPhbMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    DEFAULT = 0  #
    CS1 = 8  #
    CS2 = 16  #
    CS3 = 24  #
    CS4 = 32  #
    CS5 = 40  #
    CS6 = 48  #
    CS7 = 56  #
    AF11 = 10  #
    AF12 = 12  #
    AF13 = 14  #
    AF21 = 18  #
    AF22 = 20  #
    AF23 = 22  #
    AF31 = 26  #
    AF32 = 28  #
    AF33 = 30  #
    AF41 = 34  #
    AF42 = 36  #
    AF43 = 38  #
    EF46 = 46  #

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowIpv4DscpPhb, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowIpv4DscpPhbCounter
        """Factory property that returns an instance of the PatternFlowIpv4DscpPhbCounter class

        integer counter pattern

        Returns: PatternFlowIpv4DscpPhbCounter
        """
        return self._get_property(
            "increment", PatternFlowIpv4DscpPhbCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowIpv4DscpPhbCounter
        """Factory property that returns an instance of the PatternFlowIpv4DscpPhbCounter class

        integer counter pattern

        Returns: PatternFlowIpv4DscpPhbCounter
        """
        return self._get_property(
            "decrement", PatternFlowIpv4DscpPhbCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowIpv4DscpPhbMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4DscpPhbMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowIpv4DscpPhbMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowIpv4DscpPhbCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 63,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 63,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 63,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    DEFAULT = 0  #
    CS1 = 8  #
    CS2 = 16  #
    CS3 = 24  #
    CS4 = 32  #
    CS5 = 40  #
    CS6 = 48  #
    CS7 = 56  #
    AF11 = 10  #
    AF12 = 12  #
    AF13 = 14  #
    AF21 = 18  #
    AF22 = 20  #
    AF23 = 22  #
    AF31 = 26  #
    AF32 = 28  #
    AF33 = 30  #
    AF41 = 34  #
    AF42 = 36  #
    AF43 = 38  #
    EF46 = 46  #

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowIpv4DscpPhbCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowIpv4DscpPhbMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 5,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 6,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 6,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=6):
        super(PatternFlowIpv4DscpPhbMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowIpv4DscpPhbMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowIpv4DscpPhbMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowIpv4DscpPhbMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowIpv4DscpPhbMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowIpv4DscpPhbMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowIpv4DscpPhbMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowIpv4DscpPhbMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowIpv4DscpPhbMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=6):
        # type: (str,int,int) -> PatternFlowIpv4DscpPhbMetricTagIter
        """Factory method that creates an instance of the PatternFlowIpv4DscpPhbMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4DscpPhbMetricTagIter
        """
        item = PatternFlowIpv4DscpPhbMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=6):
        # type: (str,int,int) -> PatternFlowIpv4DscpPhbMetricTag
        """Add method that creates and returns an instance of the PatternFlowIpv4DscpPhbMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4DscpPhbMetricTag
        """
        item = PatternFlowIpv4DscpPhbMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowIpv4DscpEcn(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 3,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 3,
        },
        "increment": {"type": "PatternFlowIpv4DscpEcnCounter"},
        "decrement": {"type": "PatternFlowIpv4DscpEcnCounter"},
        "metric_tags": {"type": "PatternFlowIpv4DscpEcnMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    NON_CAPABLE = 0  #
    CAPABLE_TRANSPORT_0 = 1  #
    CAPABLE_TRANSPORT_1 = 2  #
    CONGESTION_ENCOUNTERED = 3  #

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowIpv4DscpEcn, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowIpv4DscpEcnCounter
        """Factory property that returns an instance of the PatternFlowIpv4DscpEcnCounter class

        integer counter pattern

        Returns: PatternFlowIpv4DscpEcnCounter
        """
        return self._get_property(
            "increment", PatternFlowIpv4DscpEcnCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowIpv4DscpEcnCounter
        """Factory property that returns an instance of the PatternFlowIpv4DscpEcnCounter class

        integer counter pattern

        Returns: PatternFlowIpv4DscpEcnCounter
        """
        return self._get_property(
            "decrement", PatternFlowIpv4DscpEcnCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowIpv4DscpEcnMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4DscpEcnMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowIpv4DscpEcnMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowIpv4DscpEcnCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 3,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 3,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 3,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    NON_CAPABLE = 0  #
    CAPABLE_TRANSPORT_0 = 1  #
    CAPABLE_TRANSPORT_1 = 2  #
    CONGESTION_ENCOUNTERED = 3  #

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowIpv4DscpEcnCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowIpv4DscpEcnMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 2,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 2,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=2):
        super(PatternFlowIpv4DscpEcnMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowIpv4DscpEcnMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowIpv4DscpEcnMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowIpv4DscpEcnMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowIpv4DscpEcnMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowIpv4DscpEcnMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowIpv4DscpEcnMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowIpv4DscpEcnMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowIpv4DscpEcnMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=2):
        # type: (str,int,int) -> PatternFlowIpv4DscpEcnMetricTagIter
        """Factory method that creates an instance of the PatternFlowIpv4DscpEcnMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4DscpEcnMetricTagIter
        """
        item = PatternFlowIpv4DscpEcnMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=2):
        # type: (str,int,int) -> PatternFlowIpv4DscpEcnMetricTag
        """Add method that creates and returns an instance of the PatternFlowIpv4DscpEcnMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4DscpEcnMetricTag
        """
        item = PatternFlowIpv4DscpEcnMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowIpv4TotalLength(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "auto",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 65535,
        },
        "auto": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "increment": {"type": "PatternFlowIpv4TotalLengthCounter"},
        "decrement": {"type": "PatternFlowIpv4TotalLengthCounter"},
        "metric_tags": {"type": "PatternFlowIpv4TotalLengthMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "auto",
        "value": 46,
        "values": [46],
        "auto": 46,
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    AUTO = "auto"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=46, values=[46], auto=46):
        super(PatternFlowIpv4TotalLength, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        self._set_property("auto", auto)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None, auto=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowIpv4TotalLengthCounter
        """Factory property that returns an instance of the PatternFlowIpv4TotalLengthCounter class

        integer counter pattern

        Returns: PatternFlowIpv4TotalLengthCounter
        """
        return self._get_property(
            "increment", PatternFlowIpv4TotalLengthCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowIpv4TotalLengthCounter
        """Factory property that returns an instance of the PatternFlowIpv4TotalLengthCounter class

        integer counter pattern

        Returns: PatternFlowIpv4TotalLengthCounter
        """
        return self._get_property(
            "decrement", PatternFlowIpv4TotalLengthCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["auto"], Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["auto"], Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["auto"], Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def auto(self):
        # type: () -> int
        """auto getter

        The OTG implementation can provide system generated. value for this property. If the OTG is unable to generate value. the default value must be used.

        Returns: int
        """
        return self._get_property("auto")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowIpv4TotalLengthMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4TotalLengthMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowIpv4TotalLengthMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowIpv4TotalLengthCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 46,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=46, step=1, count=1):
        super(PatternFlowIpv4TotalLengthCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowIpv4TotalLengthMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 16,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 16,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=16):
        super(PatternFlowIpv4TotalLengthMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowIpv4TotalLengthMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowIpv4TotalLengthMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowIpv4TotalLengthMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowIpv4TotalLengthMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowIpv4TotalLengthMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowIpv4TotalLengthMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowIpv4TotalLengthMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowIpv4TotalLengthMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowIpv4TotalLengthMetricTagIter
        """Factory method that creates an instance of the PatternFlowIpv4TotalLengthMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4TotalLengthMetricTagIter
        """
        item = PatternFlowIpv4TotalLengthMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowIpv4TotalLengthMetricTag
        """Add method that creates and returns an instance of the PatternFlowIpv4TotalLengthMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4TotalLengthMetricTag
        """
        item = PatternFlowIpv4TotalLengthMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowIpv4Identification(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 65535,
        },
        "increment": {"type": "PatternFlowIpv4IdentificationCounter"},
        "decrement": {"type": "PatternFlowIpv4IdentificationCounter"},
        "metric_tags": {"type": "PatternFlowIpv4IdentificationMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowIpv4Identification, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowIpv4IdentificationCounter
        """Factory property that returns an instance of the PatternFlowIpv4IdentificationCounter class

        integer counter pattern

        Returns: PatternFlowIpv4IdentificationCounter
        """
        return self._get_property(
            "increment", PatternFlowIpv4IdentificationCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowIpv4IdentificationCounter
        """Factory property that returns an instance of the PatternFlowIpv4IdentificationCounter class

        integer counter pattern

        Returns: PatternFlowIpv4IdentificationCounter
        """
        return self._get_property(
            "decrement", PatternFlowIpv4IdentificationCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowIpv4IdentificationMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4IdentificationMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowIpv4IdentificationMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowIpv4IdentificationCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowIpv4IdentificationCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowIpv4IdentificationMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 16,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 16,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=16):
        super(PatternFlowIpv4IdentificationMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowIpv4IdentificationMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowIpv4IdentificationMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowIpv4IdentificationMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowIpv4IdentificationMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowIpv4IdentificationMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowIpv4IdentificationMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowIpv4IdentificationMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowIpv4IdentificationMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowIpv4IdentificationMetricTagIter
        """Factory method that creates an instance of the PatternFlowIpv4IdentificationMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4IdentificationMetricTagIter
        """
        item = PatternFlowIpv4IdentificationMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowIpv4IdentificationMetricTag
        """Add method that creates and returns an instance of the PatternFlowIpv4IdentificationMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4IdentificationMetricTag
        """
        item = PatternFlowIpv4IdentificationMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowIpv4Reserved(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 1,
        },
        "increment": {"type": "PatternFlowIpv4ReservedCounter"},
        "decrement": {"type": "PatternFlowIpv4ReservedCounter"},
        "metric_tags": {"type": "PatternFlowIpv4ReservedMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowIpv4Reserved, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowIpv4ReservedCounter
        """Factory property that returns an instance of the PatternFlowIpv4ReservedCounter class

        integer counter pattern

        Returns: PatternFlowIpv4ReservedCounter
        """
        return self._get_property(
            "increment", PatternFlowIpv4ReservedCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowIpv4ReservedCounter
        """Factory property that returns an instance of the PatternFlowIpv4ReservedCounter class

        integer counter pattern

        Returns: PatternFlowIpv4ReservedCounter
        """
        return self._get_property(
            "decrement", PatternFlowIpv4ReservedCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowIpv4ReservedMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4ReservedMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowIpv4ReservedMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowIpv4ReservedCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowIpv4ReservedCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowIpv4ReservedMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 0,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=1):
        super(PatternFlowIpv4ReservedMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowIpv4ReservedMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowIpv4ReservedMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowIpv4ReservedMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowIpv4ReservedMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowIpv4ReservedMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowIpv4ReservedMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowIpv4ReservedMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowIpv4ReservedMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowIpv4ReservedMetricTagIter
        """Factory method that creates an instance of the PatternFlowIpv4ReservedMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4ReservedMetricTagIter
        """
        item = PatternFlowIpv4ReservedMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowIpv4ReservedMetricTag
        """Add method that creates and returns an instance of the PatternFlowIpv4ReservedMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4ReservedMetricTag
        """
        item = PatternFlowIpv4ReservedMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowIpv4DontFragment(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 1,
        },
        "increment": {"type": "PatternFlowIpv4DontFragmentCounter"},
        "decrement": {"type": "PatternFlowIpv4DontFragmentCounter"},
        "metric_tags": {"type": "PatternFlowIpv4DontFragmentMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowIpv4DontFragment, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowIpv4DontFragmentCounter
        """Factory property that returns an instance of the PatternFlowIpv4DontFragmentCounter class

        integer counter pattern

        Returns: PatternFlowIpv4DontFragmentCounter
        """
        return self._get_property(
            "increment", PatternFlowIpv4DontFragmentCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowIpv4DontFragmentCounter
        """Factory property that returns an instance of the PatternFlowIpv4DontFragmentCounter class

        integer counter pattern

        Returns: PatternFlowIpv4DontFragmentCounter
        """
        return self._get_property(
            "decrement", PatternFlowIpv4DontFragmentCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowIpv4DontFragmentMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4DontFragmentMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowIpv4DontFragmentMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowIpv4DontFragmentCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowIpv4DontFragmentCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowIpv4DontFragmentMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 0,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=1):
        super(PatternFlowIpv4DontFragmentMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowIpv4DontFragmentMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowIpv4DontFragmentMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowIpv4DontFragmentMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowIpv4DontFragmentMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowIpv4DontFragmentMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowIpv4DontFragmentMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowIpv4DontFragmentMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowIpv4DontFragmentMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowIpv4DontFragmentMetricTagIter
        """Factory method that creates an instance of the PatternFlowIpv4DontFragmentMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4DontFragmentMetricTagIter
        """
        item = PatternFlowIpv4DontFragmentMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowIpv4DontFragmentMetricTag
        """Add method that creates and returns an instance of the PatternFlowIpv4DontFragmentMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4DontFragmentMetricTag
        """
        item = PatternFlowIpv4DontFragmentMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowIpv4MoreFragments(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 1,
        },
        "increment": {"type": "PatternFlowIpv4MoreFragmentsCounter"},
        "decrement": {"type": "PatternFlowIpv4MoreFragmentsCounter"},
        "metric_tags": {"type": "PatternFlowIpv4MoreFragmentsMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowIpv4MoreFragments, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowIpv4MoreFragmentsCounter
        """Factory property that returns an instance of the PatternFlowIpv4MoreFragmentsCounter class

        integer counter pattern

        Returns: PatternFlowIpv4MoreFragmentsCounter
        """
        return self._get_property(
            "increment", PatternFlowIpv4MoreFragmentsCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowIpv4MoreFragmentsCounter
        """Factory property that returns an instance of the PatternFlowIpv4MoreFragmentsCounter class

        integer counter pattern

        Returns: PatternFlowIpv4MoreFragmentsCounter
        """
        return self._get_property(
            "decrement", PatternFlowIpv4MoreFragmentsCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowIpv4MoreFragmentsMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4MoreFragmentsMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowIpv4MoreFragmentsMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowIpv4MoreFragmentsCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowIpv4MoreFragmentsCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowIpv4MoreFragmentsMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 0,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=1):
        super(PatternFlowIpv4MoreFragmentsMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowIpv4MoreFragmentsMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowIpv4MoreFragmentsMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowIpv4MoreFragmentsMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowIpv4MoreFragmentsMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowIpv4MoreFragmentsMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowIpv4MoreFragmentsMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowIpv4MoreFragmentsMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowIpv4MoreFragmentsMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowIpv4MoreFragmentsMetricTagIter
        """Factory method that creates an instance of the PatternFlowIpv4MoreFragmentsMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4MoreFragmentsMetricTagIter
        """
        item = PatternFlowIpv4MoreFragmentsMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowIpv4MoreFragmentsMetricTag
        """Add method that creates and returns an instance of the PatternFlowIpv4MoreFragmentsMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4MoreFragmentsMetricTag
        """
        item = PatternFlowIpv4MoreFragmentsMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowIpv4FragmentOffset(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 31,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 31,
        },
        "increment": {"type": "PatternFlowIpv4FragmentOffsetCounter"},
        "decrement": {"type": "PatternFlowIpv4FragmentOffsetCounter"},
        "metric_tags": {"type": "PatternFlowIpv4FragmentOffsetMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowIpv4FragmentOffset, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowIpv4FragmentOffsetCounter
        """Factory property that returns an instance of the PatternFlowIpv4FragmentOffsetCounter class

        integer counter pattern

        Returns: PatternFlowIpv4FragmentOffsetCounter
        """
        return self._get_property(
            "increment", PatternFlowIpv4FragmentOffsetCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowIpv4FragmentOffsetCounter
        """Factory property that returns an instance of the PatternFlowIpv4FragmentOffsetCounter class

        integer counter pattern

        Returns: PatternFlowIpv4FragmentOffsetCounter
        """
        return self._get_property(
            "decrement", PatternFlowIpv4FragmentOffsetCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowIpv4FragmentOffsetMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4FragmentOffsetMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowIpv4FragmentOffsetMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowIpv4FragmentOffsetCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 31,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 31,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 31,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowIpv4FragmentOffsetCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowIpv4FragmentOffsetMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 4,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 5,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 5,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=5):
        super(PatternFlowIpv4FragmentOffsetMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowIpv4FragmentOffsetMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowIpv4FragmentOffsetMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowIpv4FragmentOffsetMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowIpv4FragmentOffsetMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowIpv4FragmentOffsetMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowIpv4FragmentOffsetMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowIpv4FragmentOffsetMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowIpv4FragmentOffsetMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=5):
        # type: (str,int,int) -> PatternFlowIpv4FragmentOffsetMetricTagIter
        """Factory method that creates an instance of the PatternFlowIpv4FragmentOffsetMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4FragmentOffsetMetricTagIter
        """
        item = PatternFlowIpv4FragmentOffsetMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=5):
        # type: (str,int,int) -> PatternFlowIpv4FragmentOffsetMetricTag
        """Add method that creates and returns an instance of the PatternFlowIpv4FragmentOffsetMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4FragmentOffsetMetricTag
        """
        item = PatternFlowIpv4FragmentOffsetMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowIpv4TimeToLive(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 255,
        },
        "increment": {"type": "PatternFlowIpv4TimeToLiveCounter"},
        "decrement": {"type": "PatternFlowIpv4TimeToLiveCounter"},
        "metric_tags": {"type": "PatternFlowIpv4TimeToLiveMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 64,
        "values": [64],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=64, values=[64]):
        super(PatternFlowIpv4TimeToLive, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowIpv4TimeToLiveCounter
        """Factory property that returns an instance of the PatternFlowIpv4TimeToLiveCounter class

        integer counter pattern

        Returns: PatternFlowIpv4TimeToLiveCounter
        """
        return self._get_property(
            "increment", PatternFlowIpv4TimeToLiveCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowIpv4TimeToLiveCounter
        """Factory property that returns an instance of the PatternFlowIpv4TimeToLiveCounter class

        integer counter pattern

        Returns: PatternFlowIpv4TimeToLiveCounter
        """
        return self._get_property(
            "decrement", PatternFlowIpv4TimeToLiveCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowIpv4TimeToLiveMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4TimeToLiveMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowIpv4TimeToLiveMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowIpv4TimeToLiveCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 64,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=64, step=1, count=1):
        super(PatternFlowIpv4TimeToLiveCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowIpv4TimeToLiveMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 8,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 8,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=8):
        super(PatternFlowIpv4TimeToLiveMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowIpv4TimeToLiveMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowIpv4TimeToLiveMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowIpv4TimeToLiveMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowIpv4TimeToLiveMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowIpv4TimeToLiveMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowIpv4TimeToLiveMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowIpv4TimeToLiveMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowIpv4TimeToLiveMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=8):
        # type: (str,int,int) -> PatternFlowIpv4TimeToLiveMetricTagIter
        """Factory method that creates an instance of the PatternFlowIpv4TimeToLiveMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4TimeToLiveMetricTagIter
        """
        item = PatternFlowIpv4TimeToLiveMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=8):
        # type: (str,int,int) -> PatternFlowIpv4TimeToLiveMetricTag
        """Add method that creates and returns an instance of the PatternFlowIpv4TimeToLiveMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4TimeToLiveMetricTag
        """
        item = PatternFlowIpv4TimeToLiveMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowIpv4Protocol(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "auto",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 255,
        },
        "auto": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "increment": {"type": "PatternFlowIpv4ProtocolCounter"},
        "decrement": {"type": "PatternFlowIpv4ProtocolCounter"},
        "metric_tags": {"type": "PatternFlowIpv4ProtocolMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "auto",
        "value": 61,
        "values": [61],
        "auto": 61,
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    AUTO = "auto"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=61, values=[61], auto=61):
        super(PatternFlowIpv4Protocol, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        self._set_property("auto", auto)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None, auto=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowIpv4ProtocolCounter
        """Factory property that returns an instance of the PatternFlowIpv4ProtocolCounter class

        integer counter pattern

        Returns: PatternFlowIpv4ProtocolCounter
        """
        return self._get_property(
            "increment", PatternFlowIpv4ProtocolCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowIpv4ProtocolCounter
        """Factory property that returns an instance of the PatternFlowIpv4ProtocolCounter class

        integer counter pattern

        Returns: PatternFlowIpv4ProtocolCounter
        """
        return self._get_property(
            "decrement", PatternFlowIpv4ProtocolCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["auto"], Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["auto"], Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["auto"], Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def auto(self):
        # type: () -> int
        """auto getter

        The OTG implementation can provide system generated. value for this property. If the OTG is unable to generate value. the default value must be used.

        Returns: int
        """
        return self._get_property("auto")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowIpv4ProtocolMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4ProtocolMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowIpv4ProtocolMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowIpv4ProtocolCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 61,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=61, step=1, count=1):
        super(PatternFlowIpv4ProtocolCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowIpv4ProtocolMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 8,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 8,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=8):
        super(PatternFlowIpv4ProtocolMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowIpv4ProtocolMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowIpv4ProtocolMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowIpv4ProtocolMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowIpv4ProtocolMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowIpv4ProtocolMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowIpv4ProtocolMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowIpv4ProtocolMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowIpv4ProtocolMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=8):
        # type: (str,int,int) -> PatternFlowIpv4ProtocolMetricTagIter
        """Factory method that creates an instance of the PatternFlowIpv4ProtocolMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4ProtocolMetricTagIter
        """
        item = PatternFlowIpv4ProtocolMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=8):
        # type: (str,int,int) -> PatternFlowIpv4ProtocolMetricTag
        """Add method that creates and returns an instance of the PatternFlowIpv4ProtocolMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4ProtocolMetricTag
        """
        item = PatternFlowIpv4ProtocolMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowIpv4HeaderChecksum(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "generated",
                "custom",
            ],
        },
        "generated": {
            "type": str,
            "enum": [
                "good",
                "bad",
            ],
        },
        "custom": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "generated",
        "generated": "good",
    }  # type: Dict[str, Union(type)]

    GENERATED = "generated"  # type: str
    CUSTOM = "custom"  # type: str

    GOOD = "good"  # type: str
    BAD = "bad"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, generated="good", custom=None):
        super(PatternFlowIpv4HeaderChecksum, self).__init__()
        self._parent = parent
        self._set_property("generated", generated)
        self._set_property("custom", custom)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, generated=None, custom=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def choice(self):
        # type: () -> Union[Literal["custom"], Literal["generated"]]
        """choice getter

        The type of checksum

        Returns: Union[Literal["custom"], Literal["generated"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        The type of checksum

        value: Union[Literal["custom"], Literal["generated"]]
        """
        self._set_property("choice", value)

    @property
    def generated(self):
        # type: () -> Union[Literal["bad"], Literal["good"]]
        """generated getter

        A system generated checksum value

        Returns: Union[Literal["bad"], Literal["good"]]
        """
        return self._get_property("generated")

    @generated.setter
    def generated(self, value):
        """generated setter

        A system generated checksum value

        value: Union[Literal["bad"], Literal["good"]]
        """
        self._set_property("generated", value, "generated")

    @property
    def custom(self):
        # type: () -> int
        """custom getter

        A custom checksum value

        Returns: int
        """
        return self._get_property("custom")

    @custom.setter
    def custom(self, value):
        """custom setter

        A custom checksum value

        value: int
        """
        self._set_property("custom", value, "custom")


class PatternFlowIpv4Src(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": str,
            "format": "ipv4",
        },
        "values": {
            "type": list,
            "itemtype": str,
            "itemformat": "ipv4",
        },
        "increment": {"type": "PatternFlowIpv4SrcCounter"},
        "decrement": {"type": "PatternFlowIpv4SrcCounter"},
        "metric_tags": {"type": "PatternFlowIpv4SrcMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": "0.0.0.0",
        "values": ["0.0.0.0"],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value="0.0.0.0", values=["0.0.0.0"]):
        super(PatternFlowIpv4Src, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowIpv4SrcCounter
        """Factory property that returns an instance of the PatternFlowIpv4SrcCounter class

        ipv4 counter pattern

        Returns: PatternFlowIpv4SrcCounter
        """
        return self._get_property(
            "increment", PatternFlowIpv4SrcCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowIpv4SrcCounter
        """Factory property that returns an instance of the PatternFlowIpv4SrcCounter class

        ipv4 counter pattern

        Returns: PatternFlowIpv4SrcCounter
        """
        return self._get_property(
            "decrement", PatternFlowIpv4SrcCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> str
        """value getter

        TBD

        Returns: str
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: str
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[str]
        """values getter

        TBD

        Returns: List[str]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[str]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowIpv4SrcMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4SrcMetricTagIter
        """
        return self._get_property(
            "metric_tags", PatternFlowIpv4SrcMetricTagIter, self._parent, self._choice
        )


class PatternFlowIpv4SrcCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": str,
            "format": "ipv4",
        },
        "step": {
            "type": str,
            "format": "ipv4",
        },
        "count": {
            "type": int,
            "format": "uint32",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": "0.0.0.0",
        "step": "0.0.0.1",
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start="0.0.0.0", step="0.0.0.1", count=1):
        super(PatternFlowIpv4SrcCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> str
        """start getter

        TBD

        Returns: str
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: str
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> str
        """step getter

        TBD

        Returns: str
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: str
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowIpv4SrcMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 31,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 32,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 32,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=32):
        super(PatternFlowIpv4SrcMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowIpv4SrcMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowIpv4SrcMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowIpv4SrcMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowIpv4SrcMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowIpv4SrcMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowIpv4SrcMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowIpv4SrcMetricTag):
            raise Exception("Item is not an instance of PatternFlowIpv4SrcMetricTag")

    def metrictag(self, name=None, offset=0, length=32):
        # type: (str,int,int) -> PatternFlowIpv4SrcMetricTagIter
        """Factory method that creates an instance of the PatternFlowIpv4SrcMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4SrcMetricTagIter
        """
        item = PatternFlowIpv4SrcMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=32):
        # type: (str,int,int) -> PatternFlowIpv4SrcMetricTag
        """Add method that creates and returns an instance of the PatternFlowIpv4SrcMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4SrcMetricTag
        """
        item = PatternFlowIpv4SrcMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowIpv4Dst(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": str,
            "format": "ipv4",
        },
        "values": {
            "type": list,
            "itemtype": str,
            "itemformat": "ipv4",
        },
        "increment": {"type": "PatternFlowIpv4DstCounter"},
        "decrement": {"type": "PatternFlowIpv4DstCounter"},
        "metric_tags": {"type": "PatternFlowIpv4DstMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": "0.0.0.0",
        "values": ["0.0.0.0"],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value="0.0.0.0", values=["0.0.0.0"]):
        super(PatternFlowIpv4Dst, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowIpv4DstCounter
        """Factory property that returns an instance of the PatternFlowIpv4DstCounter class

        ipv4 counter pattern

        Returns: PatternFlowIpv4DstCounter
        """
        return self._get_property(
            "increment", PatternFlowIpv4DstCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowIpv4DstCounter
        """Factory property that returns an instance of the PatternFlowIpv4DstCounter class

        ipv4 counter pattern

        Returns: PatternFlowIpv4DstCounter
        """
        return self._get_property(
            "decrement", PatternFlowIpv4DstCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> str
        """value getter

        TBD

        Returns: str
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: str
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[str]
        """values getter

        TBD

        Returns: List[str]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[str]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowIpv4DstMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4DstMetricTagIter
        """
        return self._get_property(
            "metric_tags", PatternFlowIpv4DstMetricTagIter, self._parent, self._choice
        )


class PatternFlowIpv4DstCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": str,
            "format": "ipv4",
        },
        "step": {
            "type": str,
            "format": "ipv4",
        },
        "count": {
            "type": int,
            "format": "uint32",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": "0.0.0.0",
        "step": "0.0.0.1",
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start="0.0.0.0", step="0.0.0.1", count=1):
        super(PatternFlowIpv4DstCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> str
        """start getter

        TBD

        Returns: str
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: str
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> str
        """step getter

        TBD

        Returns: str
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: str
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowIpv4DstMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 31,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 32,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 32,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=32):
        super(PatternFlowIpv4DstMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowIpv4DstMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowIpv4DstMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowIpv4DstMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowIpv4DstMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowIpv4DstMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowIpv4DstMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowIpv4DstMetricTag):
            raise Exception("Item is not an instance of PatternFlowIpv4DstMetricTag")

    def metrictag(self, name=None, offset=0, length=32):
        # type: (str,int,int) -> PatternFlowIpv4DstMetricTagIter
        """Factory method that creates an instance of the PatternFlowIpv4DstMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4DstMetricTagIter
        """
        item = PatternFlowIpv4DstMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=32):
        # type: (str,int,int) -> PatternFlowIpv4DstMetricTag
        """Add method that creates and returns an instance of the PatternFlowIpv4DstMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv4DstMetricTag
        """
        item = PatternFlowIpv4DstMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class FlowIpv6(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "version": {"type": "PatternFlowIpv6Version"},
        "traffic_class": {"type": "PatternFlowIpv6TrafficClass"},
        "flow_label": {"type": "PatternFlowIpv6FlowLabel"},
        "payload_length": {"type": "PatternFlowIpv6PayloadLength"},
        "next_header": {"type": "PatternFlowIpv6NextHeader"},
        "hop_limit": {"type": "PatternFlowIpv6HopLimit"},
        "src": {"type": "PatternFlowIpv6Src"},
        "dst": {"type": "PatternFlowIpv6Dst"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None):
        super(FlowIpv6, self).__init__()
        self._parent = parent

    @property
    def version(self):
        # type: () -> PatternFlowIpv6Version
        """version getter

        Version numberVersion numberVersion numberVersion number

        Returns: PatternFlowIpv6Version
        """
        return self._get_property("version", PatternFlowIpv6Version)

    @property
    def traffic_class(self):
        # type: () -> PatternFlowIpv6TrafficClass
        """traffic_class getter

        Traffic classTraffic classTraffic classTraffic class

        Returns: PatternFlowIpv6TrafficClass
        """
        return self._get_property("traffic_class", PatternFlowIpv6TrafficClass)

    @property
    def flow_label(self):
        # type: () -> PatternFlowIpv6FlowLabel
        """flow_label getter

        Flow labelFlow labelFlow labelFlow label

        Returns: PatternFlowIpv6FlowLabel
        """
        return self._get_property("flow_label", PatternFlowIpv6FlowLabel)

    @property
    def payload_length(self):
        # type: () -> PatternFlowIpv6PayloadLength
        """payload_length getter

        Payload lengthPayload lengthPayload lengthPayload length

        Returns: PatternFlowIpv6PayloadLength
        """
        return self._get_property("payload_length", PatternFlowIpv6PayloadLength)

    @property
    def next_header(self):
        # type: () -> PatternFlowIpv6NextHeader
        """next_header getter

        Next headerNext headerNext headerNext header

        Returns: PatternFlowIpv6NextHeader
        """
        return self._get_property("next_header", PatternFlowIpv6NextHeader)

    @property
    def hop_limit(self):
        # type: () -> PatternFlowIpv6HopLimit
        """hop_limit getter

        Hop limitHop limitHop limitHop limit

        Returns: PatternFlowIpv6HopLimit
        """
        return self._get_property("hop_limit", PatternFlowIpv6HopLimit)

    @property
    def src(self):
        # type: () -> PatternFlowIpv6Src
        """src getter

        Source addressSource addressSource addressSource address

        Returns: PatternFlowIpv6Src
        """
        return self._get_property("src", PatternFlowIpv6Src)

    @property
    def dst(self):
        # type: () -> PatternFlowIpv6Dst
        """dst getter

        Destination addressDestination addressDestination addressDestination address

        Returns: PatternFlowIpv6Dst
        """
        return self._get_property("dst", PatternFlowIpv6Dst)


class PatternFlowIpv6Version(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 15,
        },
        "increment": {"type": "PatternFlowIpv6VersionCounter"},
        "decrement": {"type": "PatternFlowIpv6VersionCounter"},
        "metric_tags": {"type": "PatternFlowIpv6VersionMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 6,
        "values": [6],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=6, values=[6]):
        super(PatternFlowIpv6Version, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowIpv6VersionCounter
        """Factory property that returns an instance of the PatternFlowIpv6VersionCounter class

        integer counter pattern

        Returns: PatternFlowIpv6VersionCounter
        """
        return self._get_property(
            "increment", PatternFlowIpv6VersionCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowIpv6VersionCounter
        """Factory property that returns an instance of the PatternFlowIpv6VersionCounter class

        integer counter pattern

        Returns: PatternFlowIpv6VersionCounter
        """
        return self._get_property(
            "decrement", PatternFlowIpv6VersionCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowIpv6VersionMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv6VersionMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowIpv6VersionMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowIpv6VersionCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 6,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=6, step=1, count=1):
        super(PatternFlowIpv6VersionCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowIpv6VersionMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 3,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 4,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 4,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=4):
        super(PatternFlowIpv6VersionMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowIpv6VersionMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowIpv6VersionMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowIpv6VersionMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowIpv6VersionMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowIpv6VersionMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowIpv6VersionMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowIpv6VersionMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowIpv6VersionMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=4):
        # type: (str,int,int) -> PatternFlowIpv6VersionMetricTagIter
        """Factory method that creates an instance of the PatternFlowIpv6VersionMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv6VersionMetricTagIter
        """
        item = PatternFlowIpv6VersionMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=4):
        # type: (str,int,int) -> PatternFlowIpv6VersionMetricTag
        """Add method that creates and returns an instance of the PatternFlowIpv6VersionMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv6VersionMetricTag
        """
        item = PatternFlowIpv6VersionMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowIpv6TrafficClass(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 255,
        },
        "increment": {"type": "PatternFlowIpv6TrafficClassCounter"},
        "decrement": {"type": "PatternFlowIpv6TrafficClassCounter"},
        "metric_tags": {"type": "PatternFlowIpv6TrafficClassMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowIpv6TrafficClass, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowIpv6TrafficClassCounter
        """Factory property that returns an instance of the PatternFlowIpv6TrafficClassCounter class

        integer counter pattern

        Returns: PatternFlowIpv6TrafficClassCounter
        """
        return self._get_property(
            "increment", PatternFlowIpv6TrafficClassCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowIpv6TrafficClassCounter
        """Factory property that returns an instance of the PatternFlowIpv6TrafficClassCounter class

        integer counter pattern

        Returns: PatternFlowIpv6TrafficClassCounter
        """
        return self._get_property(
            "decrement", PatternFlowIpv6TrafficClassCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowIpv6TrafficClassMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv6TrafficClassMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowIpv6TrafficClassMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowIpv6TrafficClassCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowIpv6TrafficClassCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowIpv6TrafficClassMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 8,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 8,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=8):
        super(PatternFlowIpv6TrafficClassMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowIpv6TrafficClassMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowIpv6TrafficClassMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowIpv6TrafficClassMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowIpv6TrafficClassMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowIpv6TrafficClassMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowIpv6TrafficClassMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowIpv6TrafficClassMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowIpv6TrafficClassMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=8):
        # type: (str,int,int) -> PatternFlowIpv6TrafficClassMetricTagIter
        """Factory method that creates an instance of the PatternFlowIpv6TrafficClassMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv6TrafficClassMetricTagIter
        """
        item = PatternFlowIpv6TrafficClassMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=8):
        # type: (str,int,int) -> PatternFlowIpv6TrafficClassMetricTag
        """Add method that creates and returns an instance of the PatternFlowIpv6TrafficClassMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv6TrafficClassMetricTag
        """
        item = PatternFlowIpv6TrafficClassMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowIpv6FlowLabel(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 1048575,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 1048575,
        },
        "increment": {"type": "PatternFlowIpv6FlowLabelCounter"},
        "decrement": {"type": "PatternFlowIpv6FlowLabelCounter"},
        "metric_tags": {"type": "PatternFlowIpv6FlowLabelMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowIpv6FlowLabel, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowIpv6FlowLabelCounter
        """Factory property that returns an instance of the PatternFlowIpv6FlowLabelCounter class

        integer counter pattern

        Returns: PatternFlowIpv6FlowLabelCounter
        """
        return self._get_property(
            "increment", PatternFlowIpv6FlowLabelCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowIpv6FlowLabelCounter
        """Factory property that returns an instance of the PatternFlowIpv6FlowLabelCounter class

        integer counter pattern

        Returns: PatternFlowIpv6FlowLabelCounter
        """
        return self._get_property(
            "decrement", PatternFlowIpv6FlowLabelCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowIpv6FlowLabelMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv6FlowLabelMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowIpv6FlowLabelMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowIpv6FlowLabelCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 1048575,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 1048575,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 1048575,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowIpv6FlowLabelCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowIpv6FlowLabelMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 19,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 20,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 20,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=20):
        super(PatternFlowIpv6FlowLabelMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowIpv6FlowLabelMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowIpv6FlowLabelMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowIpv6FlowLabelMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowIpv6FlowLabelMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowIpv6FlowLabelMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowIpv6FlowLabelMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowIpv6FlowLabelMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowIpv6FlowLabelMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=20):
        # type: (str,int,int) -> PatternFlowIpv6FlowLabelMetricTagIter
        """Factory method that creates an instance of the PatternFlowIpv6FlowLabelMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv6FlowLabelMetricTagIter
        """
        item = PatternFlowIpv6FlowLabelMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=20):
        # type: (str,int,int) -> PatternFlowIpv6FlowLabelMetricTag
        """Add method that creates and returns an instance of the PatternFlowIpv6FlowLabelMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv6FlowLabelMetricTag
        """
        item = PatternFlowIpv6FlowLabelMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowIpv6PayloadLength(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "auto",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 65535,
        },
        "auto": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "increment": {"type": "PatternFlowIpv6PayloadLengthCounter"},
        "decrement": {"type": "PatternFlowIpv6PayloadLengthCounter"},
        "metric_tags": {"type": "PatternFlowIpv6PayloadLengthMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "auto",
        "value": 0,
        "values": [0],
        "auto": 0,
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    AUTO = "auto"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0], auto=0):
        super(PatternFlowIpv6PayloadLength, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        self._set_property("auto", auto)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None, auto=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowIpv6PayloadLengthCounter
        """Factory property that returns an instance of the PatternFlowIpv6PayloadLengthCounter class

        integer counter pattern

        Returns: PatternFlowIpv6PayloadLengthCounter
        """
        return self._get_property(
            "increment", PatternFlowIpv6PayloadLengthCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowIpv6PayloadLengthCounter
        """Factory property that returns an instance of the PatternFlowIpv6PayloadLengthCounter class

        integer counter pattern

        Returns: PatternFlowIpv6PayloadLengthCounter
        """
        return self._get_property(
            "decrement", PatternFlowIpv6PayloadLengthCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["auto"], Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["auto"], Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["auto"], Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def auto(self):
        # type: () -> int
        """auto getter

        The OTG implementation can provide system generated. value for this property. If the OTG is unable to generate value. the default value must be used.

        Returns: int
        """
        return self._get_property("auto")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowIpv6PayloadLengthMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv6PayloadLengthMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowIpv6PayloadLengthMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowIpv6PayloadLengthCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowIpv6PayloadLengthCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowIpv6PayloadLengthMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 16,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 16,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=16):
        super(PatternFlowIpv6PayloadLengthMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowIpv6PayloadLengthMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowIpv6PayloadLengthMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowIpv6PayloadLengthMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowIpv6PayloadLengthMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowIpv6PayloadLengthMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowIpv6PayloadLengthMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowIpv6PayloadLengthMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowIpv6PayloadLengthMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowIpv6PayloadLengthMetricTagIter
        """Factory method that creates an instance of the PatternFlowIpv6PayloadLengthMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv6PayloadLengthMetricTagIter
        """
        item = PatternFlowIpv6PayloadLengthMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowIpv6PayloadLengthMetricTag
        """Add method that creates and returns an instance of the PatternFlowIpv6PayloadLengthMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv6PayloadLengthMetricTag
        """
        item = PatternFlowIpv6PayloadLengthMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowIpv6NextHeader(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "auto",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 255,
        },
        "auto": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "increment": {"type": "PatternFlowIpv6NextHeaderCounter"},
        "decrement": {"type": "PatternFlowIpv6NextHeaderCounter"},
        "metric_tags": {"type": "PatternFlowIpv6NextHeaderMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "auto",
        "value": 59,
        "values": [59],
        "auto": 59,
    }  # type: Dict[str, Union(type)]

    HOPOPT = 0  #
    ICMP = 1  #
    IGMP = 2  #
    GGP = 3  #
    IP_IN_IP = 4  #
    ST = 5  #
    TCP = 6  #
    CPT = 7  #
    EGP = 8  #
    IGP = 9  #
    NO_NEXT_HEADER = 59  #

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    AUTO = "auto"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=59, values=[59], auto=59):
        super(PatternFlowIpv6NextHeader, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        self._set_property("auto", auto)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None, auto=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowIpv6NextHeaderCounter
        """Factory property that returns an instance of the PatternFlowIpv6NextHeaderCounter class

        integer counter pattern

        Returns: PatternFlowIpv6NextHeaderCounter
        """
        return self._get_property(
            "increment", PatternFlowIpv6NextHeaderCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowIpv6NextHeaderCounter
        """Factory property that returns an instance of the PatternFlowIpv6NextHeaderCounter class

        integer counter pattern

        Returns: PatternFlowIpv6NextHeaderCounter
        """
        return self._get_property(
            "decrement", PatternFlowIpv6NextHeaderCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["auto"], Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["auto"], Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["auto"], Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def auto(self):
        # type: () -> int
        """auto getter

        The OTG implementation can provide system generated. value for this property. If the OTG is unable to generate value. the default value must be used.

        Returns: int
        """
        return self._get_property("auto")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowIpv6NextHeaderMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv6NextHeaderMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowIpv6NextHeaderMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowIpv6NextHeaderCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 59,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    HOPOPT = 0  #
    ICMP = 1  #
    IGMP = 2  #
    GGP = 3  #
    IP_IN_IP = 4  #
    ST = 5  #
    TCP = 6  #
    CPT = 7  #
    EGP = 8  #
    IGP = 9  #
    NO_NEXT_HEADER = 59  #

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=59, step=1, count=1):
        super(PatternFlowIpv6NextHeaderCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowIpv6NextHeaderMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 8,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 8,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=8):
        super(PatternFlowIpv6NextHeaderMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowIpv6NextHeaderMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowIpv6NextHeaderMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowIpv6NextHeaderMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowIpv6NextHeaderMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowIpv6NextHeaderMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowIpv6NextHeaderMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowIpv6NextHeaderMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowIpv6NextHeaderMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=8):
        # type: (str,int,int) -> PatternFlowIpv6NextHeaderMetricTagIter
        """Factory method that creates an instance of the PatternFlowIpv6NextHeaderMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv6NextHeaderMetricTagIter
        """
        item = PatternFlowIpv6NextHeaderMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=8):
        # type: (str,int,int) -> PatternFlowIpv6NextHeaderMetricTag
        """Add method that creates and returns an instance of the PatternFlowIpv6NextHeaderMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv6NextHeaderMetricTag
        """
        item = PatternFlowIpv6NextHeaderMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowIpv6HopLimit(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 255,
        },
        "increment": {"type": "PatternFlowIpv6HopLimitCounter"},
        "decrement": {"type": "PatternFlowIpv6HopLimitCounter"},
        "metric_tags": {"type": "PatternFlowIpv6HopLimitMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 64,
        "values": [64],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=64, values=[64]):
        super(PatternFlowIpv6HopLimit, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowIpv6HopLimitCounter
        """Factory property that returns an instance of the PatternFlowIpv6HopLimitCounter class

        integer counter pattern

        Returns: PatternFlowIpv6HopLimitCounter
        """
        return self._get_property(
            "increment", PatternFlowIpv6HopLimitCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowIpv6HopLimitCounter
        """Factory property that returns an instance of the PatternFlowIpv6HopLimitCounter class

        integer counter pattern

        Returns: PatternFlowIpv6HopLimitCounter
        """
        return self._get_property(
            "decrement", PatternFlowIpv6HopLimitCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowIpv6HopLimitMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv6HopLimitMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowIpv6HopLimitMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowIpv6HopLimitCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 64,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=64, step=1, count=1):
        super(PatternFlowIpv6HopLimitCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowIpv6HopLimitMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 8,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 8,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=8):
        super(PatternFlowIpv6HopLimitMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowIpv6HopLimitMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowIpv6HopLimitMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowIpv6HopLimitMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowIpv6HopLimitMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowIpv6HopLimitMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowIpv6HopLimitMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowIpv6HopLimitMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowIpv6HopLimitMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=8):
        # type: (str,int,int) -> PatternFlowIpv6HopLimitMetricTagIter
        """Factory method that creates an instance of the PatternFlowIpv6HopLimitMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv6HopLimitMetricTagIter
        """
        item = PatternFlowIpv6HopLimitMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=8):
        # type: (str,int,int) -> PatternFlowIpv6HopLimitMetricTag
        """Add method that creates and returns an instance of the PatternFlowIpv6HopLimitMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv6HopLimitMetricTag
        """
        item = PatternFlowIpv6HopLimitMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowIpv6Src(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": str,
            "format": "ipv6",
        },
        "values": {
            "type": list,
            "itemtype": str,
            "itemformat": "ipv6",
        },
        "increment": {"type": "PatternFlowIpv6SrcCounter"},
        "decrement": {"type": "PatternFlowIpv6SrcCounter"},
        "metric_tags": {"type": "PatternFlowIpv6SrcMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": "::0",
        "values": ["::0"],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value="::0", values=["::0"]):
        super(PatternFlowIpv6Src, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowIpv6SrcCounter
        """Factory property that returns an instance of the PatternFlowIpv6SrcCounter class

        ipv6 counter pattern

        Returns: PatternFlowIpv6SrcCounter
        """
        return self._get_property(
            "increment", PatternFlowIpv6SrcCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowIpv6SrcCounter
        """Factory property that returns an instance of the PatternFlowIpv6SrcCounter class

        ipv6 counter pattern

        Returns: PatternFlowIpv6SrcCounter
        """
        return self._get_property(
            "decrement", PatternFlowIpv6SrcCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> str
        """value getter

        TBD

        Returns: str
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: str
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[str]
        """values getter

        TBD

        Returns: List[str]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[str]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowIpv6SrcMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv6SrcMetricTagIter
        """
        return self._get_property(
            "metric_tags", PatternFlowIpv6SrcMetricTagIter, self._parent, self._choice
        )


class PatternFlowIpv6SrcCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": str,
            "format": "ipv6",
        },
        "step": {
            "type": str,
            "format": "ipv6",
        },
        "count": {
            "type": int,
            "format": "uint32",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": "::0",
        "step": "::1",
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start="::0", step="::1", count=1):
        super(PatternFlowIpv6SrcCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> str
        """start getter

        TBD

        Returns: str
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: str
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> str
        """step getter

        TBD

        Returns: str
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: str
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowIpv6SrcMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 127,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 128,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 128,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=128):
        super(PatternFlowIpv6SrcMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowIpv6SrcMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowIpv6SrcMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowIpv6SrcMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowIpv6SrcMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowIpv6SrcMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowIpv6SrcMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowIpv6SrcMetricTag):
            raise Exception("Item is not an instance of PatternFlowIpv6SrcMetricTag")

    def metrictag(self, name=None, offset=0, length=128):
        # type: (str,int,int) -> PatternFlowIpv6SrcMetricTagIter
        """Factory method that creates an instance of the PatternFlowIpv6SrcMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv6SrcMetricTagIter
        """
        item = PatternFlowIpv6SrcMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=128):
        # type: (str,int,int) -> PatternFlowIpv6SrcMetricTag
        """Add method that creates and returns an instance of the PatternFlowIpv6SrcMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv6SrcMetricTag
        """
        item = PatternFlowIpv6SrcMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowIpv6Dst(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": str,
            "format": "ipv6",
        },
        "values": {
            "type": list,
            "itemtype": str,
            "itemformat": "ipv6",
        },
        "increment": {"type": "PatternFlowIpv6DstCounter"},
        "decrement": {"type": "PatternFlowIpv6DstCounter"},
        "metric_tags": {"type": "PatternFlowIpv6DstMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": "::0",
        "values": ["::0"],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value="::0", values=["::0"]):
        super(PatternFlowIpv6Dst, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowIpv6DstCounter
        """Factory property that returns an instance of the PatternFlowIpv6DstCounter class

        ipv6 counter pattern

        Returns: PatternFlowIpv6DstCounter
        """
        return self._get_property(
            "increment", PatternFlowIpv6DstCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowIpv6DstCounter
        """Factory property that returns an instance of the PatternFlowIpv6DstCounter class

        ipv6 counter pattern

        Returns: PatternFlowIpv6DstCounter
        """
        return self._get_property(
            "decrement", PatternFlowIpv6DstCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> str
        """value getter

        TBD

        Returns: str
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: str
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[str]
        """values getter

        TBD

        Returns: List[str]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[str]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowIpv6DstMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv6DstMetricTagIter
        """
        return self._get_property(
            "metric_tags", PatternFlowIpv6DstMetricTagIter, self._parent, self._choice
        )


class PatternFlowIpv6DstCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": str,
            "format": "ipv6",
        },
        "step": {
            "type": str,
            "format": "ipv6",
        },
        "count": {
            "type": int,
            "format": "uint32",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": "::0",
        "step": "::1",
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start="::0", step="::1", count=1):
        super(PatternFlowIpv6DstCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> str
        """start getter

        TBD

        Returns: str
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: str
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> str
        """step getter

        TBD

        Returns: str
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: str
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowIpv6DstMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 127,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 128,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 128,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=128):
        super(PatternFlowIpv6DstMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowIpv6DstMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowIpv6DstMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowIpv6DstMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowIpv6DstMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowIpv6DstMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowIpv6DstMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowIpv6DstMetricTag):
            raise Exception("Item is not an instance of PatternFlowIpv6DstMetricTag")

    def metrictag(self, name=None, offset=0, length=128):
        # type: (str,int,int) -> PatternFlowIpv6DstMetricTagIter
        """Factory method that creates an instance of the PatternFlowIpv6DstMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv6DstMetricTagIter
        """
        item = PatternFlowIpv6DstMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=128):
        # type: (str,int,int) -> PatternFlowIpv6DstMetricTag
        """Add method that creates and returns an instance of the PatternFlowIpv6DstMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIpv6DstMetricTag
        """
        item = PatternFlowIpv6DstMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class FlowPfcPause(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "dst": {"type": "PatternFlowPfcPauseDst"},
        "src": {"type": "PatternFlowPfcPauseSrc"},
        "ether_type": {"type": "PatternFlowPfcPauseEtherType"},
        "control_op_code": {"type": "PatternFlowPfcPauseControlOpCode"},
        "class_enable_vector": {"type": "PatternFlowPfcPauseClassEnableVector"},
        "pause_class_0": {"type": "PatternFlowPfcPausePauseClass0"},
        "pause_class_1": {"type": "PatternFlowPfcPausePauseClass1"},
        "pause_class_2": {"type": "PatternFlowPfcPausePauseClass2"},
        "pause_class_3": {"type": "PatternFlowPfcPausePauseClass3"},
        "pause_class_4": {"type": "PatternFlowPfcPausePauseClass4"},
        "pause_class_5": {"type": "PatternFlowPfcPausePauseClass5"},
        "pause_class_6": {"type": "PatternFlowPfcPausePauseClass6"},
        "pause_class_7": {"type": "PatternFlowPfcPausePauseClass7"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None):
        super(FlowPfcPause, self).__init__()
        self._parent = parent

    @property
    def dst(self):
        # type: () -> PatternFlowPfcPauseDst
        """dst getter

        Destination MAC addressDestination MAC addressDestination MAC addressDestination MAC address

        Returns: PatternFlowPfcPauseDst
        """
        return self._get_property("dst", PatternFlowPfcPauseDst)

    @property
    def src(self):
        # type: () -> PatternFlowPfcPauseSrc
        """src getter

        Source MAC addressSource MAC addressSource MAC addressSource MAC address

        Returns: PatternFlowPfcPauseSrc
        """
        return self._get_property("src", PatternFlowPfcPauseSrc)

    @property
    def ether_type(self):
        # type: () -> PatternFlowPfcPauseEtherType
        """ether_type getter

        Ethernet typeEthernet typeEthernet typeEthernet type

        Returns: PatternFlowPfcPauseEtherType
        """
        return self._get_property("ether_type", PatternFlowPfcPauseEtherType)

    @property
    def control_op_code(self):
        # type: () -> PatternFlowPfcPauseControlOpCode
        """control_op_code getter

        Control operation codeControl operation codeControl operation codeControl operation code

        Returns: PatternFlowPfcPauseControlOpCode
        """
        return self._get_property("control_op_code", PatternFlowPfcPauseControlOpCode)

    @property
    def class_enable_vector(self):
        # type: () -> PatternFlowPfcPauseClassEnableVector
        """class_enable_vector getter

        DestinationDestinationDestinationDestination

        Returns: PatternFlowPfcPauseClassEnableVector
        """
        return self._get_property(
            "class_enable_vector", PatternFlowPfcPauseClassEnableVector
        )

    @property
    def pause_class_0(self):
        # type: () -> PatternFlowPfcPausePauseClass0
        """pause_class_0 getter

        Pause class 0Pause class 0Pause class 0Pause class 0

        Returns: PatternFlowPfcPausePauseClass0
        """
        return self._get_property("pause_class_0", PatternFlowPfcPausePauseClass0)

    @property
    def pause_class_1(self):
        # type: () -> PatternFlowPfcPausePauseClass1
        """pause_class_1 getter

        Pause class 1Pause class 1Pause class 1Pause class 1

        Returns: PatternFlowPfcPausePauseClass1
        """
        return self._get_property("pause_class_1", PatternFlowPfcPausePauseClass1)

    @property
    def pause_class_2(self):
        # type: () -> PatternFlowPfcPausePauseClass2
        """pause_class_2 getter

        Pause class 2Pause class 2Pause class 2Pause class 2

        Returns: PatternFlowPfcPausePauseClass2
        """
        return self._get_property("pause_class_2", PatternFlowPfcPausePauseClass2)

    @property
    def pause_class_3(self):
        # type: () -> PatternFlowPfcPausePauseClass3
        """pause_class_3 getter

        Pause class 3Pause class 3Pause class 3Pause class 3

        Returns: PatternFlowPfcPausePauseClass3
        """
        return self._get_property("pause_class_3", PatternFlowPfcPausePauseClass3)

    @property
    def pause_class_4(self):
        # type: () -> PatternFlowPfcPausePauseClass4
        """pause_class_4 getter

        Pause class 4Pause class 4Pause class 4Pause class 4

        Returns: PatternFlowPfcPausePauseClass4
        """
        return self._get_property("pause_class_4", PatternFlowPfcPausePauseClass4)

    @property
    def pause_class_5(self):
        # type: () -> PatternFlowPfcPausePauseClass5
        """pause_class_5 getter

        Pause class 5Pause class 5Pause class 5Pause class 5

        Returns: PatternFlowPfcPausePauseClass5
        """
        return self._get_property("pause_class_5", PatternFlowPfcPausePauseClass5)

    @property
    def pause_class_6(self):
        # type: () -> PatternFlowPfcPausePauseClass6
        """pause_class_6 getter

        Pause class 6Pause class 6Pause class 6Pause class 6

        Returns: PatternFlowPfcPausePauseClass6
        """
        return self._get_property("pause_class_6", PatternFlowPfcPausePauseClass6)

    @property
    def pause_class_7(self):
        # type: () -> PatternFlowPfcPausePauseClass7
        """pause_class_7 getter

        Pause class 7Pause class 7Pause class 7Pause class 7

        Returns: PatternFlowPfcPausePauseClass7
        """
        return self._get_property("pause_class_7", PatternFlowPfcPausePauseClass7)


class PatternFlowPfcPauseDst(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": str,
            "format": "mac",
        },
        "values": {
            "type": list,
            "itemtype": str,
            "itemformat": "mac",
        },
        "increment": {"type": "PatternFlowPfcPauseDstCounter"},
        "decrement": {"type": "PatternFlowPfcPauseDstCounter"},
        "metric_tags": {"type": "PatternFlowPfcPauseDstMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": "01:80:c2:00:00:01",
        "values": ["01:80:c2:00:00:01"],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        choice=None,
        value="01:80:c2:00:00:01",
        values=["01:80:c2:00:00:01"],
    ):
        super(PatternFlowPfcPauseDst, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowPfcPauseDstCounter
        """Factory property that returns an instance of the PatternFlowPfcPauseDstCounter class

        mac counter pattern

        Returns: PatternFlowPfcPauseDstCounter
        """
        return self._get_property(
            "increment", PatternFlowPfcPauseDstCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowPfcPauseDstCounter
        """Factory property that returns an instance of the PatternFlowPfcPauseDstCounter class

        mac counter pattern

        Returns: PatternFlowPfcPauseDstCounter
        """
        return self._get_property(
            "decrement", PatternFlowPfcPauseDstCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> str
        """value getter

        TBD

        Returns: str
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: str
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[str]
        """values getter

        TBD

        Returns: List[str]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[str]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowPfcPauseDstMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowPfcPauseDstMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowPfcPauseDstMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowPfcPauseDstCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": str,
            "format": "mac",
        },
        "step": {
            "type": str,
            "format": "mac",
        },
        "count": {
            "type": int,
            "format": "uint32",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": "01:80:c2:00:00:01",
        "step": "00:00:00:00:00:01",
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self, parent=None, start="01:80:c2:00:00:01", step="00:00:00:00:00:01", count=1
    ):
        super(PatternFlowPfcPauseDstCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> str
        """start getter

        TBD

        Returns: str
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: str
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> str
        """step getter

        TBD

        Returns: str
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: str
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowPfcPauseDstMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 47,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 48,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 48,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=48):
        super(PatternFlowPfcPauseDstMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowPfcPauseDstMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowPfcPauseDstMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowPfcPauseDstMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowPfcPauseDstMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowPfcPauseDstMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowPfcPauseDstMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowPfcPauseDstMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowPfcPauseDstMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=48):
        # type: (str,int,int) -> PatternFlowPfcPauseDstMetricTagIter
        """Factory method that creates an instance of the PatternFlowPfcPauseDstMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowPfcPauseDstMetricTagIter
        """
        item = PatternFlowPfcPauseDstMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=48):
        # type: (str,int,int) -> PatternFlowPfcPauseDstMetricTag
        """Add method that creates and returns an instance of the PatternFlowPfcPauseDstMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowPfcPauseDstMetricTag
        """
        item = PatternFlowPfcPauseDstMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowPfcPauseSrc(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": str,
            "format": "mac",
        },
        "values": {
            "type": list,
            "itemtype": str,
            "itemformat": "mac",
        },
        "increment": {"type": "PatternFlowPfcPauseSrcCounter"},
        "decrement": {"type": "PatternFlowPfcPauseSrcCounter"},
        "metric_tags": {"type": "PatternFlowPfcPauseSrcMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": "00:00:00:00:00:00",
        "values": ["00:00:00:00:00:00"],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        choice=None,
        value="00:00:00:00:00:00",
        values=["00:00:00:00:00:00"],
    ):
        super(PatternFlowPfcPauseSrc, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowPfcPauseSrcCounter
        """Factory property that returns an instance of the PatternFlowPfcPauseSrcCounter class

        mac counter pattern

        Returns: PatternFlowPfcPauseSrcCounter
        """
        return self._get_property(
            "increment", PatternFlowPfcPauseSrcCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowPfcPauseSrcCounter
        """Factory property that returns an instance of the PatternFlowPfcPauseSrcCounter class

        mac counter pattern

        Returns: PatternFlowPfcPauseSrcCounter
        """
        return self._get_property(
            "decrement", PatternFlowPfcPauseSrcCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> str
        """value getter

        TBD

        Returns: str
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: str
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[str]
        """values getter

        TBD

        Returns: List[str]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[str]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowPfcPauseSrcMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowPfcPauseSrcMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowPfcPauseSrcMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowPfcPauseSrcCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": str,
            "format": "mac",
        },
        "step": {
            "type": str,
            "format": "mac",
        },
        "count": {
            "type": int,
            "format": "uint32",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": "00:00:00:00:00:00",
        "step": "00:00:00:00:00:01",
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self, parent=None, start="00:00:00:00:00:00", step="00:00:00:00:00:01", count=1
    ):
        super(PatternFlowPfcPauseSrcCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> str
        """start getter

        TBD

        Returns: str
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: str
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> str
        """step getter

        TBD

        Returns: str
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: str
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowPfcPauseSrcMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 47,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 48,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 48,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=48):
        super(PatternFlowPfcPauseSrcMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowPfcPauseSrcMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowPfcPauseSrcMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowPfcPauseSrcMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowPfcPauseSrcMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowPfcPauseSrcMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowPfcPauseSrcMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowPfcPauseSrcMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowPfcPauseSrcMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=48):
        # type: (str,int,int) -> PatternFlowPfcPauseSrcMetricTagIter
        """Factory method that creates an instance of the PatternFlowPfcPauseSrcMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowPfcPauseSrcMetricTagIter
        """
        item = PatternFlowPfcPauseSrcMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=48):
        # type: (str,int,int) -> PatternFlowPfcPauseSrcMetricTag
        """Add method that creates and returns an instance of the PatternFlowPfcPauseSrcMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowPfcPauseSrcMetricTag
        """
        item = PatternFlowPfcPauseSrcMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowPfcPauseEtherType(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 65535,
        },
        "increment": {"type": "PatternFlowPfcPauseEtherTypeCounter"},
        "decrement": {"type": "PatternFlowPfcPauseEtherTypeCounter"},
        "metric_tags": {"type": "PatternFlowPfcPauseEtherTypeMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 34824,
        "values": [34824],
    }  # type: Dict[str, Union(type)]

    X8808 = 34824  #

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=34824, values=[34824]):
        super(PatternFlowPfcPauseEtherType, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowPfcPauseEtherTypeCounter
        """Factory property that returns an instance of the PatternFlowPfcPauseEtherTypeCounter class

        integer counter pattern

        Returns: PatternFlowPfcPauseEtherTypeCounter
        """
        return self._get_property(
            "increment", PatternFlowPfcPauseEtherTypeCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowPfcPauseEtherTypeCounter
        """Factory property that returns an instance of the PatternFlowPfcPauseEtherTypeCounter class

        integer counter pattern

        Returns: PatternFlowPfcPauseEtherTypeCounter
        """
        return self._get_property(
            "decrement", PatternFlowPfcPauseEtherTypeCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowPfcPauseEtherTypeMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowPfcPauseEtherTypeMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowPfcPauseEtherTypeMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowPfcPauseEtherTypeCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 34824,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    X8808 = 34824  #

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=34824, step=1, count=1):
        super(PatternFlowPfcPauseEtherTypeCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowPfcPauseEtherTypeMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 16,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 16,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=16):
        super(PatternFlowPfcPauseEtherTypeMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowPfcPauseEtherTypeMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowPfcPauseEtherTypeMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowPfcPauseEtherTypeMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowPfcPauseEtherTypeMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowPfcPauseEtherTypeMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowPfcPauseEtherTypeMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowPfcPauseEtherTypeMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowPfcPauseEtherTypeMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowPfcPauseEtherTypeMetricTagIter
        """Factory method that creates an instance of the PatternFlowPfcPauseEtherTypeMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowPfcPauseEtherTypeMetricTagIter
        """
        item = PatternFlowPfcPauseEtherTypeMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowPfcPauseEtherTypeMetricTag
        """Add method that creates and returns an instance of the PatternFlowPfcPauseEtherTypeMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowPfcPauseEtherTypeMetricTag
        """
        item = PatternFlowPfcPauseEtherTypeMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowPfcPauseControlOpCode(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 65535,
        },
        "increment": {"type": "PatternFlowPfcPauseControlOpCodeCounter"},
        "decrement": {"type": "PatternFlowPfcPauseControlOpCodeCounter"},
        "metric_tags": {"type": "PatternFlowPfcPauseControlOpCodeMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 257,
        "values": [257],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=257, values=[257]):
        super(PatternFlowPfcPauseControlOpCode, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowPfcPauseControlOpCodeCounter
        """Factory property that returns an instance of the PatternFlowPfcPauseControlOpCodeCounter class

        integer counter pattern

        Returns: PatternFlowPfcPauseControlOpCodeCounter
        """
        return self._get_property(
            "increment", PatternFlowPfcPauseControlOpCodeCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowPfcPauseControlOpCodeCounter
        """Factory property that returns an instance of the PatternFlowPfcPauseControlOpCodeCounter class

        integer counter pattern

        Returns: PatternFlowPfcPauseControlOpCodeCounter
        """
        return self._get_property(
            "decrement", PatternFlowPfcPauseControlOpCodeCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowPfcPauseControlOpCodeMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowPfcPauseControlOpCodeMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowPfcPauseControlOpCodeMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowPfcPauseControlOpCodeCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 257,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=257, step=1, count=1):
        super(PatternFlowPfcPauseControlOpCodeCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowPfcPauseControlOpCodeMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 16,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 16,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=16):
        super(PatternFlowPfcPauseControlOpCodeMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowPfcPauseControlOpCodeMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowPfcPauseControlOpCodeMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowPfcPauseControlOpCodeMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowPfcPauseControlOpCodeMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowPfcPauseControlOpCodeMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowPfcPauseControlOpCodeMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowPfcPauseControlOpCodeMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowPfcPauseControlOpCodeMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowPfcPauseControlOpCodeMetricTagIter
        """Factory method that creates an instance of the PatternFlowPfcPauseControlOpCodeMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowPfcPauseControlOpCodeMetricTagIter
        """
        item = PatternFlowPfcPauseControlOpCodeMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowPfcPauseControlOpCodeMetricTag
        """Add method that creates and returns an instance of the PatternFlowPfcPauseControlOpCodeMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowPfcPauseControlOpCodeMetricTag
        """
        item = PatternFlowPfcPauseControlOpCodeMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowPfcPauseClassEnableVector(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 65535,
        },
        "increment": {"type": "PatternFlowPfcPauseClassEnableVectorCounter"},
        "decrement": {"type": "PatternFlowPfcPauseClassEnableVectorCounter"},
        "metric_tags": {"type": "PatternFlowPfcPauseClassEnableVectorMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowPfcPauseClassEnableVector, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowPfcPauseClassEnableVectorCounter
        """Factory property that returns an instance of the PatternFlowPfcPauseClassEnableVectorCounter class

        integer counter pattern

        Returns: PatternFlowPfcPauseClassEnableVectorCounter
        """
        return self._get_property(
            "increment", PatternFlowPfcPauseClassEnableVectorCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowPfcPauseClassEnableVectorCounter
        """Factory property that returns an instance of the PatternFlowPfcPauseClassEnableVectorCounter class

        integer counter pattern

        Returns: PatternFlowPfcPauseClassEnableVectorCounter
        """
        return self._get_property(
            "decrement", PatternFlowPfcPauseClassEnableVectorCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowPfcPauseClassEnableVectorMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowPfcPauseClassEnableVectorMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowPfcPauseClassEnableVectorMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowPfcPauseClassEnableVectorCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowPfcPauseClassEnableVectorCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowPfcPauseClassEnableVectorMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 16,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 16,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=16):
        super(PatternFlowPfcPauseClassEnableVectorMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowPfcPauseClassEnableVectorMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowPfcPauseClassEnableVectorMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowPfcPauseClassEnableVectorMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowPfcPauseClassEnableVectorMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowPfcPauseClassEnableVectorMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowPfcPauseClassEnableVectorMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowPfcPauseClassEnableVectorMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowPfcPauseClassEnableVectorMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowPfcPauseClassEnableVectorMetricTagIter
        """Factory method that creates an instance of the PatternFlowPfcPauseClassEnableVectorMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowPfcPauseClassEnableVectorMetricTagIter
        """
        item = PatternFlowPfcPauseClassEnableVectorMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowPfcPauseClassEnableVectorMetricTag
        """Add method that creates and returns an instance of the PatternFlowPfcPauseClassEnableVectorMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowPfcPauseClassEnableVectorMetricTag
        """
        item = PatternFlowPfcPauseClassEnableVectorMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowPfcPausePauseClass0(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 65535,
        },
        "increment": {"type": "PatternFlowPfcPausePauseClass0Counter"},
        "decrement": {"type": "PatternFlowPfcPausePauseClass0Counter"},
        "metric_tags": {"type": "PatternFlowPfcPausePauseClass0MetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowPfcPausePauseClass0, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowPfcPausePauseClass0Counter
        """Factory property that returns an instance of the PatternFlowPfcPausePauseClass0Counter class

        integer counter pattern

        Returns: PatternFlowPfcPausePauseClass0Counter
        """
        return self._get_property(
            "increment", PatternFlowPfcPausePauseClass0Counter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowPfcPausePauseClass0Counter
        """Factory property that returns an instance of the PatternFlowPfcPausePauseClass0Counter class

        integer counter pattern

        Returns: PatternFlowPfcPausePauseClass0Counter
        """
        return self._get_property(
            "decrement", PatternFlowPfcPausePauseClass0Counter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowPfcPausePauseClass0MetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowPfcPausePauseClass0MetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowPfcPausePauseClass0MetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowPfcPausePauseClass0Counter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowPfcPausePauseClass0Counter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowPfcPausePauseClass0MetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 16,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 16,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=16):
        super(PatternFlowPfcPausePauseClass0MetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowPfcPausePauseClass0MetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowPfcPausePauseClass0MetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowPfcPausePauseClass0MetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowPfcPausePauseClass0MetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowPfcPausePauseClass0MetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowPfcPausePauseClass0MetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowPfcPausePauseClass0MetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowPfcPausePauseClass0MetricTag"
            )

    def metrictag(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowPfcPausePauseClass0MetricTagIter
        """Factory method that creates an instance of the PatternFlowPfcPausePauseClass0MetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowPfcPausePauseClass0MetricTagIter
        """
        item = PatternFlowPfcPausePauseClass0MetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowPfcPausePauseClass0MetricTag
        """Add method that creates and returns an instance of the PatternFlowPfcPausePauseClass0MetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowPfcPausePauseClass0MetricTag
        """
        item = PatternFlowPfcPausePauseClass0MetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowPfcPausePauseClass1(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 65535,
        },
        "increment": {"type": "PatternFlowPfcPausePauseClass1Counter"},
        "decrement": {"type": "PatternFlowPfcPausePauseClass1Counter"},
        "metric_tags": {"type": "PatternFlowPfcPausePauseClass1MetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowPfcPausePauseClass1, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowPfcPausePauseClass1Counter
        """Factory property that returns an instance of the PatternFlowPfcPausePauseClass1Counter class

        integer counter pattern

        Returns: PatternFlowPfcPausePauseClass1Counter
        """
        return self._get_property(
            "increment", PatternFlowPfcPausePauseClass1Counter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowPfcPausePauseClass1Counter
        """Factory property that returns an instance of the PatternFlowPfcPausePauseClass1Counter class

        integer counter pattern

        Returns: PatternFlowPfcPausePauseClass1Counter
        """
        return self._get_property(
            "decrement", PatternFlowPfcPausePauseClass1Counter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowPfcPausePauseClass1MetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowPfcPausePauseClass1MetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowPfcPausePauseClass1MetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowPfcPausePauseClass1Counter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowPfcPausePauseClass1Counter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowPfcPausePauseClass1MetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 16,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 16,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=16):
        super(PatternFlowPfcPausePauseClass1MetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowPfcPausePauseClass1MetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowPfcPausePauseClass1MetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowPfcPausePauseClass1MetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowPfcPausePauseClass1MetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowPfcPausePauseClass1MetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowPfcPausePauseClass1MetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowPfcPausePauseClass1MetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowPfcPausePauseClass1MetricTag"
            )

    def metrictag(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowPfcPausePauseClass1MetricTagIter
        """Factory method that creates an instance of the PatternFlowPfcPausePauseClass1MetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowPfcPausePauseClass1MetricTagIter
        """
        item = PatternFlowPfcPausePauseClass1MetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowPfcPausePauseClass1MetricTag
        """Add method that creates and returns an instance of the PatternFlowPfcPausePauseClass1MetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowPfcPausePauseClass1MetricTag
        """
        item = PatternFlowPfcPausePauseClass1MetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowPfcPausePauseClass2(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 65535,
        },
        "increment": {"type": "PatternFlowPfcPausePauseClass2Counter"},
        "decrement": {"type": "PatternFlowPfcPausePauseClass2Counter"},
        "metric_tags": {"type": "PatternFlowPfcPausePauseClass2MetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowPfcPausePauseClass2, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowPfcPausePauseClass2Counter
        """Factory property that returns an instance of the PatternFlowPfcPausePauseClass2Counter class

        integer counter pattern

        Returns: PatternFlowPfcPausePauseClass2Counter
        """
        return self._get_property(
            "increment", PatternFlowPfcPausePauseClass2Counter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowPfcPausePauseClass2Counter
        """Factory property that returns an instance of the PatternFlowPfcPausePauseClass2Counter class

        integer counter pattern

        Returns: PatternFlowPfcPausePauseClass2Counter
        """
        return self._get_property(
            "decrement", PatternFlowPfcPausePauseClass2Counter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowPfcPausePauseClass2MetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowPfcPausePauseClass2MetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowPfcPausePauseClass2MetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowPfcPausePauseClass2Counter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowPfcPausePauseClass2Counter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowPfcPausePauseClass2MetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 16,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 16,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=16):
        super(PatternFlowPfcPausePauseClass2MetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowPfcPausePauseClass2MetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowPfcPausePauseClass2MetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowPfcPausePauseClass2MetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowPfcPausePauseClass2MetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowPfcPausePauseClass2MetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowPfcPausePauseClass2MetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowPfcPausePauseClass2MetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowPfcPausePauseClass2MetricTag"
            )

    def metrictag(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowPfcPausePauseClass2MetricTagIter
        """Factory method that creates an instance of the PatternFlowPfcPausePauseClass2MetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowPfcPausePauseClass2MetricTagIter
        """
        item = PatternFlowPfcPausePauseClass2MetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowPfcPausePauseClass2MetricTag
        """Add method that creates and returns an instance of the PatternFlowPfcPausePauseClass2MetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowPfcPausePauseClass2MetricTag
        """
        item = PatternFlowPfcPausePauseClass2MetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowPfcPausePauseClass3(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 65535,
        },
        "increment": {"type": "PatternFlowPfcPausePauseClass3Counter"},
        "decrement": {"type": "PatternFlowPfcPausePauseClass3Counter"},
        "metric_tags": {"type": "PatternFlowPfcPausePauseClass3MetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowPfcPausePauseClass3, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowPfcPausePauseClass3Counter
        """Factory property that returns an instance of the PatternFlowPfcPausePauseClass3Counter class

        integer counter pattern

        Returns: PatternFlowPfcPausePauseClass3Counter
        """
        return self._get_property(
            "increment", PatternFlowPfcPausePauseClass3Counter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowPfcPausePauseClass3Counter
        """Factory property that returns an instance of the PatternFlowPfcPausePauseClass3Counter class

        integer counter pattern

        Returns: PatternFlowPfcPausePauseClass3Counter
        """
        return self._get_property(
            "decrement", PatternFlowPfcPausePauseClass3Counter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowPfcPausePauseClass3MetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowPfcPausePauseClass3MetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowPfcPausePauseClass3MetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowPfcPausePauseClass3Counter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowPfcPausePauseClass3Counter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowPfcPausePauseClass3MetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 16,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 16,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=16):
        super(PatternFlowPfcPausePauseClass3MetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowPfcPausePauseClass3MetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowPfcPausePauseClass3MetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowPfcPausePauseClass3MetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowPfcPausePauseClass3MetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowPfcPausePauseClass3MetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowPfcPausePauseClass3MetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowPfcPausePauseClass3MetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowPfcPausePauseClass3MetricTag"
            )

    def metrictag(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowPfcPausePauseClass3MetricTagIter
        """Factory method that creates an instance of the PatternFlowPfcPausePauseClass3MetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowPfcPausePauseClass3MetricTagIter
        """
        item = PatternFlowPfcPausePauseClass3MetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowPfcPausePauseClass3MetricTag
        """Add method that creates and returns an instance of the PatternFlowPfcPausePauseClass3MetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowPfcPausePauseClass3MetricTag
        """
        item = PatternFlowPfcPausePauseClass3MetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowPfcPausePauseClass4(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 65535,
        },
        "increment": {"type": "PatternFlowPfcPausePauseClass4Counter"},
        "decrement": {"type": "PatternFlowPfcPausePauseClass4Counter"},
        "metric_tags": {"type": "PatternFlowPfcPausePauseClass4MetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowPfcPausePauseClass4, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowPfcPausePauseClass4Counter
        """Factory property that returns an instance of the PatternFlowPfcPausePauseClass4Counter class

        integer counter pattern

        Returns: PatternFlowPfcPausePauseClass4Counter
        """
        return self._get_property(
            "increment", PatternFlowPfcPausePauseClass4Counter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowPfcPausePauseClass4Counter
        """Factory property that returns an instance of the PatternFlowPfcPausePauseClass4Counter class

        integer counter pattern

        Returns: PatternFlowPfcPausePauseClass4Counter
        """
        return self._get_property(
            "decrement", PatternFlowPfcPausePauseClass4Counter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowPfcPausePauseClass4MetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowPfcPausePauseClass4MetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowPfcPausePauseClass4MetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowPfcPausePauseClass4Counter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowPfcPausePauseClass4Counter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowPfcPausePauseClass4MetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 16,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 16,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=16):
        super(PatternFlowPfcPausePauseClass4MetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowPfcPausePauseClass4MetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowPfcPausePauseClass4MetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowPfcPausePauseClass4MetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowPfcPausePauseClass4MetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowPfcPausePauseClass4MetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowPfcPausePauseClass4MetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowPfcPausePauseClass4MetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowPfcPausePauseClass4MetricTag"
            )

    def metrictag(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowPfcPausePauseClass4MetricTagIter
        """Factory method that creates an instance of the PatternFlowPfcPausePauseClass4MetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowPfcPausePauseClass4MetricTagIter
        """
        item = PatternFlowPfcPausePauseClass4MetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowPfcPausePauseClass4MetricTag
        """Add method that creates and returns an instance of the PatternFlowPfcPausePauseClass4MetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowPfcPausePauseClass4MetricTag
        """
        item = PatternFlowPfcPausePauseClass4MetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowPfcPausePauseClass5(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 65535,
        },
        "increment": {"type": "PatternFlowPfcPausePauseClass5Counter"},
        "decrement": {"type": "PatternFlowPfcPausePauseClass5Counter"},
        "metric_tags": {"type": "PatternFlowPfcPausePauseClass5MetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowPfcPausePauseClass5, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowPfcPausePauseClass5Counter
        """Factory property that returns an instance of the PatternFlowPfcPausePauseClass5Counter class

        integer counter pattern

        Returns: PatternFlowPfcPausePauseClass5Counter
        """
        return self._get_property(
            "increment", PatternFlowPfcPausePauseClass5Counter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowPfcPausePauseClass5Counter
        """Factory property that returns an instance of the PatternFlowPfcPausePauseClass5Counter class

        integer counter pattern

        Returns: PatternFlowPfcPausePauseClass5Counter
        """
        return self._get_property(
            "decrement", PatternFlowPfcPausePauseClass5Counter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowPfcPausePauseClass5MetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowPfcPausePauseClass5MetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowPfcPausePauseClass5MetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowPfcPausePauseClass5Counter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowPfcPausePauseClass5Counter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowPfcPausePauseClass5MetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 16,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 16,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=16):
        super(PatternFlowPfcPausePauseClass5MetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowPfcPausePauseClass5MetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowPfcPausePauseClass5MetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowPfcPausePauseClass5MetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowPfcPausePauseClass5MetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowPfcPausePauseClass5MetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowPfcPausePauseClass5MetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowPfcPausePauseClass5MetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowPfcPausePauseClass5MetricTag"
            )

    def metrictag(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowPfcPausePauseClass5MetricTagIter
        """Factory method that creates an instance of the PatternFlowPfcPausePauseClass5MetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowPfcPausePauseClass5MetricTagIter
        """
        item = PatternFlowPfcPausePauseClass5MetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowPfcPausePauseClass5MetricTag
        """Add method that creates and returns an instance of the PatternFlowPfcPausePauseClass5MetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowPfcPausePauseClass5MetricTag
        """
        item = PatternFlowPfcPausePauseClass5MetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowPfcPausePauseClass6(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 65535,
        },
        "increment": {"type": "PatternFlowPfcPausePauseClass6Counter"},
        "decrement": {"type": "PatternFlowPfcPausePauseClass6Counter"},
        "metric_tags": {"type": "PatternFlowPfcPausePauseClass6MetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowPfcPausePauseClass6, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowPfcPausePauseClass6Counter
        """Factory property that returns an instance of the PatternFlowPfcPausePauseClass6Counter class

        integer counter pattern

        Returns: PatternFlowPfcPausePauseClass6Counter
        """
        return self._get_property(
            "increment", PatternFlowPfcPausePauseClass6Counter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowPfcPausePauseClass6Counter
        """Factory property that returns an instance of the PatternFlowPfcPausePauseClass6Counter class

        integer counter pattern

        Returns: PatternFlowPfcPausePauseClass6Counter
        """
        return self._get_property(
            "decrement", PatternFlowPfcPausePauseClass6Counter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowPfcPausePauseClass6MetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowPfcPausePauseClass6MetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowPfcPausePauseClass6MetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowPfcPausePauseClass6Counter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowPfcPausePauseClass6Counter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowPfcPausePauseClass6MetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 16,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 16,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=16):
        super(PatternFlowPfcPausePauseClass6MetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowPfcPausePauseClass6MetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowPfcPausePauseClass6MetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowPfcPausePauseClass6MetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowPfcPausePauseClass6MetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowPfcPausePauseClass6MetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowPfcPausePauseClass6MetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowPfcPausePauseClass6MetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowPfcPausePauseClass6MetricTag"
            )

    def metrictag(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowPfcPausePauseClass6MetricTagIter
        """Factory method that creates an instance of the PatternFlowPfcPausePauseClass6MetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowPfcPausePauseClass6MetricTagIter
        """
        item = PatternFlowPfcPausePauseClass6MetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowPfcPausePauseClass6MetricTag
        """Add method that creates and returns an instance of the PatternFlowPfcPausePauseClass6MetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowPfcPausePauseClass6MetricTag
        """
        item = PatternFlowPfcPausePauseClass6MetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowPfcPausePauseClass7(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 65535,
        },
        "increment": {"type": "PatternFlowPfcPausePauseClass7Counter"},
        "decrement": {"type": "PatternFlowPfcPausePauseClass7Counter"},
        "metric_tags": {"type": "PatternFlowPfcPausePauseClass7MetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowPfcPausePauseClass7, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowPfcPausePauseClass7Counter
        """Factory property that returns an instance of the PatternFlowPfcPausePauseClass7Counter class

        integer counter pattern

        Returns: PatternFlowPfcPausePauseClass7Counter
        """
        return self._get_property(
            "increment", PatternFlowPfcPausePauseClass7Counter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowPfcPausePauseClass7Counter
        """Factory property that returns an instance of the PatternFlowPfcPausePauseClass7Counter class

        integer counter pattern

        Returns: PatternFlowPfcPausePauseClass7Counter
        """
        return self._get_property(
            "decrement", PatternFlowPfcPausePauseClass7Counter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowPfcPausePauseClass7MetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowPfcPausePauseClass7MetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowPfcPausePauseClass7MetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowPfcPausePauseClass7Counter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowPfcPausePauseClass7Counter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowPfcPausePauseClass7MetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 16,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 16,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=16):
        super(PatternFlowPfcPausePauseClass7MetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowPfcPausePauseClass7MetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowPfcPausePauseClass7MetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowPfcPausePauseClass7MetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowPfcPausePauseClass7MetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowPfcPausePauseClass7MetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowPfcPausePauseClass7MetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowPfcPausePauseClass7MetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowPfcPausePauseClass7MetricTag"
            )

    def metrictag(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowPfcPausePauseClass7MetricTagIter
        """Factory method that creates an instance of the PatternFlowPfcPausePauseClass7MetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowPfcPausePauseClass7MetricTagIter
        """
        item = PatternFlowPfcPausePauseClass7MetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowPfcPausePauseClass7MetricTag
        """Add method that creates and returns an instance of the PatternFlowPfcPausePauseClass7MetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowPfcPausePauseClass7MetricTag
        """
        item = PatternFlowPfcPausePauseClass7MetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class FlowEthernetPause(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "dst": {"type": "PatternFlowEthernetPauseDst"},
        "src": {"type": "PatternFlowEthernetPauseSrc"},
        "ether_type": {"type": "PatternFlowEthernetPauseEtherType"},
        "control_op_code": {"type": "PatternFlowEthernetPauseControlOpCode"},
        "time": {"type": "PatternFlowEthernetPauseTime"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None):
        super(FlowEthernetPause, self).__init__()
        self._parent = parent

    @property
    def dst(self):
        # type: () -> PatternFlowEthernetPauseDst
        """dst getter

        Destination MAC addressDestination MAC addressDestination MAC addressDestination MAC address

        Returns: PatternFlowEthernetPauseDst
        """
        return self._get_property("dst", PatternFlowEthernetPauseDst)

    @property
    def src(self):
        # type: () -> PatternFlowEthernetPauseSrc
        """src getter

        Source MAC addressSource MAC addressSource MAC addressSource MAC address

        Returns: PatternFlowEthernetPauseSrc
        """
        return self._get_property("src", PatternFlowEthernetPauseSrc)

    @property
    def ether_type(self):
        # type: () -> PatternFlowEthernetPauseEtherType
        """ether_type getter

        Ethernet typeEthernet typeEthernet typeEthernet type

        Returns: PatternFlowEthernetPauseEtherType
        """
        return self._get_property("ether_type", PatternFlowEthernetPauseEtherType)

    @property
    def control_op_code(self):
        # type: () -> PatternFlowEthernetPauseControlOpCode
        """control_op_code getter

        Control operation codeControl operation codeControl operation codeControl operation code

        Returns: PatternFlowEthernetPauseControlOpCode
        """
        return self._get_property(
            "control_op_code", PatternFlowEthernetPauseControlOpCode
        )

    @property
    def time(self):
        # type: () -> PatternFlowEthernetPauseTime
        """time getter

        TimeTimeTimeTime

        Returns: PatternFlowEthernetPauseTime
        """
        return self._get_property("time", PatternFlowEthernetPauseTime)


class PatternFlowEthernetPauseDst(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": str,
            "format": "mac",
        },
        "values": {
            "type": list,
            "itemtype": str,
            "itemformat": "mac",
        },
        "increment": {"type": "PatternFlowEthernetPauseDstCounter"},
        "decrement": {"type": "PatternFlowEthernetPauseDstCounter"},
        "metric_tags": {"type": "PatternFlowEthernetPauseDstMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": "01:80:c2:00:00:01",
        "values": ["01:80:c2:00:00:01"],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        choice=None,
        value="01:80:c2:00:00:01",
        values=["01:80:c2:00:00:01"],
    ):
        super(PatternFlowEthernetPauseDst, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowEthernetPauseDstCounter
        """Factory property that returns an instance of the PatternFlowEthernetPauseDstCounter class

        mac counter pattern

        Returns: PatternFlowEthernetPauseDstCounter
        """
        return self._get_property(
            "increment", PatternFlowEthernetPauseDstCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowEthernetPauseDstCounter
        """Factory property that returns an instance of the PatternFlowEthernetPauseDstCounter class

        mac counter pattern

        Returns: PatternFlowEthernetPauseDstCounter
        """
        return self._get_property(
            "decrement", PatternFlowEthernetPauseDstCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> str
        """value getter

        TBD

        Returns: str
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: str
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[str]
        """values getter

        TBD

        Returns: List[str]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[str]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowEthernetPauseDstMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowEthernetPauseDstMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowEthernetPauseDstMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowEthernetPauseDstCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": str,
            "format": "mac",
        },
        "step": {
            "type": str,
            "format": "mac",
        },
        "count": {
            "type": int,
            "format": "uint32",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": "01:80:c2:00:00:01",
        "step": "00:00:00:00:00:01",
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self, parent=None, start="01:80:c2:00:00:01", step="00:00:00:00:00:01", count=1
    ):
        super(PatternFlowEthernetPauseDstCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> str
        """start getter

        TBD

        Returns: str
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: str
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> str
        """step getter

        TBD

        Returns: str
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: str
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowEthernetPauseDstMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 47,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 48,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 48,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=48):
        super(PatternFlowEthernetPauseDstMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowEthernetPauseDstMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowEthernetPauseDstMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowEthernetPauseDstMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowEthernetPauseDstMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowEthernetPauseDstMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowEthernetPauseDstMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowEthernetPauseDstMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowEthernetPauseDstMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=48):
        # type: (str,int,int) -> PatternFlowEthernetPauseDstMetricTagIter
        """Factory method that creates an instance of the PatternFlowEthernetPauseDstMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowEthernetPauseDstMetricTagIter
        """
        item = PatternFlowEthernetPauseDstMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=48):
        # type: (str,int,int) -> PatternFlowEthernetPauseDstMetricTag
        """Add method that creates and returns an instance of the PatternFlowEthernetPauseDstMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowEthernetPauseDstMetricTag
        """
        item = PatternFlowEthernetPauseDstMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowEthernetPauseSrc(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": str,
            "format": "mac",
        },
        "values": {
            "type": list,
            "itemtype": str,
            "itemformat": "mac",
        },
        "increment": {"type": "PatternFlowEthernetPauseSrcCounter"},
        "decrement": {"type": "PatternFlowEthernetPauseSrcCounter"},
        "metric_tags": {"type": "PatternFlowEthernetPauseSrcMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": "00:00:00:00:00:00",
        "values": ["00:00:00:00:00:00"],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        choice=None,
        value="00:00:00:00:00:00",
        values=["00:00:00:00:00:00"],
    ):
        super(PatternFlowEthernetPauseSrc, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowEthernetPauseSrcCounter
        """Factory property that returns an instance of the PatternFlowEthernetPauseSrcCounter class

        mac counter pattern

        Returns: PatternFlowEthernetPauseSrcCounter
        """
        return self._get_property(
            "increment", PatternFlowEthernetPauseSrcCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowEthernetPauseSrcCounter
        """Factory property that returns an instance of the PatternFlowEthernetPauseSrcCounter class

        mac counter pattern

        Returns: PatternFlowEthernetPauseSrcCounter
        """
        return self._get_property(
            "decrement", PatternFlowEthernetPauseSrcCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> str
        """value getter

        TBD

        Returns: str
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: str
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[str]
        """values getter

        TBD

        Returns: List[str]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[str]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowEthernetPauseSrcMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowEthernetPauseSrcMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowEthernetPauseSrcMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowEthernetPauseSrcCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": str,
            "format": "mac",
        },
        "step": {
            "type": str,
            "format": "mac",
        },
        "count": {
            "type": int,
            "format": "uint32",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": "00:00:00:00:00:00",
        "step": "00:00:00:00:00:01",
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self, parent=None, start="00:00:00:00:00:00", step="00:00:00:00:00:01", count=1
    ):
        super(PatternFlowEthernetPauseSrcCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> str
        """start getter

        TBD

        Returns: str
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: str
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> str
        """step getter

        TBD

        Returns: str
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: str
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowEthernetPauseSrcMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 47,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 48,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 48,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=48):
        super(PatternFlowEthernetPauseSrcMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowEthernetPauseSrcMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowEthernetPauseSrcMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowEthernetPauseSrcMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowEthernetPauseSrcMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowEthernetPauseSrcMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowEthernetPauseSrcMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowEthernetPauseSrcMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowEthernetPauseSrcMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=48):
        # type: (str,int,int) -> PatternFlowEthernetPauseSrcMetricTagIter
        """Factory method that creates an instance of the PatternFlowEthernetPauseSrcMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowEthernetPauseSrcMetricTagIter
        """
        item = PatternFlowEthernetPauseSrcMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=48):
        # type: (str,int,int) -> PatternFlowEthernetPauseSrcMetricTag
        """Add method that creates and returns an instance of the PatternFlowEthernetPauseSrcMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowEthernetPauseSrcMetricTag
        """
        item = PatternFlowEthernetPauseSrcMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowEthernetPauseEtherType(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 65535,
        },
        "increment": {"type": "PatternFlowEthernetPauseEtherTypeCounter"},
        "decrement": {"type": "PatternFlowEthernetPauseEtherTypeCounter"},
        "metric_tags": {"type": "PatternFlowEthernetPauseEtherTypeMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 34824,
        "values": [34824],
    }  # type: Dict[str, Union(type)]

    FLOW_CONTROL = 34824  #

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=34824, values=[34824]):
        super(PatternFlowEthernetPauseEtherType, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowEthernetPauseEtherTypeCounter
        """Factory property that returns an instance of the PatternFlowEthernetPauseEtherTypeCounter class

        integer counter pattern

        Returns: PatternFlowEthernetPauseEtherTypeCounter
        """
        return self._get_property(
            "increment", PatternFlowEthernetPauseEtherTypeCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowEthernetPauseEtherTypeCounter
        """Factory property that returns an instance of the PatternFlowEthernetPauseEtherTypeCounter class

        integer counter pattern

        Returns: PatternFlowEthernetPauseEtherTypeCounter
        """
        return self._get_property(
            "decrement", PatternFlowEthernetPauseEtherTypeCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowEthernetPauseEtherTypeMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowEthernetPauseEtherTypeMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowEthernetPauseEtherTypeMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowEthernetPauseEtherTypeCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 34824,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    FLOW_CONTROL = 34824  #

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=34824, step=1, count=1):
        super(PatternFlowEthernetPauseEtherTypeCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowEthernetPauseEtherTypeMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 16,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 16,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=16):
        super(PatternFlowEthernetPauseEtherTypeMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowEthernetPauseEtherTypeMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowEthernetPauseEtherTypeMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowEthernetPauseEtherTypeMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowEthernetPauseEtherTypeMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowEthernetPauseEtherTypeMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowEthernetPauseEtherTypeMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowEthernetPauseEtherTypeMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowEthernetPauseEtherTypeMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowEthernetPauseEtherTypeMetricTagIter
        """Factory method that creates an instance of the PatternFlowEthernetPauseEtherTypeMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowEthernetPauseEtherTypeMetricTagIter
        """
        item = PatternFlowEthernetPauseEtherTypeMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowEthernetPauseEtherTypeMetricTag
        """Add method that creates and returns an instance of the PatternFlowEthernetPauseEtherTypeMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowEthernetPauseEtherTypeMetricTag
        """
        item = PatternFlowEthernetPauseEtherTypeMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowEthernetPauseControlOpCode(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 65535,
        },
        "increment": {"type": "PatternFlowEthernetPauseControlOpCodeCounter"},
        "decrement": {"type": "PatternFlowEthernetPauseControlOpCodeCounter"},
        "metric_tags": {"type": "PatternFlowEthernetPauseControlOpCodeMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 1,
        "values": [1],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=1, values=[1]):
        super(PatternFlowEthernetPauseControlOpCode, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowEthernetPauseControlOpCodeCounter
        """Factory property that returns an instance of the PatternFlowEthernetPauseControlOpCodeCounter class

        integer counter pattern

        Returns: PatternFlowEthernetPauseControlOpCodeCounter
        """
        return self._get_property(
            "increment", PatternFlowEthernetPauseControlOpCodeCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowEthernetPauseControlOpCodeCounter
        """Factory property that returns an instance of the PatternFlowEthernetPauseControlOpCodeCounter class

        integer counter pattern

        Returns: PatternFlowEthernetPauseControlOpCodeCounter
        """
        return self._get_property(
            "decrement", PatternFlowEthernetPauseControlOpCodeCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowEthernetPauseControlOpCodeMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowEthernetPauseControlOpCodeMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowEthernetPauseControlOpCodeMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowEthernetPauseControlOpCodeCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 1,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=1, step=1, count=1):
        super(PatternFlowEthernetPauseControlOpCodeCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowEthernetPauseControlOpCodeMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 16,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 16,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=16):
        super(PatternFlowEthernetPauseControlOpCodeMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowEthernetPauseControlOpCodeMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowEthernetPauseControlOpCodeMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowEthernetPauseControlOpCodeMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowEthernetPauseControlOpCodeMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowEthernetPauseControlOpCodeMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowEthernetPauseControlOpCodeMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowEthernetPauseControlOpCodeMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowEthernetPauseControlOpCodeMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowEthernetPauseControlOpCodeMetricTagIter
        """Factory method that creates an instance of the PatternFlowEthernetPauseControlOpCodeMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowEthernetPauseControlOpCodeMetricTagIter
        """
        item = PatternFlowEthernetPauseControlOpCodeMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowEthernetPauseControlOpCodeMetricTag
        """Add method that creates and returns an instance of the PatternFlowEthernetPauseControlOpCodeMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowEthernetPauseControlOpCodeMetricTag
        """
        item = PatternFlowEthernetPauseControlOpCodeMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowEthernetPauseTime(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 65535,
        },
        "increment": {"type": "PatternFlowEthernetPauseTimeCounter"},
        "decrement": {"type": "PatternFlowEthernetPauseTimeCounter"},
        "metric_tags": {"type": "PatternFlowEthernetPauseTimeMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowEthernetPauseTime, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowEthernetPauseTimeCounter
        """Factory property that returns an instance of the PatternFlowEthernetPauseTimeCounter class

        integer counter pattern

        Returns: PatternFlowEthernetPauseTimeCounter
        """
        return self._get_property(
            "increment", PatternFlowEthernetPauseTimeCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowEthernetPauseTimeCounter
        """Factory property that returns an instance of the PatternFlowEthernetPauseTimeCounter class

        integer counter pattern

        Returns: PatternFlowEthernetPauseTimeCounter
        """
        return self._get_property(
            "decrement", PatternFlowEthernetPauseTimeCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowEthernetPauseTimeMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowEthernetPauseTimeMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowEthernetPauseTimeMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowEthernetPauseTimeCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowEthernetPauseTimeCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowEthernetPauseTimeMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 16,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 16,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=16):
        super(PatternFlowEthernetPauseTimeMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowEthernetPauseTimeMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowEthernetPauseTimeMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowEthernetPauseTimeMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowEthernetPauseTimeMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowEthernetPauseTimeMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowEthernetPauseTimeMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowEthernetPauseTimeMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowEthernetPauseTimeMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowEthernetPauseTimeMetricTagIter
        """Factory method that creates an instance of the PatternFlowEthernetPauseTimeMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowEthernetPauseTimeMetricTagIter
        """
        item = PatternFlowEthernetPauseTimeMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowEthernetPauseTimeMetricTag
        """Add method that creates and returns an instance of the PatternFlowEthernetPauseTimeMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowEthernetPauseTimeMetricTag
        """
        item = PatternFlowEthernetPauseTimeMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class FlowTcp(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "src_port": {"type": "PatternFlowTcpSrcPort"},
        "dst_port": {"type": "PatternFlowTcpDstPort"},
        "seq_num": {"type": "PatternFlowTcpSeqNum"},
        "ack_num": {"type": "PatternFlowTcpAckNum"},
        "data_offset": {"type": "PatternFlowTcpDataOffset"},
        "ecn_ns": {"type": "PatternFlowTcpEcnNs"},
        "ecn_cwr": {"type": "PatternFlowTcpEcnCwr"},
        "ecn_echo": {"type": "PatternFlowTcpEcnEcho"},
        "ctl_urg": {"type": "PatternFlowTcpCtlUrg"},
        "ctl_ack": {"type": "PatternFlowTcpCtlAck"},
        "ctl_psh": {"type": "PatternFlowTcpCtlPsh"},
        "ctl_rst": {"type": "PatternFlowTcpCtlRst"},
        "ctl_syn": {"type": "PatternFlowTcpCtlSyn"},
        "ctl_fin": {"type": "PatternFlowTcpCtlFin"},
        "window": {"type": "PatternFlowTcpWindow"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None):
        super(FlowTcp, self).__init__()
        self._parent = parent

    @property
    def src_port(self):
        # type: () -> PatternFlowTcpSrcPort
        """src_port getter

        Source portSource portSource portSource port

        Returns: PatternFlowTcpSrcPort
        """
        return self._get_property("src_port", PatternFlowTcpSrcPort)

    @property
    def dst_port(self):
        # type: () -> PatternFlowTcpDstPort
        """dst_port getter

        Destination portDestination portDestination portDestination port

        Returns: PatternFlowTcpDstPort
        """
        return self._get_property("dst_port", PatternFlowTcpDstPort)

    @property
    def seq_num(self):
        # type: () -> PatternFlowTcpSeqNum
        """seq_num getter

        Sequence numberSequence numberSequence numberSequence number

        Returns: PatternFlowTcpSeqNum
        """
        return self._get_property("seq_num", PatternFlowTcpSeqNum)

    @property
    def ack_num(self):
        # type: () -> PatternFlowTcpAckNum
        """ack_num getter

        Acknowledgement numberAcknowledgement numberAcknowledgement numberAcknowledgement number

        Returns: PatternFlowTcpAckNum
        """
        return self._get_property("ack_num", PatternFlowTcpAckNum)

    @property
    def data_offset(self):
        # type: () -> PatternFlowTcpDataOffset
        """data_offset getter

        The number of 32 bit words in the TCP header. This indicates where the data begins.The number of 32 bit words in the TCP header. This indicates where the data begins.The number of 32 bit words in the TCP header. This indicates where the data begins.The number of 32 bit words in the TCP header. This indicates where the data begins.

        Returns: PatternFlowTcpDataOffset
        """
        return self._get_property("data_offset", PatternFlowTcpDataOffset)

    @property
    def ecn_ns(self):
        # type: () -> PatternFlowTcpEcnNs
        """ecn_ns getter

        Explicit congestion notification, concealment protection.Explicit congestion notification, concealment protection.Explicit congestion notification, concealment protection.Explicit congestion notification, concealment protection.

        Returns: PatternFlowTcpEcnNs
        """
        return self._get_property("ecn_ns", PatternFlowTcpEcnNs)

    @property
    def ecn_cwr(self):
        # type: () -> PatternFlowTcpEcnCwr
        """ecn_cwr getter

        Explicit congestion notification, congestion window reduced.Explicit congestion notification, congestion window reduced.Explicit congestion notification, congestion window reduced.Explicit congestion notification, congestion window reduced.

        Returns: PatternFlowTcpEcnCwr
        """
        return self._get_property("ecn_cwr", PatternFlowTcpEcnCwr)

    @property
    def ecn_echo(self):
        # type: () -> PatternFlowTcpEcnEcho
        """ecn_echo getter

        Explicit congestion notification, echo. indicates the peer is ecn capable. indicates that packet with ipv4.ecn 11 in the ip header was received during normal transmission.Explicit congestion notification, echo. indicates the peer is ecn capable. indicates that packet with ipv4.ecn 11 in the ip header was received during normal transmission.Explicit congestion notification, echo. indicates the peer is ecn capable. indicates that packet with ipv4.ecn 11 in the ip header was received during normal transmission.Explicit congestion notification, echo. indicates the peer is ecn capable. indicates that packet with ipv4.ecn 11 in the ip header was received during normal transmission.

        Returns: PatternFlowTcpEcnEcho
        """
        return self._get_property("ecn_echo", PatternFlowTcpEcnEcho)

    @property
    def ctl_urg(self):
        # type: () -> PatternFlowTcpCtlUrg
        """ctl_urg getter

        A value of indicates that the urgent pointer field is significant.A value of indicates that the urgent pointer field is significant.A value of indicates that the urgent pointer field is significant.A value of indicates that the urgent pointer field is significant.

        Returns: PatternFlowTcpCtlUrg
        """
        return self._get_property("ctl_urg", PatternFlowTcpCtlUrg)

    @property
    def ctl_ack(self):
        # type: () -> PatternFlowTcpCtlAck
        """ctl_ack getter

        A value of indicates that the ackknowledgment field is significant.A value of indicates that the ackknowledgment field is significant.A value of indicates that the ackknowledgment field is significant.A value of indicates that the ackknowledgment field is significant.

        Returns: PatternFlowTcpCtlAck
        """
        return self._get_property("ctl_ack", PatternFlowTcpCtlAck)

    @property
    def ctl_psh(self):
        # type: () -> PatternFlowTcpCtlPsh
        """ctl_psh getter

        Asks to push the buffered data to the receiving application. Asks to push the buffered data to the receiving application. Asks to push the buffered data to the receiving application. Asks to push the buffered data to the receiving application.

        Returns: PatternFlowTcpCtlPsh
        """
        return self._get_property("ctl_psh", PatternFlowTcpCtlPsh)

    @property
    def ctl_rst(self):
        # type: () -> PatternFlowTcpCtlRst
        """ctl_rst getter

        Reset the connection. Reset the connection. Reset the connection. Reset the connection.

        Returns: PatternFlowTcpCtlRst
        """
        return self._get_property("ctl_rst", PatternFlowTcpCtlRst)

    @property
    def ctl_syn(self):
        # type: () -> PatternFlowTcpCtlSyn
        """ctl_syn getter

        Synchronize sequenece numbers. Synchronize sequenece numbers. Synchronize sequenece numbers. Synchronize sequenece numbers.

        Returns: PatternFlowTcpCtlSyn
        """
        return self._get_property("ctl_syn", PatternFlowTcpCtlSyn)

    @property
    def ctl_fin(self):
        # type: () -> PatternFlowTcpCtlFin
        """ctl_fin getter

        Last packet from the sender. Last packet from the sender. Last packet from the sender. Last packet from the sender.

        Returns: PatternFlowTcpCtlFin
        """
        return self._get_property("ctl_fin", PatternFlowTcpCtlFin)

    @property
    def window(self):
        # type: () -> PatternFlowTcpWindow
        """window getter

        Tcp connection window.Tcp connection window.Tcp connection window.Tcp connection window.

        Returns: PatternFlowTcpWindow
        """
        return self._get_property("window", PatternFlowTcpWindow)


class PatternFlowTcpSrcPort(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 65535,
        },
        "increment": {"type": "PatternFlowTcpSrcPortCounter"},
        "decrement": {"type": "PatternFlowTcpSrcPortCounter"},
        "metric_tags": {"type": "PatternFlowTcpSrcPortMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowTcpSrcPort, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowTcpSrcPortCounter
        """Factory property that returns an instance of the PatternFlowTcpSrcPortCounter class

        integer counter pattern

        Returns: PatternFlowTcpSrcPortCounter
        """
        return self._get_property(
            "increment", PatternFlowTcpSrcPortCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowTcpSrcPortCounter
        """Factory property that returns an instance of the PatternFlowTcpSrcPortCounter class

        integer counter pattern

        Returns: PatternFlowTcpSrcPortCounter
        """
        return self._get_property(
            "decrement", PatternFlowTcpSrcPortCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowTcpSrcPortMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowTcpSrcPortMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowTcpSrcPortMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowTcpSrcPortCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowTcpSrcPortCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowTcpSrcPortMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 16,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 16,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=16):
        super(PatternFlowTcpSrcPortMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowTcpSrcPortMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowTcpSrcPortMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowTcpSrcPortMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowTcpSrcPortMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowTcpSrcPortMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowTcpSrcPortMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowTcpSrcPortMetricTag):
            raise Exception("Item is not an instance of PatternFlowTcpSrcPortMetricTag")

    def metrictag(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowTcpSrcPortMetricTagIter
        """Factory method that creates an instance of the PatternFlowTcpSrcPortMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowTcpSrcPortMetricTagIter
        """
        item = PatternFlowTcpSrcPortMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowTcpSrcPortMetricTag
        """Add method that creates and returns an instance of the PatternFlowTcpSrcPortMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowTcpSrcPortMetricTag
        """
        item = PatternFlowTcpSrcPortMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowTcpDstPort(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 65535,
        },
        "increment": {"type": "PatternFlowTcpDstPortCounter"},
        "decrement": {"type": "PatternFlowTcpDstPortCounter"},
        "metric_tags": {"type": "PatternFlowTcpDstPortMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowTcpDstPort, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowTcpDstPortCounter
        """Factory property that returns an instance of the PatternFlowTcpDstPortCounter class

        integer counter pattern

        Returns: PatternFlowTcpDstPortCounter
        """
        return self._get_property(
            "increment", PatternFlowTcpDstPortCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowTcpDstPortCounter
        """Factory property that returns an instance of the PatternFlowTcpDstPortCounter class

        integer counter pattern

        Returns: PatternFlowTcpDstPortCounter
        """
        return self._get_property(
            "decrement", PatternFlowTcpDstPortCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowTcpDstPortMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowTcpDstPortMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowTcpDstPortMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowTcpDstPortCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowTcpDstPortCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowTcpDstPortMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 16,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 16,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=16):
        super(PatternFlowTcpDstPortMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowTcpDstPortMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowTcpDstPortMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowTcpDstPortMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowTcpDstPortMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowTcpDstPortMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowTcpDstPortMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowTcpDstPortMetricTag):
            raise Exception("Item is not an instance of PatternFlowTcpDstPortMetricTag")

    def metrictag(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowTcpDstPortMetricTagIter
        """Factory method that creates an instance of the PatternFlowTcpDstPortMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowTcpDstPortMetricTagIter
        """
        item = PatternFlowTcpDstPortMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowTcpDstPortMetricTag
        """Add method that creates and returns an instance of the PatternFlowTcpDstPortMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowTcpDstPortMetricTag
        """
        item = PatternFlowTcpDstPortMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowTcpSeqNum(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
        },
        "increment": {"type": "PatternFlowTcpSeqNumCounter"},
        "decrement": {"type": "PatternFlowTcpSeqNumCounter"},
        "metric_tags": {"type": "PatternFlowTcpSeqNumMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowTcpSeqNum, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowTcpSeqNumCounter
        """Factory property that returns an instance of the PatternFlowTcpSeqNumCounter class

        integer counter pattern

        Returns: PatternFlowTcpSeqNumCounter
        """
        return self._get_property(
            "increment", PatternFlowTcpSeqNumCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowTcpSeqNumCounter
        """Factory property that returns an instance of the PatternFlowTcpSeqNumCounter class

        integer counter pattern

        Returns: PatternFlowTcpSeqNumCounter
        """
        return self._get_property(
            "decrement", PatternFlowTcpSeqNumCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowTcpSeqNumMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowTcpSeqNumMetricTagIter
        """
        return self._get_property(
            "metric_tags", PatternFlowTcpSeqNumMetricTagIter, self._parent, self._choice
        )


class PatternFlowTcpSeqNumCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
        },
        "step": {
            "type": int,
            "format": "uint32",
        },
        "count": {
            "type": int,
            "format": "uint32",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowTcpSeqNumCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowTcpSeqNumMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 31,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 32,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 32,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=32):
        super(PatternFlowTcpSeqNumMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowTcpSeqNumMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowTcpSeqNumMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowTcpSeqNumMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowTcpSeqNumMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowTcpSeqNumMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowTcpSeqNumMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowTcpSeqNumMetricTag):
            raise Exception("Item is not an instance of PatternFlowTcpSeqNumMetricTag")

    def metrictag(self, name=None, offset=0, length=32):
        # type: (str,int,int) -> PatternFlowTcpSeqNumMetricTagIter
        """Factory method that creates an instance of the PatternFlowTcpSeqNumMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowTcpSeqNumMetricTagIter
        """
        item = PatternFlowTcpSeqNumMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=32):
        # type: (str,int,int) -> PatternFlowTcpSeqNumMetricTag
        """Add method that creates and returns an instance of the PatternFlowTcpSeqNumMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowTcpSeqNumMetricTag
        """
        item = PatternFlowTcpSeqNumMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowTcpAckNum(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
        },
        "increment": {"type": "PatternFlowTcpAckNumCounter"},
        "decrement": {"type": "PatternFlowTcpAckNumCounter"},
        "metric_tags": {"type": "PatternFlowTcpAckNumMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowTcpAckNum, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowTcpAckNumCounter
        """Factory property that returns an instance of the PatternFlowTcpAckNumCounter class

        integer counter pattern

        Returns: PatternFlowTcpAckNumCounter
        """
        return self._get_property(
            "increment", PatternFlowTcpAckNumCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowTcpAckNumCounter
        """Factory property that returns an instance of the PatternFlowTcpAckNumCounter class

        integer counter pattern

        Returns: PatternFlowTcpAckNumCounter
        """
        return self._get_property(
            "decrement", PatternFlowTcpAckNumCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowTcpAckNumMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowTcpAckNumMetricTagIter
        """
        return self._get_property(
            "metric_tags", PatternFlowTcpAckNumMetricTagIter, self._parent, self._choice
        )


class PatternFlowTcpAckNumCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
        },
        "step": {
            "type": int,
            "format": "uint32",
        },
        "count": {
            "type": int,
            "format": "uint32",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowTcpAckNumCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowTcpAckNumMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 31,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 32,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 32,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=32):
        super(PatternFlowTcpAckNumMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowTcpAckNumMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowTcpAckNumMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowTcpAckNumMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowTcpAckNumMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowTcpAckNumMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowTcpAckNumMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowTcpAckNumMetricTag):
            raise Exception("Item is not an instance of PatternFlowTcpAckNumMetricTag")

    def metrictag(self, name=None, offset=0, length=32):
        # type: (str,int,int) -> PatternFlowTcpAckNumMetricTagIter
        """Factory method that creates an instance of the PatternFlowTcpAckNumMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowTcpAckNumMetricTagIter
        """
        item = PatternFlowTcpAckNumMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=32):
        # type: (str,int,int) -> PatternFlowTcpAckNumMetricTag
        """Add method that creates and returns an instance of the PatternFlowTcpAckNumMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowTcpAckNumMetricTag
        """
        item = PatternFlowTcpAckNumMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowTcpDataOffset(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 15,
        },
        "increment": {"type": "PatternFlowTcpDataOffsetCounter"},
        "decrement": {"type": "PatternFlowTcpDataOffsetCounter"},
        "metric_tags": {"type": "PatternFlowTcpDataOffsetMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowTcpDataOffset, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowTcpDataOffsetCounter
        """Factory property that returns an instance of the PatternFlowTcpDataOffsetCounter class

        integer counter pattern

        Returns: PatternFlowTcpDataOffsetCounter
        """
        return self._get_property(
            "increment", PatternFlowTcpDataOffsetCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowTcpDataOffsetCounter
        """Factory property that returns an instance of the PatternFlowTcpDataOffsetCounter class

        integer counter pattern

        Returns: PatternFlowTcpDataOffsetCounter
        """
        return self._get_property(
            "decrement", PatternFlowTcpDataOffsetCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowTcpDataOffsetMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowTcpDataOffsetMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowTcpDataOffsetMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowTcpDataOffsetCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowTcpDataOffsetCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowTcpDataOffsetMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 3,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 4,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 4,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=4):
        super(PatternFlowTcpDataOffsetMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowTcpDataOffsetMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowTcpDataOffsetMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowTcpDataOffsetMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowTcpDataOffsetMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowTcpDataOffsetMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowTcpDataOffsetMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowTcpDataOffsetMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowTcpDataOffsetMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=4):
        # type: (str,int,int) -> PatternFlowTcpDataOffsetMetricTagIter
        """Factory method that creates an instance of the PatternFlowTcpDataOffsetMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowTcpDataOffsetMetricTagIter
        """
        item = PatternFlowTcpDataOffsetMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=4):
        # type: (str,int,int) -> PatternFlowTcpDataOffsetMetricTag
        """Add method that creates and returns an instance of the PatternFlowTcpDataOffsetMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowTcpDataOffsetMetricTag
        """
        item = PatternFlowTcpDataOffsetMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowTcpEcnNs(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 1,
        },
        "increment": {"type": "PatternFlowTcpEcnNsCounter"},
        "decrement": {"type": "PatternFlowTcpEcnNsCounter"},
        "metric_tags": {"type": "PatternFlowTcpEcnNsMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowTcpEcnNs, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowTcpEcnNsCounter
        """Factory property that returns an instance of the PatternFlowTcpEcnNsCounter class

        integer counter pattern

        Returns: PatternFlowTcpEcnNsCounter
        """
        return self._get_property(
            "increment", PatternFlowTcpEcnNsCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowTcpEcnNsCounter
        """Factory property that returns an instance of the PatternFlowTcpEcnNsCounter class

        integer counter pattern

        Returns: PatternFlowTcpEcnNsCounter
        """
        return self._get_property(
            "decrement", PatternFlowTcpEcnNsCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowTcpEcnNsMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowTcpEcnNsMetricTagIter
        """
        return self._get_property(
            "metric_tags", PatternFlowTcpEcnNsMetricTagIter, self._parent, self._choice
        )


class PatternFlowTcpEcnNsCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowTcpEcnNsCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowTcpEcnNsMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 0,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=1):
        super(PatternFlowTcpEcnNsMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowTcpEcnNsMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowTcpEcnNsMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowTcpEcnNsMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowTcpEcnNsMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowTcpEcnNsMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowTcpEcnNsMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowTcpEcnNsMetricTag):
            raise Exception("Item is not an instance of PatternFlowTcpEcnNsMetricTag")

    def metrictag(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowTcpEcnNsMetricTagIter
        """Factory method that creates an instance of the PatternFlowTcpEcnNsMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowTcpEcnNsMetricTagIter
        """
        item = PatternFlowTcpEcnNsMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowTcpEcnNsMetricTag
        """Add method that creates and returns an instance of the PatternFlowTcpEcnNsMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowTcpEcnNsMetricTag
        """
        item = PatternFlowTcpEcnNsMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowTcpEcnCwr(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 1,
        },
        "increment": {"type": "PatternFlowTcpEcnCwrCounter"},
        "decrement": {"type": "PatternFlowTcpEcnCwrCounter"},
        "metric_tags": {"type": "PatternFlowTcpEcnCwrMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowTcpEcnCwr, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowTcpEcnCwrCounter
        """Factory property that returns an instance of the PatternFlowTcpEcnCwrCounter class

        integer counter pattern

        Returns: PatternFlowTcpEcnCwrCounter
        """
        return self._get_property(
            "increment", PatternFlowTcpEcnCwrCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowTcpEcnCwrCounter
        """Factory property that returns an instance of the PatternFlowTcpEcnCwrCounter class

        integer counter pattern

        Returns: PatternFlowTcpEcnCwrCounter
        """
        return self._get_property(
            "decrement", PatternFlowTcpEcnCwrCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowTcpEcnCwrMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowTcpEcnCwrMetricTagIter
        """
        return self._get_property(
            "metric_tags", PatternFlowTcpEcnCwrMetricTagIter, self._parent, self._choice
        )


class PatternFlowTcpEcnCwrCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowTcpEcnCwrCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowTcpEcnCwrMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 0,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=1):
        super(PatternFlowTcpEcnCwrMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowTcpEcnCwrMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowTcpEcnCwrMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowTcpEcnCwrMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowTcpEcnCwrMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowTcpEcnCwrMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowTcpEcnCwrMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowTcpEcnCwrMetricTag):
            raise Exception("Item is not an instance of PatternFlowTcpEcnCwrMetricTag")

    def metrictag(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowTcpEcnCwrMetricTagIter
        """Factory method that creates an instance of the PatternFlowTcpEcnCwrMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowTcpEcnCwrMetricTagIter
        """
        item = PatternFlowTcpEcnCwrMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowTcpEcnCwrMetricTag
        """Add method that creates and returns an instance of the PatternFlowTcpEcnCwrMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowTcpEcnCwrMetricTag
        """
        item = PatternFlowTcpEcnCwrMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowTcpEcnEcho(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 1,
        },
        "increment": {"type": "PatternFlowTcpEcnEchoCounter"},
        "decrement": {"type": "PatternFlowTcpEcnEchoCounter"},
        "metric_tags": {"type": "PatternFlowTcpEcnEchoMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowTcpEcnEcho, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowTcpEcnEchoCounter
        """Factory property that returns an instance of the PatternFlowTcpEcnEchoCounter class

        integer counter pattern

        Returns: PatternFlowTcpEcnEchoCounter
        """
        return self._get_property(
            "increment", PatternFlowTcpEcnEchoCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowTcpEcnEchoCounter
        """Factory property that returns an instance of the PatternFlowTcpEcnEchoCounter class

        integer counter pattern

        Returns: PatternFlowTcpEcnEchoCounter
        """
        return self._get_property(
            "decrement", PatternFlowTcpEcnEchoCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowTcpEcnEchoMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowTcpEcnEchoMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowTcpEcnEchoMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowTcpEcnEchoCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowTcpEcnEchoCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowTcpEcnEchoMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 0,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=1):
        super(PatternFlowTcpEcnEchoMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowTcpEcnEchoMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowTcpEcnEchoMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowTcpEcnEchoMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowTcpEcnEchoMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowTcpEcnEchoMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowTcpEcnEchoMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowTcpEcnEchoMetricTag):
            raise Exception("Item is not an instance of PatternFlowTcpEcnEchoMetricTag")

    def metrictag(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowTcpEcnEchoMetricTagIter
        """Factory method that creates an instance of the PatternFlowTcpEcnEchoMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowTcpEcnEchoMetricTagIter
        """
        item = PatternFlowTcpEcnEchoMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowTcpEcnEchoMetricTag
        """Add method that creates and returns an instance of the PatternFlowTcpEcnEchoMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowTcpEcnEchoMetricTag
        """
        item = PatternFlowTcpEcnEchoMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowTcpCtlUrg(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 1,
        },
        "increment": {"type": "PatternFlowTcpCtlUrgCounter"},
        "decrement": {"type": "PatternFlowTcpCtlUrgCounter"},
        "metric_tags": {"type": "PatternFlowTcpCtlUrgMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowTcpCtlUrg, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowTcpCtlUrgCounter
        """Factory property that returns an instance of the PatternFlowTcpCtlUrgCounter class

        integer counter pattern

        Returns: PatternFlowTcpCtlUrgCounter
        """
        return self._get_property(
            "increment", PatternFlowTcpCtlUrgCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowTcpCtlUrgCounter
        """Factory property that returns an instance of the PatternFlowTcpCtlUrgCounter class

        integer counter pattern

        Returns: PatternFlowTcpCtlUrgCounter
        """
        return self._get_property(
            "decrement", PatternFlowTcpCtlUrgCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowTcpCtlUrgMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowTcpCtlUrgMetricTagIter
        """
        return self._get_property(
            "metric_tags", PatternFlowTcpCtlUrgMetricTagIter, self._parent, self._choice
        )


class PatternFlowTcpCtlUrgCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowTcpCtlUrgCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowTcpCtlUrgMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 0,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=1):
        super(PatternFlowTcpCtlUrgMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowTcpCtlUrgMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowTcpCtlUrgMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowTcpCtlUrgMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowTcpCtlUrgMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowTcpCtlUrgMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowTcpCtlUrgMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowTcpCtlUrgMetricTag):
            raise Exception("Item is not an instance of PatternFlowTcpCtlUrgMetricTag")

    def metrictag(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowTcpCtlUrgMetricTagIter
        """Factory method that creates an instance of the PatternFlowTcpCtlUrgMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowTcpCtlUrgMetricTagIter
        """
        item = PatternFlowTcpCtlUrgMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowTcpCtlUrgMetricTag
        """Add method that creates and returns an instance of the PatternFlowTcpCtlUrgMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowTcpCtlUrgMetricTag
        """
        item = PatternFlowTcpCtlUrgMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowTcpCtlAck(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 1,
        },
        "increment": {"type": "PatternFlowTcpCtlAckCounter"},
        "decrement": {"type": "PatternFlowTcpCtlAckCounter"},
        "metric_tags": {"type": "PatternFlowTcpCtlAckMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowTcpCtlAck, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowTcpCtlAckCounter
        """Factory property that returns an instance of the PatternFlowTcpCtlAckCounter class

        integer counter pattern

        Returns: PatternFlowTcpCtlAckCounter
        """
        return self._get_property(
            "increment", PatternFlowTcpCtlAckCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowTcpCtlAckCounter
        """Factory property that returns an instance of the PatternFlowTcpCtlAckCounter class

        integer counter pattern

        Returns: PatternFlowTcpCtlAckCounter
        """
        return self._get_property(
            "decrement", PatternFlowTcpCtlAckCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowTcpCtlAckMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowTcpCtlAckMetricTagIter
        """
        return self._get_property(
            "metric_tags", PatternFlowTcpCtlAckMetricTagIter, self._parent, self._choice
        )


class PatternFlowTcpCtlAckCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowTcpCtlAckCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowTcpCtlAckMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 0,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=1):
        super(PatternFlowTcpCtlAckMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowTcpCtlAckMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowTcpCtlAckMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowTcpCtlAckMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowTcpCtlAckMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowTcpCtlAckMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowTcpCtlAckMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowTcpCtlAckMetricTag):
            raise Exception("Item is not an instance of PatternFlowTcpCtlAckMetricTag")

    def metrictag(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowTcpCtlAckMetricTagIter
        """Factory method that creates an instance of the PatternFlowTcpCtlAckMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowTcpCtlAckMetricTagIter
        """
        item = PatternFlowTcpCtlAckMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowTcpCtlAckMetricTag
        """Add method that creates and returns an instance of the PatternFlowTcpCtlAckMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowTcpCtlAckMetricTag
        """
        item = PatternFlowTcpCtlAckMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowTcpCtlPsh(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 1,
        },
        "increment": {"type": "PatternFlowTcpCtlPshCounter"},
        "decrement": {"type": "PatternFlowTcpCtlPshCounter"},
        "metric_tags": {"type": "PatternFlowTcpCtlPshMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowTcpCtlPsh, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowTcpCtlPshCounter
        """Factory property that returns an instance of the PatternFlowTcpCtlPshCounter class

        integer counter pattern

        Returns: PatternFlowTcpCtlPshCounter
        """
        return self._get_property(
            "increment", PatternFlowTcpCtlPshCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowTcpCtlPshCounter
        """Factory property that returns an instance of the PatternFlowTcpCtlPshCounter class

        integer counter pattern

        Returns: PatternFlowTcpCtlPshCounter
        """
        return self._get_property(
            "decrement", PatternFlowTcpCtlPshCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowTcpCtlPshMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowTcpCtlPshMetricTagIter
        """
        return self._get_property(
            "metric_tags", PatternFlowTcpCtlPshMetricTagIter, self._parent, self._choice
        )


class PatternFlowTcpCtlPshCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowTcpCtlPshCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowTcpCtlPshMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 0,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=1):
        super(PatternFlowTcpCtlPshMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowTcpCtlPshMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowTcpCtlPshMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowTcpCtlPshMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowTcpCtlPshMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowTcpCtlPshMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowTcpCtlPshMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowTcpCtlPshMetricTag):
            raise Exception("Item is not an instance of PatternFlowTcpCtlPshMetricTag")

    def metrictag(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowTcpCtlPshMetricTagIter
        """Factory method that creates an instance of the PatternFlowTcpCtlPshMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowTcpCtlPshMetricTagIter
        """
        item = PatternFlowTcpCtlPshMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowTcpCtlPshMetricTag
        """Add method that creates and returns an instance of the PatternFlowTcpCtlPshMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowTcpCtlPshMetricTag
        """
        item = PatternFlowTcpCtlPshMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowTcpCtlRst(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 1,
        },
        "increment": {"type": "PatternFlowTcpCtlRstCounter"},
        "decrement": {"type": "PatternFlowTcpCtlRstCounter"},
        "metric_tags": {"type": "PatternFlowTcpCtlRstMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowTcpCtlRst, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowTcpCtlRstCounter
        """Factory property that returns an instance of the PatternFlowTcpCtlRstCounter class

        integer counter pattern

        Returns: PatternFlowTcpCtlRstCounter
        """
        return self._get_property(
            "increment", PatternFlowTcpCtlRstCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowTcpCtlRstCounter
        """Factory property that returns an instance of the PatternFlowTcpCtlRstCounter class

        integer counter pattern

        Returns: PatternFlowTcpCtlRstCounter
        """
        return self._get_property(
            "decrement", PatternFlowTcpCtlRstCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowTcpCtlRstMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowTcpCtlRstMetricTagIter
        """
        return self._get_property(
            "metric_tags", PatternFlowTcpCtlRstMetricTagIter, self._parent, self._choice
        )


class PatternFlowTcpCtlRstCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowTcpCtlRstCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowTcpCtlRstMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 0,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=1):
        super(PatternFlowTcpCtlRstMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowTcpCtlRstMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowTcpCtlRstMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowTcpCtlRstMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowTcpCtlRstMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowTcpCtlRstMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowTcpCtlRstMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowTcpCtlRstMetricTag):
            raise Exception("Item is not an instance of PatternFlowTcpCtlRstMetricTag")

    def metrictag(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowTcpCtlRstMetricTagIter
        """Factory method that creates an instance of the PatternFlowTcpCtlRstMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowTcpCtlRstMetricTagIter
        """
        item = PatternFlowTcpCtlRstMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowTcpCtlRstMetricTag
        """Add method that creates and returns an instance of the PatternFlowTcpCtlRstMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowTcpCtlRstMetricTag
        """
        item = PatternFlowTcpCtlRstMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowTcpCtlSyn(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 1,
        },
        "increment": {"type": "PatternFlowTcpCtlSynCounter"},
        "decrement": {"type": "PatternFlowTcpCtlSynCounter"},
        "metric_tags": {"type": "PatternFlowTcpCtlSynMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowTcpCtlSyn, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowTcpCtlSynCounter
        """Factory property that returns an instance of the PatternFlowTcpCtlSynCounter class

        integer counter pattern

        Returns: PatternFlowTcpCtlSynCounter
        """
        return self._get_property(
            "increment", PatternFlowTcpCtlSynCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowTcpCtlSynCounter
        """Factory property that returns an instance of the PatternFlowTcpCtlSynCounter class

        integer counter pattern

        Returns: PatternFlowTcpCtlSynCounter
        """
        return self._get_property(
            "decrement", PatternFlowTcpCtlSynCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowTcpCtlSynMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowTcpCtlSynMetricTagIter
        """
        return self._get_property(
            "metric_tags", PatternFlowTcpCtlSynMetricTagIter, self._parent, self._choice
        )


class PatternFlowTcpCtlSynCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowTcpCtlSynCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowTcpCtlSynMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 0,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=1):
        super(PatternFlowTcpCtlSynMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowTcpCtlSynMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowTcpCtlSynMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowTcpCtlSynMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowTcpCtlSynMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowTcpCtlSynMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowTcpCtlSynMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowTcpCtlSynMetricTag):
            raise Exception("Item is not an instance of PatternFlowTcpCtlSynMetricTag")

    def metrictag(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowTcpCtlSynMetricTagIter
        """Factory method that creates an instance of the PatternFlowTcpCtlSynMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowTcpCtlSynMetricTagIter
        """
        item = PatternFlowTcpCtlSynMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowTcpCtlSynMetricTag
        """Add method that creates and returns an instance of the PatternFlowTcpCtlSynMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowTcpCtlSynMetricTag
        """
        item = PatternFlowTcpCtlSynMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowTcpCtlFin(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 1,
        },
        "increment": {"type": "PatternFlowTcpCtlFinCounter"},
        "decrement": {"type": "PatternFlowTcpCtlFinCounter"},
        "metric_tags": {"type": "PatternFlowTcpCtlFinMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowTcpCtlFin, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowTcpCtlFinCounter
        """Factory property that returns an instance of the PatternFlowTcpCtlFinCounter class

        integer counter pattern

        Returns: PatternFlowTcpCtlFinCounter
        """
        return self._get_property(
            "increment", PatternFlowTcpCtlFinCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowTcpCtlFinCounter
        """Factory property that returns an instance of the PatternFlowTcpCtlFinCounter class

        integer counter pattern

        Returns: PatternFlowTcpCtlFinCounter
        """
        return self._get_property(
            "decrement", PatternFlowTcpCtlFinCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowTcpCtlFinMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowTcpCtlFinMetricTagIter
        """
        return self._get_property(
            "metric_tags", PatternFlowTcpCtlFinMetricTagIter, self._parent, self._choice
        )


class PatternFlowTcpCtlFinCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowTcpCtlFinCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowTcpCtlFinMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 0,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=1):
        super(PatternFlowTcpCtlFinMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowTcpCtlFinMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowTcpCtlFinMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowTcpCtlFinMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowTcpCtlFinMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowTcpCtlFinMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowTcpCtlFinMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowTcpCtlFinMetricTag):
            raise Exception("Item is not an instance of PatternFlowTcpCtlFinMetricTag")

    def metrictag(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowTcpCtlFinMetricTagIter
        """Factory method that creates an instance of the PatternFlowTcpCtlFinMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowTcpCtlFinMetricTagIter
        """
        item = PatternFlowTcpCtlFinMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowTcpCtlFinMetricTag
        """Add method that creates and returns an instance of the PatternFlowTcpCtlFinMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowTcpCtlFinMetricTag
        """
        item = PatternFlowTcpCtlFinMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowTcpWindow(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 65535,
        },
        "increment": {"type": "PatternFlowTcpWindowCounter"},
        "decrement": {"type": "PatternFlowTcpWindowCounter"},
        "metric_tags": {"type": "PatternFlowTcpWindowMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowTcpWindow, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowTcpWindowCounter
        """Factory property that returns an instance of the PatternFlowTcpWindowCounter class

        integer counter pattern

        Returns: PatternFlowTcpWindowCounter
        """
        return self._get_property(
            "increment", PatternFlowTcpWindowCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowTcpWindowCounter
        """Factory property that returns an instance of the PatternFlowTcpWindowCounter class

        integer counter pattern

        Returns: PatternFlowTcpWindowCounter
        """
        return self._get_property(
            "decrement", PatternFlowTcpWindowCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowTcpWindowMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowTcpWindowMetricTagIter
        """
        return self._get_property(
            "metric_tags", PatternFlowTcpWindowMetricTagIter, self._parent, self._choice
        )


class PatternFlowTcpWindowCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowTcpWindowCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowTcpWindowMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 16,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 16,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=16):
        super(PatternFlowTcpWindowMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowTcpWindowMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowTcpWindowMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowTcpWindowMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowTcpWindowMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowTcpWindowMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowTcpWindowMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowTcpWindowMetricTag):
            raise Exception("Item is not an instance of PatternFlowTcpWindowMetricTag")

    def metrictag(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowTcpWindowMetricTagIter
        """Factory method that creates an instance of the PatternFlowTcpWindowMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowTcpWindowMetricTagIter
        """
        item = PatternFlowTcpWindowMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowTcpWindowMetricTag
        """Add method that creates and returns an instance of the PatternFlowTcpWindowMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowTcpWindowMetricTag
        """
        item = PatternFlowTcpWindowMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class FlowUdp(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "src_port": {"type": "PatternFlowUdpSrcPort"},
        "dst_port": {"type": "PatternFlowUdpDstPort"},
        "length": {"type": "PatternFlowUdpLength"},
        "checksum": {"type": "PatternFlowUdpChecksum"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None):
        super(FlowUdp, self).__init__()
        self._parent = parent

    @property
    def src_port(self):
        # type: () -> PatternFlowUdpSrcPort
        """src_port getter

        Source portSource portSource portSource port

        Returns: PatternFlowUdpSrcPort
        """
        return self._get_property("src_port", PatternFlowUdpSrcPort)

    @property
    def dst_port(self):
        # type: () -> PatternFlowUdpDstPort
        """dst_port getter

        Destination portDestination portDestination portDestination port

        Returns: PatternFlowUdpDstPort
        """
        return self._get_property("dst_port", PatternFlowUdpDstPort)

    @property
    def length(self):
        # type: () -> PatternFlowUdpLength
        """length getter

        LengthLengthLengthLength

        Returns: PatternFlowUdpLength
        """
        return self._get_property("length", PatternFlowUdpLength)

    @property
    def checksum(self):
        # type: () -> PatternFlowUdpChecksum
        """checksum getter

        UDP checksumUDP checksumUDP checksumUDP checksum

        Returns: PatternFlowUdpChecksum
        """
        return self._get_property("checksum", PatternFlowUdpChecksum)


class PatternFlowUdpSrcPort(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 65535,
        },
        "increment": {"type": "PatternFlowUdpSrcPortCounter"},
        "decrement": {"type": "PatternFlowUdpSrcPortCounter"},
        "metric_tags": {"type": "PatternFlowUdpSrcPortMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowUdpSrcPort, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowUdpSrcPortCounter
        """Factory property that returns an instance of the PatternFlowUdpSrcPortCounter class

        integer counter pattern

        Returns: PatternFlowUdpSrcPortCounter
        """
        return self._get_property(
            "increment", PatternFlowUdpSrcPortCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowUdpSrcPortCounter
        """Factory property that returns an instance of the PatternFlowUdpSrcPortCounter class

        integer counter pattern

        Returns: PatternFlowUdpSrcPortCounter
        """
        return self._get_property(
            "decrement", PatternFlowUdpSrcPortCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowUdpSrcPortMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowUdpSrcPortMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowUdpSrcPortMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowUdpSrcPortCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowUdpSrcPortCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowUdpSrcPortMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 16,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 16,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=16):
        super(PatternFlowUdpSrcPortMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowUdpSrcPortMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowUdpSrcPortMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowUdpSrcPortMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowUdpSrcPortMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowUdpSrcPortMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowUdpSrcPortMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowUdpSrcPortMetricTag):
            raise Exception("Item is not an instance of PatternFlowUdpSrcPortMetricTag")

    def metrictag(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowUdpSrcPortMetricTagIter
        """Factory method that creates an instance of the PatternFlowUdpSrcPortMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowUdpSrcPortMetricTagIter
        """
        item = PatternFlowUdpSrcPortMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowUdpSrcPortMetricTag
        """Add method that creates and returns an instance of the PatternFlowUdpSrcPortMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowUdpSrcPortMetricTag
        """
        item = PatternFlowUdpSrcPortMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowUdpDstPort(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 65535,
        },
        "increment": {"type": "PatternFlowUdpDstPortCounter"},
        "decrement": {"type": "PatternFlowUdpDstPortCounter"},
        "metric_tags": {"type": "PatternFlowUdpDstPortMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowUdpDstPort, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowUdpDstPortCounter
        """Factory property that returns an instance of the PatternFlowUdpDstPortCounter class

        integer counter pattern

        Returns: PatternFlowUdpDstPortCounter
        """
        return self._get_property(
            "increment", PatternFlowUdpDstPortCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowUdpDstPortCounter
        """Factory property that returns an instance of the PatternFlowUdpDstPortCounter class

        integer counter pattern

        Returns: PatternFlowUdpDstPortCounter
        """
        return self._get_property(
            "decrement", PatternFlowUdpDstPortCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowUdpDstPortMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowUdpDstPortMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowUdpDstPortMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowUdpDstPortCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowUdpDstPortCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowUdpDstPortMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 16,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 16,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=16):
        super(PatternFlowUdpDstPortMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowUdpDstPortMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowUdpDstPortMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowUdpDstPortMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowUdpDstPortMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowUdpDstPortMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowUdpDstPortMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowUdpDstPortMetricTag):
            raise Exception("Item is not an instance of PatternFlowUdpDstPortMetricTag")

    def metrictag(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowUdpDstPortMetricTagIter
        """Factory method that creates an instance of the PatternFlowUdpDstPortMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowUdpDstPortMetricTagIter
        """
        item = PatternFlowUdpDstPortMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowUdpDstPortMetricTag
        """Add method that creates and returns an instance of the PatternFlowUdpDstPortMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowUdpDstPortMetricTag
        """
        item = PatternFlowUdpDstPortMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowUdpLength(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 65535,
        },
        "increment": {"type": "PatternFlowUdpLengthCounter"},
        "decrement": {"type": "PatternFlowUdpLengthCounter"},
        "metric_tags": {"type": "PatternFlowUdpLengthMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowUdpLength, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowUdpLengthCounter
        """Factory property that returns an instance of the PatternFlowUdpLengthCounter class

        integer counter pattern

        Returns: PatternFlowUdpLengthCounter
        """
        return self._get_property(
            "increment", PatternFlowUdpLengthCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowUdpLengthCounter
        """Factory property that returns an instance of the PatternFlowUdpLengthCounter class

        integer counter pattern

        Returns: PatternFlowUdpLengthCounter
        """
        return self._get_property(
            "decrement", PatternFlowUdpLengthCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowUdpLengthMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowUdpLengthMetricTagIter
        """
        return self._get_property(
            "metric_tags", PatternFlowUdpLengthMetricTagIter, self._parent, self._choice
        )


class PatternFlowUdpLengthCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowUdpLengthCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowUdpLengthMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 16,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 16,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=16):
        super(PatternFlowUdpLengthMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowUdpLengthMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowUdpLengthMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowUdpLengthMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowUdpLengthMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowUdpLengthMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowUdpLengthMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowUdpLengthMetricTag):
            raise Exception("Item is not an instance of PatternFlowUdpLengthMetricTag")

    def metrictag(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowUdpLengthMetricTagIter
        """Factory method that creates an instance of the PatternFlowUdpLengthMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowUdpLengthMetricTagIter
        """
        item = PatternFlowUdpLengthMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowUdpLengthMetricTag
        """Add method that creates and returns an instance of the PatternFlowUdpLengthMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowUdpLengthMetricTag
        """
        item = PatternFlowUdpLengthMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowUdpChecksum(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "generated",
                "custom",
            ],
        },
        "generated": {
            "type": str,
            "enum": [
                "good",
                "bad",
            ],
        },
        "custom": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "generated",
        "generated": "good",
    }  # type: Dict[str, Union(type)]

    GENERATED = "generated"  # type: str
    CUSTOM = "custom"  # type: str

    GOOD = "good"  # type: str
    BAD = "bad"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, generated="good", custom=None):
        super(PatternFlowUdpChecksum, self).__init__()
        self._parent = parent
        self._set_property("generated", generated)
        self._set_property("custom", custom)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, generated=None, custom=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def choice(self):
        # type: () -> Union[Literal["custom"], Literal["generated"]]
        """choice getter

        The type of checksum

        Returns: Union[Literal["custom"], Literal["generated"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        The type of checksum

        value: Union[Literal["custom"], Literal["generated"]]
        """
        self._set_property("choice", value)

    @property
    def generated(self):
        # type: () -> Union[Literal["bad"], Literal["good"]]
        """generated getter

        A system generated checksum value

        Returns: Union[Literal["bad"], Literal["good"]]
        """
        return self._get_property("generated")

    @generated.setter
    def generated(self, value):
        """generated setter

        A system generated checksum value

        value: Union[Literal["bad"], Literal["good"]]
        """
        self._set_property("generated", value, "generated")

    @property
    def custom(self):
        # type: () -> int
        """custom getter

        A custom checksum value

        Returns: int
        """
        return self._get_property("custom")

    @custom.setter
    def custom(self, value):
        """custom setter

        A custom checksum value

        value: int
        """
        self._set_property("custom", value, "custom")


class FlowGre(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "checksum_present": {"type": "PatternFlowGreChecksumPresent"},
        "reserved0": {"type": "PatternFlowGreReserved0"},
        "version": {"type": "PatternFlowGreVersion"},
        "protocol": {"type": "PatternFlowGreProtocol"},
        "checksum": {"type": "PatternFlowGreChecksum"},
        "reserved1": {"type": "PatternFlowGreReserved1"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None):
        super(FlowGre, self).__init__()
        self._parent = parent

    @property
    def checksum_present(self):
        # type: () -> PatternFlowGreChecksumPresent
        """checksum_present getter

        Checksum present bitChecksum present bitChecksum present bitChecksum present bit

        Returns: PatternFlowGreChecksumPresent
        """
        return self._get_property("checksum_present", PatternFlowGreChecksumPresent)

    @property
    def reserved0(self):
        # type: () -> PatternFlowGreReserved0
        """reserved0 getter

        Reserved bitsReserved bitsReserved bitsReserved bits

        Returns: PatternFlowGreReserved0
        """
        return self._get_property("reserved0", PatternFlowGreReserved0)

    @property
    def version(self):
        # type: () -> PatternFlowGreVersion
        """version getter

        GRE version numberGRE version numberGRE version numberGRE version number

        Returns: PatternFlowGreVersion
        """
        return self._get_property("version", PatternFlowGreVersion)

    @property
    def protocol(self):
        # type: () -> PatternFlowGreProtocol
        """protocol getter

        Protocol type of encapsulated payloadProtocol type of encapsulated payloadProtocol type of encapsulated payloadProtocol type of encapsulated payload

        Returns: PatternFlowGreProtocol
        """
        return self._get_property("protocol", PatternFlowGreProtocol)

    @property
    def checksum(self):
        # type: () -> PatternFlowGreChecksum
        """checksum getter

        Optional checksum of GRE header and payload. Only present if the checksum_present bit is set.Optional checksum of GRE header and payload. Only present if the checksum_present bit is set.Optional checksum of GRE header and payload. Only present if the checksum_present bit is set.Optional checksum of GRE header and payload. Only present if the checksum_present bit is set.

        Returns: PatternFlowGreChecksum
        """
        return self._get_property("checksum", PatternFlowGreChecksum)

    @property
    def reserved1(self):
        # type: () -> PatternFlowGreReserved1
        """reserved1 getter

        Optional reserved field. Only present if the checksum_present bit is set.Optional reserved field. Only present if the checksum_present bit is set.Optional reserved field. Only present if the checksum_present bit is set.Optional reserved field. Only present if the checksum_present bit is set.

        Returns: PatternFlowGreReserved1
        """
        return self._get_property("reserved1", PatternFlowGreReserved1)


class PatternFlowGreChecksumPresent(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 1,
        },
        "increment": {"type": "PatternFlowGreChecksumPresentCounter"},
        "decrement": {"type": "PatternFlowGreChecksumPresentCounter"},
        "metric_tags": {"type": "PatternFlowGreChecksumPresentMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowGreChecksumPresent, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowGreChecksumPresentCounter
        """Factory property that returns an instance of the PatternFlowGreChecksumPresentCounter class

        integer counter pattern

        Returns: PatternFlowGreChecksumPresentCounter
        """
        return self._get_property(
            "increment", PatternFlowGreChecksumPresentCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowGreChecksumPresentCounter
        """Factory property that returns an instance of the PatternFlowGreChecksumPresentCounter class

        integer counter pattern

        Returns: PatternFlowGreChecksumPresentCounter
        """
        return self._get_property(
            "decrement", PatternFlowGreChecksumPresentCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowGreChecksumPresentMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGreChecksumPresentMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowGreChecksumPresentMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowGreChecksumPresentCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowGreChecksumPresentCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowGreChecksumPresentMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 0,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=1):
        super(PatternFlowGreChecksumPresentMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowGreChecksumPresentMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowGreChecksumPresentMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowGreChecksumPresentMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowGreChecksumPresentMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowGreChecksumPresentMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowGreChecksumPresentMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowGreChecksumPresentMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowGreChecksumPresentMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowGreChecksumPresentMetricTagIter
        """Factory method that creates an instance of the PatternFlowGreChecksumPresentMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGreChecksumPresentMetricTagIter
        """
        item = PatternFlowGreChecksumPresentMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowGreChecksumPresentMetricTag
        """Add method that creates and returns an instance of the PatternFlowGreChecksumPresentMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGreChecksumPresentMetricTag
        """
        item = PatternFlowGreChecksumPresentMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowGreReserved0(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 4095,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 4095,
        },
        "increment": {"type": "PatternFlowGreReserved0Counter"},
        "decrement": {"type": "PatternFlowGreReserved0Counter"},
        "metric_tags": {"type": "PatternFlowGreReserved0MetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowGreReserved0, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowGreReserved0Counter
        """Factory property that returns an instance of the PatternFlowGreReserved0Counter class

        integer counter pattern

        Returns: PatternFlowGreReserved0Counter
        """
        return self._get_property(
            "increment", PatternFlowGreReserved0Counter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowGreReserved0Counter
        """Factory property that returns an instance of the PatternFlowGreReserved0Counter class

        integer counter pattern

        Returns: PatternFlowGreReserved0Counter
        """
        return self._get_property(
            "decrement", PatternFlowGreReserved0Counter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowGreReserved0MetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGreReserved0MetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowGreReserved0MetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowGreReserved0Counter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 4095,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 4095,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 4095,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowGreReserved0Counter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowGreReserved0MetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 11,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 12,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 12,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=12):
        super(PatternFlowGreReserved0MetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowGreReserved0MetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowGreReserved0MetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowGreReserved0MetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowGreReserved0MetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowGreReserved0MetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowGreReserved0MetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowGreReserved0MetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowGreReserved0MetricTag"
            )

    def metrictag(self, name=None, offset=0, length=12):
        # type: (str,int,int) -> PatternFlowGreReserved0MetricTagIter
        """Factory method that creates an instance of the PatternFlowGreReserved0MetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGreReserved0MetricTagIter
        """
        item = PatternFlowGreReserved0MetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=12):
        # type: (str,int,int) -> PatternFlowGreReserved0MetricTag
        """Add method that creates and returns an instance of the PatternFlowGreReserved0MetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGreReserved0MetricTag
        """
        item = PatternFlowGreReserved0MetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowGreVersion(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 7,
        },
        "increment": {"type": "PatternFlowGreVersionCounter"},
        "decrement": {"type": "PatternFlowGreVersionCounter"},
        "metric_tags": {"type": "PatternFlowGreVersionMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowGreVersion, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowGreVersionCounter
        """Factory property that returns an instance of the PatternFlowGreVersionCounter class

        integer counter pattern

        Returns: PatternFlowGreVersionCounter
        """
        return self._get_property(
            "increment", PatternFlowGreVersionCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowGreVersionCounter
        """Factory property that returns an instance of the PatternFlowGreVersionCounter class

        integer counter pattern

        Returns: PatternFlowGreVersionCounter
        """
        return self._get_property(
            "decrement", PatternFlowGreVersionCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowGreVersionMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGreVersionMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowGreVersionMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowGreVersionCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowGreVersionCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowGreVersionMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 2,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 3,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 3,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=3):
        super(PatternFlowGreVersionMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowGreVersionMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowGreVersionMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowGreVersionMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowGreVersionMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowGreVersionMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowGreVersionMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowGreVersionMetricTag):
            raise Exception("Item is not an instance of PatternFlowGreVersionMetricTag")

    def metrictag(self, name=None, offset=0, length=3):
        # type: (str,int,int) -> PatternFlowGreVersionMetricTagIter
        """Factory method that creates an instance of the PatternFlowGreVersionMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGreVersionMetricTagIter
        """
        item = PatternFlowGreVersionMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=3):
        # type: (str,int,int) -> PatternFlowGreVersionMetricTag
        """Add method that creates and returns an instance of the PatternFlowGreVersionMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGreVersionMetricTag
        """
        item = PatternFlowGreVersionMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowGreProtocol(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 65535,
        },
        "increment": {"type": "PatternFlowGreProtocolCounter"},
        "decrement": {"type": "PatternFlowGreProtocolCounter"},
        "metric_tags": {"type": "PatternFlowGreProtocolMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 2048,
        "values": [2048],
    }  # type: Dict[str, Union(type)]

    IPV4 = 2048  #
    IPV6 = 34525  #

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=2048, values=[2048]):
        super(PatternFlowGreProtocol, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowGreProtocolCounter
        """Factory property that returns an instance of the PatternFlowGreProtocolCounter class

        integer counter pattern

        Returns: PatternFlowGreProtocolCounter
        """
        return self._get_property(
            "increment", PatternFlowGreProtocolCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowGreProtocolCounter
        """Factory property that returns an instance of the PatternFlowGreProtocolCounter class

        integer counter pattern

        Returns: PatternFlowGreProtocolCounter
        """
        return self._get_property(
            "decrement", PatternFlowGreProtocolCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowGreProtocolMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGreProtocolMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowGreProtocolMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowGreProtocolCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 2048,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    IPV4 = 2048  #
    IPV6 = 34525  #

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=2048, step=1, count=1):
        super(PatternFlowGreProtocolCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowGreProtocolMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 16,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 16,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=16):
        super(PatternFlowGreProtocolMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowGreProtocolMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowGreProtocolMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowGreProtocolMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowGreProtocolMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowGreProtocolMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowGreProtocolMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowGreProtocolMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowGreProtocolMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowGreProtocolMetricTagIter
        """Factory method that creates an instance of the PatternFlowGreProtocolMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGreProtocolMetricTagIter
        """
        item = PatternFlowGreProtocolMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowGreProtocolMetricTag
        """Add method that creates and returns an instance of the PatternFlowGreProtocolMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGreProtocolMetricTag
        """
        item = PatternFlowGreProtocolMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowGreChecksum(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "generated",
                "custom",
            ],
        },
        "generated": {
            "type": str,
            "enum": [
                "good",
                "bad",
            ],
        },
        "custom": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "generated",
        "generated": "good",
    }  # type: Dict[str, Union(type)]

    GENERATED = "generated"  # type: str
    CUSTOM = "custom"  # type: str

    GOOD = "good"  # type: str
    BAD = "bad"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, generated="good", custom=None):
        super(PatternFlowGreChecksum, self).__init__()
        self._parent = parent
        self._set_property("generated", generated)
        self._set_property("custom", custom)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, generated=None, custom=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def choice(self):
        # type: () -> Union[Literal["custom"], Literal["generated"]]
        """choice getter

        The type of checksum

        Returns: Union[Literal["custom"], Literal["generated"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        The type of checksum

        value: Union[Literal["custom"], Literal["generated"]]
        """
        self._set_property("choice", value)

    @property
    def generated(self):
        # type: () -> Union[Literal["bad"], Literal["good"]]
        """generated getter

        A system generated checksum value

        Returns: Union[Literal["bad"], Literal["good"]]
        """
        return self._get_property("generated")

    @generated.setter
    def generated(self, value):
        """generated setter

        A system generated checksum value

        value: Union[Literal["bad"], Literal["good"]]
        """
        self._set_property("generated", value, "generated")

    @property
    def custom(self):
        # type: () -> int
        """custom getter

        A custom checksum value

        Returns: int
        """
        return self._get_property("custom")

    @custom.setter
    def custom(self, value):
        """custom setter

        A custom checksum value

        value: int
        """
        self._set_property("custom", value, "custom")


class PatternFlowGreReserved1(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 65535,
        },
        "increment": {"type": "PatternFlowGreReserved1Counter"},
        "decrement": {"type": "PatternFlowGreReserved1Counter"},
        "metric_tags": {"type": "PatternFlowGreReserved1MetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowGreReserved1, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowGreReserved1Counter
        """Factory property that returns an instance of the PatternFlowGreReserved1Counter class

        integer counter pattern

        Returns: PatternFlowGreReserved1Counter
        """
        return self._get_property(
            "increment", PatternFlowGreReserved1Counter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowGreReserved1Counter
        """Factory property that returns an instance of the PatternFlowGreReserved1Counter class

        integer counter pattern

        Returns: PatternFlowGreReserved1Counter
        """
        return self._get_property(
            "decrement", PatternFlowGreReserved1Counter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowGreReserved1MetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGreReserved1MetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowGreReserved1MetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowGreReserved1Counter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowGreReserved1Counter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowGreReserved1MetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 16,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 16,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=16):
        super(PatternFlowGreReserved1MetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowGreReserved1MetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowGreReserved1MetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowGreReserved1MetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowGreReserved1MetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowGreReserved1MetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowGreReserved1MetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowGreReserved1MetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowGreReserved1MetricTag"
            )

    def metrictag(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowGreReserved1MetricTagIter
        """Factory method that creates an instance of the PatternFlowGreReserved1MetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGreReserved1MetricTagIter
        """
        item = PatternFlowGreReserved1MetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowGreReserved1MetricTag
        """Add method that creates and returns an instance of the PatternFlowGreReserved1MetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGreReserved1MetricTag
        """
        item = PatternFlowGreReserved1MetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class FlowGtpv1(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "version": {"type": "PatternFlowGtpv1Version"},
        "protocol_type": {"type": "PatternFlowGtpv1ProtocolType"},
        "reserved": {"type": "PatternFlowGtpv1Reserved"},
        "e_flag": {"type": "PatternFlowGtpv1EFlag"},
        "s_flag": {"type": "PatternFlowGtpv1SFlag"},
        "pn_flag": {"type": "PatternFlowGtpv1PnFlag"},
        "message_type": {"type": "PatternFlowGtpv1MessageType"},
        "message_length": {"type": "PatternFlowGtpv1MessageLength"},
        "teid": {"type": "PatternFlowGtpv1Teid"},
        "squence_number": {"type": "PatternFlowGtpv1SquenceNumber"},
        "n_pdu_number": {"type": "PatternFlowGtpv1NPduNumber"},
        "next_extension_header_type": {
            "type": "PatternFlowGtpv1NextExtensionHeaderType"
        },
        "extension_headers": {"type": "FlowGtpExtensionIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None):
        super(FlowGtpv1, self).__init__()
        self._parent = parent

    @property
    def version(self):
        # type: () -> PatternFlowGtpv1Version
        """version getter

        GTPv1 versionGTPv1 versionGTPv1 versionGTPv1 version

        Returns: PatternFlowGtpv1Version
        """
        return self._get_property("version", PatternFlowGtpv1Version)

    @property
    def protocol_type(self):
        # type: () -> PatternFlowGtpv1ProtocolType
        """protocol_type getter

        Protocol type, GTP is 1, GTP' is 0Protocol type, GTP is 1, GTP' is 0Protocol type, GTP is 1, GTP' is 0Protocol type, GTP is 1, GTP' is 0

        Returns: PatternFlowGtpv1ProtocolType
        """
        return self._get_property("protocol_type", PatternFlowGtpv1ProtocolType)

    @property
    def reserved(self):
        # type: () -> PatternFlowGtpv1Reserved
        """reserved getter

        Reserved fieldReserved fieldReserved fieldReserved field

        Returns: PatternFlowGtpv1Reserved
        """
        return self._get_property("reserved", PatternFlowGtpv1Reserved)

    @property
    def e_flag(self):
        # type: () -> PatternFlowGtpv1EFlag
        """e_flag getter

        Extension header field presentExtension header field presentExtension header field presentExtension header field present

        Returns: PatternFlowGtpv1EFlag
        """
        return self._get_property("e_flag", PatternFlowGtpv1EFlag)

    @property
    def s_flag(self):
        # type: () -> PatternFlowGtpv1SFlag
        """s_flag getter

        Sequence number field presentSequence number field presentSequence number field presentSequence number field present

        Returns: PatternFlowGtpv1SFlag
        """
        return self._get_property("s_flag", PatternFlowGtpv1SFlag)

    @property
    def pn_flag(self):
        # type: () -> PatternFlowGtpv1PnFlag
        """pn_flag getter

        N-PDU field presentN-PDU field presentN-PDU field presentN-PDU field present

        Returns: PatternFlowGtpv1PnFlag
        """
        return self._get_property("pn_flag", PatternFlowGtpv1PnFlag)

    @property
    def message_type(self):
        # type: () -> PatternFlowGtpv1MessageType
        """message_type getter

        The type of GTP message Different types of messages are defined in 3GPP TS 29.060 section 7.1The type of GTP message Different types of messages are defined in 3GPP TS 29.060 section 7.1The type of GTP message Different types of messages are defined in 3GPP TS 29.060 section 7.1The type of GTP message Different types of messages are defined in 3GPP TS 29.060 section 7.1

        Returns: PatternFlowGtpv1MessageType
        """
        return self._get_property("message_type", PatternFlowGtpv1MessageType)

    @property
    def message_length(self):
        # type: () -> PatternFlowGtpv1MessageLength
        """message_length getter

        The length of the payload (the bytes following the mandatory 8-byte GTP header) in bytes that includes any optional fieldsThe length of the payload (the bytes following the mandatory 8-byte GTP header) in bytes that includes any optional fieldsThe length of the payload (the bytes following the mandatory 8-byte GTP header) in bytes that includes any optional fieldsThe length of the payload (the bytes following the mandatory 8-byte GTP header) in bytes that includes any optional fields

        Returns: PatternFlowGtpv1MessageLength
        """
        return self._get_property("message_length", PatternFlowGtpv1MessageLength)

    @property
    def teid(self):
        # type: () -> PatternFlowGtpv1Teid
        """teid getter

        Tunnel endpoint identifier (TEID) used to multiplex connections in the same GTP tunnelTunnel endpoint identifier (TEID) used to multiplex connections in the same GTP tunnelTunnel endpoint identifier (TEID) used to multiplex connections in the same GTP tunnelTunnel endpoint identifier (TEID) used to multiplex connections in the same GTP tunnel

        Returns: PatternFlowGtpv1Teid
        """
        return self._get_property("teid", PatternFlowGtpv1Teid)

    @property
    def squence_number(self):
        # type: () -> PatternFlowGtpv1SquenceNumber
        """squence_number getter

        Sequence number. Exists if any of the e_flag, s_flag, or pn_flag bits are on. Must be interpreted only if the s_flag bit is on.Sequence number. Exists if any of the e_flag, s_flag, or pn_flag bits are on. Must be interpreted only if the s_flag bit is on.Sequence number. Exists if any of the e_flag, s_flag, or pn_flag bits are on. Must be interpreted only if the s_flag bit is on.Sequence number. Exists if any of the e_flag, s_flag, or pn_flag bits are on. Must be interpreted only if the s_flag bit is on.

        Returns: PatternFlowGtpv1SquenceNumber
        """
        return self._get_property("squence_number", PatternFlowGtpv1SquenceNumber)

    @property
    def n_pdu_number(self):
        # type: () -> PatternFlowGtpv1NPduNumber
        """n_pdu_number getter

        N-PDU number. Exists if any of the e_flag, s_flag, or pn_flag bits are on. Must be interpreted only if the pn_flag bit is on.N-PDU number. Exists if any of the e_flag, s_flag, or pn_flag bits are on. Must be interpreted only if the pn_flag bit is on.N-PDU number. Exists if any of the e_flag, s_flag, or pn_flag bits are on. Must be interpreted only if the pn_flag bit is on.N-PDU number. Exists if any of the e_flag, s_flag, or pn_flag bits are on. Must be interpreted only if the pn_flag bit is on.

        Returns: PatternFlowGtpv1NPduNumber
        """
        return self._get_property("n_pdu_number", PatternFlowGtpv1NPduNumber)

    @property
    def next_extension_header_type(self):
        # type: () -> PatternFlowGtpv1NextExtensionHeaderType
        """next_extension_header_type getter

        Next extension header. Exists if any of the e_flag, s_flag, or pn_flag bits are on. Must be interpreted only if the e_flag bit is on.Next extension header. Exists if any of the e_flag, s_flag, or pn_flag bits are on. Must be interpreted only if the e_flag bit is on.Next extension header. Exists if any of the e_flag, s_flag, or pn_flag bits are on. Must be interpreted only if the e_flag bit is on.Next extension header. Exists if any of the e_flag, s_flag, or pn_flag bits are on. Must be interpreted only if the e_flag bit is on.

        Returns: PatternFlowGtpv1NextExtensionHeaderType
        """
        return self._get_property(
            "next_extension_header_type", PatternFlowGtpv1NextExtensionHeaderType
        )

    @property
    def extension_headers(self):
        # type: () -> FlowGtpExtensionIter
        """extension_headers getter

        A list of optional extension headers.

        Returns: FlowGtpExtensionIter
        """
        return self._get_property(
            "extension_headers", FlowGtpExtensionIter, self._parent, self._choice
        )


class PatternFlowGtpv1Version(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 7,
        },
        "increment": {"type": "PatternFlowGtpv1VersionCounter"},
        "decrement": {"type": "PatternFlowGtpv1VersionCounter"},
        "metric_tags": {"type": "PatternFlowGtpv1VersionMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 1,
        "values": [1],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=1, values=[1]):
        super(PatternFlowGtpv1Version, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowGtpv1VersionCounter
        """Factory property that returns an instance of the PatternFlowGtpv1VersionCounter class

        integer counter pattern

        Returns: PatternFlowGtpv1VersionCounter
        """
        return self._get_property(
            "increment", PatternFlowGtpv1VersionCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowGtpv1VersionCounter
        """Factory property that returns an instance of the PatternFlowGtpv1VersionCounter class

        integer counter pattern

        Returns: PatternFlowGtpv1VersionCounter
        """
        return self._get_property(
            "decrement", PatternFlowGtpv1VersionCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowGtpv1VersionMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv1VersionMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowGtpv1VersionMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowGtpv1VersionCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 1,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=1, step=1, count=1):
        super(PatternFlowGtpv1VersionCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowGtpv1VersionMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 2,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 3,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 3,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=3):
        super(PatternFlowGtpv1VersionMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowGtpv1VersionMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowGtpv1VersionMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowGtpv1VersionMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowGtpv1VersionMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowGtpv1VersionMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowGtpv1VersionMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowGtpv1VersionMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowGtpv1VersionMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=3):
        # type: (str,int,int) -> PatternFlowGtpv1VersionMetricTagIter
        """Factory method that creates an instance of the PatternFlowGtpv1VersionMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv1VersionMetricTagIter
        """
        item = PatternFlowGtpv1VersionMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=3):
        # type: (str,int,int) -> PatternFlowGtpv1VersionMetricTag
        """Add method that creates and returns an instance of the PatternFlowGtpv1VersionMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv1VersionMetricTag
        """
        item = PatternFlowGtpv1VersionMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowGtpv1ProtocolType(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 1,
        },
        "increment": {"type": "PatternFlowGtpv1ProtocolTypeCounter"},
        "decrement": {"type": "PatternFlowGtpv1ProtocolTypeCounter"},
        "metric_tags": {"type": "PatternFlowGtpv1ProtocolTypeMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 1,
        "values": [1],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=1, values=[1]):
        super(PatternFlowGtpv1ProtocolType, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowGtpv1ProtocolTypeCounter
        """Factory property that returns an instance of the PatternFlowGtpv1ProtocolTypeCounter class

        integer counter pattern

        Returns: PatternFlowGtpv1ProtocolTypeCounter
        """
        return self._get_property(
            "increment", PatternFlowGtpv1ProtocolTypeCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowGtpv1ProtocolTypeCounter
        """Factory property that returns an instance of the PatternFlowGtpv1ProtocolTypeCounter class

        integer counter pattern

        Returns: PatternFlowGtpv1ProtocolTypeCounter
        """
        return self._get_property(
            "decrement", PatternFlowGtpv1ProtocolTypeCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowGtpv1ProtocolTypeMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv1ProtocolTypeMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowGtpv1ProtocolTypeMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowGtpv1ProtocolTypeCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 1,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=1, step=1, count=1):
        super(PatternFlowGtpv1ProtocolTypeCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowGtpv1ProtocolTypeMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 0,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=1):
        super(PatternFlowGtpv1ProtocolTypeMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowGtpv1ProtocolTypeMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowGtpv1ProtocolTypeMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowGtpv1ProtocolTypeMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowGtpv1ProtocolTypeMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowGtpv1ProtocolTypeMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowGtpv1ProtocolTypeMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowGtpv1ProtocolTypeMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowGtpv1ProtocolTypeMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowGtpv1ProtocolTypeMetricTagIter
        """Factory method that creates an instance of the PatternFlowGtpv1ProtocolTypeMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv1ProtocolTypeMetricTagIter
        """
        item = PatternFlowGtpv1ProtocolTypeMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowGtpv1ProtocolTypeMetricTag
        """Add method that creates and returns an instance of the PatternFlowGtpv1ProtocolTypeMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv1ProtocolTypeMetricTag
        """
        item = PatternFlowGtpv1ProtocolTypeMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowGtpv1Reserved(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 1,
        },
        "increment": {"type": "PatternFlowGtpv1ReservedCounter"},
        "decrement": {"type": "PatternFlowGtpv1ReservedCounter"},
        "metric_tags": {"type": "PatternFlowGtpv1ReservedMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowGtpv1Reserved, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowGtpv1ReservedCounter
        """Factory property that returns an instance of the PatternFlowGtpv1ReservedCounter class

        integer counter pattern

        Returns: PatternFlowGtpv1ReservedCounter
        """
        return self._get_property(
            "increment", PatternFlowGtpv1ReservedCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowGtpv1ReservedCounter
        """Factory property that returns an instance of the PatternFlowGtpv1ReservedCounter class

        integer counter pattern

        Returns: PatternFlowGtpv1ReservedCounter
        """
        return self._get_property(
            "decrement", PatternFlowGtpv1ReservedCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowGtpv1ReservedMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv1ReservedMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowGtpv1ReservedMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowGtpv1ReservedCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowGtpv1ReservedCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowGtpv1ReservedMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 0,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=1):
        super(PatternFlowGtpv1ReservedMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowGtpv1ReservedMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowGtpv1ReservedMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowGtpv1ReservedMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowGtpv1ReservedMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowGtpv1ReservedMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowGtpv1ReservedMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowGtpv1ReservedMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowGtpv1ReservedMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowGtpv1ReservedMetricTagIter
        """Factory method that creates an instance of the PatternFlowGtpv1ReservedMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv1ReservedMetricTagIter
        """
        item = PatternFlowGtpv1ReservedMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowGtpv1ReservedMetricTag
        """Add method that creates and returns an instance of the PatternFlowGtpv1ReservedMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv1ReservedMetricTag
        """
        item = PatternFlowGtpv1ReservedMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowGtpv1EFlag(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 1,
        },
        "increment": {"type": "PatternFlowGtpv1EFlagCounter"},
        "decrement": {"type": "PatternFlowGtpv1EFlagCounter"},
        "metric_tags": {"type": "PatternFlowGtpv1EFlagMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowGtpv1EFlag, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowGtpv1EFlagCounter
        """Factory property that returns an instance of the PatternFlowGtpv1EFlagCounter class

        integer counter pattern

        Returns: PatternFlowGtpv1EFlagCounter
        """
        return self._get_property(
            "increment", PatternFlowGtpv1EFlagCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowGtpv1EFlagCounter
        """Factory property that returns an instance of the PatternFlowGtpv1EFlagCounter class

        integer counter pattern

        Returns: PatternFlowGtpv1EFlagCounter
        """
        return self._get_property(
            "decrement", PatternFlowGtpv1EFlagCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowGtpv1EFlagMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv1EFlagMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowGtpv1EFlagMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowGtpv1EFlagCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowGtpv1EFlagCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowGtpv1EFlagMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 0,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=1):
        super(PatternFlowGtpv1EFlagMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowGtpv1EFlagMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowGtpv1EFlagMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowGtpv1EFlagMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowGtpv1EFlagMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowGtpv1EFlagMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowGtpv1EFlagMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowGtpv1EFlagMetricTag):
            raise Exception("Item is not an instance of PatternFlowGtpv1EFlagMetricTag")

    def metrictag(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowGtpv1EFlagMetricTagIter
        """Factory method that creates an instance of the PatternFlowGtpv1EFlagMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv1EFlagMetricTagIter
        """
        item = PatternFlowGtpv1EFlagMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowGtpv1EFlagMetricTag
        """Add method that creates and returns an instance of the PatternFlowGtpv1EFlagMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv1EFlagMetricTag
        """
        item = PatternFlowGtpv1EFlagMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowGtpv1SFlag(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 1,
        },
        "increment": {"type": "PatternFlowGtpv1SFlagCounter"},
        "decrement": {"type": "PatternFlowGtpv1SFlagCounter"},
        "metric_tags": {"type": "PatternFlowGtpv1SFlagMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowGtpv1SFlag, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowGtpv1SFlagCounter
        """Factory property that returns an instance of the PatternFlowGtpv1SFlagCounter class

        integer counter pattern

        Returns: PatternFlowGtpv1SFlagCounter
        """
        return self._get_property(
            "increment", PatternFlowGtpv1SFlagCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowGtpv1SFlagCounter
        """Factory property that returns an instance of the PatternFlowGtpv1SFlagCounter class

        integer counter pattern

        Returns: PatternFlowGtpv1SFlagCounter
        """
        return self._get_property(
            "decrement", PatternFlowGtpv1SFlagCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowGtpv1SFlagMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv1SFlagMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowGtpv1SFlagMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowGtpv1SFlagCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowGtpv1SFlagCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowGtpv1SFlagMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 0,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=1):
        super(PatternFlowGtpv1SFlagMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowGtpv1SFlagMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowGtpv1SFlagMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowGtpv1SFlagMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowGtpv1SFlagMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowGtpv1SFlagMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowGtpv1SFlagMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowGtpv1SFlagMetricTag):
            raise Exception("Item is not an instance of PatternFlowGtpv1SFlagMetricTag")

    def metrictag(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowGtpv1SFlagMetricTagIter
        """Factory method that creates an instance of the PatternFlowGtpv1SFlagMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv1SFlagMetricTagIter
        """
        item = PatternFlowGtpv1SFlagMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowGtpv1SFlagMetricTag
        """Add method that creates and returns an instance of the PatternFlowGtpv1SFlagMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv1SFlagMetricTag
        """
        item = PatternFlowGtpv1SFlagMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowGtpv1PnFlag(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 1,
        },
        "increment": {"type": "PatternFlowGtpv1PnFlagCounter"},
        "decrement": {"type": "PatternFlowGtpv1PnFlagCounter"},
        "metric_tags": {"type": "PatternFlowGtpv1PnFlagMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowGtpv1PnFlag, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowGtpv1PnFlagCounter
        """Factory property that returns an instance of the PatternFlowGtpv1PnFlagCounter class

        integer counter pattern

        Returns: PatternFlowGtpv1PnFlagCounter
        """
        return self._get_property(
            "increment", PatternFlowGtpv1PnFlagCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowGtpv1PnFlagCounter
        """Factory property that returns an instance of the PatternFlowGtpv1PnFlagCounter class

        integer counter pattern

        Returns: PatternFlowGtpv1PnFlagCounter
        """
        return self._get_property(
            "decrement", PatternFlowGtpv1PnFlagCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowGtpv1PnFlagMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv1PnFlagMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowGtpv1PnFlagMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowGtpv1PnFlagCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowGtpv1PnFlagCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowGtpv1PnFlagMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 0,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=1):
        super(PatternFlowGtpv1PnFlagMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowGtpv1PnFlagMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowGtpv1PnFlagMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowGtpv1PnFlagMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowGtpv1PnFlagMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowGtpv1PnFlagMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowGtpv1PnFlagMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowGtpv1PnFlagMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowGtpv1PnFlagMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowGtpv1PnFlagMetricTagIter
        """Factory method that creates an instance of the PatternFlowGtpv1PnFlagMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv1PnFlagMetricTagIter
        """
        item = PatternFlowGtpv1PnFlagMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowGtpv1PnFlagMetricTag
        """Add method that creates and returns an instance of the PatternFlowGtpv1PnFlagMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv1PnFlagMetricTag
        """
        item = PatternFlowGtpv1PnFlagMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowGtpv1MessageType(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 255,
        },
        "increment": {"type": "PatternFlowGtpv1MessageTypeCounter"},
        "decrement": {"type": "PatternFlowGtpv1MessageTypeCounter"},
        "metric_tags": {"type": "PatternFlowGtpv1MessageTypeMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowGtpv1MessageType, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowGtpv1MessageTypeCounter
        """Factory property that returns an instance of the PatternFlowGtpv1MessageTypeCounter class

        integer counter pattern

        Returns: PatternFlowGtpv1MessageTypeCounter
        """
        return self._get_property(
            "increment", PatternFlowGtpv1MessageTypeCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowGtpv1MessageTypeCounter
        """Factory property that returns an instance of the PatternFlowGtpv1MessageTypeCounter class

        integer counter pattern

        Returns: PatternFlowGtpv1MessageTypeCounter
        """
        return self._get_property(
            "decrement", PatternFlowGtpv1MessageTypeCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowGtpv1MessageTypeMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv1MessageTypeMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowGtpv1MessageTypeMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowGtpv1MessageTypeCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowGtpv1MessageTypeCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowGtpv1MessageTypeMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 8,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 8,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=8):
        super(PatternFlowGtpv1MessageTypeMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowGtpv1MessageTypeMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowGtpv1MessageTypeMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowGtpv1MessageTypeMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowGtpv1MessageTypeMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowGtpv1MessageTypeMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowGtpv1MessageTypeMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowGtpv1MessageTypeMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowGtpv1MessageTypeMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=8):
        # type: (str,int,int) -> PatternFlowGtpv1MessageTypeMetricTagIter
        """Factory method that creates an instance of the PatternFlowGtpv1MessageTypeMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv1MessageTypeMetricTagIter
        """
        item = PatternFlowGtpv1MessageTypeMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=8):
        # type: (str,int,int) -> PatternFlowGtpv1MessageTypeMetricTag
        """Add method that creates and returns an instance of the PatternFlowGtpv1MessageTypeMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv1MessageTypeMetricTag
        """
        item = PatternFlowGtpv1MessageTypeMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowGtpv1MessageLength(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 65535,
        },
        "increment": {"type": "PatternFlowGtpv1MessageLengthCounter"},
        "decrement": {"type": "PatternFlowGtpv1MessageLengthCounter"},
        "metric_tags": {"type": "PatternFlowGtpv1MessageLengthMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowGtpv1MessageLength, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowGtpv1MessageLengthCounter
        """Factory property that returns an instance of the PatternFlowGtpv1MessageLengthCounter class

        integer counter pattern

        Returns: PatternFlowGtpv1MessageLengthCounter
        """
        return self._get_property(
            "increment", PatternFlowGtpv1MessageLengthCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowGtpv1MessageLengthCounter
        """Factory property that returns an instance of the PatternFlowGtpv1MessageLengthCounter class

        integer counter pattern

        Returns: PatternFlowGtpv1MessageLengthCounter
        """
        return self._get_property(
            "decrement", PatternFlowGtpv1MessageLengthCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowGtpv1MessageLengthMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv1MessageLengthMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowGtpv1MessageLengthMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowGtpv1MessageLengthCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowGtpv1MessageLengthCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowGtpv1MessageLengthMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 16,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 16,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=16):
        super(PatternFlowGtpv1MessageLengthMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowGtpv1MessageLengthMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowGtpv1MessageLengthMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowGtpv1MessageLengthMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowGtpv1MessageLengthMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowGtpv1MessageLengthMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowGtpv1MessageLengthMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowGtpv1MessageLengthMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowGtpv1MessageLengthMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowGtpv1MessageLengthMetricTagIter
        """Factory method that creates an instance of the PatternFlowGtpv1MessageLengthMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv1MessageLengthMetricTagIter
        """
        item = PatternFlowGtpv1MessageLengthMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowGtpv1MessageLengthMetricTag
        """Add method that creates and returns an instance of the PatternFlowGtpv1MessageLengthMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv1MessageLengthMetricTag
        """
        item = PatternFlowGtpv1MessageLengthMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowGtpv1Teid(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
        },
        "increment": {"type": "PatternFlowGtpv1TeidCounter"},
        "decrement": {"type": "PatternFlowGtpv1TeidCounter"},
        "metric_tags": {"type": "PatternFlowGtpv1TeidMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowGtpv1Teid, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowGtpv1TeidCounter
        """Factory property that returns an instance of the PatternFlowGtpv1TeidCounter class

        integer counter pattern

        Returns: PatternFlowGtpv1TeidCounter
        """
        return self._get_property(
            "increment", PatternFlowGtpv1TeidCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowGtpv1TeidCounter
        """Factory property that returns an instance of the PatternFlowGtpv1TeidCounter class

        integer counter pattern

        Returns: PatternFlowGtpv1TeidCounter
        """
        return self._get_property(
            "decrement", PatternFlowGtpv1TeidCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowGtpv1TeidMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv1TeidMetricTagIter
        """
        return self._get_property(
            "metric_tags", PatternFlowGtpv1TeidMetricTagIter, self._parent, self._choice
        )


class PatternFlowGtpv1TeidCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
        },
        "step": {
            "type": int,
            "format": "uint32",
        },
        "count": {
            "type": int,
            "format": "uint32",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowGtpv1TeidCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowGtpv1TeidMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 31,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 32,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 32,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=32):
        super(PatternFlowGtpv1TeidMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowGtpv1TeidMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowGtpv1TeidMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowGtpv1TeidMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowGtpv1TeidMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowGtpv1TeidMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowGtpv1TeidMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowGtpv1TeidMetricTag):
            raise Exception("Item is not an instance of PatternFlowGtpv1TeidMetricTag")

    def metrictag(self, name=None, offset=0, length=32):
        # type: (str,int,int) -> PatternFlowGtpv1TeidMetricTagIter
        """Factory method that creates an instance of the PatternFlowGtpv1TeidMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv1TeidMetricTagIter
        """
        item = PatternFlowGtpv1TeidMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=32):
        # type: (str,int,int) -> PatternFlowGtpv1TeidMetricTag
        """Add method that creates and returns an instance of the PatternFlowGtpv1TeidMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv1TeidMetricTag
        """
        item = PatternFlowGtpv1TeidMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowGtpv1SquenceNumber(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 65535,
        },
        "increment": {"type": "PatternFlowGtpv1SquenceNumberCounter"},
        "decrement": {"type": "PatternFlowGtpv1SquenceNumberCounter"},
        "metric_tags": {"type": "PatternFlowGtpv1SquenceNumberMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowGtpv1SquenceNumber, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowGtpv1SquenceNumberCounter
        """Factory property that returns an instance of the PatternFlowGtpv1SquenceNumberCounter class

        integer counter pattern

        Returns: PatternFlowGtpv1SquenceNumberCounter
        """
        return self._get_property(
            "increment", PatternFlowGtpv1SquenceNumberCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowGtpv1SquenceNumberCounter
        """Factory property that returns an instance of the PatternFlowGtpv1SquenceNumberCounter class

        integer counter pattern

        Returns: PatternFlowGtpv1SquenceNumberCounter
        """
        return self._get_property(
            "decrement", PatternFlowGtpv1SquenceNumberCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowGtpv1SquenceNumberMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv1SquenceNumberMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowGtpv1SquenceNumberMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowGtpv1SquenceNumberCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowGtpv1SquenceNumberCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowGtpv1SquenceNumberMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 16,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 16,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=16):
        super(PatternFlowGtpv1SquenceNumberMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowGtpv1SquenceNumberMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowGtpv1SquenceNumberMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowGtpv1SquenceNumberMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowGtpv1SquenceNumberMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowGtpv1SquenceNumberMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowGtpv1SquenceNumberMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowGtpv1SquenceNumberMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowGtpv1SquenceNumberMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowGtpv1SquenceNumberMetricTagIter
        """Factory method that creates an instance of the PatternFlowGtpv1SquenceNumberMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv1SquenceNumberMetricTagIter
        """
        item = PatternFlowGtpv1SquenceNumberMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowGtpv1SquenceNumberMetricTag
        """Add method that creates and returns an instance of the PatternFlowGtpv1SquenceNumberMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv1SquenceNumberMetricTag
        """
        item = PatternFlowGtpv1SquenceNumberMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowGtpv1NPduNumber(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 255,
        },
        "increment": {"type": "PatternFlowGtpv1NPduNumberCounter"},
        "decrement": {"type": "PatternFlowGtpv1NPduNumberCounter"},
        "metric_tags": {"type": "PatternFlowGtpv1NPduNumberMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowGtpv1NPduNumber, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowGtpv1NPduNumberCounter
        """Factory property that returns an instance of the PatternFlowGtpv1NPduNumberCounter class

        integer counter pattern

        Returns: PatternFlowGtpv1NPduNumberCounter
        """
        return self._get_property(
            "increment", PatternFlowGtpv1NPduNumberCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowGtpv1NPduNumberCounter
        """Factory property that returns an instance of the PatternFlowGtpv1NPduNumberCounter class

        integer counter pattern

        Returns: PatternFlowGtpv1NPduNumberCounter
        """
        return self._get_property(
            "decrement", PatternFlowGtpv1NPduNumberCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowGtpv1NPduNumberMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv1NPduNumberMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowGtpv1NPduNumberMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowGtpv1NPduNumberCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowGtpv1NPduNumberCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowGtpv1NPduNumberMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 8,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 8,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=8):
        super(PatternFlowGtpv1NPduNumberMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowGtpv1NPduNumberMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowGtpv1NPduNumberMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowGtpv1NPduNumberMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowGtpv1NPduNumberMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowGtpv1NPduNumberMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowGtpv1NPduNumberMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowGtpv1NPduNumberMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowGtpv1NPduNumberMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=8):
        # type: (str,int,int) -> PatternFlowGtpv1NPduNumberMetricTagIter
        """Factory method that creates an instance of the PatternFlowGtpv1NPduNumberMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv1NPduNumberMetricTagIter
        """
        item = PatternFlowGtpv1NPduNumberMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=8):
        # type: (str,int,int) -> PatternFlowGtpv1NPduNumberMetricTag
        """Add method that creates and returns an instance of the PatternFlowGtpv1NPduNumberMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv1NPduNumberMetricTag
        """
        item = PatternFlowGtpv1NPduNumberMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowGtpv1NextExtensionHeaderType(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 255,
        },
        "increment": {"type": "PatternFlowGtpv1NextExtensionHeaderTypeCounter"},
        "decrement": {"type": "PatternFlowGtpv1NextExtensionHeaderTypeCounter"},
        "metric_tags": {"type": "PatternFlowGtpv1NextExtensionHeaderTypeMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowGtpv1NextExtensionHeaderType, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowGtpv1NextExtensionHeaderTypeCounter
        """Factory property that returns an instance of the PatternFlowGtpv1NextExtensionHeaderTypeCounter class

        integer counter pattern

        Returns: PatternFlowGtpv1NextExtensionHeaderTypeCounter
        """
        return self._get_property(
            "increment",
            PatternFlowGtpv1NextExtensionHeaderTypeCounter,
            self,
            "increment",
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowGtpv1NextExtensionHeaderTypeCounter
        """Factory property that returns an instance of the PatternFlowGtpv1NextExtensionHeaderTypeCounter class

        integer counter pattern

        Returns: PatternFlowGtpv1NextExtensionHeaderTypeCounter
        """
        return self._get_property(
            "decrement",
            PatternFlowGtpv1NextExtensionHeaderTypeCounter,
            self,
            "decrement",
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowGtpv1NextExtensionHeaderTypeMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv1NextExtensionHeaderTypeMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowGtpv1NextExtensionHeaderTypeMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowGtpv1NextExtensionHeaderTypeCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowGtpv1NextExtensionHeaderTypeCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowGtpv1NextExtensionHeaderTypeMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 8,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 8,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=8):
        super(PatternFlowGtpv1NextExtensionHeaderTypeMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowGtpv1NextExtensionHeaderTypeMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowGtpv1NextExtensionHeaderTypeMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowGtpv1NextExtensionHeaderTypeMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowGtpv1NextExtensionHeaderTypeMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowGtpv1NextExtensionHeaderTypeMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowGtpv1NextExtensionHeaderTypeMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowGtpv1NextExtensionHeaderTypeMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowGtpv1NextExtensionHeaderTypeMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=8):
        # type: (str,int,int) -> PatternFlowGtpv1NextExtensionHeaderTypeMetricTagIter
        """Factory method that creates an instance of the PatternFlowGtpv1NextExtensionHeaderTypeMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv1NextExtensionHeaderTypeMetricTagIter
        """
        item = PatternFlowGtpv1NextExtensionHeaderTypeMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=8):
        # type: (str,int,int) -> PatternFlowGtpv1NextExtensionHeaderTypeMetricTag
        """Add method that creates and returns an instance of the PatternFlowGtpv1NextExtensionHeaderTypeMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv1NextExtensionHeaderTypeMetricTag
        """
        item = PatternFlowGtpv1NextExtensionHeaderTypeMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class FlowGtpExtension(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "extension_length": {"type": "PatternFlowGtpExtensionExtensionLength"},
        "contents": {"type": "PatternFlowGtpExtensionContents"},
        "next_extension_header": {"type": "PatternFlowGtpExtensionNextExtensionHeader"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None):
        super(FlowGtpExtension, self).__init__()
        self._parent = parent

    @property
    def extension_length(self):
        # type: () -> PatternFlowGtpExtensionExtensionLength
        """extension_length getter

        This field states the length of this extension header, including the length, the contents, and the next extension header field, in 4-octet units, so the length of the extension must always be multiple of 4.This field states the length of this extension header, including the length, the contents, and the next extension header field, in 4-octet units, so the length of the extension must always be multiple of 4.This field states the length of this extension header, including the length, the contents, and the next extension header field, in 4-octet units, so the length of the extension must always be multiple of 4.

        Returns: PatternFlowGtpExtensionExtensionLength
        """
        return self._get_property(
            "extension_length", PatternFlowGtpExtensionExtensionLength
        )

    @property
    def contents(self):
        # type: () -> PatternFlowGtpExtensionContents
        """contents getter

        The extension header contentsThe extension header contentsThe extension header contents

        Returns: PatternFlowGtpExtensionContents
        """
        return self._get_property("contents", PatternFlowGtpExtensionContents)

    @property
    def next_extension_header(self):
        # type: () -> PatternFlowGtpExtensionNextExtensionHeader
        """next_extension_header getter

        It states the type of the next extension, or if no next extension exists. This permits chaining several next extension headers.It states the type of the next extension, or if no next extension exists. This permits chaining several next extension headers.It states the type of the next extension, or if no next extension exists. This permits chaining several next extension headers.

        Returns: PatternFlowGtpExtensionNextExtensionHeader
        """
        return self._get_property(
            "next_extension_header", PatternFlowGtpExtensionNextExtensionHeader
        )


class PatternFlowGtpExtensionExtensionLength(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 255,
        },
        "increment": {"type": "PatternFlowGtpExtensionExtensionLengthCounter"},
        "decrement": {"type": "PatternFlowGtpExtensionExtensionLengthCounter"},
        "metric_tags": {"type": "PatternFlowGtpExtensionExtensionLengthMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowGtpExtensionExtensionLength, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowGtpExtensionExtensionLengthCounter
        """Factory property that returns an instance of the PatternFlowGtpExtensionExtensionLengthCounter class

        integer counter pattern

        Returns: PatternFlowGtpExtensionExtensionLengthCounter
        """
        return self._get_property(
            "increment",
            PatternFlowGtpExtensionExtensionLengthCounter,
            self,
            "increment",
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowGtpExtensionExtensionLengthCounter
        """Factory property that returns an instance of the PatternFlowGtpExtensionExtensionLengthCounter class

        integer counter pattern

        Returns: PatternFlowGtpExtensionExtensionLengthCounter
        """
        return self._get_property(
            "decrement",
            PatternFlowGtpExtensionExtensionLengthCounter,
            self,
            "decrement",
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowGtpExtensionExtensionLengthMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpExtensionExtensionLengthMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowGtpExtensionExtensionLengthMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowGtpExtensionExtensionLengthCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowGtpExtensionExtensionLengthCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowGtpExtensionExtensionLengthMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 8,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 8,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=8):
        super(PatternFlowGtpExtensionExtensionLengthMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowGtpExtensionExtensionLengthMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowGtpExtensionExtensionLengthMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowGtpExtensionExtensionLengthMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowGtpExtensionExtensionLengthMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowGtpExtensionExtensionLengthMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowGtpExtensionExtensionLengthMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowGtpExtensionExtensionLengthMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowGtpExtensionExtensionLengthMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=8):
        # type: (str,int,int) -> PatternFlowGtpExtensionExtensionLengthMetricTagIter
        """Factory method that creates an instance of the PatternFlowGtpExtensionExtensionLengthMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpExtensionExtensionLengthMetricTagIter
        """
        item = PatternFlowGtpExtensionExtensionLengthMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=8):
        # type: (str,int,int) -> PatternFlowGtpExtensionExtensionLengthMetricTag
        """Add method that creates and returns an instance of the PatternFlowGtpExtensionExtensionLengthMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpExtensionExtensionLengthMetricTag
        """
        item = PatternFlowGtpExtensionExtensionLengthMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowGtpExtensionContents(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint64",
            "maximum": 281474976710655,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint64",
            "maximum": 281474976710655,
        },
        "increment": {"type": "PatternFlowGtpExtensionContentsCounter"},
        "decrement": {"type": "PatternFlowGtpExtensionContentsCounter"},
        "metric_tags": {"type": "PatternFlowGtpExtensionContentsMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowGtpExtensionContents, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowGtpExtensionContentsCounter
        """Factory property that returns an instance of the PatternFlowGtpExtensionContentsCounter class

        integer counter pattern

        Returns: PatternFlowGtpExtensionContentsCounter
        """
        return self._get_property(
            "increment", PatternFlowGtpExtensionContentsCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowGtpExtensionContentsCounter
        """Factory property that returns an instance of the PatternFlowGtpExtensionContentsCounter class

        integer counter pattern

        Returns: PatternFlowGtpExtensionContentsCounter
        """
        return self._get_property(
            "decrement", PatternFlowGtpExtensionContentsCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowGtpExtensionContentsMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpExtensionContentsMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowGtpExtensionContentsMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowGtpExtensionContentsCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint64",
            "maximum": 281474976710655,
        },
        "step": {
            "type": int,
            "format": "uint64",
            "maximum": 281474976710655,
        },
        "count": {
            "type": int,
            "format": "uint64",
            "maximum": 281474976710655,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowGtpExtensionContentsCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowGtpExtensionContentsMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint64",
            "maximum": 47,
        },
        "length": {
            "type": int,
            "format": "uint64",
            "minimum": 1,
            "maximum": 48,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 48,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=48):
        super(PatternFlowGtpExtensionContentsMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowGtpExtensionContentsMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowGtpExtensionContentsMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowGtpExtensionContentsMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowGtpExtensionContentsMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowGtpExtensionContentsMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowGtpExtensionContentsMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowGtpExtensionContentsMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowGtpExtensionContentsMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=48):
        # type: (str,int,int) -> PatternFlowGtpExtensionContentsMetricTagIter
        """Factory method that creates an instance of the PatternFlowGtpExtensionContentsMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpExtensionContentsMetricTagIter
        """
        item = PatternFlowGtpExtensionContentsMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=48):
        # type: (str,int,int) -> PatternFlowGtpExtensionContentsMetricTag
        """Add method that creates and returns an instance of the PatternFlowGtpExtensionContentsMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpExtensionContentsMetricTag
        """
        item = PatternFlowGtpExtensionContentsMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowGtpExtensionNextExtensionHeader(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 255,
        },
        "increment": {"type": "PatternFlowGtpExtensionNextExtensionHeaderCounter"},
        "decrement": {"type": "PatternFlowGtpExtensionNextExtensionHeaderCounter"},
        "metric_tags": {
            "type": "PatternFlowGtpExtensionNextExtensionHeaderMetricTagIter"
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowGtpExtensionNextExtensionHeader, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowGtpExtensionNextExtensionHeaderCounter
        """Factory property that returns an instance of the PatternFlowGtpExtensionNextExtensionHeaderCounter class

        integer counter pattern

        Returns: PatternFlowGtpExtensionNextExtensionHeaderCounter
        """
        return self._get_property(
            "increment",
            PatternFlowGtpExtensionNextExtensionHeaderCounter,
            self,
            "increment",
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowGtpExtensionNextExtensionHeaderCounter
        """Factory property that returns an instance of the PatternFlowGtpExtensionNextExtensionHeaderCounter class

        integer counter pattern

        Returns: PatternFlowGtpExtensionNextExtensionHeaderCounter
        """
        return self._get_property(
            "decrement",
            PatternFlowGtpExtensionNextExtensionHeaderCounter,
            self,
            "decrement",
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowGtpExtensionNextExtensionHeaderMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpExtensionNextExtensionHeaderMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowGtpExtensionNextExtensionHeaderMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowGtpExtensionNextExtensionHeaderCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowGtpExtensionNextExtensionHeaderCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowGtpExtensionNextExtensionHeaderMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 8,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 8,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=8):
        super(PatternFlowGtpExtensionNextExtensionHeaderMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowGtpExtensionNextExtensionHeaderMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowGtpExtensionNextExtensionHeaderMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowGtpExtensionNextExtensionHeaderMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowGtpExtensionNextExtensionHeaderMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowGtpExtensionNextExtensionHeaderMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowGtpExtensionNextExtensionHeaderMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowGtpExtensionNextExtensionHeaderMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowGtpExtensionNextExtensionHeaderMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=8):
        # type: (str,int,int) -> PatternFlowGtpExtensionNextExtensionHeaderMetricTagIter
        """Factory method that creates an instance of the PatternFlowGtpExtensionNextExtensionHeaderMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpExtensionNextExtensionHeaderMetricTagIter
        """
        item = PatternFlowGtpExtensionNextExtensionHeaderMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=8):
        # type: (str,int,int) -> PatternFlowGtpExtensionNextExtensionHeaderMetricTag
        """Add method that creates and returns an instance of the PatternFlowGtpExtensionNextExtensionHeaderMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpExtensionNextExtensionHeaderMetricTag
        """
        item = PatternFlowGtpExtensionNextExtensionHeaderMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class FlowGtpExtensionIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(FlowGtpExtensionIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[FlowGtpExtension]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> FlowGtpExtensionIter
        return self._iter()

    def __next__(self):
        # type: () -> FlowGtpExtension
        return self._next()

    def next(self):
        # type: () -> FlowGtpExtension
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, FlowGtpExtension):
            raise Exception("Item is not an instance of FlowGtpExtension")

    def gtpextension(self):
        # type: () -> FlowGtpExtensionIter
        """Factory method that creates an instance of the FlowGtpExtension class

        TBD

        Returns: FlowGtpExtensionIter
        """
        item = FlowGtpExtension(parent=self._parent)
        self._add(item)
        return self

    def add(self):
        # type: () -> FlowGtpExtension
        """Add method that creates and returns an instance of the FlowGtpExtension class

        TBD

        Returns: FlowGtpExtension
        """
        item = FlowGtpExtension(parent=self._parent)
        self._add(item)
        return item


class FlowGtpv2(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "version": {"type": "PatternFlowGtpv2Version"},
        "piggybacking_flag": {"type": "PatternFlowGtpv2PiggybackingFlag"},
        "teid_flag": {"type": "PatternFlowGtpv2TeidFlag"},
        "spare1": {"type": "PatternFlowGtpv2Spare1"},
        "message_type": {"type": "PatternFlowGtpv2MessageType"},
        "message_length": {"type": "PatternFlowGtpv2MessageLength"},
        "teid": {"type": "PatternFlowGtpv2Teid"},
        "sequence_number": {"type": "PatternFlowGtpv2SequenceNumber"},
        "spare2": {"type": "PatternFlowGtpv2Spare2"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None):
        super(FlowGtpv2, self).__init__()
        self._parent = parent

    @property
    def version(self):
        # type: () -> PatternFlowGtpv2Version
        """version getter

        Version numberVersion numberVersion numberVersion number

        Returns: PatternFlowGtpv2Version
        """
        return self._get_property("version", PatternFlowGtpv2Version)

    @property
    def piggybacking_flag(self):
        # type: () -> PatternFlowGtpv2PiggybackingFlag
        """piggybacking_flag getter

        If piggybacking_flag is set to then another GTP-C message with its own header shall be present at the end of the current messageIf piggybacking_flag is set to then another GTP-C message with its own header shall be present at the end of the current messageIf piggybacking_flag is set to then another GTP-C message with its own header shall be present at the end of the current messageIf piggybacking_flag is set to then another GTP-C message with its own header shall be present at the end of the current message

        Returns: PatternFlowGtpv2PiggybackingFlag
        """
        return self._get_property("piggybacking_flag", PatternFlowGtpv2PiggybackingFlag)

    @property
    def teid_flag(self):
        # type: () -> PatternFlowGtpv2TeidFlag
        """teid_flag getter

        If teid_flag is set to then the TEID field will be present between the message length and the sequence number. All messages except Echo and Echo reply require TEID to be presentIf teid_flag is set to then the TEID field will be present between the message length and the sequence number. All messages except Echo and Echo reply require TEID to be presentIf teid_flag is set to then the TEID field will be present between the message length and the sequence number. All messages except Echo and Echo reply require TEID to be presentIf teid_flag is set to then the TEID field will be present between the message length and the sequence number. All messages except Echo and Echo reply require TEID to be present

        Returns: PatternFlowGtpv2TeidFlag
        """
        return self._get_property("teid_flag", PatternFlowGtpv2TeidFlag)

    @property
    def spare1(self):
        # type: () -> PatternFlowGtpv2Spare1
        """spare1 getter

        A 3-bit reserved field (must be 0).A 3-bit reserved field (must be 0).A 3-bit reserved field (must be 0).A 3-bit reserved field (must be 0).

        Returns: PatternFlowGtpv2Spare1
        """
        return self._get_property("spare1", PatternFlowGtpv2Spare1)

    @property
    def message_type(self):
        # type: () -> PatternFlowGtpv2MessageType
        """message_type getter

        An 8-bit field that indicates the type of GTP message. Different types of messages are defined in 3GPP TS 29.060 section 7.1An 8-bit field that indicates the type of GTP message. Different types of messages are defined in 3GPP TS 29.060 section 7.1An 8-bit field that indicates the type of GTP message. Different types of messages are defined in 3GPP TS 29.060 section 7.1An 8-bit field that indicates the type of GTP message. Different types of messages are defined in 3GPP TS 29.060 section 7.1

        Returns: PatternFlowGtpv2MessageType
        """
        return self._get_property("message_type", PatternFlowGtpv2MessageType)

    @property
    def message_length(self):
        # type: () -> PatternFlowGtpv2MessageLength
        """message_length getter

        A 16-bit field that indicates the length of the payload in bytes, excluding the mandatory GTP-c header (first bytes). Includes the TEID and sequence_number if they are present.A 16-bit field that indicates the length of the payload in bytes, excluding the mandatory GTP-c header (first bytes). Includes the TEID and sequence_number if they are present.A 16-bit field that indicates the length of the payload in bytes, excluding the mandatory GTP-c header (first bytes). Includes the TEID and sequence_number if they are present.A 16-bit field that indicates the length of the payload in bytes, excluding the mandatory GTP-c header (first bytes). Includes the TEID and sequence_number if they are present.

        Returns: PatternFlowGtpv2MessageLength
        """
        return self._get_property("message_length", PatternFlowGtpv2MessageLength)

    @property
    def teid(self):
        # type: () -> PatternFlowGtpv2Teid
        """teid getter

        Tunnel endpoint identifier. 32-bit (4-octet) field used to multiplex different connections in the same GTP tunnel. Is present only if the teid_flag is set.Tunnel endpoint identifier. 32-bit (4-octet) field used to multiplex different connections in the same GTP tunnel. Is present only if the teid_flag is set.Tunnel endpoint identifier. 32-bit (4-octet) field used to multiplex different connections in the same GTP tunnel. Is present only if the teid_flag is set.Tunnel endpoint identifier. 32-bit (4-octet) field used to multiplex different connections in the same GTP tunnel. Is present only if the teid_flag is set.

        Returns: PatternFlowGtpv2Teid
        """
        return self._get_property("teid", PatternFlowGtpv2Teid)

    @property
    def sequence_number(self):
        # type: () -> PatternFlowGtpv2SequenceNumber
        """sequence_number getter

        The sequence numberThe sequence numberThe sequence numberThe sequence number

        Returns: PatternFlowGtpv2SequenceNumber
        """
        return self._get_property("sequence_number", PatternFlowGtpv2SequenceNumber)

    @property
    def spare2(self):
        # type: () -> PatternFlowGtpv2Spare2
        """spare2 getter

        Reserved fieldReserved fieldReserved fieldReserved field

        Returns: PatternFlowGtpv2Spare2
        """
        return self._get_property("spare2", PatternFlowGtpv2Spare2)


class PatternFlowGtpv2Version(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 7,
        },
        "increment": {"type": "PatternFlowGtpv2VersionCounter"},
        "decrement": {"type": "PatternFlowGtpv2VersionCounter"},
        "metric_tags": {"type": "PatternFlowGtpv2VersionMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 2,
        "values": [2],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=2, values=[2]):
        super(PatternFlowGtpv2Version, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowGtpv2VersionCounter
        """Factory property that returns an instance of the PatternFlowGtpv2VersionCounter class

        integer counter pattern

        Returns: PatternFlowGtpv2VersionCounter
        """
        return self._get_property(
            "increment", PatternFlowGtpv2VersionCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowGtpv2VersionCounter
        """Factory property that returns an instance of the PatternFlowGtpv2VersionCounter class

        integer counter pattern

        Returns: PatternFlowGtpv2VersionCounter
        """
        return self._get_property(
            "decrement", PatternFlowGtpv2VersionCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowGtpv2VersionMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv2VersionMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowGtpv2VersionMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowGtpv2VersionCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 2,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=2, step=1, count=1):
        super(PatternFlowGtpv2VersionCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowGtpv2VersionMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 2,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 3,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 3,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=3):
        super(PatternFlowGtpv2VersionMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowGtpv2VersionMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowGtpv2VersionMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowGtpv2VersionMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowGtpv2VersionMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowGtpv2VersionMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowGtpv2VersionMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowGtpv2VersionMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowGtpv2VersionMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=3):
        # type: (str,int,int) -> PatternFlowGtpv2VersionMetricTagIter
        """Factory method that creates an instance of the PatternFlowGtpv2VersionMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv2VersionMetricTagIter
        """
        item = PatternFlowGtpv2VersionMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=3):
        # type: (str,int,int) -> PatternFlowGtpv2VersionMetricTag
        """Add method that creates and returns an instance of the PatternFlowGtpv2VersionMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv2VersionMetricTag
        """
        item = PatternFlowGtpv2VersionMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowGtpv2PiggybackingFlag(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 1,
        },
        "increment": {"type": "PatternFlowGtpv2PiggybackingFlagCounter"},
        "decrement": {"type": "PatternFlowGtpv2PiggybackingFlagCounter"},
        "metric_tags": {"type": "PatternFlowGtpv2PiggybackingFlagMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowGtpv2PiggybackingFlag, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowGtpv2PiggybackingFlagCounter
        """Factory property that returns an instance of the PatternFlowGtpv2PiggybackingFlagCounter class

        integer counter pattern

        Returns: PatternFlowGtpv2PiggybackingFlagCounter
        """
        return self._get_property(
            "increment", PatternFlowGtpv2PiggybackingFlagCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowGtpv2PiggybackingFlagCounter
        """Factory property that returns an instance of the PatternFlowGtpv2PiggybackingFlagCounter class

        integer counter pattern

        Returns: PatternFlowGtpv2PiggybackingFlagCounter
        """
        return self._get_property(
            "decrement", PatternFlowGtpv2PiggybackingFlagCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowGtpv2PiggybackingFlagMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv2PiggybackingFlagMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowGtpv2PiggybackingFlagMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowGtpv2PiggybackingFlagCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowGtpv2PiggybackingFlagCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowGtpv2PiggybackingFlagMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 0,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=1):
        super(PatternFlowGtpv2PiggybackingFlagMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowGtpv2PiggybackingFlagMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowGtpv2PiggybackingFlagMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowGtpv2PiggybackingFlagMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowGtpv2PiggybackingFlagMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowGtpv2PiggybackingFlagMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowGtpv2PiggybackingFlagMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowGtpv2PiggybackingFlagMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowGtpv2PiggybackingFlagMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowGtpv2PiggybackingFlagMetricTagIter
        """Factory method that creates an instance of the PatternFlowGtpv2PiggybackingFlagMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv2PiggybackingFlagMetricTagIter
        """
        item = PatternFlowGtpv2PiggybackingFlagMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowGtpv2PiggybackingFlagMetricTag
        """Add method that creates and returns an instance of the PatternFlowGtpv2PiggybackingFlagMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv2PiggybackingFlagMetricTag
        """
        item = PatternFlowGtpv2PiggybackingFlagMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowGtpv2TeidFlag(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 1,
        },
        "increment": {"type": "PatternFlowGtpv2TeidFlagCounter"},
        "decrement": {"type": "PatternFlowGtpv2TeidFlagCounter"},
        "metric_tags": {"type": "PatternFlowGtpv2TeidFlagMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowGtpv2TeidFlag, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowGtpv2TeidFlagCounter
        """Factory property that returns an instance of the PatternFlowGtpv2TeidFlagCounter class

        integer counter pattern

        Returns: PatternFlowGtpv2TeidFlagCounter
        """
        return self._get_property(
            "increment", PatternFlowGtpv2TeidFlagCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowGtpv2TeidFlagCounter
        """Factory property that returns an instance of the PatternFlowGtpv2TeidFlagCounter class

        integer counter pattern

        Returns: PatternFlowGtpv2TeidFlagCounter
        """
        return self._get_property(
            "decrement", PatternFlowGtpv2TeidFlagCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowGtpv2TeidFlagMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv2TeidFlagMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowGtpv2TeidFlagMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowGtpv2TeidFlagCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowGtpv2TeidFlagCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowGtpv2TeidFlagMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 0,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=1):
        super(PatternFlowGtpv2TeidFlagMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowGtpv2TeidFlagMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowGtpv2TeidFlagMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowGtpv2TeidFlagMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowGtpv2TeidFlagMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowGtpv2TeidFlagMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowGtpv2TeidFlagMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowGtpv2TeidFlagMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowGtpv2TeidFlagMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowGtpv2TeidFlagMetricTagIter
        """Factory method that creates an instance of the PatternFlowGtpv2TeidFlagMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv2TeidFlagMetricTagIter
        """
        item = PatternFlowGtpv2TeidFlagMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowGtpv2TeidFlagMetricTag
        """Add method that creates and returns an instance of the PatternFlowGtpv2TeidFlagMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv2TeidFlagMetricTag
        """
        item = PatternFlowGtpv2TeidFlagMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowGtpv2Spare1(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 7,
        },
        "increment": {"type": "PatternFlowGtpv2Spare1Counter"},
        "decrement": {"type": "PatternFlowGtpv2Spare1Counter"},
        "metric_tags": {"type": "PatternFlowGtpv2Spare1MetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowGtpv2Spare1, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowGtpv2Spare1Counter
        """Factory property that returns an instance of the PatternFlowGtpv2Spare1Counter class

        integer counter pattern

        Returns: PatternFlowGtpv2Spare1Counter
        """
        return self._get_property(
            "increment", PatternFlowGtpv2Spare1Counter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowGtpv2Spare1Counter
        """Factory property that returns an instance of the PatternFlowGtpv2Spare1Counter class

        integer counter pattern

        Returns: PatternFlowGtpv2Spare1Counter
        """
        return self._get_property(
            "decrement", PatternFlowGtpv2Spare1Counter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowGtpv2Spare1MetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv2Spare1MetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowGtpv2Spare1MetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowGtpv2Spare1Counter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowGtpv2Spare1Counter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowGtpv2Spare1MetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 2,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 3,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 3,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=3):
        super(PatternFlowGtpv2Spare1MetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowGtpv2Spare1MetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowGtpv2Spare1MetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowGtpv2Spare1MetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowGtpv2Spare1MetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowGtpv2Spare1MetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowGtpv2Spare1MetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowGtpv2Spare1MetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowGtpv2Spare1MetricTag"
            )

    def metrictag(self, name=None, offset=0, length=3):
        # type: (str,int,int) -> PatternFlowGtpv2Spare1MetricTagIter
        """Factory method that creates an instance of the PatternFlowGtpv2Spare1MetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv2Spare1MetricTagIter
        """
        item = PatternFlowGtpv2Spare1MetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=3):
        # type: (str,int,int) -> PatternFlowGtpv2Spare1MetricTag
        """Add method that creates and returns an instance of the PatternFlowGtpv2Spare1MetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv2Spare1MetricTag
        """
        item = PatternFlowGtpv2Spare1MetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowGtpv2MessageType(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 255,
        },
        "increment": {"type": "PatternFlowGtpv2MessageTypeCounter"},
        "decrement": {"type": "PatternFlowGtpv2MessageTypeCounter"},
        "metric_tags": {"type": "PatternFlowGtpv2MessageTypeMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowGtpv2MessageType, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowGtpv2MessageTypeCounter
        """Factory property that returns an instance of the PatternFlowGtpv2MessageTypeCounter class

        integer counter pattern

        Returns: PatternFlowGtpv2MessageTypeCounter
        """
        return self._get_property(
            "increment", PatternFlowGtpv2MessageTypeCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowGtpv2MessageTypeCounter
        """Factory property that returns an instance of the PatternFlowGtpv2MessageTypeCounter class

        integer counter pattern

        Returns: PatternFlowGtpv2MessageTypeCounter
        """
        return self._get_property(
            "decrement", PatternFlowGtpv2MessageTypeCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowGtpv2MessageTypeMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv2MessageTypeMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowGtpv2MessageTypeMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowGtpv2MessageTypeCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowGtpv2MessageTypeCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowGtpv2MessageTypeMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 8,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 8,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=8):
        super(PatternFlowGtpv2MessageTypeMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowGtpv2MessageTypeMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowGtpv2MessageTypeMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowGtpv2MessageTypeMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowGtpv2MessageTypeMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowGtpv2MessageTypeMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowGtpv2MessageTypeMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowGtpv2MessageTypeMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowGtpv2MessageTypeMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=8):
        # type: (str,int,int) -> PatternFlowGtpv2MessageTypeMetricTagIter
        """Factory method that creates an instance of the PatternFlowGtpv2MessageTypeMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv2MessageTypeMetricTagIter
        """
        item = PatternFlowGtpv2MessageTypeMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=8):
        # type: (str,int,int) -> PatternFlowGtpv2MessageTypeMetricTag
        """Add method that creates and returns an instance of the PatternFlowGtpv2MessageTypeMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv2MessageTypeMetricTag
        """
        item = PatternFlowGtpv2MessageTypeMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowGtpv2MessageLength(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 65535,
        },
        "increment": {"type": "PatternFlowGtpv2MessageLengthCounter"},
        "decrement": {"type": "PatternFlowGtpv2MessageLengthCounter"},
        "metric_tags": {"type": "PatternFlowGtpv2MessageLengthMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowGtpv2MessageLength, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowGtpv2MessageLengthCounter
        """Factory property that returns an instance of the PatternFlowGtpv2MessageLengthCounter class

        integer counter pattern

        Returns: PatternFlowGtpv2MessageLengthCounter
        """
        return self._get_property(
            "increment", PatternFlowGtpv2MessageLengthCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowGtpv2MessageLengthCounter
        """Factory property that returns an instance of the PatternFlowGtpv2MessageLengthCounter class

        integer counter pattern

        Returns: PatternFlowGtpv2MessageLengthCounter
        """
        return self._get_property(
            "decrement", PatternFlowGtpv2MessageLengthCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowGtpv2MessageLengthMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv2MessageLengthMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowGtpv2MessageLengthMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowGtpv2MessageLengthCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowGtpv2MessageLengthCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowGtpv2MessageLengthMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 16,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 16,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=16):
        super(PatternFlowGtpv2MessageLengthMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowGtpv2MessageLengthMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowGtpv2MessageLengthMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowGtpv2MessageLengthMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowGtpv2MessageLengthMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowGtpv2MessageLengthMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowGtpv2MessageLengthMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowGtpv2MessageLengthMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowGtpv2MessageLengthMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowGtpv2MessageLengthMetricTagIter
        """Factory method that creates an instance of the PatternFlowGtpv2MessageLengthMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv2MessageLengthMetricTagIter
        """
        item = PatternFlowGtpv2MessageLengthMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowGtpv2MessageLengthMetricTag
        """Add method that creates and returns an instance of the PatternFlowGtpv2MessageLengthMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv2MessageLengthMetricTag
        """
        item = PatternFlowGtpv2MessageLengthMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowGtpv2Teid(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
        },
        "increment": {"type": "PatternFlowGtpv2TeidCounter"},
        "decrement": {"type": "PatternFlowGtpv2TeidCounter"},
        "metric_tags": {"type": "PatternFlowGtpv2TeidMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowGtpv2Teid, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowGtpv2TeidCounter
        """Factory property that returns an instance of the PatternFlowGtpv2TeidCounter class

        integer counter pattern

        Returns: PatternFlowGtpv2TeidCounter
        """
        return self._get_property(
            "increment", PatternFlowGtpv2TeidCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowGtpv2TeidCounter
        """Factory property that returns an instance of the PatternFlowGtpv2TeidCounter class

        integer counter pattern

        Returns: PatternFlowGtpv2TeidCounter
        """
        return self._get_property(
            "decrement", PatternFlowGtpv2TeidCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowGtpv2TeidMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv2TeidMetricTagIter
        """
        return self._get_property(
            "metric_tags", PatternFlowGtpv2TeidMetricTagIter, self._parent, self._choice
        )


class PatternFlowGtpv2TeidCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
        },
        "step": {
            "type": int,
            "format": "uint32",
        },
        "count": {
            "type": int,
            "format": "uint32",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowGtpv2TeidCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowGtpv2TeidMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 31,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 32,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 32,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=32):
        super(PatternFlowGtpv2TeidMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowGtpv2TeidMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowGtpv2TeidMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowGtpv2TeidMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowGtpv2TeidMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowGtpv2TeidMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowGtpv2TeidMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowGtpv2TeidMetricTag):
            raise Exception("Item is not an instance of PatternFlowGtpv2TeidMetricTag")

    def metrictag(self, name=None, offset=0, length=32):
        # type: (str,int,int) -> PatternFlowGtpv2TeidMetricTagIter
        """Factory method that creates an instance of the PatternFlowGtpv2TeidMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv2TeidMetricTagIter
        """
        item = PatternFlowGtpv2TeidMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=32):
        # type: (str,int,int) -> PatternFlowGtpv2TeidMetricTag
        """Add method that creates and returns an instance of the PatternFlowGtpv2TeidMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv2TeidMetricTag
        """
        item = PatternFlowGtpv2TeidMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowGtpv2SequenceNumber(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 16777215,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 16777215,
        },
        "increment": {"type": "PatternFlowGtpv2SequenceNumberCounter"},
        "decrement": {"type": "PatternFlowGtpv2SequenceNumberCounter"},
        "metric_tags": {"type": "PatternFlowGtpv2SequenceNumberMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowGtpv2SequenceNumber, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowGtpv2SequenceNumberCounter
        """Factory property that returns an instance of the PatternFlowGtpv2SequenceNumberCounter class

        integer counter pattern

        Returns: PatternFlowGtpv2SequenceNumberCounter
        """
        return self._get_property(
            "increment", PatternFlowGtpv2SequenceNumberCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowGtpv2SequenceNumberCounter
        """Factory property that returns an instance of the PatternFlowGtpv2SequenceNumberCounter class

        integer counter pattern

        Returns: PatternFlowGtpv2SequenceNumberCounter
        """
        return self._get_property(
            "decrement", PatternFlowGtpv2SequenceNumberCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowGtpv2SequenceNumberMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv2SequenceNumberMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowGtpv2SequenceNumberMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowGtpv2SequenceNumberCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 16777215,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 16777215,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 16777215,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowGtpv2SequenceNumberCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowGtpv2SequenceNumberMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 23,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 24,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 24,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=24):
        super(PatternFlowGtpv2SequenceNumberMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowGtpv2SequenceNumberMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowGtpv2SequenceNumberMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowGtpv2SequenceNumberMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowGtpv2SequenceNumberMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowGtpv2SequenceNumberMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowGtpv2SequenceNumberMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowGtpv2SequenceNumberMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowGtpv2SequenceNumberMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=24):
        # type: (str,int,int) -> PatternFlowGtpv2SequenceNumberMetricTagIter
        """Factory method that creates an instance of the PatternFlowGtpv2SequenceNumberMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv2SequenceNumberMetricTagIter
        """
        item = PatternFlowGtpv2SequenceNumberMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=24):
        # type: (str,int,int) -> PatternFlowGtpv2SequenceNumberMetricTag
        """Add method that creates and returns an instance of the PatternFlowGtpv2SequenceNumberMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv2SequenceNumberMetricTag
        """
        item = PatternFlowGtpv2SequenceNumberMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowGtpv2Spare2(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 255,
        },
        "increment": {"type": "PatternFlowGtpv2Spare2Counter"},
        "decrement": {"type": "PatternFlowGtpv2Spare2Counter"},
        "metric_tags": {"type": "PatternFlowGtpv2Spare2MetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowGtpv2Spare2, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowGtpv2Spare2Counter
        """Factory property that returns an instance of the PatternFlowGtpv2Spare2Counter class

        integer counter pattern

        Returns: PatternFlowGtpv2Spare2Counter
        """
        return self._get_property(
            "increment", PatternFlowGtpv2Spare2Counter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowGtpv2Spare2Counter
        """Factory property that returns an instance of the PatternFlowGtpv2Spare2Counter class

        integer counter pattern

        Returns: PatternFlowGtpv2Spare2Counter
        """
        return self._get_property(
            "decrement", PatternFlowGtpv2Spare2Counter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowGtpv2Spare2MetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv2Spare2MetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowGtpv2Spare2MetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowGtpv2Spare2Counter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowGtpv2Spare2Counter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowGtpv2Spare2MetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 8,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 8,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=8):
        super(PatternFlowGtpv2Spare2MetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowGtpv2Spare2MetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowGtpv2Spare2MetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowGtpv2Spare2MetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowGtpv2Spare2MetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowGtpv2Spare2MetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowGtpv2Spare2MetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowGtpv2Spare2MetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowGtpv2Spare2MetricTag"
            )

    def metrictag(self, name=None, offset=0, length=8):
        # type: (str,int,int) -> PatternFlowGtpv2Spare2MetricTagIter
        """Factory method that creates an instance of the PatternFlowGtpv2Spare2MetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv2Spare2MetricTagIter
        """
        item = PatternFlowGtpv2Spare2MetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=8):
        # type: (str,int,int) -> PatternFlowGtpv2Spare2MetricTag
        """Add method that creates and returns an instance of the PatternFlowGtpv2Spare2MetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowGtpv2Spare2MetricTag
        """
        item = PatternFlowGtpv2Spare2MetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class FlowArp(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "hardware_type": {"type": "PatternFlowArpHardwareType"},
        "protocol_type": {"type": "PatternFlowArpProtocolType"},
        "hardware_length": {"type": "PatternFlowArpHardwareLength"},
        "protocol_length": {"type": "PatternFlowArpProtocolLength"},
        "operation": {"type": "PatternFlowArpOperation"},
        "sender_hardware_addr": {"type": "PatternFlowArpSenderHardwareAddr"},
        "sender_protocol_addr": {"type": "PatternFlowArpSenderProtocolAddr"},
        "target_hardware_addr": {"type": "PatternFlowArpTargetHardwareAddr"},
        "target_protocol_addr": {"type": "PatternFlowArpTargetProtocolAddr"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None):
        super(FlowArp, self).__init__()
        self._parent = parent

    @property
    def hardware_type(self):
        # type: () -> PatternFlowArpHardwareType
        """hardware_type getter

        Network link protocol typeNetwork link protocol typeNetwork link protocol typeNetwork link protocol type

        Returns: PatternFlowArpHardwareType
        """
        return self._get_property("hardware_type", PatternFlowArpHardwareType)

    @property
    def protocol_type(self):
        # type: () -> PatternFlowArpProtocolType
        """protocol_type getter

        The internetwork protocol for which the ARP request is intendedThe internetwork protocol for which the ARP request is intendedThe internetwork protocol for which the ARP request is intendedThe internetwork protocol for which the ARP request is intended

        Returns: PatternFlowArpProtocolType
        """
        return self._get_property("protocol_type", PatternFlowArpProtocolType)

    @property
    def hardware_length(self):
        # type: () -> PatternFlowArpHardwareLength
        """hardware_length getter

        Length (in octets) of hardware addressLength (in octets) of hardware addressLength (in octets) of hardware addressLength (in octets) of hardware address

        Returns: PatternFlowArpHardwareLength
        """
        return self._get_property("hardware_length", PatternFlowArpHardwareLength)

    @property
    def protocol_length(self):
        # type: () -> PatternFlowArpProtocolLength
        """protocol_length getter

        Length (in octets) of internetwork addressesLength (in octets) of internetwork addressesLength (in octets) of internetwork addressesLength (in octets) of internetwork addresses

        Returns: PatternFlowArpProtocolLength
        """
        return self._get_property("protocol_length", PatternFlowArpProtocolLength)

    @property
    def operation(self):
        # type: () -> PatternFlowArpOperation
        """operation getter

        The operation that the sender is performingThe operation that the sender is performingThe operation that the sender is performingThe operation that the sender is performing

        Returns: PatternFlowArpOperation
        """
        return self._get_property("operation", PatternFlowArpOperation)

    @property
    def sender_hardware_addr(self):
        # type: () -> PatternFlowArpSenderHardwareAddr
        """sender_hardware_addr getter

        Media address of the senderMedia address of the senderMedia address of the senderMedia address of the sender

        Returns: PatternFlowArpSenderHardwareAddr
        """
        return self._get_property(
            "sender_hardware_addr", PatternFlowArpSenderHardwareAddr
        )

    @property
    def sender_protocol_addr(self):
        # type: () -> PatternFlowArpSenderProtocolAddr
        """sender_protocol_addr getter

        Internetwork address of the senderInternetwork address of the senderInternetwork address of the senderInternetwork address of the sender

        Returns: PatternFlowArpSenderProtocolAddr
        """
        return self._get_property(
            "sender_protocol_addr", PatternFlowArpSenderProtocolAddr
        )

    @property
    def target_hardware_addr(self):
        # type: () -> PatternFlowArpTargetHardwareAddr
        """target_hardware_addr getter

        Media address of the targetMedia address of the targetMedia address of the targetMedia address of the target

        Returns: PatternFlowArpTargetHardwareAddr
        """
        return self._get_property(
            "target_hardware_addr", PatternFlowArpTargetHardwareAddr
        )

    @property
    def target_protocol_addr(self):
        # type: () -> PatternFlowArpTargetProtocolAddr
        """target_protocol_addr getter

        Internetwork address of the targetInternetwork address of the targetInternetwork address of the targetInternetwork address of the target

        Returns: PatternFlowArpTargetProtocolAddr
        """
        return self._get_property(
            "target_protocol_addr", PatternFlowArpTargetProtocolAddr
        )


class PatternFlowArpHardwareType(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 65535,
        },
        "increment": {"type": "PatternFlowArpHardwareTypeCounter"},
        "decrement": {"type": "PatternFlowArpHardwareTypeCounter"},
        "metric_tags": {"type": "PatternFlowArpHardwareTypeMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 1,
        "values": [1],
    }  # type: Dict[str, Union(type)]

    ETHERNET = 1  #

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=1, values=[1]):
        super(PatternFlowArpHardwareType, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowArpHardwareTypeCounter
        """Factory property that returns an instance of the PatternFlowArpHardwareTypeCounter class

        integer counter pattern

        Returns: PatternFlowArpHardwareTypeCounter
        """
        return self._get_property(
            "increment", PatternFlowArpHardwareTypeCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowArpHardwareTypeCounter
        """Factory property that returns an instance of the PatternFlowArpHardwareTypeCounter class

        integer counter pattern

        Returns: PatternFlowArpHardwareTypeCounter
        """
        return self._get_property(
            "decrement", PatternFlowArpHardwareTypeCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowArpHardwareTypeMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowArpHardwareTypeMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowArpHardwareTypeMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowArpHardwareTypeCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 1,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    ETHERNET = 1  #

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=1, step=1, count=1):
        super(PatternFlowArpHardwareTypeCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowArpHardwareTypeMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 16,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 16,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=16):
        super(PatternFlowArpHardwareTypeMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowArpHardwareTypeMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowArpHardwareTypeMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowArpHardwareTypeMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowArpHardwareTypeMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowArpHardwareTypeMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowArpHardwareTypeMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowArpHardwareTypeMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowArpHardwareTypeMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowArpHardwareTypeMetricTagIter
        """Factory method that creates an instance of the PatternFlowArpHardwareTypeMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowArpHardwareTypeMetricTagIter
        """
        item = PatternFlowArpHardwareTypeMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowArpHardwareTypeMetricTag
        """Add method that creates and returns an instance of the PatternFlowArpHardwareTypeMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowArpHardwareTypeMetricTag
        """
        item = PatternFlowArpHardwareTypeMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowArpProtocolType(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 65535,
        },
        "increment": {"type": "PatternFlowArpProtocolTypeCounter"},
        "decrement": {"type": "PatternFlowArpProtocolTypeCounter"},
        "metric_tags": {"type": "PatternFlowArpProtocolTypeMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 2048,
        "values": [2048],
    }  # type: Dict[str, Union(type)]

    IPV4 = 2048  #
    IPV6 = 34525  #

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=2048, values=[2048]):
        super(PatternFlowArpProtocolType, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowArpProtocolTypeCounter
        """Factory property that returns an instance of the PatternFlowArpProtocolTypeCounter class

        integer counter pattern

        Returns: PatternFlowArpProtocolTypeCounter
        """
        return self._get_property(
            "increment", PatternFlowArpProtocolTypeCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowArpProtocolTypeCounter
        """Factory property that returns an instance of the PatternFlowArpProtocolTypeCounter class

        integer counter pattern

        Returns: PatternFlowArpProtocolTypeCounter
        """
        return self._get_property(
            "decrement", PatternFlowArpProtocolTypeCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowArpProtocolTypeMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowArpProtocolTypeMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowArpProtocolTypeMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowArpProtocolTypeCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 2048,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    IPV4 = 2048  #
    IPV6 = 34525  #

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=2048, step=1, count=1):
        super(PatternFlowArpProtocolTypeCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowArpProtocolTypeMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 16,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 16,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=16):
        super(PatternFlowArpProtocolTypeMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowArpProtocolTypeMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowArpProtocolTypeMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowArpProtocolTypeMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowArpProtocolTypeMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowArpProtocolTypeMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowArpProtocolTypeMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowArpProtocolTypeMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowArpProtocolTypeMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowArpProtocolTypeMetricTagIter
        """Factory method that creates an instance of the PatternFlowArpProtocolTypeMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowArpProtocolTypeMetricTagIter
        """
        item = PatternFlowArpProtocolTypeMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowArpProtocolTypeMetricTag
        """Add method that creates and returns an instance of the PatternFlowArpProtocolTypeMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowArpProtocolTypeMetricTag
        """
        item = PatternFlowArpProtocolTypeMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowArpHardwareLength(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 255,
        },
        "increment": {"type": "PatternFlowArpHardwareLengthCounter"},
        "decrement": {"type": "PatternFlowArpHardwareLengthCounter"},
        "metric_tags": {"type": "PatternFlowArpHardwareLengthMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 6,
        "values": [6],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=6, values=[6]):
        super(PatternFlowArpHardwareLength, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowArpHardwareLengthCounter
        """Factory property that returns an instance of the PatternFlowArpHardwareLengthCounter class

        integer counter pattern

        Returns: PatternFlowArpHardwareLengthCounter
        """
        return self._get_property(
            "increment", PatternFlowArpHardwareLengthCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowArpHardwareLengthCounter
        """Factory property that returns an instance of the PatternFlowArpHardwareLengthCounter class

        integer counter pattern

        Returns: PatternFlowArpHardwareLengthCounter
        """
        return self._get_property(
            "decrement", PatternFlowArpHardwareLengthCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowArpHardwareLengthMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowArpHardwareLengthMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowArpHardwareLengthMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowArpHardwareLengthCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 6,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=6, step=1, count=1):
        super(PatternFlowArpHardwareLengthCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowArpHardwareLengthMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 8,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 8,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=8):
        super(PatternFlowArpHardwareLengthMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowArpHardwareLengthMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowArpHardwareLengthMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowArpHardwareLengthMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowArpHardwareLengthMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowArpHardwareLengthMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowArpHardwareLengthMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowArpHardwareLengthMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowArpHardwareLengthMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=8):
        # type: (str,int,int) -> PatternFlowArpHardwareLengthMetricTagIter
        """Factory method that creates an instance of the PatternFlowArpHardwareLengthMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowArpHardwareLengthMetricTagIter
        """
        item = PatternFlowArpHardwareLengthMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=8):
        # type: (str,int,int) -> PatternFlowArpHardwareLengthMetricTag
        """Add method that creates and returns an instance of the PatternFlowArpHardwareLengthMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowArpHardwareLengthMetricTag
        """
        item = PatternFlowArpHardwareLengthMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowArpProtocolLength(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 255,
        },
        "increment": {"type": "PatternFlowArpProtocolLengthCounter"},
        "decrement": {"type": "PatternFlowArpProtocolLengthCounter"},
        "metric_tags": {"type": "PatternFlowArpProtocolLengthMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 4,
        "values": [4],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=4, values=[4]):
        super(PatternFlowArpProtocolLength, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowArpProtocolLengthCounter
        """Factory property that returns an instance of the PatternFlowArpProtocolLengthCounter class

        integer counter pattern

        Returns: PatternFlowArpProtocolLengthCounter
        """
        return self._get_property(
            "increment", PatternFlowArpProtocolLengthCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowArpProtocolLengthCounter
        """Factory property that returns an instance of the PatternFlowArpProtocolLengthCounter class

        integer counter pattern

        Returns: PatternFlowArpProtocolLengthCounter
        """
        return self._get_property(
            "decrement", PatternFlowArpProtocolLengthCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowArpProtocolLengthMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowArpProtocolLengthMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowArpProtocolLengthMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowArpProtocolLengthCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 4,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=4, step=1, count=1):
        super(PatternFlowArpProtocolLengthCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowArpProtocolLengthMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 8,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 8,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=8):
        super(PatternFlowArpProtocolLengthMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowArpProtocolLengthMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowArpProtocolLengthMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowArpProtocolLengthMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowArpProtocolLengthMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowArpProtocolLengthMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowArpProtocolLengthMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowArpProtocolLengthMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowArpProtocolLengthMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=8):
        # type: (str,int,int) -> PatternFlowArpProtocolLengthMetricTagIter
        """Factory method that creates an instance of the PatternFlowArpProtocolLengthMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowArpProtocolLengthMetricTagIter
        """
        item = PatternFlowArpProtocolLengthMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=8):
        # type: (str,int,int) -> PatternFlowArpProtocolLengthMetricTag
        """Add method that creates and returns an instance of the PatternFlowArpProtocolLengthMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowArpProtocolLengthMetricTag
        """
        item = PatternFlowArpProtocolLengthMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowArpOperation(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 65535,
        },
        "increment": {"type": "PatternFlowArpOperationCounter"},
        "decrement": {"type": "PatternFlowArpOperationCounter"},
        "metric_tags": {"type": "PatternFlowArpOperationMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 1,
        "values": [1],
    }  # type: Dict[str, Union(type)]

    REQUEST = 1  #
    REPLY = 2  #

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=1, values=[1]):
        super(PatternFlowArpOperation, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowArpOperationCounter
        """Factory property that returns an instance of the PatternFlowArpOperationCounter class

        integer counter pattern

        Returns: PatternFlowArpOperationCounter
        """
        return self._get_property(
            "increment", PatternFlowArpOperationCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowArpOperationCounter
        """Factory property that returns an instance of the PatternFlowArpOperationCounter class

        integer counter pattern

        Returns: PatternFlowArpOperationCounter
        """
        return self._get_property(
            "decrement", PatternFlowArpOperationCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowArpOperationMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowArpOperationMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowArpOperationMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowArpOperationCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 1,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    REQUEST = 1  #
    REPLY = 2  #

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=1, step=1, count=1):
        super(PatternFlowArpOperationCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowArpOperationMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 16,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 16,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=16):
        super(PatternFlowArpOperationMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowArpOperationMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowArpOperationMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowArpOperationMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowArpOperationMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowArpOperationMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowArpOperationMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowArpOperationMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowArpOperationMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowArpOperationMetricTagIter
        """Factory method that creates an instance of the PatternFlowArpOperationMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowArpOperationMetricTagIter
        """
        item = PatternFlowArpOperationMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowArpOperationMetricTag
        """Add method that creates and returns an instance of the PatternFlowArpOperationMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowArpOperationMetricTag
        """
        item = PatternFlowArpOperationMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowArpSenderHardwareAddr(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": str,
            "format": "mac",
        },
        "values": {
            "type": list,
            "itemtype": str,
            "itemformat": "mac",
        },
        "increment": {"type": "PatternFlowArpSenderHardwareAddrCounter"},
        "decrement": {"type": "PatternFlowArpSenderHardwareAddrCounter"},
        "metric_tags": {"type": "PatternFlowArpSenderHardwareAddrMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": "00:00:00:00:00:00",
        "values": ["00:00:00:00:00:00"],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        choice=None,
        value="00:00:00:00:00:00",
        values=["00:00:00:00:00:00"],
    ):
        super(PatternFlowArpSenderHardwareAddr, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowArpSenderHardwareAddrCounter
        """Factory property that returns an instance of the PatternFlowArpSenderHardwareAddrCounter class

        mac counter pattern

        Returns: PatternFlowArpSenderHardwareAddrCounter
        """
        return self._get_property(
            "increment", PatternFlowArpSenderHardwareAddrCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowArpSenderHardwareAddrCounter
        """Factory property that returns an instance of the PatternFlowArpSenderHardwareAddrCounter class

        mac counter pattern

        Returns: PatternFlowArpSenderHardwareAddrCounter
        """
        return self._get_property(
            "decrement", PatternFlowArpSenderHardwareAddrCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> str
        """value getter

        TBD

        Returns: str
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: str
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[str]
        """values getter

        TBD

        Returns: List[str]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[str]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowArpSenderHardwareAddrMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowArpSenderHardwareAddrMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowArpSenderHardwareAddrMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowArpSenderHardwareAddrCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": str,
            "format": "mac",
        },
        "step": {
            "type": str,
            "format": "mac",
        },
        "count": {
            "type": int,
            "format": "uint32",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": "00:00:00:00:00:00",
        "step": "00:00:00:00:00:01",
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self, parent=None, start="00:00:00:00:00:00", step="00:00:00:00:00:01", count=1
    ):
        super(PatternFlowArpSenderHardwareAddrCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> str
        """start getter

        TBD

        Returns: str
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: str
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> str
        """step getter

        TBD

        Returns: str
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: str
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowArpSenderHardwareAddrMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 47,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 48,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 48,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=48):
        super(PatternFlowArpSenderHardwareAddrMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowArpSenderHardwareAddrMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowArpSenderHardwareAddrMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowArpSenderHardwareAddrMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowArpSenderHardwareAddrMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowArpSenderHardwareAddrMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowArpSenderHardwareAddrMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowArpSenderHardwareAddrMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowArpSenderHardwareAddrMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=48):
        # type: (str,int,int) -> PatternFlowArpSenderHardwareAddrMetricTagIter
        """Factory method that creates an instance of the PatternFlowArpSenderHardwareAddrMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowArpSenderHardwareAddrMetricTagIter
        """
        item = PatternFlowArpSenderHardwareAddrMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=48):
        # type: (str,int,int) -> PatternFlowArpSenderHardwareAddrMetricTag
        """Add method that creates and returns an instance of the PatternFlowArpSenderHardwareAddrMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowArpSenderHardwareAddrMetricTag
        """
        item = PatternFlowArpSenderHardwareAddrMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowArpSenderProtocolAddr(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": str,
            "format": "ipv4",
        },
        "values": {
            "type": list,
            "itemtype": str,
            "itemformat": "ipv4",
        },
        "increment": {"type": "PatternFlowArpSenderProtocolAddrCounter"},
        "decrement": {"type": "PatternFlowArpSenderProtocolAddrCounter"},
        "metric_tags": {"type": "PatternFlowArpSenderProtocolAddrMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": "0.0.0.0",
        "values": ["0.0.0.0"],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value="0.0.0.0", values=["0.0.0.0"]):
        super(PatternFlowArpSenderProtocolAddr, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowArpSenderProtocolAddrCounter
        """Factory property that returns an instance of the PatternFlowArpSenderProtocolAddrCounter class

        ipv4 counter pattern

        Returns: PatternFlowArpSenderProtocolAddrCounter
        """
        return self._get_property(
            "increment", PatternFlowArpSenderProtocolAddrCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowArpSenderProtocolAddrCounter
        """Factory property that returns an instance of the PatternFlowArpSenderProtocolAddrCounter class

        ipv4 counter pattern

        Returns: PatternFlowArpSenderProtocolAddrCounter
        """
        return self._get_property(
            "decrement", PatternFlowArpSenderProtocolAddrCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> str
        """value getter

        TBD

        Returns: str
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: str
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[str]
        """values getter

        TBD

        Returns: List[str]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[str]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowArpSenderProtocolAddrMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowArpSenderProtocolAddrMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowArpSenderProtocolAddrMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowArpSenderProtocolAddrCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": str,
            "format": "ipv4",
        },
        "step": {
            "type": str,
            "format": "ipv4",
        },
        "count": {
            "type": int,
            "format": "uint32",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": "0.0.0.0",
        "step": "0.0.0.1",
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start="0.0.0.0", step="0.0.0.1", count=1):
        super(PatternFlowArpSenderProtocolAddrCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> str
        """start getter

        TBD

        Returns: str
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: str
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> str
        """step getter

        TBD

        Returns: str
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: str
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowArpSenderProtocolAddrMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 31,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 32,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 32,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=32):
        super(PatternFlowArpSenderProtocolAddrMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowArpSenderProtocolAddrMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowArpSenderProtocolAddrMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowArpSenderProtocolAddrMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowArpSenderProtocolAddrMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowArpSenderProtocolAddrMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowArpSenderProtocolAddrMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowArpSenderProtocolAddrMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowArpSenderProtocolAddrMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=32):
        # type: (str,int,int) -> PatternFlowArpSenderProtocolAddrMetricTagIter
        """Factory method that creates an instance of the PatternFlowArpSenderProtocolAddrMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowArpSenderProtocolAddrMetricTagIter
        """
        item = PatternFlowArpSenderProtocolAddrMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=32):
        # type: (str,int,int) -> PatternFlowArpSenderProtocolAddrMetricTag
        """Add method that creates and returns an instance of the PatternFlowArpSenderProtocolAddrMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowArpSenderProtocolAddrMetricTag
        """
        item = PatternFlowArpSenderProtocolAddrMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowArpTargetHardwareAddr(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": str,
            "format": "mac",
        },
        "values": {
            "type": list,
            "itemtype": str,
            "itemformat": "mac",
        },
        "increment": {"type": "PatternFlowArpTargetHardwareAddrCounter"},
        "decrement": {"type": "PatternFlowArpTargetHardwareAddrCounter"},
        "metric_tags": {"type": "PatternFlowArpTargetHardwareAddrMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": "00:00:00:00:00:00",
        "values": ["00:00:00:00:00:00"],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        choice=None,
        value="00:00:00:00:00:00",
        values=["00:00:00:00:00:00"],
    ):
        super(PatternFlowArpTargetHardwareAddr, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowArpTargetHardwareAddrCounter
        """Factory property that returns an instance of the PatternFlowArpTargetHardwareAddrCounter class

        mac counter pattern

        Returns: PatternFlowArpTargetHardwareAddrCounter
        """
        return self._get_property(
            "increment", PatternFlowArpTargetHardwareAddrCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowArpTargetHardwareAddrCounter
        """Factory property that returns an instance of the PatternFlowArpTargetHardwareAddrCounter class

        mac counter pattern

        Returns: PatternFlowArpTargetHardwareAddrCounter
        """
        return self._get_property(
            "decrement", PatternFlowArpTargetHardwareAddrCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> str
        """value getter

        TBD

        Returns: str
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: str
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[str]
        """values getter

        TBD

        Returns: List[str]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[str]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowArpTargetHardwareAddrMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowArpTargetHardwareAddrMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowArpTargetHardwareAddrMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowArpTargetHardwareAddrCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": str,
            "format": "mac",
        },
        "step": {
            "type": str,
            "format": "mac",
        },
        "count": {
            "type": int,
            "format": "uint32",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": "00:00:00:00:00:00",
        "step": "00:00:00:00:00:01",
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self, parent=None, start="00:00:00:00:00:00", step="00:00:00:00:00:01", count=1
    ):
        super(PatternFlowArpTargetHardwareAddrCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> str
        """start getter

        TBD

        Returns: str
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: str
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> str
        """step getter

        TBD

        Returns: str
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: str
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowArpTargetHardwareAddrMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 47,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 48,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 48,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=48):
        super(PatternFlowArpTargetHardwareAddrMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowArpTargetHardwareAddrMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowArpTargetHardwareAddrMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowArpTargetHardwareAddrMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowArpTargetHardwareAddrMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowArpTargetHardwareAddrMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowArpTargetHardwareAddrMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowArpTargetHardwareAddrMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowArpTargetHardwareAddrMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=48):
        # type: (str,int,int) -> PatternFlowArpTargetHardwareAddrMetricTagIter
        """Factory method that creates an instance of the PatternFlowArpTargetHardwareAddrMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowArpTargetHardwareAddrMetricTagIter
        """
        item = PatternFlowArpTargetHardwareAddrMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=48):
        # type: (str,int,int) -> PatternFlowArpTargetHardwareAddrMetricTag
        """Add method that creates and returns an instance of the PatternFlowArpTargetHardwareAddrMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowArpTargetHardwareAddrMetricTag
        """
        item = PatternFlowArpTargetHardwareAddrMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowArpTargetProtocolAddr(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": str,
            "format": "ipv4",
        },
        "values": {
            "type": list,
            "itemtype": str,
            "itemformat": "ipv4",
        },
        "increment": {"type": "PatternFlowArpTargetProtocolAddrCounter"},
        "decrement": {"type": "PatternFlowArpTargetProtocolAddrCounter"},
        "metric_tags": {"type": "PatternFlowArpTargetProtocolAddrMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": "0.0.0.0",
        "values": ["0.0.0.0"],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value="0.0.0.0", values=["0.0.0.0"]):
        super(PatternFlowArpTargetProtocolAddr, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowArpTargetProtocolAddrCounter
        """Factory property that returns an instance of the PatternFlowArpTargetProtocolAddrCounter class

        ipv4 counter pattern

        Returns: PatternFlowArpTargetProtocolAddrCounter
        """
        return self._get_property(
            "increment", PatternFlowArpTargetProtocolAddrCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowArpTargetProtocolAddrCounter
        """Factory property that returns an instance of the PatternFlowArpTargetProtocolAddrCounter class

        ipv4 counter pattern

        Returns: PatternFlowArpTargetProtocolAddrCounter
        """
        return self._get_property(
            "decrement", PatternFlowArpTargetProtocolAddrCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> str
        """value getter

        TBD

        Returns: str
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: str
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[str]
        """values getter

        TBD

        Returns: List[str]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[str]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowArpTargetProtocolAddrMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowArpTargetProtocolAddrMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowArpTargetProtocolAddrMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowArpTargetProtocolAddrCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": str,
            "format": "ipv4",
        },
        "step": {
            "type": str,
            "format": "ipv4",
        },
        "count": {
            "type": int,
            "format": "uint32",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": "0.0.0.0",
        "step": "0.0.0.1",
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start="0.0.0.0", step="0.0.0.1", count=1):
        super(PatternFlowArpTargetProtocolAddrCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> str
        """start getter

        TBD

        Returns: str
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: str
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> str
        """step getter

        TBD

        Returns: str
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: str
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowArpTargetProtocolAddrMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 31,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 32,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 32,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=32):
        super(PatternFlowArpTargetProtocolAddrMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowArpTargetProtocolAddrMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowArpTargetProtocolAddrMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowArpTargetProtocolAddrMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowArpTargetProtocolAddrMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowArpTargetProtocolAddrMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowArpTargetProtocolAddrMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowArpTargetProtocolAddrMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowArpTargetProtocolAddrMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=32):
        # type: (str,int,int) -> PatternFlowArpTargetProtocolAddrMetricTagIter
        """Factory method that creates an instance of the PatternFlowArpTargetProtocolAddrMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowArpTargetProtocolAddrMetricTagIter
        """
        item = PatternFlowArpTargetProtocolAddrMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=32):
        # type: (str,int,int) -> PatternFlowArpTargetProtocolAddrMetricTag
        """Add method that creates and returns an instance of the PatternFlowArpTargetProtocolAddrMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowArpTargetProtocolAddrMetricTag
        """
        item = PatternFlowArpTargetProtocolAddrMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class FlowIcmp(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "echo",
            ],
        },
        "echo": {"type": "FlowIcmpEcho"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "echo",
    }  # type: Dict[str, Union(type)]

    ECHO = "echo"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None):
        super(FlowIcmp, self).__init__()
        self._parent = parent
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    @property
    def echo(self):
        # type: () -> FlowIcmpEcho
        """Factory property that returns an instance of the FlowIcmpEcho class

        Packet Header for ICMP echo request

        Returns: FlowIcmpEcho
        """
        return self._get_property("echo", FlowIcmpEcho, self, "echo")

    @property
    def choice(self):
        # type: () -> Union[Literal["echo"]]
        """choice getter

        TBD

        Returns: Union[Literal["echo"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["echo"]]
        """
        self._set_property("choice", value)


class FlowIcmpEcho(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "type": {"type": "PatternFlowIcmpEchoType"},
        "code": {"type": "PatternFlowIcmpEchoCode"},
        "checksum": {"type": "PatternFlowIcmpEchoChecksum"},
        "identifier": {"type": "PatternFlowIcmpEchoIdentifier"},
        "sequence_number": {"type": "PatternFlowIcmpEchoSequenceNumber"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None):
        super(FlowIcmpEcho, self).__init__()
        self._parent = parent

    @property
    def type(self):
        # type: () -> PatternFlowIcmpEchoType
        """type getter

        The type of ICMP echo packetThe type of ICMP echo packetThe type of ICMP echo packetThe type of ICMP echo packet

        Returns: PatternFlowIcmpEchoType
        """
        return self._get_property("type", PatternFlowIcmpEchoType)

    @property
    def code(self):
        # type: () -> PatternFlowIcmpEchoCode
        """code getter

        The ICMP subtype. The default code for ICMP echo request and reply is 0.The ICMP subtype. The default code for ICMP echo request and reply is 0.The ICMP subtype. The default code for ICMP echo request and reply is 0.The ICMP subtype. The default code for ICMP echo request and reply is 0.

        Returns: PatternFlowIcmpEchoCode
        """
        return self._get_property("code", PatternFlowIcmpEchoCode)

    @property
    def checksum(self):
        # type: () -> PatternFlowIcmpEchoChecksum
        """checksum getter

        ICMP checksumICMP checksumICMP checksumICMP checksum

        Returns: PatternFlowIcmpEchoChecksum
        """
        return self._get_property("checksum", PatternFlowIcmpEchoChecksum)

    @property
    def identifier(self):
        # type: () -> PatternFlowIcmpEchoIdentifier
        """identifier getter

        ICMP identifierICMP identifierICMP identifierICMP identifier

        Returns: PatternFlowIcmpEchoIdentifier
        """
        return self._get_property("identifier", PatternFlowIcmpEchoIdentifier)

    @property
    def sequence_number(self):
        # type: () -> PatternFlowIcmpEchoSequenceNumber
        """sequence_number getter

        ICMP sequence numberICMP sequence numberICMP sequence numberICMP sequence number

        Returns: PatternFlowIcmpEchoSequenceNumber
        """
        return self._get_property("sequence_number", PatternFlowIcmpEchoSequenceNumber)


class PatternFlowIcmpEchoType(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 255,
        },
        "increment": {"type": "PatternFlowIcmpEchoTypeCounter"},
        "decrement": {"type": "PatternFlowIcmpEchoTypeCounter"},
        "metric_tags": {"type": "PatternFlowIcmpEchoTypeMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 8,
        "values": [8],
    }  # type: Dict[str, Union(type)]

    REPLY = 0  #
    REQUEST = 8  #

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=8, values=[8]):
        super(PatternFlowIcmpEchoType, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowIcmpEchoTypeCounter
        """Factory property that returns an instance of the PatternFlowIcmpEchoTypeCounter class

        integer counter pattern

        Returns: PatternFlowIcmpEchoTypeCounter
        """
        return self._get_property(
            "increment", PatternFlowIcmpEchoTypeCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowIcmpEchoTypeCounter
        """Factory property that returns an instance of the PatternFlowIcmpEchoTypeCounter class

        integer counter pattern

        Returns: PatternFlowIcmpEchoTypeCounter
        """
        return self._get_property(
            "decrement", PatternFlowIcmpEchoTypeCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowIcmpEchoTypeMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIcmpEchoTypeMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowIcmpEchoTypeMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowIcmpEchoTypeCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 8,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    REPLY = 0  #
    REQUEST = 8  #

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=8, step=1, count=1):
        super(PatternFlowIcmpEchoTypeCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowIcmpEchoTypeMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 8,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 8,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=8):
        super(PatternFlowIcmpEchoTypeMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowIcmpEchoTypeMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowIcmpEchoTypeMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowIcmpEchoTypeMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowIcmpEchoTypeMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowIcmpEchoTypeMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowIcmpEchoTypeMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowIcmpEchoTypeMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowIcmpEchoTypeMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=8):
        # type: (str,int,int) -> PatternFlowIcmpEchoTypeMetricTagIter
        """Factory method that creates an instance of the PatternFlowIcmpEchoTypeMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIcmpEchoTypeMetricTagIter
        """
        item = PatternFlowIcmpEchoTypeMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=8):
        # type: (str,int,int) -> PatternFlowIcmpEchoTypeMetricTag
        """Add method that creates and returns an instance of the PatternFlowIcmpEchoTypeMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIcmpEchoTypeMetricTag
        """
        item = PatternFlowIcmpEchoTypeMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowIcmpEchoCode(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 255,
        },
        "increment": {"type": "PatternFlowIcmpEchoCodeCounter"},
        "decrement": {"type": "PatternFlowIcmpEchoCodeCounter"},
        "metric_tags": {"type": "PatternFlowIcmpEchoCodeMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowIcmpEchoCode, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowIcmpEchoCodeCounter
        """Factory property that returns an instance of the PatternFlowIcmpEchoCodeCounter class

        integer counter pattern

        Returns: PatternFlowIcmpEchoCodeCounter
        """
        return self._get_property(
            "increment", PatternFlowIcmpEchoCodeCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowIcmpEchoCodeCounter
        """Factory property that returns an instance of the PatternFlowIcmpEchoCodeCounter class

        integer counter pattern

        Returns: PatternFlowIcmpEchoCodeCounter
        """
        return self._get_property(
            "decrement", PatternFlowIcmpEchoCodeCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowIcmpEchoCodeMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIcmpEchoCodeMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowIcmpEchoCodeMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowIcmpEchoCodeCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowIcmpEchoCodeCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowIcmpEchoCodeMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 8,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 8,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=8):
        super(PatternFlowIcmpEchoCodeMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowIcmpEchoCodeMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowIcmpEchoCodeMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowIcmpEchoCodeMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowIcmpEchoCodeMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowIcmpEchoCodeMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowIcmpEchoCodeMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowIcmpEchoCodeMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowIcmpEchoCodeMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=8):
        # type: (str,int,int) -> PatternFlowIcmpEchoCodeMetricTagIter
        """Factory method that creates an instance of the PatternFlowIcmpEchoCodeMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIcmpEchoCodeMetricTagIter
        """
        item = PatternFlowIcmpEchoCodeMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=8):
        # type: (str,int,int) -> PatternFlowIcmpEchoCodeMetricTag
        """Add method that creates and returns an instance of the PatternFlowIcmpEchoCodeMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIcmpEchoCodeMetricTag
        """
        item = PatternFlowIcmpEchoCodeMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowIcmpEchoChecksum(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "generated",
                "custom",
            ],
        },
        "generated": {
            "type": str,
            "enum": [
                "good",
                "bad",
            ],
        },
        "custom": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "generated",
        "generated": "good",
    }  # type: Dict[str, Union(type)]

    GENERATED = "generated"  # type: str
    CUSTOM = "custom"  # type: str

    GOOD = "good"  # type: str
    BAD = "bad"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, generated="good", custom=None):
        super(PatternFlowIcmpEchoChecksum, self).__init__()
        self._parent = parent
        self._set_property("generated", generated)
        self._set_property("custom", custom)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, generated=None, custom=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def choice(self):
        # type: () -> Union[Literal["custom"], Literal["generated"]]
        """choice getter

        The type of checksum

        Returns: Union[Literal["custom"], Literal["generated"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        The type of checksum

        value: Union[Literal["custom"], Literal["generated"]]
        """
        self._set_property("choice", value)

    @property
    def generated(self):
        # type: () -> Union[Literal["bad"], Literal["good"]]
        """generated getter

        A system generated checksum value

        Returns: Union[Literal["bad"], Literal["good"]]
        """
        return self._get_property("generated")

    @generated.setter
    def generated(self, value):
        """generated setter

        A system generated checksum value

        value: Union[Literal["bad"], Literal["good"]]
        """
        self._set_property("generated", value, "generated")

    @property
    def custom(self):
        # type: () -> int
        """custom getter

        A custom checksum value

        Returns: int
        """
        return self._get_property("custom")

    @custom.setter
    def custom(self, value):
        """custom setter

        A custom checksum value

        value: int
        """
        self._set_property("custom", value, "custom")


class PatternFlowIcmpEchoIdentifier(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 65535,
        },
        "increment": {"type": "PatternFlowIcmpEchoIdentifierCounter"},
        "decrement": {"type": "PatternFlowIcmpEchoIdentifierCounter"},
        "metric_tags": {"type": "PatternFlowIcmpEchoIdentifierMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowIcmpEchoIdentifier, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowIcmpEchoIdentifierCounter
        """Factory property that returns an instance of the PatternFlowIcmpEchoIdentifierCounter class

        integer counter pattern

        Returns: PatternFlowIcmpEchoIdentifierCounter
        """
        return self._get_property(
            "increment", PatternFlowIcmpEchoIdentifierCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowIcmpEchoIdentifierCounter
        """Factory property that returns an instance of the PatternFlowIcmpEchoIdentifierCounter class

        integer counter pattern

        Returns: PatternFlowIcmpEchoIdentifierCounter
        """
        return self._get_property(
            "decrement", PatternFlowIcmpEchoIdentifierCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowIcmpEchoIdentifierMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIcmpEchoIdentifierMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowIcmpEchoIdentifierMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowIcmpEchoIdentifierCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowIcmpEchoIdentifierCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowIcmpEchoIdentifierMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 16,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 16,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=16):
        super(PatternFlowIcmpEchoIdentifierMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowIcmpEchoIdentifierMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowIcmpEchoIdentifierMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowIcmpEchoIdentifierMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowIcmpEchoIdentifierMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowIcmpEchoIdentifierMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowIcmpEchoIdentifierMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowIcmpEchoIdentifierMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowIcmpEchoIdentifierMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowIcmpEchoIdentifierMetricTagIter
        """Factory method that creates an instance of the PatternFlowIcmpEchoIdentifierMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIcmpEchoIdentifierMetricTagIter
        """
        item = PatternFlowIcmpEchoIdentifierMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowIcmpEchoIdentifierMetricTag
        """Add method that creates and returns an instance of the PatternFlowIcmpEchoIdentifierMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIcmpEchoIdentifierMetricTag
        """
        item = PatternFlowIcmpEchoIdentifierMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowIcmpEchoSequenceNumber(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 65535,
        },
        "increment": {"type": "PatternFlowIcmpEchoSequenceNumberCounter"},
        "decrement": {"type": "PatternFlowIcmpEchoSequenceNumberCounter"},
        "metric_tags": {"type": "PatternFlowIcmpEchoSequenceNumberMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowIcmpEchoSequenceNumber, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowIcmpEchoSequenceNumberCounter
        """Factory property that returns an instance of the PatternFlowIcmpEchoSequenceNumberCounter class

        integer counter pattern

        Returns: PatternFlowIcmpEchoSequenceNumberCounter
        """
        return self._get_property(
            "increment", PatternFlowIcmpEchoSequenceNumberCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowIcmpEchoSequenceNumberCounter
        """Factory property that returns an instance of the PatternFlowIcmpEchoSequenceNumberCounter class

        integer counter pattern

        Returns: PatternFlowIcmpEchoSequenceNumberCounter
        """
        return self._get_property(
            "decrement", PatternFlowIcmpEchoSequenceNumberCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowIcmpEchoSequenceNumberMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIcmpEchoSequenceNumberMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowIcmpEchoSequenceNumberMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowIcmpEchoSequenceNumberCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowIcmpEchoSequenceNumberCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowIcmpEchoSequenceNumberMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 16,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 16,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=16):
        super(PatternFlowIcmpEchoSequenceNumberMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowIcmpEchoSequenceNumberMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowIcmpEchoSequenceNumberMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowIcmpEchoSequenceNumberMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowIcmpEchoSequenceNumberMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowIcmpEchoSequenceNumberMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowIcmpEchoSequenceNumberMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowIcmpEchoSequenceNumberMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowIcmpEchoSequenceNumberMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowIcmpEchoSequenceNumberMetricTagIter
        """Factory method that creates an instance of the PatternFlowIcmpEchoSequenceNumberMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIcmpEchoSequenceNumberMetricTagIter
        """
        item = PatternFlowIcmpEchoSequenceNumberMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowIcmpEchoSequenceNumberMetricTag
        """Add method that creates and returns an instance of the PatternFlowIcmpEchoSequenceNumberMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIcmpEchoSequenceNumberMetricTag
        """
        item = PatternFlowIcmpEchoSequenceNumberMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class FlowIcmpv6(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "echo",
            ],
        },
        "echo": {"type": "FlowIcmpv6Echo"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "echo",
    }  # type: Dict[str, Union(type)]

    ECHO = "echo"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None):
        super(FlowIcmpv6, self).__init__()
        self._parent = parent
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    @property
    def echo(self):
        # type: () -> FlowIcmpv6Echo
        """Factory property that returns an instance of the FlowIcmpv6Echo class

        Packet Header for ICMPv6 Echo

        Returns: FlowIcmpv6Echo
        """
        return self._get_property("echo", FlowIcmpv6Echo, self, "echo")

    @property
    def choice(self):
        # type: () -> Union[Literal["echo"]]
        """choice getter

        TBD

        Returns: Union[Literal["echo"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["echo"]]
        """
        self._set_property("choice", value)


class FlowIcmpv6Echo(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "type": {"type": "PatternFlowIcmpv6EchoType"},
        "code": {"type": "PatternFlowIcmpv6EchoCode"},
        "identifier": {"type": "PatternFlowIcmpv6EchoIdentifier"},
        "sequence_number": {"type": "PatternFlowIcmpv6EchoSequenceNumber"},
        "checksum": {"type": "PatternFlowIcmpv6EchoChecksum"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None):
        super(FlowIcmpv6Echo, self).__init__()
        self._parent = parent

    @property
    def type(self):
        # type: () -> PatternFlowIcmpv6EchoType
        """type getter

        ICMPv6 echo typeICMPv6 echo typeICMPv6 echo typeICMPv6 echo type

        Returns: PatternFlowIcmpv6EchoType
        """
        return self._get_property("type", PatternFlowIcmpv6EchoType)

    @property
    def code(self):
        # type: () -> PatternFlowIcmpv6EchoCode
        """code getter

        ICMPv6 echo sub typeICMPv6 echo sub typeICMPv6 echo sub typeICMPv6 echo sub type

        Returns: PatternFlowIcmpv6EchoCode
        """
        return self._get_property("code", PatternFlowIcmpv6EchoCode)

    @property
    def identifier(self):
        # type: () -> PatternFlowIcmpv6EchoIdentifier
        """identifier getter

        ICMPv6 echo identifierICMPv6 echo identifierICMPv6 echo identifierICMPv6 echo identifier

        Returns: PatternFlowIcmpv6EchoIdentifier
        """
        return self._get_property("identifier", PatternFlowIcmpv6EchoIdentifier)

    @property
    def sequence_number(self):
        # type: () -> PatternFlowIcmpv6EchoSequenceNumber
        """sequence_number getter

        ICMPv6 echo sequence numberICMPv6 echo sequence numberICMPv6 echo sequence numberICMPv6 echo sequence number

        Returns: PatternFlowIcmpv6EchoSequenceNumber
        """
        return self._get_property(
            "sequence_number", PatternFlowIcmpv6EchoSequenceNumber
        )

    @property
    def checksum(self):
        # type: () -> PatternFlowIcmpv6EchoChecksum
        """checksum getter

        ICMPv6 checksumICMPv6 checksumICMPv6 checksumICMPv6 checksum

        Returns: PatternFlowIcmpv6EchoChecksum
        """
        return self._get_property("checksum", PatternFlowIcmpv6EchoChecksum)


class PatternFlowIcmpv6EchoType(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 255,
        },
        "increment": {"type": "PatternFlowIcmpv6EchoTypeCounter"},
        "decrement": {"type": "PatternFlowIcmpv6EchoTypeCounter"},
        "metric_tags": {"type": "PatternFlowIcmpv6EchoTypeMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 128,
        "values": [128],
    }  # type: Dict[str, Union(type)]

    REQUEST = 128  #
    REPLY = 129  #

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=128, values=[128]):
        super(PatternFlowIcmpv6EchoType, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowIcmpv6EchoTypeCounter
        """Factory property that returns an instance of the PatternFlowIcmpv6EchoTypeCounter class

        integer counter pattern

        Returns: PatternFlowIcmpv6EchoTypeCounter
        """
        return self._get_property(
            "increment", PatternFlowIcmpv6EchoTypeCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowIcmpv6EchoTypeCounter
        """Factory property that returns an instance of the PatternFlowIcmpv6EchoTypeCounter class

        integer counter pattern

        Returns: PatternFlowIcmpv6EchoTypeCounter
        """
        return self._get_property(
            "decrement", PatternFlowIcmpv6EchoTypeCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowIcmpv6EchoTypeMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIcmpv6EchoTypeMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowIcmpv6EchoTypeMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowIcmpv6EchoTypeCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 128,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    REQUEST = 128  #
    REPLY = 129  #

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=128, step=1, count=1):
        super(PatternFlowIcmpv6EchoTypeCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowIcmpv6EchoTypeMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 8,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 8,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=8):
        super(PatternFlowIcmpv6EchoTypeMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowIcmpv6EchoTypeMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowIcmpv6EchoTypeMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowIcmpv6EchoTypeMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowIcmpv6EchoTypeMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowIcmpv6EchoTypeMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowIcmpv6EchoTypeMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowIcmpv6EchoTypeMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowIcmpv6EchoTypeMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=8):
        # type: (str,int,int) -> PatternFlowIcmpv6EchoTypeMetricTagIter
        """Factory method that creates an instance of the PatternFlowIcmpv6EchoTypeMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIcmpv6EchoTypeMetricTagIter
        """
        item = PatternFlowIcmpv6EchoTypeMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=8):
        # type: (str,int,int) -> PatternFlowIcmpv6EchoTypeMetricTag
        """Add method that creates and returns an instance of the PatternFlowIcmpv6EchoTypeMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIcmpv6EchoTypeMetricTag
        """
        item = PatternFlowIcmpv6EchoTypeMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowIcmpv6EchoCode(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 255,
        },
        "increment": {"type": "PatternFlowIcmpv6EchoCodeCounter"},
        "decrement": {"type": "PatternFlowIcmpv6EchoCodeCounter"},
        "metric_tags": {"type": "PatternFlowIcmpv6EchoCodeMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowIcmpv6EchoCode, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowIcmpv6EchoCodeCounter
        """Factory property that returns an instance of the PatternFlowIcmpv6EchoCodeCounter class

        integer counter pattern

        Returns: PatternFlowIcmpv6EchoCodeCounter
        """
        return self._get_property(
            "increment", PatternFlowIcmpv6EchoCodeCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowIcmpv6EchoCodeCounter
        """Factory property that returns an instance of the PatternFlowIcmpv6EchoCodeCounter class

        integer counter pattern

        Returns: PatternFlowIcmpv6EchoCodeCounter
        """
        return self._get_property(
            "decrement", PatternFlowIcmpv6EchoCodeCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowIcmpv6EchoCodeMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIcmpv6EchoCodeMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowIcmpv6EchoCodeMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowIcmpv6EchoCodeCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowIcmpv6EchoCodeCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowIcmpv6EchoCodeMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 8,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 8,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=8):
        super(PatternFlowIcmpv6EchoCodeMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowIcmpv6EchoCodeMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowIcmpv6EchoCodeMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowIcmpv6EchoCodeMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowIcmpv6EchoCodeMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowIcmpv6EchoCodeMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowIcmpv6EchoCodeMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowIcmpv6EchoCodeMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowIcmpv6EchoCodeMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=8):
        # type: (str,int,int) -> PatternFlowIcmpv6EchoCodeMetricTagIter
        """Factory method that creates an instance of the PatternFlowIcmpv6EchoCodeMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIcmpv6EchoCodeMetricTagIter
        """
        item = PatternFlowIcmpv6EchoCodeMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=8):
        # type: (str,int,int) -> PatternFlowIcmpv6EchoCodeMetricTag
        """Add method that creates and returns an instance of the PatternFlowIcmpv6EchoCodeMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIcmpv6EchoCodeMetricTag
        """
        item = PatternFlowIcmpv6EchoCodeMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowIcmpv6EchoIdentifier(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 65535,
        },
        "increment": {"type": "PatternFlowIcmpv6EchoIdentifierCounter"},
        "decrement": {"type": "PatternFlowIcmpv6EchoIdentifierCounter"},
        "metric_tags": {"type": "PatternFlowIcmpv6EchoIdentifierMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowIcmpv6EchoIdentifier, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowIcmpv6EchoIdentifierCounter
        """Factory property that returns an instance of the PatternFlowIcmpv6EchoIdentifierCounter class

        integer counter pattern

        Returns: PatternFlowIcmpv6EchoIdentifierCounter
        """
        return self._get_property(
            "increment", PatternFlowIcmpv6EchoIdentifierCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowIcmpv6EchoIdentifierCounter
        """Factory property that returns an instance of the PatternFlowIcmpv6EchoIdentifierCounter class

        integer counter pattern

        Returns: PatternFlowIcmpv6EchoIdentifierCounter
        """
        return self._get_property(
            "decrement", PatternFlowIcmpv6EchoIdentifierCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowIcmpv6EchoIdentifierMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIcmpv6EchoIdentifierMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowIcmpv6EchoIdentifierMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowIcmpv6EchoIdentifierCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowIcmpv6EchoIdentifierCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowIcmpv6EchoIdentifierMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 16,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 16,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=16):
        super(PatternFlowIcmpv6EchoIdentifierMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowIcmpv6EchoIdentifierMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowIcmpv6EchoIdentifierMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowIcmpv6EchoIdentifierMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowIcmpv6EchoIdentifierMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowIcmpv6EchoIdentifierMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowIcmpv6EchoIdentifierMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowIcmpv6EchoIdentifierMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowIcmpv6EchoIdentifierMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowIcmpv6EchoIdentifierMetricTagIter
        """Factory method that creates an instance of the PatternFlowIcmpv6EchoIdentifierMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIcmpv6EchoIdentifierMetricTagIter
        """
        item = PatternFlowIcmpv6EchoIdentifierMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowIcmpv6EchoIdentifierMetricTag
        """Add method that creates and returns an instance of the PatternFlowIcmpv6EchoIdentifierMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIcmpv6EchoIdentifierMetricTag
        """
        item = PatternFlowIcmpv6EchoIdentifierMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowIcmpv6EchoSequenceNumber(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 65535,
        },
        "increment": {"type": "PatternFlowIcmpv6EchoSequenceNumberCounter"},
        "decrement": {"type": "PatternFlowIcmpv6EchoSequenceNumberCounter"},
        "metric_tags": {"type": "PatternFlowIcmpv6EchoSequenceNumberMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowIcmpv6EchoSequenceNumber, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowIcmpv6EchoSequenceNumberCounter
        """Factory property that returns an instance of the PatternFlowIcmpv6EchoSequenceNumberCounter class

        integer counter pattern

        Returns: PatternFlowIcmpv6EchoSequenceNumberCounter
        """
        return self._get_property(
            "increment", PatternFlowIcmpv6EchoSequenceNumberCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowIcmpv6EchoSequenceNumberCounter
        """Factory property that returns an instance of the PatternFlowIcmpv6EchoSequenceNumberCounter class

        integer counter pattern

        Returns: PatternFlowIcmpv6EchoSequenceNumberCounter
        """
        return self._get_property(
            "decrement", PatternFlowIcmpv6EchoSequenceNumberCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowIcmpv6EchoSequenceNumberMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIcmpv6EchoSequenceNumberMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowIcmpv6EchoSequenceNumberMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowIcmpv6EchoSequenceNumberCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowIcmpv6EchoSequenceNumberCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowIcmpv6EchoSequenceNumberMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 16,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 16,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=16):
        super(PatternFlowIcmpv6EchoSequenceNumberMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowIcmpv6EchoSequenceNumberMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowIcmpv6EchoSequenceNumberMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowIcmpv6EchoSequenceNumberMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowIcmpv6EchoSequenceNumberMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowIcmpv6EchoSequenceNumberMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowIcmpv6EchoSequenceNumberMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowIcmpv6EchoSequenceNumberMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowIcmpv6EchoSequenceNumberMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowIcmpv6EchoSequenceNumberMetricTagIter
        """Factory method that creates an instance of the PatternFlowIcmpv6EchoSequenceNumberMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIcmpv6EchoSequenceNumberMetricTagIter
        """
        item = PatternFlowIcmpv6EchoSequenceNumberMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowIcmpv6EchoSequenceNumberMetricTag
        """Add method that creates and returns an instance of the PatternFlowIcmpv6EchoSequenceNumberMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIcmpv6EchoSequenceNumberMetricTag
        """
        item = PatternFlowIcmpv6EchoSequenceNumberMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowIcmpv6EchoChecksum(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "generated",
                "custom",
            ],
        },
        "generated": {
            "type": str,
            "enum": [
                "good",
                "bad",
            ],
        },
        "custom": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "generated",
        "generated": "good",
    }  # type: Dict[str, Union(type)]

    GENERATED = "generated"  # type: str
    CUSTOM = "custom"  # type: str

    GOOD = "good"  # type: str
    BAD = "bad"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, generated="good", custom=None):
        super(PatternFlowIcmpv6EchoChecksum, self).__init__()
        self._parent = parent
        self._set_property("generated", generated)
        self._set_property("custom", custom)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, generated=None, custom=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def choice(self):
        # type: () -> Union[Literal["custom"], Literal["generated"]]
        """choice getter

        The type of checksum

        Returns: Union[Literal["custom"], Literal["generated"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        The type of checksum

        value: Union[Literal["custom"], Literal["generated"]]
        """
        self._set_property("choice", value)

    @property
    def generated(self):
        # type: () -> Union[Literal["bad"], Literal["good"]]
        """generated getter

        A system generated checksum value

        Returns: Union[Literal["bad"], Literal["good"]]
        """
        return self._get_property("generated")

    @generated.setter
    def generated(self, value):
        """generated setter

        A system generated checksum value

        value: Union[Literal["bad"], Literal["good"]]
        """
        self._set_property("generated", value, "generated")

    @property
    def custom(self):
        # type: () -> int
        """custom getter

        A custom checksum value

        Returns: int
        """
        return self._get_property("custom")

    @custom.setter
    def custom(self, value):
        """custom setter

        A custom checksum value

        value: int
        """
        self._set_property("custom", value, "custom")


class FlowPpp(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "address": {"type": "PatternFlowPppAddress"},
        "control": {"type": "PatternFlowPppControl"},
        "protocol_type": {"type": "PatternFlowPppProtocolType"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None):
        super(FlowPpp, self).__init__()
        self._parent = parent

    @property
    def address(self):
        # type: () -> PatternFlowPppAddress
        """address getter

        PPP addressPPP addressPPP addressPPP address

        Returns: PatternFlowPppAddress
        """
        return self._get_property("address", PatternFlowPppAddress)

    @property
    def control(self):
        # type: () -> PatternFlowPppControl
        """control getter

        PPP controlPPP controlPPP controlPPP control

        Returns: PatternFlowPppControl
        """
        return self._get_property("control", PatternFlowPppControl)

    @property
    def protocol_type(self):
        # type: () -> PatternFlowPppProtocolType
        """protocol_type getter

        PPP protocol typePPP protocol typePPP protocol typePPP protocol type

        Returns: PatternFlowPppProtocolType
        """
        return self._get_property("protocol_type", PatternFlowPppProtocolType)


class PatternFlowPppAddress(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 255,
        },
        "increment": {"type": "PatternFlowPppAddressCounter"},
        "decrement": {"type": "PatternFlowPppAddressCounter"},
        "metric_tags": {"type": "PatternFlowPppAddressMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 255,
        "values": [255],
    }  # type: Dict[str, Union(type)]

    STANDARD_ADDRESS = 255  #

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=255, values=[255]):
        super(PatternFlowPppAddress, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowPppAddressCounter
        """Factory property that returns an instance of the PatternFlowPppAddressCounter class

        integer counter pattern

        Returns: PatternFlowPppAddressCounter
        """
        return self._get_property(
            "increment", PatternFlowPppAddressCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowPppAddressCounter
        """Factory property that returns an instance of the PatternFlowPppAddressCounter class

        integer counter pattern

        Returns: PatternFlowPppAddressCounter
        """
        return self._get_property(
            "decrement", PatternFlowPppAddressCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowPppAddressMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowPppAddressMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowPppAddressMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowPppAddressCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 255,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    STANDARD_ADDRESS = 255  #

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=255, step=1, count=1):
        super(PatternFlowPppAddressCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowPppAddressMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 8,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 8,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=8):
        super(PatternFlowPppAddressMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowPppAddressMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowPppAddressMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowPppAddressMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowPppAddressMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowPppAddressMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowPppAddressMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowPppAddressMetricTag):
            raise Exception("Item is not an instance of PatternFlowPppAddressMetricTag")

    def metrictag(self, name=None, offset=0, length=8):
        # type: (str,int,int) -> PatternFlowPppAddressMetricTagIter
        """Factory method that creates an instance of the PatternFlowPppAddressMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowPppAddressMetricTagIter
        """
        item = PatternFlowPppAddressMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=8):
        # type: (str,int,int) -> PatternFlowPppAddressMetricTag
        """Add method that creates and returns an instance of the PatternFlowPppAddressMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowPppAddressMetricTag
        """
        item = PatternFlowPppAddressMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowPppControl(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 255,
        },
        "increment": {"type": "PatternFlowPppControlCounter"},
        "decrement": {"type": "PatternFlowPppControlCounter"},
        "metric_tags": {"type": "PatternFlowPppControlMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 3,
        "values": [3],
    }  # type: Dict[str, Union(type)]

    UNNUMBERED_DATA = 3  #

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=3, values=[3]):
        super(PatternFlowPppControl, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowPppControlCounter
        """Factory property that returns an instance of the PatternFlowPppControlCounter class

        integer counter pattern

        Returns: PatternFlowPppControlCounter
        """
        return self._get_property(
            "increment", PatternFlowPppControlCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowPppControlCounter
        """Factory property that returns an instance of the PatternFlowPppControlCounter class

        integer counter pattern

        Returns: PatternFlowPppControlCounter
        """
        return self._get_property(
            "decrement", PatternFlowPppControlCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowPppControlMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowPppControlMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowPppControlMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowPppControlCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 3,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    UNNUMBERED_DATA = 3  #

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=3, step=1, count=1):
        super(PatternFlowPppControlCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowPppControlMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 8,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 8,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=8):
        super(PatternFlowPppControlMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowPppControlMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowPppControlMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowPppControlMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowPppControlMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowPppControlMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowPppControlMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowPppControlMetricTag):
            raise Exception("Item is not an instance of PatternFlowPppControlMetricTag")

    def metrictag(self, name=None, offset=0, length=8):
        # type: (str,int,int) -> PatternFlowPppControlMetricTagIter
        """Factory method that creates an instance of the PatternFlowPppControlMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowPppControlMetricTagIter
        """
        item = PatternFlowPppControlMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=8):
        # type: (str,int,int) -> PatternFlowPppControlMetricTag
        """Add method that creates and returns an instance of the PatternFlowPppControlMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowPppControlMetricTag
        """
        item = PatternFlowPppControlMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowPppProtocolType(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "auto",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 65535,
        },
        "auto": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "increment": {"type": "PatternFlowPppProtocolTypeCounter"},
        "decrement": {"type": "PatternFlowPppProtocolTypeCounter"},
        "metric_tags": {"type": "PatternFlowPppProtocolTypeMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "auto",
        "value": 33,
        "values": [33],
        "auto": 33,
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    AUTO = "auto"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=33, values=[33], auto=33):
        super(PatternFlowPppProtocolType, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        self._set_property("auto", auto)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None, auto=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowPppProtocolTypeCounter
        """Factory property that returns an instance of the PatternFlowPppProtocolTypeCounter class

        integer counter pattern

        Returns: PatternFlowPppProtocolTypeCounter
        """
        return self._get_property(
            "increment", PatternFlowPppProtocolTypeCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowPppProtocolTypeCounter
        """Factory property that returns an instance of the PatternFlowPppProtocolTypeCounter class

        integer counter pattern

        Returns: PatternFlowPppProtocolTypeCounter
        """
        return self._get_property(
            "decrement", PatternFlowPppProtocolTypeCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["auto"], Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["auto"], Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["auto"], Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def auto(self):
        # type: () -> int
        """auto getter

        The OTG implementation can provide system generated. value for this property. If the OTG is unable to generate value. the default value must be used.

        Returns: int
        """
        return self._get_property("auto")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowPppProtocolTypeMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowPppProtocolTypeMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowPppProtocolTypeMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowPppProtocolTypeCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 33,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=33, step=1, count=1):
        super(PatternFlowPppProtocolTypeCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowPppProtocolTypeMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 16,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 16,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=16):
        super(PatternFlowPppProtocolTypeMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowPppProtocolTypeMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowPppProtocolTypeMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowPppProtocolTypeMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowPppProtocolTypeMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowPppProtocolTypeMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowPppProtocolTypeMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowPppProtocolTypeMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowPppProtocolTypeMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowPppProtocolTypeMetricTagIter
        """Factory method that creates an instance of the PatternFlowPppProtocolTypeMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowPppProtocolTypeMetricTagIter
        """
        item = PatternFlowPppProtocolTypeMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=16):
        # type: (str,int,int) -> PatternFlowPppProtocolTypeMetricTag
        """Add method that creates and returns an instance of the PatternFlowPppProtocolTypeMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowPppProtocolTypeMetricTag
        """
        item = PatternFlowPppProtocolTypeMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class FlowIgmpv1(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "version": {"type": "PatternFlowIgmpv1Version"},
        "type": {"type": "PatternFlowIgmpv1Type"},
        "unused": {"type": "PatternFlowIgmpv1Unused"},
        "checksum": {"type": "PatternFlowIgmpv1Checksum"},
        "group_address": {"type": "PatternFlowIgmpv1GroupAddress"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None):
        super(FlowIgmpv1, self).__init__()
        self._parent = parent

    @property
    def version(self):
        # type: () -> PatternFlowIgmpv1Version
        """version getter

        Version numberVersion numberVersion numberVersion number

        Returns: PatternFlowIgmpv1Version
        """
        return self._get_property("version", PatternFlowIgmpv1Version)

    @property
    def type(self):
        # type: () -> PatternFlowIgmpv1Type
        """type getter

        Type of messageType of messageType of messageType of message

        Returns: PatternFlowIgmpv1Type
        """
        return self._get_property("type", PatternFlowIgmpv1Type)

    @property
    def unused(self):
        # type: () -> PatternFlowIgmpv1Unused
        """unused getter

        UnusedUnusedUnusedUnused

        Returns: PatternFlowIgmpv1Unused
        """
        return self._get_property("unused", PatternFlowIgmpv1Unused)

    @property
    def checksum(self):
        # type: () -> PatternFlowIgmpv1Checksum
        """checksum getter

        ChecksumChecksumChecksumChecksum

        Returns: PatternFlowIgmpv1Checksum
        """
        return self._get_property("checksum", PatternFlowIgmpv1Checksum)

    @property
    def group_address(self):
        # type: () -> PatternFlowIgmpv1GroupAddress
        """group_address getter

        Group addressGroup addressGroup addressGroup address

        Returns: PatternFlowIgmpv1GroupAddress
        """
        return self._get_property("group_address", PatternFlowIgmpv1GroupAddress)


class PatternFlowIgmpv1Version(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 15,
        },
        "increment": {"type": "PatternFlowIgmpv1VersionCounter"},
        "decrement": {"type": "PatternFlowIgmpv1VersionCounter"},
        "metric_tags": {"type": "PatternFlowIgmpv1VersionMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 1,
        "values": [1],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=1, values=[1]):
        super(PatternFlowIgmpv1Version, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowIgmpv1VersionCounter
        """Factory property that returns an instance of the PatternFlowIgmpv1VersionCounter class

        integer counter pattern

        Returns: PatternFlowIgmpv1VersionCounter
        """
        return self._get_property(
            "increment", PatternFlowIgmpv1VersionCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowIgmpv1VersionCounter
        """Factory property that returns an instance of the PatternFlowIgmpv1VersionCounter class

        integer counter pattern

        Returns: PatternFlowIgmpv1VersionCounter
        """
        return self._get_property(
            "decrement", PatternFlowIgmpv1VersionCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowIgmpv1VersionMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIgmpv1VersionMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowIgmpv1VersionMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowIgmpv1VersionCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 1,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=1, step=1, count=1):
        super(PatternFlowIgmpv1VersionCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowIgmpv1VersionMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 3,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 4,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 4,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=4):
        super(PatternFlowIgmpv1VersionMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowIgmpv1VersionMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowIgmpv1VersionMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowIgmpv1VersionMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowIgmpv1VersionMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowIgmpv1VersionMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowIgmpv1VersionMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowIgmpv1VersionMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowIgmpv1VersionMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=4):
        # type: (str,int,int) -> PatternFlowIgmpv1VersionMetricTagIter
        """Factory method that creates an instance of the PatternFlowIgmpv1VersionMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIgmpv1VersionMetricTagIter
        """
        item = PatternFlowIgmpv1VersionMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=4):
        # type: (str,int,int) -> PatternFlowIgmpv1VersionMetricTag
        """Add method that creates and returns an instance of the PatternFlowIgmpv1VersionMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIgmpv1VersionMetricTag
        """
        item = PatternFlowIgmpv1VersionMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowIgmpv1Type(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 15,
        },
        "increment": {"type": "PatternFlowIgmpv1TypeCounter"},
        "decrement": {"type": "PatternFlowIgmpv1TypeCounter"},
        "metric_tags": {"type": "PatternFlowIgmpv1TypeMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 1,
        "values": [1],
    }  # type: Dict[str, Union(type)]

    QUERY = 1  #
    REPORT = 2  #

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=1, values=[1]):
        super(PatternFlowIgmpv1Type, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowIgmpv1TypeCounter
        """Factory property that returns an instance of the PatternFlowIgmpv1TypeCounter class

        integer counter pattern

        Returns: PatternFlowIgmpv1TypeCounter
        """
        return self._get_property(
            "increment", PatternFlowIgmpv1TypeCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowIgmpv1TypeCounter
        """Factory property that returns an instance of the PatternFlowIgmpv1TypeCounter class

        integer counter pattern

        Returns: PatternFlowIgmpv1TypeCounter
        """
        return self._get_property(
            "decrement", PatternFlowIgmpv1TypeCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowIgmpv1TypeMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIgmpv1TypeMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowIgmpv1TypeMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowIgmpv1TypeCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 15,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 1,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    QUERY = 1  #
    REPORT = 2  #

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=1, step=1, count=1):
        super(PatternFlowIgmpv1TypeCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowIgmpv1TypeMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 3,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 4,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 4,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=4):
        super(PatternFlowIgmpv1TypeMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowIgmpv1TypeMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowIgmpv1TypeMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowIgmpv1TypeMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowIgmpv1TypeMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowIgmpv1TypeMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowIgmpv1TypeMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowIgmpv1TypeMetricTag):
            raise Exception("Item is not an instance of PatternFlowIgmpv1TypeMetricTag")

    def metrictag(self, name=None, offset=0, length=4):
        # type: (str,int,int) -> PatternFlowIgmpv1TypeMetricTagIter
        """Factory method that creates an instance of the PatternFlowIgmpv1TypeMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIgmpv1TypeMetricTagIter
        """
        item = PatternFlowIgmpv1TypeMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=4):
        # type: (str,int,int) -> PatternFlowIgmpv1TypeMetricTag
        """Add method that creates and returns an instance of the PatternFlowIgmpv1TypeMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIgmpv1TypeMetricTag
        """
        item = PatternFlowIgmpv1TypeMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowIgmpv1Unused(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 255,
        },
        "increment": {"type": "PatternFlowIgmpv1UnusedCounter"},
        "decrement": {"type": "PatternFlowIgmpv1UnusedCounter"},
        "metric_tags": {"type": "PatternFlowIgmpv1UnusedMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowIgmpv1Unused, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowIgmpv1UnusedCounter
        """Factory property that returns an instance of the PatternFlowIgmpv1UnusedCounter class

        integer counter pattern

        Returns: PatternFlowIgmpv1UnusedCounter
        """
        return self._get_property(
            "increment", PatternFlowIgmpv1UnusedCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowIgmpv1UnusedCounter
        """Factory property that returns an instance of the PatternFlowIgmpv1UnusedCounter class

        integer counter pattern

        Returns: PatternFlowIgmpv1UnusedCounter
        """
        return self._get_property(
            "decrement", PatternFlowIgmpv1UnusedCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowIgmpv1UnusedMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIgmpv1UnusedMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowIgmpv1UnusedMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowIgmpv1UnusedCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowIgmpv1UnusedCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowIgmpv1UnusedMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 8,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 8,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=8):
        super(PatternFlowIgmpv1UnusedMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowIgmpv1UnusedMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowIgmpv1UnusedMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowIgmpv1UnusedMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowIgmpv1UnusedMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowIgmpv1UnusedMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowIgmpv1UnusedMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowIgmpv1UnusedMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowIgmpv1UnusedMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=8):
        # type: (str,int,int) -> PatternFlowIgmpv1UnusedMetricTagIter
        """Factory method that creates an instance of the PatternFlowIgmpv1UnusedMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIgmpv1UnusedMetricTagIter
        """
        item = PatternFlowIgmpv1UnusedMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=8):
        # type: (str,int,int) -> PatternFlowIgmpv1UnusedMetricTag
        """Add method that creates and returns an instance of the PatternFlowIgmpv1UnusedMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIgmpv1UnusedMetricTag
        """
        item = PatternFlowIgmpv1UnusedMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowIgmpv1Checksum(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "generated",
                "custom",
            ],
        },
        "generated": {
            "type": str,
            "enum": [
                "good",
                "bad",
            ],
        },
        "custom": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "generated",
        "generated": "good",
    }  # type: Dict[str, Union(type)]

    GENERATED = "generated"  # type: str
    CUSTOM = "custom"  # type: str

    GOOD = "good"  # type: str
    BAD = "bad"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, generated="good", custom=None):
        super(PatternFlowIgmpv1Checksum, self).__init__()
        self._parent = parent
        self._set_property("generated", generated)
        self._set_property("custom", custom)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, generated=None, custom=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def choice(self):
        # type: () -> Union[Literal["custom"], Literal["generated"]]
        """choice getter

        The type of checksum

        Returns: Union[Literal["custom"], Literal["generated"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        The type of checksum

        value: Union[Literal["custom"], Literal["generated"]]
        """
        self._set_property("choice", value)

    @property
    def generated(self):
        # type: () -> Union[Literal["bad"], Literal["good"]]
        """generated getter

        A system generated checksum value

        Returns: Union[Literal["bad"], Literal["good"]]
        """
        return self._get_property("generated")

    @generated.setter
    def generated(self, value):
        """generated setter

        A system generated checksum value

        value: Union[Literal["bad"], Literal["good"]]
        """
        self._set_property("generated", value, "generated")

    @property
    def custom(self):
        # type: () -> int
        """custom getter

        A custom checksum value

        Returns: int
        """
        return self._get_property("custom")

    @custom.setter
    def custom(self, value):
        """custom setter

        A custom checksum value

        value: int
        """
        self._set_property("custom", value, "custom")


class PatternFlowIgmpv1GroupAddress(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": str,
            "format": "ipv4",
        },
        "values": {
            "type": list,
            "itemtype": str,
            "itemformat": "ipv4",
        },
        "increment": {"type": "PatternFlowIgmpv1GroupAddressCounter"},
        "decrement": {"type": "PatternFlowIgmpv1GroupAddressCounter"},
        "metric_tags": {"type": "PatternFlowIgmpv1GroupAddressMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": "0.0.0.0",
        "values": ["0.0.0.0"],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value="0.0.0.0", values=["0.0.0.0"]):
        super(PatternFlowIgmpv1GroupAddress, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowIgmpv1GroupAddressCounter
        """Factory property that returns an instance of the PatternFlowIgmpv1GroupAddressCounter class

        ipv4 counter pattern

        Returns: PatternFlowIgmpv1GroupAddressCounter
        """
        return self._get_property(
            "increment", PatternFlowIgmpv1GroupAddressCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowIgmpv1GroupAddressCounter
        """Factory property that returns an instance of the PatternFlowIgmpv1GroupAddressCounter class

        ipv4 counter pattern

        Returns: PatternFlowIgmpv1GroupAddressCounter
        """
        return self._get_property(
            "decrement", PatternFlowIgmpv1GroupAddressCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> str
        """value getter

        TBD

        Returns: str
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: str
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[str]
        """values getter

        TBD

        Returns: List[str]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[str]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowIgmpv1GroupAddressMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIgmpv1GroupAddressMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowIgmpv1GroupAddressMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowIgmpv1GroupAddressCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": str,
            "format": "ipv4",
        },
        "step": {
            "type": str,
            "format": "ipv4",
        },
        "count": {
            "type": int,
            "format": "uint32",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": "0.0.0.0",
        "step": "0.0.0.1",
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start="0.0.0.0", step="0.0.0.1", count=1):
        super(PatternFlowIgmpv1GroupAddressCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> str
        """start getter

        TBD

        Returns: str
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: str
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> str
        """step getter

        TBD

        Returns: str
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: str
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowIgmpv1GroupAddressMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 31,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 32,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 32,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=32):
        super(PatternFlowIgmpv1GroupAddressMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowIgmpv1GroupAddressMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowIgmpv1GroupAddressMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowIgmpv1GroupAddressMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowIgmpv1GroupAddressMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowIgmpv1GroupAddressMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowIgmpv1GroupAddressMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowIgmpv1GroupAddressMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowIgmpv1GroupAddressMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=32):
        # type: (str,int,int) -> PatternFlowIgmpv1GroupAddressMetricTagIter
        """Factory method that creates an instance of the PatternFlowIgmpv1GroupAddressMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIgmpv1GroupAddressMetricTagIter
        """
        item = PatternFlowIgmpv1GroupAddressMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=32):
        # type: (str,int,int) -> PatternFlowIgmpv1GroupAddressMetricTag
        """Add method that creates and returns an instance of the PatternFlowIgmpv1GroupAddressMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowIgmpv1GroupAddressMetricTag
        """
        item = PatternFlowIgmpv1GroupAddressMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class FlowMpls(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "label": {"type": "PatternFlowMplsLabel"},
        "traffic_class": {"type": "PatternFlowMplsTrafficClass"},
        "bottom_of_stack": {"type": "PatternFlowMplsBottomOfStack"},
        "time_to_live": {"type": "PatternFlowMplsTimeToLive"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None):
        super(FlowMpls, self).__init__()
        self._parent = parent

    @property
    def label(self):
        # type: () -> PatternFlowMplsLabel
        """label getter

        Label of routersLabel of routersLabel of routersLabel of routers

        Returns: PatternFlowMplsLabel
        """
        return self._get_property("label", PatternFlowMplsLabel)

    @property
    def traffic_class(self):
        # type: () -> PatternFlowMplsTrafficClass
        """traffic_class getter

        Traffic classTraffic classTraffic classTraffic class

        Returns: PatternFlowMplsTrafficClass
        """
        return self._get_property("traffic_class", PatternFlowMplsTrafficClass)

    @property
    def bottom_of_stack(self):
        # type: () -> PatternFlowMplsBottomOfStack
        """bottom_of_stack getter

        Bottom of stackBottom of stackBottom of stackBottom of stack

        Returns: PatternFlowMplsBottomOfStack
        """
        return self._get_property("bottom_of_stack", PatternFlowMplsBottomOfStack)

    @property
    def time_to_live(self):
        # type: () -> PatternFlowMplsTimeToLive
        """time_to_live getter

        Time to liveTime to liveTime to liveTime to live

        Returns: PatternFlowMplsTimeToLive
        """
        return self._get_property("time_to_live", PatternFlowMplsTimeToLive)


class PatternFlowMplsLabel(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "auto",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 1048575,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 1048575,
        },
        "auto": {
            "type": int,
            "format": "uint32",
            "maximum": 1048575,
        },
        "increment": {"type": "PatternFlowMplsLabelCounter"},
        "decrement": {"type": "PatternFlowMplsLabelCounter"},
        "metric_tags": {"type": "PatternFlowMplsLabelMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "auto",
        "value": 16,
        "values": [16],
        "auto": 16,
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    AUTO = "auto"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=16, values=[16], auto=16):
        super(PatternFlowMplsLabel, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        self._set_property("auto", auto)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None, auto=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowMplsLabelCounter
        """Factory property that returns an instance of the PatternFlowMplsLabelCounter class

        integer counter pattern

        Returns: PatternFlowMplsLabelCounter
        """
        return self._get_property(
            "increment", PatternFlowMplsLabelCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowMplsLabelCounter
        """Factory property that returns an instance of the PatternFlowMplsLabelCounter class

        integer counter pattern

        Returns: PatternFlowMplsLabelCounter
        """
        return self._get_property(
            "decrement", PatternFlowMplsLabelCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["auto"], Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["auto"], Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["auto"], Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def auto(self):
        # type: () -> int
        """auto getter

        The OTG implementation can provide system generated. value for this property. If the OTG is unable to generate value. the default value must be used.

        Returns: int
        """
        return self._get_property("auto")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowMplsLabelMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowMplsLabelMetricTagIter
        """
        return self._get_property(
            "metric_tags", PatternFlowMplsLabelMetricTagIter, self._parent, self._choice
        )


class PatternFlowMplsLabelCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 1048575,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 1048575,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 1048575,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 16,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=16, step=1, count=1):
        super(PatternFlowMplsLabelCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowMplsLabelMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 19,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 20,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 20,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=20):
        super(PatternFlowMplsLabelMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowMplsLabelMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowMplsLabelMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowMplsLabelMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowMplsLabelMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowMplsLabelMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowMplsLabelMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowMplsLabelMetricTag):
            raise Exception("Item is not an instance of PatternFlowMplsLabelMetricTag")

    def metrictag(self, name=None, offset=0, length=20):
        # type: (str,int,int) -> PatternFlowMplsLabelMetricTagIter
        """Factory method that creates an instance of the PatternFlowMplsLabelMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowMplsLabelMetricTagIter
        """
        item = PatternFlowMplsLabelMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=20):
        # type: (str,int,int) -> PatternFlowMplsLabelMetricTag
        """Add method that creates and returns an instance of the PatternFlowMplsLabelMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowMplsLabelMetricTag
        """
        item = PatternFlowMplsLabelMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowMplsTrafficClass(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 7,
        },
        "increment": {"type": "PatternFlowMplsTrafficClassCounter"},
        "decrement": {"type": "PatternFlowMplsTrafficClassCounter"},
        "metric_tags": {"type": "PatternFlowMplsTrafficClassMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 0,
        "values": [0],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=0, values=[0]):
        super(PatternFlowMplsTrafficClass, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowMplsTrafficClassCounter
        """Factory property that returns an instance of the PatternFlowMplsTrafficClassCounter class

        integer counter pattern

        Returns: PatternFlowMplsTrafficClassCounter
        """
        return self._get_property(
            "increment", PatternFlowMplsTrafficClassCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowMplsTrafficClassCounter
        """Factory property that returns an instance of the PatternFlowMplsTrafficClassCounter class

        integer counter pattern

        Returns: PatternFlowMplsTrafficClassCounter
        """
        return self._get_property(
            "decrement", PatternFlowMplsTrafficClassCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowMplsTrafficClassMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowMplsTrafficClassMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowMplsTrafficClassMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowMplsTrafficClassCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 0,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=0, step=1, count=1):
        super(PatternFlowMplsTrafficClassCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowMplsTrafficClassMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 2,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 3,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 3,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=3):
        super(PatternFlowMplsTrafficClassMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowMplsTrafficClassMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowMplsTrafficClassMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowMplsTrafficClassMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowMplsTrafficClassMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowMplsTrafficClassMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowMplsTrafficClassMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowMplsTrafficClassMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowMplsTrafficClassMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=3):
        # type: (str,int,int) -> PatternFlowMplsTrafficClassMetricTagIter
        """Factory method that creates an instance of the PatternFlowMplsTrafficClassMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowMplsTrafficClassMetricTagIter
        """
        item = PatternFlowMplsTrafficClassMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=3):
        # type: (str,int,int) -> PatternFlowMplsTrafficClassMetricTag
        """Add method that creates and returns an instance of the PatternFlowMplsTrafficClassMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowMplsTrafficClassMetricTag
        """
        item = PatternFlowMplsTrafficClassMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowMplsBottomOfStack(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "auto",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 1,
        },
        "auto": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "increment": {"type": "PatternFlowMplsBottomOfStackCounter"},
        "decrement": {"type": "PatternFlowMplsBottomOfStackCounter"},
        "metric_tags": {"type": "PatternFlowMplsBottomOfStackMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "auto",
        "value": 1,
        "values": [1],
        "auto": 1,
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    AUTO = "auto"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=1, values=[1], auto=1):
        super(PatternFlowMplsBottomOfStack, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        self._set_property("auto", auto)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None, auto=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowMplsBottomOfStackCounter
        """Factory property that returns an instance of the PatternFlowMplsBottomOfStackCounter class

        integer counter pattern

        Returns: PatternFlowMplsBottomOfStackCounter
        """
        return self._get_property(
            "increment", PatternFlowMplsBottomOfStackCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowMplsBottomOfStackCounter
        """Factory property that returns an instance of the PatternFlowMplsBottomOfStackCounter class

        integer counter pattern

        Returns: PatternFlowMplsBottomOfStackCounter
        """
        return self._get_property(
            "decrement", PatternFlowMplsBottomOfStackCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["auto"], Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["auto"], Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["auto"], Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def auto(self):
        # type: () -> int
        """auto getter

        The OTG implementation can provide system generated. value for this property. If the OTG is unable to generate value. the default value must be used.

        Returns: int
        """
        return self._get_property("auto")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowMplsBottomOfStackMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowMplsBottomOfStackMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowMplsBottomOfStackMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowMplsBottomOfStackCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 1,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=1, step=1, count=1):
        super(PatternFlowMplsBottomOfStackCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowMplsBottomOfStackMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 0,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 1,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=1):
        super(PatternFlowMplsBottomOfStackMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowMplsBottomOfStackMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowMplsBottomOfStackMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowMplsBottomOfStackMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowMplsBottomOfStackMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowMplsBottomOfStackMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowMplsBottomOfStackMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowMplsBottomOfStackMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowMplsBottomOfStackMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowMplsBottomOfStackMetricTagIter
        """Factory method that creates an instance of the PatternFlowMplsBottomOfStackMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowMplsBottomOfStackMetricTagIter
        """
        item = PatternFlowMplsBottomOfStackMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=1):
        # type: (str,int,int) -> PatternFlowMplsBottomOfStackMetricTag
        """Add method that creates and returns an instance of the PatternFlowMplsBottomOfStackMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowMplsBottomOfStackMetricTag
        """
        item = PatternFlowMplsBottomOfStackMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class PatternFlowMplsTimeToLive(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "value",
                "values",
                "increment",
                "decrement",
            ],
        },
        "value": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "values": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
            "maximum": 255,
        },
        "increment": {"type": "PatternFlowMplsTimeToLiveCounter"},
        "decrement": {"type": "PatternFlowMplsTimeToLiveCounter"},
        "metric_tags": {"type": "PatternFlowMplsTimeToLiveMetricTagIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 64,
        "values": [64],
    }  # type: Dict[str, Union(type)]

    VALUE = "value"  # type: str
    VALUES = "values"  # type: str
    INCREMENT = "increment"  # type: str
    DECREMENT = "decrement"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=64, values=[64]):
        super(PatternFlowMplsTimeToLive, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        self._set_property("values", values)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> PatternFlowMplsTimeToLiveCounter
        """Factory property that returns an instance of the PatternFlowMplsTimeToLiveCounter class

        integer counter pattern

        Returns: PatternFlowMplsTimeToLiveCounter
        """
        return self._get_property(
            "increment", PatternFlowMplsTimeToLiveCounter, self, "increment"
        )

    @property
    def decrement(self):
        # type: () -> PatternFlowMplsTimeToLiveCounter
        """Factory property that returns an instance of the PatternFlowMplsTimeToLiveCounter class

        integer counter pattern

        Returns: PatternFlowMplsTimeToLiveCounter
        """
        return self._get_property(
            "decrement", PatternFlowMplsTimeToLiveCounter, self, "decrement"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """choice getter

        TBD

        Returns: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["decrement"], Literal["increment"], Literal["value"], Literal["values"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> int
        """value getter

        TBD

        Returns: int
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        TBD

        value: int
        """
        self._set_property("value", value, "value")

    @property
    def values(self):
        # type: () -> List[int]
        """values getter

        TBD

        Returns: List[int]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        TBD

        value: List[int]
        """
        self._set_property("values", value, "values")

    @property
    def metric_tags(self):
        # type: () -> PatternFlowMplsTimeToLiveMetricTagIter
        """metric_tags getter

        One or more metric tags can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowMplsTimeToLiveMetricTagIter
        """
        return self._get_property(
            "metric_tags",
            PatternFlowMplsTimeToLiveMetricTagIter,
            self._parent,
            self._choice,
        )


class PatternFlowMplsTimeToLiveCounter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "step": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
        "count": {
            "type": int,
            "format": "uint32",
            "maximum": 255,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 64,
        "step": 1,
        "count": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=64, step=1, count=1):
        super(PatternFlowMplsTimeToLiveCounter, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("step", step)
        self._set_property("count", count)

    def set(self, start=None, step=None, count=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        TBD

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        TBD

        value: int
        """
        self._set_property("start", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        TBD

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        TBD

        value: int
        """
        self._set_property("step", value)

    @property
    def count(self):
        # type: () -> int
        """count getter

        TBD

        Returns: int
        """
        return self._get_property("count")

    @count.setter
    def count(self, value):
        """count setter

        TBD

        value: int
        """
        self._set_property("count", value)


class PatternFlowMplsTimeToLiveMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "offset": {
            "type": int,
            "format": "uint32",
            "maximum": 7,
        },
        "length": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
            "maximum": 8,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("name",)  # type: tuple(str)

    _DEFAULTS = {
        "offset": 0,
        "length": 8,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, offset=0, length=8):
        super(PatternFlowMplsTimeToLiveMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("offset", offset)
        self._set_property("length", length)

    def set(self, name=None, offset=None, length=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name used to identify the metrics associated with the values applicable for configured offset and length inside corresponding header field

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)

    @property
    def offset(self):
        # type: () -> int
        """offset getter

        Offset in bits relative to start of corresponding header field

        Returns: int
        """
        return self._get_property("offset")

    @offset.setter
    def offset(self, value):
        """offset setter

        Offset in bits relative to start of corresponding header field

        value: int
        """
        self._set_property("offset", value)

    @property
    def length(self):
        # type: () -> int
        """length getter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        Returns: int
        """
        return self._get_property("length")

    @length.setter
    def length(self, value):
        """length setter

        Number of bits to track for metrics starting from configured offset of corresponding header field

        value: int
        """
        self._set_property("length", value)


class PatternFlowMplsTimeToLiveMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PatternFlowMplsTimeToLiveMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PatternFlowMplsTimeToLiveMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PatternFlowMplsTimeToLiveMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> PatternFlowMplsTimeToLiveMetricTag
        return self._next()

    def next(self):
        # type: () -> PatternFlowMplsTimeToLiveMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PatternFlowMplsTimeToLiveMetricTag):
            raise Exception(
                "Item is not an instance of PatternFlowMplsTimeToLiveMetricTag"
            )

    def metrictag(self, name=None, offset=0, length=8):
        # type: (str,int,int) -> PatternFlowMplsTimeToLiveMetricTagIter
        """Factory method that creates an instance of the PatternFlowMplsTimeToLiveMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowMplsTimeToLiveMetricTagIter
        """
        item = PatternFlowMplsTimeToLiveMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return self

    def add(self, name=None, offset=0, length=8):
        # type: (str,int,int) -> PatternFlowMplsTimeToLiveMetricTag
        """Add method that creates and returns an instance of the PatternFlowMplsTimeToLiveMetricTag class

        Metric tag can be used to enable tracking portion of or all bits in corresponding header field for metrics per each applicable value. These would appear as tagged metrics in corresponding flow metrics.

        Returns: PatternFlowMplsTimeToLiveMetricTag
        """
        item = PatternFlowMplsTimeToLiveMetricTag(
            parent=self._parent, name=name, offset=offset, length=length
        )
        self._add(item)
        return item


class FlowHeaderIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = True

    def __init__(self, parent=None, choice=None):
        super(FlowHeaderIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[FlowArp, FlowCustom, FlowEthernet, FlowEthernetPause, FlowGre, FlowGtpv1, FlowGtpv2, FlowHeader, FlowIcmp, FlowIcmpv6, FlowIgmpv1, FlowIpv4, FlowIpv6, FlowMpls, FlowPfcPause, FlowPpp, FlowTcp, FlowUdp, FlowVlan, FlowVxlan]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> FlowHeaderIter
        return self._iter()

    def __next__(self):
        # type: () -> FlowHeader
        return self._next()

    def next(self):
        # type: () -> FlowHeader
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, FlowHeader):
            raise Exception("Item is not an instance of FlowHeader")

    def header(self):
        # type: () -> FlowHeaderIter
        """Factory method that creates an instance of the FlowHeader class

        Configuration for all traffic packet headers

        Returns: FlowHeaderIter
        """
        item = FlowHeader(parent=self._parent, choice=self._choice)
        self._add(item)
        return self

    def add(self):
        # type: () -> FlowHeader
        """Add method that creates and returns an instance of the FlowHeader class

        Configuration for all traffic packet headers

        Returns: FlowHeader
        """
        item = FlowHeader(parent=self._parent, choice=self._choice)
        self._add(item)
        return item

    def custom(self, bytes=None):
        # type: (str) -> FlowHeaderIter
        """Factory method that creates an instance of the FlowCustom class

        Custom packet header

        Returns: FlowHeaderIter
        """
        item = FlowHeader()
        item.custom
        item.choice = "custom"
        self._add(item)
        return self

    def ethernet(self):
        # type: () -> FlowHeaderIter
        """Factory method that creates an instance of the FlowEthernet class

        Ethernet packet header

        Returns: FlowHeaderIter
        """
        item = FlowHeader()
        item.ethernet
        item.choice = "ethernet"
        self._add(item)
        return self

    def vlan(self):
        # type: () -> FlowHeaderIter
        """Factory method that creates an instance of the FlowVlan class

        VLAN packet header

        Returns: FlowHeaderIter
        """
        item = FlowHeader()
        item.vlan
        item.choice = "vlan"
        self._add(item)
        return self

    def vxlan(self):
        # type: () -> FlowHeaderIter
        """Factory method that creates an instance of the FlowVxlan class

        VXLAN packet header

        Returns: FlowHeaderIter
        """
        item = FlowHeader()
        item.vxlan
        item.choice = "vxlan"
        self._add(item)
        return self

    def ipv4(self):
        # type: () -> FlowHeaderIter
        """Factory method that creates an instance of the FlowIpv4 class

        IPv4 packet header

        Returns: FlowHeaderIter
        """
        item = FlowHeader()
        item.ipv4
        item.choice = "ipv4"
        self._add(item)
        return self

    def ipv6(self):
        # type: () -> FlowHeaderIter
        """Factory method that creates an instance of the FlowIpv6 class

        IPv6 packet header

        Returns: FlowHeaderIter
        """
        item = FlowHeader()
        item.ipv6
        item.choice = "ipv6"
        self._add(item)
        return self

    def pfcpause(self):
        # type: () -> FlowHeaderIter
        """Factory method that creates an instance of the FlowPfcPause class

        IEEE 802.1Qbb PFC Pause packet header.

        Returns: FlowHeaderIter
        """
        item = FlowHeader()
        item.pfcpause
        item.choice = "pfcpause"
        self._add(item)
        return self

    def ethernetpause(self):
        # type: () -> FlowHeaderIter
        """Factory method that creates an instance of the FlowEthernetPause class

        IEEE 802.3x global ethernet pause packet header

        Returns: FlowHeaderIter
        """
        item = FlowHeader()
        item.ethernetpause
        item.choice = "ethernetpause"
        self._add(item)
        return self

    def tcp(self):
        # type: () -> FlowHeaderIter
        """Factory method that creates an instance of the FlowTcp class

        TCP packet header

        Returns: FlowHeaderIter
        """
        item = FlowHeader()
        item.tcp
        item.choice = "tcp"
        self._add(item)
        return self

    def udp(self):
        # type: () -> FlowHeaderIter
        """Factory method that creates an instance of the FlowUdp class

        UDP packet header

        Returns: FlowHeaderIter
        """
        item = FlowHeader()
        item.udp
        item.choice = "udp"
        self._add(item)
        return self

    def gre(self):
        # type: () -> FlowHeaderIter
        """Factory method that creates an instance of the FlowGre class

        Standard GRE packet header (RFC2784)

        Returns: FlowHeaderIter
        """
        item = FlowHeader()
        item.gre
        item.choice = "gre"
        self._add(item)
        return self

    def gtpv1(self):
        # type: () -> FlowHeaderIter
        """Factory method that creates an instance of the FlowGtpv1 class

        GTPv1 packet header

        Returns: FlowHeaderIter
        """
        item = FlowHeader()
        item.gtpv1
        item.choice = "gtpv1"
        self._add(item)
        return self

    def gtpv2(self):
        # type: () -> FlowHeaderIter
        """Factory method that creates an instance of the FlowGtpv2 class

        GTPv2 packet header

        Returns: FlowHeaderIter
        """
        item = FlowHeader()
        item.gtpv2
        item.choice = "gtpv2"
        self._add(item)
        return self

    def arp(self):
        # type: () -> FlowHeaderIter
        """Factory method that creates an instance of the FlowArp class

        ARP packet header

        Returns: FlowHeaderIter
        """
        item = FlowHeader()
        item.arp
        item.choice = "arp"
        self._add(item)
        return self

    def icmp(self):
        # type: () -> FlowHeaderIter
        """Factory method that creates an instance of the FlowIcmp class

        ICMP packet header

        Returns: FlowHeaderIter
        """
        item = FlowHeader()
        item.icmp
        item.choice = "icmp"
        self._add(item)
        return self

    def icmpv6(self):
        # type: () -> FlowHeaderIter
        """Factory method that creates an instance of the FlowIcmpv6 class

        ICMPv6 packet header

        Returns: FlowHeaderIter
        """
        item = FlowHeader()
        item.icmpv6
        item.choice = "icmpv6"
        self._add(item)
        return self

    def ppp(self):
        # type: () -> FlowHeaderIter
        """Factory method that creates an instance of the FlowPpp class

        PPP packet header

        Returns: FlowHeaderIter
        """
        item = FlowHeader()
        item.ppp
        item.choice = "ppp"
        self._add(item)
        return self

    def igmpv1(self):
        # type: () -> FlowHeaderIter
        """Factory method that creates an instance of the FlowIgmpv1 class

        IGMPv1 packet header

        Returns: FlowHeaderIter
        """
        item = FlowHeader()
        item.igmpv1
        item.choice = "igmpv1"
        self._add(item)
        return self

    def mpls(self):
        # type: () -> FlowHeaderIter
        """Factory method that creates an instance of the FlowMpls class

        MPLS packet header; When configuring multiple such headers, the count shall not exceed 20.

        Returns: FlowHeaderIter
        """
        item = FlowHeader()
        item.mpls
        item.choice = "mpls"
        self._add(item)
        return self


class FlowSize(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "fixed",
                "increment",
                "random",
                "weight_pairs",
            ],
        },
        "fixed": {
            "type": int,
            "format": "uint32",
        },
        "increment": {"type": "FlowSizeIncrement"},
        "random": {"type": "FlowSizeRandom"},
        "weight_pairs": {"type": "FlowSizeWeightPairs"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "fixed",
        "fixed": 64,
    }  # type: Dict[str, Union(type)]

    FIXED = "fixed"  # type: str
    INCREMENT = "increment"  # type: str
    RANDOM = "random"  # type: str
    WEIGHT_PAIRS = "weight_pairs"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, fixed=64):
        super(FlowSize, self).__init__()
        self._parent = parent
        self._set_property("fixed", fixed)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, fixed=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def increment(self):
        # type: () -> FlowSizeIncrement
        """Factory property that returns an instance of the FlowSizeIncrement class

        Frame size that increments from starting size to an ending size incrementing by step size.

        Returns: FlowSizeIncrement
        """
        return self._get_property("increment", FlowSizeIncrement, self, "increment")

    @property
    def random(self):
        # type: () -> FlowSizeRandom
        """Factory property that returns an instance of the FlowSizeRandom class

        Random frame size from min value to max value.

        Returns: FlowSizeRandom
        """
        return self._get_property("random", FlowSizeRandom, self, "random")

    @property
    def weight_pairs(self):
        # type: () -> FlowSizeWeightPairs
        """Factory property that returns an instance of the FlowSizeWeightPairs class

        Frame size distribution, defined as <size, weight> pairs (including IMIX distribution).. Frames are randomly generated such that the proportion of each frame size out of the total number of frames are matching with the weight value of the <size, weight> pair. However, as with any other probability distribution, the sample distribution is close to theoretical value only if the size of the sample is reasonably large. When the number of frames is very low the transmitted frames may not come close to the ratio described in the weight.

        Returns: FlowSizeWeightPairs
        """
        return self._get_property(
            "weight_pairs", FlowSizeWeightPairs, self, "weight_pairs"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["fixed"], Literal["increment"], Literal["random"], Literal["weight_pairs"]]
        """choice getter

        TBD

        Returns: Union[Literal["fixed"], Literal["increment"], Literal["random"], Literal["weight_pairs"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["fixed"], Literal["increment"], Literal["random"], Literal["weight_pairs"]]
        """
        self._set_property("choice", value)

    @property
    def fixed(self):
        # type: () -> int
        """fixed getter

        TBD

        Returns: int
        """
        return self._get_property("fixed")

    @fixed.setter
    def fixed(self, value):
        """fixed setter

        TBD

        value: int
        """
        self._set_property("fixed", value, "fixed")


class FlowSizeIncrement(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "start": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
        },
        "end": {
            "type": int,
            "format": "uint32",
            "minimum": 64,
        },
        "step": {
            "type": int,
            "format": "uint32",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "start": 64,
        "end": 1518,
        "step": 1,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, start=64, end=1518, step=1):
        super(FlowSizeIncrement, self).__init__()
        self._parent = parent
        self._set_property("start", start)
        self._set_property("end", end)
        self._set_property("step", step)

    def set(self, start=None, end=None, step=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def start(self):
        # type: () -> int
        """start getter

        Starting frame size in bytes

        Returns: int
        """
        return self._get_property("start")

    @start.setter
    def start(self, value):
        """start setter

        Starting frame size in bytes

        value: int
        """
        self._set_property("start", value)

    @property
    def end(self):
        # type: () -> int
        """end getter

        Ending frame size in bytes

        Returns: int
        """
        return self._get_property("end")

    @end.setter
    def end(self, value):
        """end setter

        Ending frame size in bytes

        value: int
        """
        self._set_property("end", value)

    @property
    def step(self):
        # type: () -> int
        """step getter

        Step frame size in bytes

        Returns: int
        """
        return self._get_property("step")

    @step.setter
    def step(self, value):
        """step setter

        Step frame size in bytes

        value: int
        """
        self._set_property("step", value)


class FlowSizeRandom(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "min": {
            "type": int,
            "format": "uint32",
        },
        "max": {
            "type": int,
            "format": "uint32",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "min": 64,
        "max": 1518,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, min=64, max=1518):
        super(FlowSizeRandom, self).__init__()
        self._parent = parent
        self._set_property("min", min)
        self._set_property("max", max)

    def set(self, min=None, max=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def min(self):
        # type: () -> int
        """min getter

        TBD

        Returns: int
        """
        return self._get_property("min")

    @min.setter
    def min(self, value):
        """min setter

        TBD

        value: int
        """
        self._set_property("min", value)

    @property
    def max(self):
        # type: () -> int
        """max getter

        TBD

        Returns: int
        """
        return self._get_property("max")

    @max.setter
    def max(self, value):
        """max setter

        TBD

        value: int
        """
        self._set_property("max", value)


class FlowSizeWeightPairs(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "predefined",
                "custom",
            ],
        },
        "predefined": {
            "type": str,
            "enum": [
                "imix",
                "ipsec_imix",
                "ipv6_imix",
                "standard_imix",
                "tcp_imix",
            ],
        },
        "custom": {"type": "FlowSizeWeightPairsCustomIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "predefined",
        "predefined": "imix",
    }  # type: Dict[str, Union(type)]

    PREDEFINED = "predefined"  # type: str
    CUSTOM = "custom"  # type: str

    IMIX = "imix"  # type: str
    IPSEC_IMIX = "ipsec_imix"  # type: str
    IPV6_IMIX = "ipv6_imix"  # type: str
    STANDARD_IMIX = "standard_imix"  # type: str
    TCP_IMIX = "tcp_imix"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, predefined="imix"):
        super(FlowSizeWeightPairs, self).__init__()
        self._parent = parent
        self._set_property("predefined", predefined)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, predefined=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def choice(self):
        # type: () -> Union[Literal["custom"], Literal["predefined"]]
        """choice getter

        TBD

        Returns: Union[Literal["custom"], Literal["predefined"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["custom"], Literal["predefined"]]
        """
        self._set_property("choice", value)

    @property
    def predefined(self):
        # type: () -> Union[Literal["imix"], Literal["ipsec_imix"], Literal["ipv6_imix"], Literal["standard_imix"], Literal["tcp_imix"]]
        """predefined getter

        Specify predefined frame size distribution <size, weight> pairs (including IMIX distribution). The available predefined distribution pairs are:. IMIX (64:7, 570:4, and 1518:1) - IPSec IMIX (90:58.67, 92:2, 594:23.66 and 1418:15.67) - IPv6 IMIX (60:58.67, 496:2, 594:23.66 and 1518:15.67) - Standard IMIX (58:58.67, 62:2, 594:23.66 and 1518:15.67) - TCP IMIX (90:58.67, 92:2, 594:23.66 and 1518:15.67)

        Returns: Union[Literal["imix"], Literal["ipsec_imix"], Literal["ipv6_imix"], Literal["standard_imix"], Literal["tcp_imix"]]
        """
        return self._get_property("predefined")

    @predefined.setter
    def predefined(self, value):
        """predefined setter

        Specify predefined frame size distribution <size, weight> pairs (including IMIX distribution). The available predefined distribution pairs are:. IMIX (64:7, 570:4, and 1518:1) - IPSec IMIX (90:58.67, 92:2, 594:23.66 and 1418:15.67) - IPv6 IMIX (60:58.67, 496:2, 594:23.66 and 1518:15.67) - Standard IMIX (58:58.67, 62:2, 594:23.66 and 1518:15.67) - TCP IMIX (90:58.67, 92:2, 594:23.66 and 1518:15.67)

        value: Union[Literal["imix"], Literal["ipsec_imix"], Literal["ipv6_imix"], Literal["standard_imix"], Literal["tcp_imix"]]
        """
        self._set_property("predefined", value, "predefined")

    @property
    def custom(self):
        # type: () -> FlowSizeWeightPairsCustomIter
        """custom getter

        TBD

        Returns: FlowSizeWeightPairsCustomIter
        """
        return self._get_property(
            "custom", FlowSizeWeightPairsCustomIter, self._parent, self._choice
        )


class FlowSizeWeightPairsCustom(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "size": {
            "type": int,
            "format": "uint32",
            "minimum": 12,
            "maximum": 65535,
        },
        "weight": {
            "type": float,
            "format": "float",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "size": 64,
        "weight": 1.0,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, size=64, weight=1):
        super(FlowSizeWeightPairsCustom, self).__init__()
        self._parent = parent
        self._set_property("size", size)
        self._set_property("weight", weight)

    def set(self, size=None, weight=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def size(self):
        # type: () -> int
        """size getter

        The size of the frame (in bytes) for this weight pair.

        Returns: int
        """
        return self._get_property("size")

    @size.setter
    def size(self, value):
        """size setter

        The size of the frame (in bytes) for this weight pair.

        value: int
        """
        self._set_property("size", value)

    @property
    def weight(self):
        # type: () -> float
        """weight getter

        Weight assigned to the corresponding frame size in this weight pair. Higher weight means more packets.

        Returns: float
        """
        return self._get_property("weight")

    @weight.setter
    def weight(self, value):
        """weight setter

        Weight assigned to the corresponding frame size in this weight pair. Higher weight means more packets.

        value: float
        """
        self._set_property("weight", value)


class FlowSizeWeightPairsCustomIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(FlowSizeWeightPairsCustomIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[FlowSizeWeightPairsCustom]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> FlowSizeWeightPairsCustomIter
        return self._iter()

    def __next__(self):
        # type: () -> FlowSizeWeightPairsCustom
        return self._next()

    def next(self):
        # type: () -> FlowSizeWeightPairsCustom
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, FlowSizeWeightPairsCustom):
            raise Exception("Item is not an instance of FlowSizeWeightPairsCustom")

    def custom(self, size=64, weight=1):
        # type: (int,float) -> FlowSizeWeightPairsCustomIter
        """Factory method that creates an instance of the FlowSizeWeightPairsCustom class

        Custom frame size distribution <size, weight> pair.

        Returns: FlowSizeWeightPairsCustomIter
        """
        item = FlowSizeWeightPairsCustom(parent=self._parent, size=size, weight=weight)
        self._add(item)
        return self

    def add(self, size=64, weight=1):
        # type: (int,float) -> FlowSizeWeightPairsCustom
        """Add method that creates and returns an instance of the FlowSizeWeightPairsCustom class

        Custom frame size distribution <size, weight> pair.

        Returns: FlowSizeWeightPairsCustom
        """
        item = FlowSizeWeightPairsCustom(parent=self._parent, size=size, weight=weight)
        self._add(item)
        return item


class FlowRate(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "pps",
                "bps",
                "kbps",
                "mbps",
                "gbps",
                "percentage",
            ],
        },
        "pps": {
            "type": int,
            "format": "uint64",
            "minimum": 1,
        },
        "bps": {
            "type": int,
            "format": "uint64",
            "minimum": 672,
        },
        "kbps": {
            "type": int,
            "format": "uint64",
            "minimum": 1,
        },
        "mbps": {
            "type": int,
            "format": "uint64",
            "minimum": 1,
        },
        "gbps": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
        },
        "percentage": {
            "type": float,
            "format": "float",
            "minimum": 0,
            "maximum": 100,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "pps",
        "pps": 1000,
        "bps": 1000000000,
        "kbps": 1000000,
        "mbps": 1000,
        "gbps": 1,
        "percentage": 100.0,
    }  # type: Dict[str, Union(type)]

    PPS = "pps"  # type: str
    BPS = "bps"  # type: str
    KBPS = "kbps"  # type: str
    MBPS = "mbps"  # type: str
    GBPS = "gbps"  # type: str
    PERCENTAGE = "percentage"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        choice=None,
        pps=1000,
        bps=1000000000,
        kbps=1000000,
        mbps=1000,
        gbps=1,
        percentage=100,
    ):
        super(FlowRate, self).__init__()
        self._parent = parent
        self._set_property("pps", pps)
        self._set_property("bps", bps)
        self._set_property("kbps", kbps)
        self._set_property("mbps", mbps)
        self._set_property("gbps", gbps)
        self._set_property("percentage", percentage)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, pps=None, bps=None, kbps=None, mbps=None, gbps=None, percentage=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def choice(self):
        # type: () -> Union[Literal["bps"], Literal["gbps"], Literal["kbps"], Literal["mbps"], Literal["percentage"], Literal["pps"]]
        """choice getter

        The available types of flow rate.

        Returns: Union[Literal["bps"], Literal["gbps"], Literal["kbps"], Literal["mbps"], Literal["percentage"], Literal["pps"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        The available types of flow rate.

        value: Union[Literal["bps"], Literal["gbps"], Literal["kbps"], Literal["mbps"], Literal["percentage"], Literal["pps"]]
        """
        self._set_property("choice", value)

    @property
    def pps(self):
        # type: () -> int
        """pps getter

        Packets per second.

        Returns: int
        """
        return self._get_property("pps")

    @pps.setter
    def pps(self, value):
        """pps setter

        Packets per second.

        value: int
        """
        self._set_property("pps", value, "pps")

    @property
    def bps(self):
        # type: () -> int
        """bps getter

        Bits per second.

        Returns: int
        """
        return self._get_property("bps")

    @bps.setter
    def bps(self, value):
        """bps setter

        Bits per second.

        value: int
        """
        self._set_property("bps", value, "bps")

    @property
    def kbps(self):
        # type: () -> int
        """kbps getter

        Kilobits per second.

        Returns: int
        """
        return self._get_property("kbps")

    @kbps.setter
    def kbps(self, value):
        """kbps setter

        Kilobits per second.

        value: int
        """
        self._set_property("kbps", value, "kbps")

    @property
    def mbps(self):
        # type: () -> int
        """mbps getter

        Megabits per second.

        Returns: int
        """
        return self._get_property("mbps")

    @mbps.setter
    def mbps(self, value):
        """mbps setter

        Megabits per second.

        value: int
        """
        self._set_property("mbps", value, "mbps")

    @property
    def gbps(self):
        # type: () -> int
        """gbps getter

        Gigabits per second.

        Returns: int
        """
        return self._get_property("gbps")

    @gbps.setter
    def gbps(self, value):
        """gbps setter

        Gigabits per second.

        value: int
        """
        self._set_property("gbps", value, "gbps")

    @property
    def percentage(self):
        # type: () -> float
        """percentage getter

        The percentage of port location's available bandwidth.

        Returns: float
        """
        return self._get_property("percentage")

    @percentage.setter
    def percentage(self, value):
        """percentage setter

        The percentage of port location's available bandwidth.

        value: float
        """
        self._set_property("percentage", value, "percentage")


class FlowDuration(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "fixed_packets",
                "fixed_seconds",
                "burst",
                "continuous",
            ],
        },
        "fixed_packets": {"type": "FlowFixedPackets"},
        "fixed_seconds": {"type": "FlowFixedSeconds"},
        "burst": {"type": "FlowBurst"},
        "continuous": {"type": "FlowContinuous"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "continuous",
    }  # type: Dict[str, Union(type)]

    FIXED_PACKETS = "fixed_packets"  # type: str
    FIXED_SECONDS = "fixed_seconds"  # type: str
    BURST = "burst"  # type: str
    CONTINUOUS = "continuous"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None):
        super(FlowDuration, self).__init__()
        self._parent = parent
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    @property
    def fixed_packets(self):
        # type: () -> FlowFixedPackets
        """Factory property that returns an instance of the FlowFixedPackets class

        Transmit fixed number of packets after which the flow will stop.

        Returns: FlowFixedPackets
        """
        return self._get_property(
            "fixed_packets", FlowFixedPackets, self, "fixed_packets"
        )

    @property
    def fixed_seconds(self):
        # type: () -> FlowFixedSeconds
        """Factory property that returns an instance of the FlowFixedSeconds class

        Transmit for fixed number of seconds after which the flow will stop.

        Returns: FlowFixedSeconds
        """
        return self._get_property(
            "fixed_seconds", FlowFixedSeconds, self, "fixed_seconds"
        )

    @property
    def burst(self):
        # type: () -> FlowBurst
        """Factory property that returns an instance of the FlowBurst class

        Transmits continuous or fixed burst of packets. For continuous burst of packets, it will not automatically stop.. For fixed burst of packets, it will stop after transmitting fixed number of bursts.

        Returns: FlowBurst
        """
        return self._get_property("burst", FlowBurst, self, "burst")

    @property
    def continuous(self):
        # type: () -> FlowContinuous
        """Factory property that returns an instance of the FlowContinuous class

        Transmit will be continuous and will not stop automatically.

        Returns: FlowContinuous
        """
        return self._get_property("continuous", FlowContinuous, self, "continuous")

    @property
    def choice(self):
        # type: () -> Union[Literal["burst"], Literal["continuous"], Literal["fixed_packets"], Literal["fixed_seconds"]]
        """choice getter

        A choice used to determine the type of duration.

        Returns: Union[Literal["burst"], Literal["continuous"], Literal["fixed_packets"], Literal["fixed_seconds"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        A choice used to determine the type of duration.

        value: Union[Literal["burst"], Literal["continuous"], Literal["fixed_packets"], Literal["fixed_seconds"]]
        """
        self._set_property("choice", value)


class FlowFixedPackets(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "packets": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
        },
        "gap": {
            "type": int,
            "format": "uint32",
        },
        "delay": {"type": "FlowDelay"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "packets": 1,
        "gap": 12,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, packets=1, gap=12):
        super(FlowFixedPackets, self).__init__()
        self._parent = parent
        self._set_property("packets", packets)
        self._set_property("gap", gap)

    def set(self, packets=None, gap=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def packets(self):
        # type: () -> int
        """packets getter

        Stop transmit of the flow after this number of packets.

        Returns: int
        """
        return self._get_property("packets")

    @packets.setter
    def packets(self, value):
        """packets setter

        Stop transmit of the flow after this number of packets.

        value: int
        """
        self._set_property("packets", value)

    @property
    def gap(self):
        # type: () -> int
        """gap getter

        The minimum gap between packets expressed as bytes.

        Returns: int
        """
        return self._get_property("gap")

    @gap.setter
    def gap(self, value):
        """gap setter

        The minimum gap between packets expressed as bytes.

        value: int
        """
        self._set_property("gap", value)

    @property
    def delay(self):
        # type: () -> FlowDelay
        """delay getter

        The optional container to specify the delay before starting transmission of packets.The optional container to specify the delay before starting transmission of packets.The optional container to specify the delay before starting transmission of packets.The optional container to specify the delay before starting transmission of packets.

        Returns: FlowDelay
        """
        return self._get_property("delay", FlowDelay)


class FlowDelay(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "bytes",
                "nanoseconds",
                "microseconds",
            ],
        },
        "bytes": {
            "type": float,
            "format": "float",
            "minimum": 0,
        },
        "nanoseconds": {
            "type": float,
            "format": "float",
            "minimum": 0,
        },
        "microseconds": {
            "type": float,
            "format": "float",
            "minimum": 0,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "bytes",
        "bytes": 0.0,
        "nanoseconds": 0.0,
        "microseconds": 0.0,
    }  # type: Dict[str, Union(type)]

    BYTES = "bytes"  # type: str
    NANOSECONDS = "nanoseconds"  # type: str
    MICROSECONDS = "microseconds"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self, parent=None, choice=None, bytes=0, nanoseconds=0, microseconds=0
    ):
        super(FlowDelay, self).__init__()
        self._parent = parent
        self._set_property("bytes", bytes)
        self._set_property("nanoseconds", nanoseconds)
        self._set_property("microseconds", microseconds)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, bytes=None, nanoseconds=None, microseconds=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def choice(self):
        # type: () -> Union[Literal["bytes"], Literal["microseconds"], Literal["nanoseconds"]]
        """choice getter

        TBD

        Returns: Union[Literal["bytes"], Literal["microseconds"], Literal["nanoseconds"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["bytes"], Literal["microseconds"], Literal["nanoseconds"]]
        """
        self._set_property("choice", value)

    @property
    def bytes(self):
        # type: () -> float
        """bytes getter

        The delay before starting transmission of packets.. value of indicates no delay.

        Returns: float
        """
        return self._get_property("bytes")

    @bytes.setter
    def bytes(self, value):
        """bytes setter

        The delay before starting transmission of packets.. value of indicates no delay.

        value: float
        """
        self._set_property("bytes", value, "bytes")

    @property
    def nanoseconds(self):
        # type: () -> float
        """nanoseconds getter

        The delay before starting transmission of packets.. value of indicates no delay.

        Returns: float
        """
        return self._get_property("nanoseconds")

    @nanoseconds.setter
    def nanoseconds(self, value):
        """nanoseconds setter

        The delay before starting transmission of packets.. value of indicates no delay.

        value: float
        """
        self._set_property("nanoseconds", value, "nanoseconds")

    @property
    def microseconds(self):
        # type: () -> float
        """microseconds getter

        The delay before starting transmission of packets.. value of indicates no delay.

        Returns: float
        """
        return self._get_property("microseconds")

    @microseconds.setter
    def microseconds(self, value):
        """microseconds setter

        The delay before starting transmission of packets.. value of indicates no delay.

        value: float
        """
        self._set_property("microseconds", value, "microseconds")


class FlowFixedSeconds(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "seconds": {
            "type": float,
            "minimum": 0,
        },
        "gap": {
            "type": int,
            "format": "uint32",
        },
        "delay": {"type": "FlowDelay"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "seconds": 1.0,
        "gap": 12,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, seconds=1, gap=12):
        super(FlowFixedSeconds, self).__init__()
        self._parent = parent
        self._set_property("seconds", seconds)
        self._set_property("gap", gap)

    def set(self, seconds=None, gap=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def seconds(self):
        # type: () -> float
        """seconds getter

        Stop transmit of the flow after this number of seconds.

        Returns: float
        """
        return self._get_property("seconds")

    @seconds.setter
    def seconds(self, value):
        """seconds setter

        Stop transmit of the flow after this number of seconds.

        value: float
        """
        self._set_property("seconds", value)

    @property
    def gap(self):
        # type: () -> int
        """gap getter

        The minimum gap between packets expressed as bytes.

        Returns: int
        """
        return self._get_property("gap")

    @gap.setter
    def gap(self, value):
        """gap setter

        The minimum gap between packets expressed as bytes.

        value: int
        """
        self._set_property("gap", value)

    @property
    def delay(self):
        # type: () -> FlowDelay
        """delay getter

        The optional container to specify the delay before starting transmission of packets.The optional container to specify the delay before starting transmission of packets.The optional container to specify the delay before starting transmission of packets.The optional container to specify the delay before starting transmission of packets.

        Returns: FlowDelay
        """
        return self._get_property("delay", FlowDelay)


class FlowBurst(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "bursts": {
            "type": int,
            "format": "uint32",
        },
        "packets": {
            "type": int,
            "format": "uint32",
            "minimum": 1,
        },
        "gap": {
            "type": int,
            "format": "uint32",
        },
        "inter_burst_gap": {"type": "FlowDurationInterBurstGap"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "bursts": 0,
        "packets": 1,
        "gap": 12,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, bursts=0, packets=1, gap=12):
        super(FlowBurst, self).__init__()
        self._parent = parent
        self._set_property("bursts", bursts)
        self._set_property("packets", packets)
        self._set_property("gap", gap)

    def set(self, bursts=None, packets=None, gap=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def bursts(self):
        # type: () -> int
        """bursts getter

        The number of packet bursts transmitted per flow.. value of implies continuous burst of packets.

        Returns: int
        """
        return self._get_property("bursts")

    @bursts.setter
    def bursts(self, value):
        """bursts setter

        The number of packet bursts transmitted per flow.. value of implies continuous burst of packets.

        value: int
        """
        self._set_property("bursts", value)

    @property
    def packets(self):
        # type: () -> int
        """packets getter

        The number of packets transmitted per burst.

        Returns: int
        """
        return self._get_property("packets")

    @packets.setter
    def packets(self, value):
        """packets setter

        The number of packets transmitted per burst.

        value: int
        """
        self._set_property("packets", value)

    @property
    def gap(self):
        # type: () -> int
        """gap getter

        The minimum gap between packets expressed as bytes.

        Returns: int
        """
        return self._get_property("gap")

    @gap.setter
    def gap(self, value):
        """gap setter

        The minimum gap between packets expressed as bytes.

        value: int
        """
        self._set_property("gap", value)

    @property
    def inter_burst_gap(self):
        # type: () -> FlowDurationInterBurstGap
        """inter_burst_gap getter

        The optional container for specifying gap between bursts.The optional container for specifying gap between bursts.The optional container for specifying gap between bursts.The optional container for specifying gap between bursts.

        Returns: FlowDurationInterBurstGap
        """
        return self._get_property("inter_burst_gap", FlowDurationInterBurstGap)


class FlowDurationInterBurstGap(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "bytes",
                "nanoseconds",
                "microseconds",
            ],
        },
        "bytes": {
            "type": float,
            "format": "double",
            "minimum": 0,
        },
        "nanoseconds": {
            "type": float,
            "format": "double",
            "minimum": 0,
        },
        "microseconds": {
            "type": float,
            "format": "double",
            "minimum": 0,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "bytes",
        "bytes": 12.0,
        "nanoseconds": 96.0,
        "microseconds": 0.096,
    }  # type: Dict[str, Union(type)]

    BYTES = "bytes"  # type: str
    NANOSECONDS = "nanoseconds"  # type: str
    MICROSECONDS = "microseconds"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self, parent=None, choice=None, bytes=12, nanoseconds=96, microseconds=0.096
    ):
        super(FlowDurationInterBurstGap, self).__init__()
        self._parent = parent
        self._set_property("bytes", bytes)
        self._set_property("nanoseconds", nanoseconds)
        self._set_property("microseconds", microseconds)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, bytes=None, nanoseconds=None, microseconds=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def choice(self):
        # type: () -> Union[Literal["bytes"], Literal["microseconds"], Literal["nanoseconds"]]
        """choice getter

        The type of inter burst gap units.

        Returns: Union[Literal["bytes"], Literal["microseconds"], Literal["nanoseconds"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        The type of inter burst gap units.

        value: Union[Literal["bytes"], Literal["microseconds"], Literal["nanoseconds"]]
        """
        self._set_property("choice", value)

    @property
    def bytes(self):
        # type: () -> float
        """bytes getter

        The amount of time between bursts expressed in bytes.. value of indicates no gap between bursts.

        Returns: float
        """
        return self._get_property("bytes")

    @bytes.setter
    def bytes(self, value):
        """bytes setter

        The amount of time between bursts expressed in bytes.. value of indicates no gap between bursts.

        value: float
        """
        self._set_property("bytes", value, "bytes")

    @property
    def nanoseconds(self):
        # type: () -> float
        """nanoseconds getter

        The amount of time between bursts expressed in nanoseconds.. value of indicates no gap between bursts.

        Returns: float
        """
        return self._get_property("nanoseconds")

    @nanoseconds.setter
    def nanoseconds(self, value):
        """nanoseconds setter

        The amount of time between bursts expressed in nanoseconds.. value of indicates no gap between bursts.

        value: float
        """
        self._set_property("nanoseconds", value, "nanoseconds")

    @property
    def microseconds(self):
        # type: () -> float
        """microseconds getter

        The amount of time between bursts expressed in microseconds.. value of indicates no gap between bursts.

        Returns: float
        """
        return self._get_property("microseconds")

    @microseconds.setter
    def microseconds(self, value):
        """microseconds setter

        The amount of time between bursts expressed in microseconds.. value of indicates no gap between bursts.

        value: float
        """
        self._set_property("microseconds", value, "microseconds")


class FlowContinuous(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "gap": {
            "type": int,
            "format": "uint32",
        },
        "delay": {"type": "FlowDelay"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "gap": 12,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, gap=12):
        super(FlowContinuous, self).__init__()
        self._parent = parent
        self._set_property("gap", gap)

    def set(self, gap=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def gap(self):
        # type: () -> int
        """gap getter

        The minimum gap between packets expressed as bytes.

        Returns: int
        """
        return self._get_property("gap")

    @gap.setter
    def gap(self, value):
        """gap setter

        The minimum gap between packets expressed as bytes.

        value: int
        """
        self._set_property("gap", value)

    @property
    def delay(self):
        # type: () -> FlowDelay
        """delay getter

        The optional container to specify the delay before starting transmission of packets.The optional container to specify the delay before starting transmission of packets.The optional container to specify the delay before starting transmission of packets.The optional container to specify the delay before starting transmission of packets.

        Returns: FlowDelay
        """
        return self._get_property("delay", FlowDelay)


class FlowMetrics(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "enable": {"type": bool},
        "loss": {"type": bool},
        "rx_tx_ratio": {"type": "FlowRxTxRatio"},
        "timestamps": {"type": bool},
        "latency": {"type": "FlowLatencyMetrics"},
        "predefined_metric_tags": {"type": "FlowPredefinedTags"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "enable": False,
        "loss": False,
        "timestamps": False,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, enable=False, loss=False, timestamps=False):
        super(FlowMetrics, self).__init__()
        self._parent = parent
        self._set_property("enable", enable)
        self._set_property("loss", loss)
        self._set_property("timestamps", timestamps)

    def set(self, enable=None, loss=None, timestamps=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def enable(self):
        # type: () -> bool
        """enable getter

        Enables flow metrics.. Enabling this option may affect the resultant packet payload due to additional instrumentation data.

        Returns: bool
        """
        return self._get_property("enable")

    @enable.setter
    def enable(self, value):
        """enable setter

        Enables flow metrics.. Enabling this option may affect the resultant packet payload due to additional instrumentation data.

        value: bool
        """
        self._set_property("enable", value)

    @property
    def loss(self):
        # type: () -> bool
        """loss getter

        Enables additional flow metric loss calculation.

        Returns: bool
        """
        return self._get_property("loss")

    @loss.setter
    def loss(self, value):
        """loss setter

        Enables additional flow metric loss calculation.

        value: bool
        """
        self._set_property("loss", value)

    @property
    def rx_tx_ratio(self):
        # type: () -> FlowRxTxRatio
        """rx_tx_ratio getter

        Rx Tx ratio is the ratio of expected number of Rx packets across all Rx ports to the Tx packets. for the configured flow. It is factor by which the Tx packet count is multiplied to calculate. the sum of expected Rx packet count, across all Rx ports. This will be used to calculate loss. percentage of flow at aggregate level.Rx Tx ratio is the ratio of expected number of Rx packets across all Rx ports to the Tx packets. for the configured flow. It is factor by which the Tx packet count is multiplied to calculate. the sum of expected Rx packet count, across all Rx ports. This will be used to calculate loss. percentage of flow at aggregate level.Rx Tx ratio is the ratio of expected number of Rx packets across all Rx ports to the Tx packets. for the configured flow. It is factor by which the Tx packet count is multiplied to calculate. the sum of expected Rx packet count, across all Rx ports. This will be used to calculate loss. percentage of flow at aggregate level.Rx Tx ratio.

        Returns: FlowRxTxRatio
        """
        return self._get_property("rx_tx_ratio", FlowRxTxRatio)

    @property
    def timestamps(self):
        # type: () -> bool
        """timestamps getter

        Enables additional flow metric first and last timestamps.

        Returns: bool
        """
        return self._get_property("timestamps")

    @timestamps.setter
    def timestamps(self, value):
        """timestamps setter

        Enables additional flow metric first and last timestamps.

        value: bool
        """
        self._set_property("timestamps", value)

    @property
    def latency(self):
        # type: () -> FlowLatencyMetrics
        """latency getter

        The optional container for per flow latency metric configuration.The optional container for per flow latency metric configuration.The optional container for per flow latency metric configuration.Latency metrics.

        Returns: FlowLatencyMetrics
        """
        return self._get_property("latency", FlowLatencyMetrics)

    @property
    def predefined_metric_tags(self):
        # type: () -> FlowPredefinedTags
        """predefined_metric_tags getter

        List of predefined flow tracking options, outside packet fields, that can be enabled.List of predefined flow tracking options, outside packet fields, that can be enabled.List of predefined flow tracking options, outside packet fields, that can be enabled.Predefined metric tags

        Returns: FlowPredefinedTags
        """
        return self._get_property("predefined_metric_tags", FlowPredefinedTags)


class FlowRxTxRatio(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "rx_count",
                "value",
            ],
        },
        "rx_count": {"type": "FlowRxTxRatioRxCount"},
        "value": {
            "type": float,
            "format": "float",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "value",
        "value": 1.0,
    }  # type: Dict[str, Union(type)]

    RX_COUNT = "rx_count"  # type: str
    VALUE = "value"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, value=1.0):
        super(FlowRxTxRatio, self).__init__()
        self._parent = parent
        self._set_property("value", value)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, value=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def rx_count(self):
        # type: () -> FlowRxTxRatioRxCount
        """Factory property that returns an instance of the FlowRxTxRatioRxCount class

        This is for cases where one copy of Tx packet is received on all Rx ports and so the sum total of Rx packets. received across all Rx ports is multiple of Rx port count and Tx packets.

        Returns: FlowRxTxRatioRxCount
        """
        return self._get_property("rx_count", FlowRxTxRatioRxCount, self, "rx_count")

    @property
    def choice(self):
        # type: () -> Union[Literal["rx_count"], Literal["value"]]
        """choice getter

        TBD

        Returns: Union[Literal["rx_count"], Literal["value"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["rx_count"], Literal["value"]]
        """
        self._set_property("choice", value)

    @property
    def value(self):
        # type: () -> float
        """value getter

        Should be positive, non-zero value. The default value of 1, is when the Rx packet count across. all ports is expected to match the Tx packet count. custom integer value (>1) can be specified for. loss calculation for cases when there are multiple destination addresses configured within one flow,. but DUT is configured to replicate only to subset of Rx ports. For cases when Tx side generates two. packets from each source in 1:1 protection mode but only one of the two packets are received by the. Rx port, we may need to specify fractional value instead.

        Returns: float
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        Should be positive, non-zero value. The default value of 1, is when the Rx packet count across. all ports is expected to match the Tx packet count. custom integer value (>1) can be specified for. loss calculation for cases when there are multiple destination addresses configured within one flow,. but DUT is configured to replicate only to subset of Rx ports. For cases when Tx side generates two. packets from each source in 1:1 protection mode but only one of the two packets are received by the. Rx port, we may need to specify fractional value instead.

        value: float
        """
        self._set_property("value", value, "value")


class FlowRxTxRatioRxCount(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {}  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None):
        super(FlowRxTxRatioRxCount, self).__init__()
        self._parent = parent


class FlowLatencyMetrics(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "enable": {"type": bool},
        "mode": {
            "type": str,
            "enum": [
                "store_forward",
                "cut_through",
            ],
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "enable": False,
        "mode": "store_forward",
    }  # type: Dict[str, Union(type)]

    STORE_FORWARD = "store_forward"  # type: str
    CUT_THROUGH = "cut_through"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, enable=False, mode="store_forward"):
        super(FlowLatencyMetrics, self).__init__()
        self._parent = parent
        self._set_property("enable", enable)
        self._set_property("mode", mode)

    def set(self, enable=None, mode=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def enable(self):
        # type: () -> bool
        """enable getter

        True to enable latency metrics using timestamps.. Enabling this option may affect the resultant packet payload due to additional instrumentation data.

        Returns: bool
        """
        return self._get_property("enable")

    @enable.setter
    def enable(self, value):
        """enable setter

        True to enable latency metrics using timestamps.. Enabling this option may affect the resultant packet payload due to additional instrumentation data.

        value: bool
        """
        self._set_property("enable", value)

    @property
    def mode(self):
        # type: () -> Union[Literal["cut_through"], Literal["store_forward"]]
        """mode getter

        Select the type of latency measurement. The different types of latency measurements are:. . store_forward:. The time interval starting when the last bit of the frame leaves the. sending port and ending when the first bit of the frame is seen on. the receiving port (LIFO). This is based on the RFC 1242 standard.. . cut_through:. The time interval starting when the first bit of the frame leaves. the sending port and ending when the first bit of the frame is seen. on the receiving port (FIFO). This is based on the RFC 1242 standard.

        Returns: Union[Literal["cut_through"], Literal["store_forward"]]
        """
        return self._get_property("mode")

    @mode.setter
    def mode(self, value):
        """mode setter

        Select the type of latency measurement. The different types of latency measurements are:. . store_forward:. The time interval starting when the last bit of the frame leaves the. sending port and ending when the first bit of the frame is seen on. the receiving port (LIFO). This is based on the RFC 1242 standard.. . cut_through:. The time interval starting when the first bit of the frame leaves. the sending port and ending when the first bit of the frame is seen. on the receiving port (FIFO). This is based on the RFC 1242 standard.

        value: Union[Literal["cut_through"], Literal["store_forward"]]
        """
        self._set_property("mode", value)


class FlowPredefinedTags(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "rx_name": {"type": bool},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "rx_name": False,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, rx_name=False):
        super(FlowPredefinedTags, self).__init__()
        self._parent = parent
        self._set_property("rx_name", rx_name)

    def set(self, rx_name=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def rx_name(self):
        # type: () -> bool
        """rx_name getter

        Enables Rx port or lag level disaggregation with predefined metrics tag name set as "rx_name".. The Rx port lag names can be found under tagged_metrics tag names in flow metrics response.

        Returns: bool
        """
        return self._get_property("rx_name")

    @rx_name.setter
    def rx_name(self, value):
        """rx_name setter

        Enables Rx port or lag level disaggregation with predefined metrics tag name set as "rx_name".. The Rx port lag names can be found under tagged_metrics tag names in flow metrics response.

        value: bool
        """
        self._set_property("rx_name", value)


class FlowIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(FlowIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[Flow]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> FlowIter
        return self._iter()

    def __next__(self):
        # type: () -> Flow
        return self._next()

    def next(self):
        # type: () -> Flow
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, Flow):
            raise Exception("Item is not an instance of Flow")

    def flow(self, name=None):
        # type: (str) -> FlowIter
        """Factory method that creates an instance of the Flow class

        A high level data plane traffic flow.

        Returns: FlowIter
        """
        item = Flow(parent=self._parent, name=name)
        self._add(item)
        return self

    def add(self, name=None):
        # type: (str) -> Flow
        """Add method that creates and returns an instance of the Flow class

        A high level data plane traffic flow.

        Returns: Flow
        """
        item = Flow(parent=self._parent, name=name)
        self._add(item)
        return item


class Event(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "enable": {"type": bool},
        "link": {"type": "EventLink"},
        "rx_rate_threshold": {"type": "EventRxRateThreshold"},
        "route_advertise_withdraw": {"type": "EventRouteAdvertiseWithdraw"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "enable": False,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, enable=False):
        super(Event, self).__init__()
        self._parent = parent
        self._set_property("enable", enable)

    def set(self, enable=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def enable(self):
        # type: () -> bool
        """enable getter

        True to enable all events. Enabling this option may affect the resultant packet payload due to additional instrumentation data.

        Returns: bool
        """
        return self._get_property("enable")

    @enable.setter
    def enable(self, value):
        """enable setter

        True to enable all events. Enabling this option may affect the resultant packet payload due to additional instrumentation data.

        value: bool
        """
        self._set_property("enable", value)

    @property
    def link(self):
        # type: () -> EventLink
        """link getter

        The optional container for link up/down event configuration.The optional container for link up/down event configuration.The optional container for link up/down event configuration.

        Returns: EventLink
        """
        return self._get_property("link", EventLink)

    @property
    def rx_rate_threshold(self):
        # type: () -> EventRxRateThreshold
        """rx_rate_threshold getter

        The optional container for rx rate threshold event configuration.The optional container for rx rate threshold event configuration.The optional container for rx rate threshold event configuration.

        Returns: EventRxRateThreshold
        """
        return self._get_property("rx_rate_threshold", EventRxRateThreshold)

    @property
    def route_advertise_withdraw(self):
        # type: () -> EventRouteAdvertiseWithdraw
        """route_advertise_withdraw getter

        The optional container for route advertise/withdraw event configuration.The optional container for route advertise/withdraw event configuration.The optional container for route advertise/withdraw event configuration.

        Returns: EventRouteAdvertiseWithdraw
        """
        return self._get_property(
            "route_advertise_withdraw", EventRouteAdvertiseWithdraw
        )


class EventLink(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "enable": {"type": bool},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "enable": False,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, enable=False):
        super(EventLink, self).__init__()
        self._parent = parent
        self._set_property("enable", enable)

    def set(self, enable=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def enable(self):
        # type: () -> bool
        """enable getter

        True to enable notifications when link up/down event occurs.

        Returns: bool
        """
        return self._get_property("enable")

    @enable.setter
    def enable(self, value):
        """enable setter

        True to enable notifications when link up/down event occurs.

        value: bool
        """
        self._set_property("enable", value)


class EventRxRateThreshold(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "enable": {"type": bool},
        "threshold": {
            "type": float,
            "format": "float",
            "minimum": 0,
            "maximum": 100,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "enable": False,
        "threshold": 95.0,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, enable=False, threshold=95):
        super(EventRxRateThreshold, self).__init__()
        self._parent = parent
        self._set_property("enable", enable)
        self._set_property("threshold", threshold)

    def set(self, enable=None, threshold=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def enable(self):
        # type: () -> bool
        """enable getter

        True to enable the rx_rate_threshold event. Enabling this option may affect the resultant packet payload due to additional instrumentation data.

        Returns: bool
        """
        return self._get_property("enable")

    @enable.setter
    def enable(self, value):
        """enable setter

        True to enable the rx_rate_threshold event. Enabling this option may affect the resultant packet payload due to additional instrumentation data.

        value: bool
        """
        self._set_property("enable", value)

    @property
    def threshold(self):
        # type: () -> float
        """threshold getter

        True to enable notifications when the rx rate of flow passes above or below the threshold value.

        Returns: float
        """
        return self._get_property("threshold")

    @threshold.setter
    def threshold(self, value):
        """threshold setter

        True to enable notifications when the rx rate of flow passes above or below the threshold value.

        value: float
        """
        self._set_property("threshold", value)


class EventRouteAdvertiseWithdraw(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "enable": {"type": bool},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "enable": False,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, enable=False):
        super(EventRouteAdvertiseWithdraw, self).__init__()
        self._parent = parent
        self._set_property("enable", enable)

    def set(self, enable=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def enable(self):
        # type: () -> bool
        """enable getter

        True to enable notifications when route advertise/withdraw event occurs.

        Returns: bool
        """
        return self._get_property("enable")

    @enable.setter
    def enable(self, value):
        """enable setter

        True to enable notifications when route advertise/withdraw event occurs.

        value: bool
        """
        self._set_property("enable", value)


class ConfigOptions(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "port_options": {"type": "PortOptions"},
        "protocol_options": {"type": "ProtocolOptions"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None):
        super(ConfigOptions, self).__init__()
        self._parent = parent

    @property
    def port_options(self):
        # type: () -> PortOptions
        """port_options getter

        Common port options that apply to all configured Port objects. Common port options that apply to all configured Port objects. Common port options that apply to all configured Port objects.

        Returns: PortOptions
        """
        return self._get_property("port_options", PortOptions)

    @property
    def protocol_options(self):
        # type: () -> ProtocolOptions
        """protocol_options getter

        Common options that apply to all configured protocols and interfaces. Common options that apply to all configured protocols and interfaces. Common options that apply to all configured protocols and interfaces.

        Returns: ProtocolOptions
        """
        return self._get_property("protocol_options", ProtocolOptions)


class PortOptions(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "location_preemption": {"type": bool},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "location_preemption": False,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, location_preemption=False):
        super(PortOptions, self).__init__()
        self._parent = parent
        self._set_property("location_preemption", location_preemption)

    def set(self, location_preemption=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def location_preemption(self):
        # type: () -> bool
        """location_preemption getter

        Preempt all the test port locations as defined by the Port.Port.properties.location. If the test ports defined by their location values are in use and this value is true, the test ports will be preempted.

        Returns: bool
        """
        return self._get_property("location_preemption")

    @location_preemption.setter
    def location_preemption(self, value):
        """location_preemption setter

        Preempt all the test port locations as defined by the Port.Port.properties.location. If the test ports defined by their location values are in use and this value is true, the test ports will be preempted.

        value: bool
        """
        self._set_property("location_preemption", value)


class ProtocolOptions(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "auto_start_all": {"type": bool},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "auto_start_all": True,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, auto_start_all=True):
        super(ProtocolOptions, self).__init__()
        self._parent = parent
        self._set_property("auto_start_all", auto_start_all)

    def set(self, auto_start_all=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def auto_start_all(self):
        # type: () -> bool
        """auto_start_all getter

        When set to true, all underlying resources for configured protocols and interfaces shall be created and corresponding protocol session negotiation shall be initiated. Otherwise, when set to false, corresponding protocol session negotiation will need to be initiated using separate set_protocol_state API call.

        Returns: bool
        """
        return self._get_property("auto_start_all")

    @auto_start_all.setter
    def auto_start_all(self, value):
        """auto_start_all setter

        When set to true, all underlying resources for configured protocols and interfaces shall be created and corresponding protocol session negotiation shall be initiated. Otherwise, when set to false, corresponding protocol session negotiation will need to be initiated using separate set_protocol_state API call.

        value: bool
        """
        self._set_property("auto_start_all", value)


class Lldp(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "connection": {"type": "LldpConnection"},
        "chassis_id": {"type": "LldpChassisId"},
        "port_id": {"type": "LldpPortId"},
        "system_name": {"type": "LldpSystemName"},
        "hold_time": {
            "type": int,
            "format": "uint32",
            "minimum": 10,
            "maximum": 65535,
        },
        "advertisement_interval": {
            "type": int,
            "format": "uint32",
            "minimum": 5,
            "maximum": 65534,
        },
        "name": {"type": str},
    }  # type: Dict[str, str]

    _REQUIRED = ("connection", "name")  # type: tuple(str)

    _DEFAULTS = {
        "hold_time": 120,
        "advertisement_interval": 30,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self, parent=None, hold_time=120, advertisement_interval=30, name=None
    ):
        super(Lldp, self).__init__()
        self._parent = parent
        self._set_property("hold_time", hold_time)
        self._set_property("advertisement_interval", advertisement_interval)
        self._set_property("name", name)

    def set(self, hold_time=None, advertisement_interval=None, name=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def connection(self):
        # type: () -> LldpConnection
        """connection getter

        LLDP connection to test port. In future if more connection options arise LLDP connection object will be enhanced. LLDP connection to test port. In future if more connection options arise LLDP connection object will be enhanced. LLDP connection to test port. In future if more connection options arise LLDP connection object will be enhanced. The unique name of the object on which LLDP is running.

        Returns: LldpConnection
        """
        return self._get_property("connection", LldpConnection)

    @property
    def chassis_id(self):
        # type: () -> LldpChassisId
        """chassis_id getter

        The Chassis ID is mandatory TLV which identifies the chassis component of the endpoint identifier associated with the transmitting LLDP agent. This field identifies the format and source of the chassis identifier string. It is based on the enumerator defined by the LldpChassisIdSubtype object from IEEE 802.1AB MIB.The Chassis ID is mandatory TLV which identifies the chassis component of the endpoint identifier associated with the transmitting LLDP agent. This field identifies the format and source of the chassis identifier string. It is based on the enumerator defined by the LldpChassisIdSubtype object from IEEE 802.1AB MIB.The Chassis ID is mandatory TLV which identifies the chassis component of the endpoint identifier associated with the transmitting LLDP agent. This field identifies the format and source of the chassis identifier string. It is based on the enumerator defined by the LldpChassisIdSubtype object from IEEE 802.1AB MIB.The Chassis ID is mandatory TLV which identifies the chassis component of the endpoint identifier associated with the transmitting LLDP agent. If mac address is specified it should be in colon seperated mac address format.

        Returns: LldpChassisId
        """
        return self._get_property("chassis_id", LldpChassisId)

    @property
    def port_id(self):
        # type: () -> LldpPortId
        """port_id getter

        The Port ID is mandatory TLV which identifies the port component of the endpoint identifier associated with the transmitting LLDP agent.This field identifies the format and source of the port identifier string. It is based on the enumerator defined by the PtopoPortIdType object from RFC2922.The Port ID is mandatory TLV which identifies the port component of the endpoint identifier associated with the transmitting LLDP agent.This field identifies the format and source of the port identifier string. It is based on the enumerator defined by the PtopoPortIdType object from RFC2922.The Port ID is mandatory TLV which identifies the port component of the endpoint identifier associated with the transmitting LLDP agent.This field identifies the format and source of the port identifier string. It is based on the enumerator defined by the PtopoPortIdType object from RFC2922.The Port ID is mandatory TLV which identifies the port component of the endpoint identifier associated with the transmitting LLDP agent. If the specified port is an IEEE 802.3 Repeater port, then this TLV is optional.

        Returns: LldpPortId
        """
        return self._get_property("port_id", LldpPortId)

    @property
    def system_name(self):
        # type: () -> LldpSystemName
        """system_name getter

        The system Name configured in the System Name TLV. The system Name configured in the System Name TLV. The system Name configured in the System Name TLV. The system name field shall contain an alpha-numeric string that indicates the system's administratively assigned name. The system name should be the system's fully qualified domain name. If implementations support IETF RFC 3418, the sysName object should be used for this field.

        Returns: LldpSystemName
        """
        return self._get_property("system_name", LldpSystemName)

    @property
    def hold_time(self):
        # type: () -> int
        """hold_time getter

        Specifies the amount of time in seconds receiving device should maintain LLDP information sent by the device before discarding it.

        Returns: int
        """
        return self._get_property("hold_time")

    @hold_time.setter
    def hold_time(self, value):
        """hold_time setter

        Specifies the amount of time in seconds receiving device should maintain LLDP information sent by the device before discarding it.

        value: int
        """
        self._set_property("hold_time", value)

    @property
    def advertisement_interval(self):
        # type: () -> int
        """advertisement_interval getter

        Set the transmission frequency of LLDP updates in seconds.

        Returns: int
        """
        return self._get_property("advertisement_interval")

    @advertisement_interval.setter
    def advertisement_interval(self, value):
        """advertisement_interval setter

        Set the transmission frequency of LLDP updates in seconds.

        value: int
        """
        self._set_property("advertisement_interval", value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Globally unique name of an object. It also serves as the primary key for arrays of objects.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property name as None")
        self._set_property("name", value)


class LldpConnection(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "port_name",
            ],
        },
        "port_name": {"type": str},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    PORT_NAME = "port_name"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, port_name=None):
        super(LldpConnection, self).__init__()
        self._parent = parent
        self._set_property("port_name", port_name)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, port_name=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def choice(self):
        # type: () -> Union[Literal["port_name"]]
        """choice getter

        The name of the test port or other connection objects on which LLDP is configured.

        Returns: Union[Literal["port_name"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        The name of the test port or other connection objects on which LLDP is configured.

        value: Union[Literal["port_name"]]
        """
        self._set_property("choice", value)

    @property
    def port_name(self):
        # type: () -> str
        """port_name getter

        Name of the test port on which LLDP is configured on.. x-constraint:. /components/schemas/Port/properties/name. . x-constraint:. /components/schemas/Port/properties/name.

        Returns: str
        """
        return self._get_property("port_name")

    @port_name.setter
    def port_name(self, value):
        """port_name setter

        Name of the test port on which LLDP is configured on.. x-constraint:. /components/schemas/Port/properties/name. . x-constraint:. /components/schemas/Port/properties/name.

        value: str
        """
        self._set_property("port_name", value, "port_name")


class LldpChassisId(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "mac_address_subtype",
                "interface_name_subtype",
                "local_subtype",
            ],
        },
        "mac_address_subtype": {"type": "LldpChassisMacSubType"},
        "interface_name_subtype": {"type": str},
        "local_subtype": {"type": str},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "mac_address_subtype",
    }  # type: Dict[str, Union(type)]

    MAC_ADDRESS_SUBTYPE = "mac_address_subtype"  # type: str
    INTERFACE_NAME_SUBTYPE = "interface_name_subtype"  # type: str
    LOCAL_SUBTYPE = "local_subtype"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self, parent=None, choice=None, interface_name_subtype=None, local_subtype=None
    ):
        super(LldpChassisId, self).__init__()
        self._parent = parent
        self._set_property("interface_name_subtype", interface_name_subtype)
        self._set_property("local_subtype", local_subtype)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, interface_name_subtype=None, local_subtype=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def mac_address_subtype(self):
        # type: () -> LldpChassisMacSubType
        """Factory property that returns an instance of the LldpChassisMacSubType class

        The MAC address configured in the Chassis ID TLV.

        Returns: LldpChassisMacSubType
        """
        return self._get_property(
            "mac_address_subtype", LldpChassisMacSubType, self, "mac_address_subtype"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["interface_name_subtype"], Literal["local_subtype"], Literal["mac_address_subtype"]]
        """choice getter

        Chassis ID subtype to be used in Chassis ID TLV.

        Returns: Union[Literal["interface_name_subtype"], Literal["local_subtype"], Literal["mac_address_subtype"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        Chassis ID subtype to be used in Chassis ID TLV.

        value: Union[Literal["interface_name_subtype"], Literal["local_subtype"], Literal["mac_address_subtype"]]
        """
        self._set_property("choice", value)

    @property
    def interface_name_subtype(self):
        # type: () -> str
        """interface_name_subtype getter

        Name of an interface of the chassis that uniquely identifies the chassis.

        Returns: str
        """
        return self._get_property("interface_name_subtype")

    @interface_name_subtype.setter
    def interface_name_subtype(self, value):
        """interface_name_subtype setter

        Name of an interface of the chassis that uniquely identifies the chassis.

        value: str
        """
        self._set_property("interface_name_subtype", value, "interface_name_subtype")

    @property
    def local_subtype(self):
        # type: () -> str
        """local_subtype getter

        Locally assigned name of the chassis.

        Returns: str
        """
        return self._get_property("local_subtype")

    @local_subtype.setter
    def local_subtype(self, value):
        """local_subtype setter

        Locally assigned name of the chassis.

        value: str
        """
        self._set_property("local_subtype", value, "local_subtype")


class LldpChassisMacSubType(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "auto",
                "value",
            ],
        },
        "auto": {
            "type": str,
            "format": "mac",
        },
        "value": {
            "type": str,
            "format": "mac",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "auto",
    }  # type: Dict[str, Union(type)]

    AUTO = "auto"  # type: str
    VALUE = "value"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, auto=None, value=None):
        super(LldpChassisMacSubType, self).__init__()
        self._parent = parent
        self._set_property("auto", auto)
        self._set_property("value", value)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, auto=None, value=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def choice(self):
        # type: () -> Union[Literal["auto"], Literal["value"]]
        """choice getter

        In auto mode the system generated value is set for this property, while if the choice is selected as value, user configured value will be used for this property.

        Returns: Union[Literal["auto"], Literal["value"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        In auto mode the system generated value is set for this property, while if the choice is selected as value, user configured value will be used for this property.

        value: Union[Literal["auto"], Literal["value"]]
        """
        self._set_property("choice", value)

    @property
    def auto(self):
        # type: () -> str
        """auto getter

        The OTG implementation must provide system generated value for this property.

        Returns: str
        """
        return self._get_property("auto")

    @property
    def value(self):
        # type: () -> str
        """value getter

        User must specify value if mode is not auto.

        Returns: str
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        User must specify value if mode is not auto.

        value: str
        """
        self._set_property("value", value, "value")


class LldpPortId(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "mac_address_subtype",
                "interface_name_subtype",
                "local_subtype",
            ],
        },
        "mac_address_subtype": {"type": str},
        "interface_name_subtype": {"type": "LldpPortInterfaceNameSubType"},
        "local_subtype": {"type": str},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "interface_name_subtype",
    }  # type: Dict[str, Union(type)]

    MAC_ADDRESS_SUBTYPE = "mac_address_subtype"  # type: str
    INTERFACE_NAME_SUBTYPE = "interface_name_subtype"  # type: str
    LOCAL_SUBTYPE = "local_subtype"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self, parent=None, choice=None, mac_address_subtype=None, local_subtype=None
    ):
        super(LldpPortId, self).__init__()
        self._parent = parent
        self._set_property("mac_address_subtype", mac_address_subtype)
        self._set_property("local_subtype", local_subtype)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, mac_address_subtype=None, local_subtype=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def interface_name_subtype(self):
        # type: () -> LldpPortInterfaceNameSubType
        """Factory property that returns an instance of the LldpPortInterfaceNameSubType class

        The interface name configured in the Port ID TLV.

        Returns: LldpPortInterfaceNameSubType
        """
        return self._get_property(
            "interface_name_subtype",
            LldpPortInterfaceNameSubType,
            self,
            "interface_name_subtype",
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["interface_name_subtype"], Literal["local_subtype"], Literal["mac_address_subtype"]]
        """choice getter

        Port ID subtype to be used in Port ID TLV.

        Returns: Union[Literal["interface_name_subtype"], Literal["local_subtype"], Literal["mac_address_subtype"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        Port ID subtype to be used in Port ID TLV.

        value: Union[Literal["interface_name_subtype"], Literal["local_subtype"], Literal["mac_address_subtype"]]
        """
        self._set_property("choice", value)

    @property
    def mac_address_subtype(self):
        # type: () -> str
        """mac_address_subtype getter

        The MAC Address configured in the Port ID TLV.

        Returns: str
        """
        return self._get_property("mac_address_subtype")

    @mac_address_subtype.setter
    def mac_address_subtype(self, value):
        """mac_address_subtype setter

        The MAC Address configured in the Port ID TLV.

        value: str
        """
        self._set_property("mac_address_subtype", value, "mac_address_subtype")

    @property
    def local_subtype(self):
        # type: () -> str
        """local_subtype getter

        The Locally assigned name configured in the Port ID TLV.

        Returns: str
        """
        return self._get_property("local_subtype")

    @local_subtype.setter
    def local_subtype(self, value):
        """local_subtype setter

        The Locally assigned name configured in the Port ID TLV.

        value: str
        """
        self._set_property("local_subtype", value, "local_subtype")


class LldpPortInterfaceNameSubType(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "auto",
                "value",
            ],
        },
        "auto": {"type": str},
        "value": {"type": str},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "auto",
    }  # type: Dict[str, Union(type)]

    AUTO = "auto"  # type: str
    VALUE = "value"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, auto=None, value=None):
        super(LldpPortInterfaceNameSubType, self).__init__()
        self._parent = parent
        self._set_property("auto", auto)
        self._set_property("value", value)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, auto=None, value=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def choice(self):
        # type: () -> Union[Literal["auto"], Literal["value"]]
        """choice getter

        In auto mode the system generated value is set for this property, while if the choice is selected as value, user configured value will be used for this property.

        Returns: Union[Literal["auto"], Literal["value"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        In auto mode the system generated value is set for this property, while if the choice is selected as value, user configured value will be used for this property.

        value: Union[Literal["auto"], Literal["value"]]
        """
        self._set_property("choice", value)

    @property
    def auto(self):
        # type: () -> str
        """auto getter

        The OTG implementation must provide system generated value for this property.

        Returns: str
        """
        return self._get_property("auto")

    @property
    def value(self):
        # type: () -> str
        """value getter

        User must specify value if mode is not auto.

        Returns: str
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        User must specify value if mode is not auto.

        value: str
        """
        self._set_property("value", value, "value")


class LldpSystemName(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "auto",
                "value",
            ],
        },
        "auto": {"type": str},
        "value": {"type": str},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "auto",
    }  # type: Dict[str, Union(type)]

    AUTO = "auto"  # type: str
    VALUE = "value"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, auto=None, value=None):
        super(LldpSystemName, self).__init__()
        self._parent = parent
        self._set_property("auto", auto)
        self._set_property("value", value)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, auto=None, value=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def choice(self):
        # type: () -> Union[Literal["auto"], Literal["value"]]
        """choice getter

        In auto mode the system generated value is set for this property, while if the choice is selected as value, user configured value will be used for this property.

        Returns: Union[Literal["auto"], Literal["value"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        In auto mode the system generated value is set for this property, while if the choice is selected as value, user configured value will be used for this property.

        value: Union[Literal["auto"], Literal["value"]]
        """
        self._set_property("choice", value)

    @property
    def auto(self):
        # type: () -> str
        """auto getter

        The OTG implementation must provide system generated value for this property.

        Returns: str
        """
        return self._get_property("auto")

    @property
    def value(self):
        # type: () -> str
        """value getter

        User must specify value if mode is not auto.

        Returns: str
        """
        return self._get_property("value")

    @value.setter
    def value(self, value):
        """value setter

        User must specify value if mode is not auto.

        value: str
        """
        self._set_property("value", value, "value")


class LldpIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(LldpIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[Lldp]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> LldpIter
        return self._iter()

    def __next__(self):
        # type: () -> Lldp
        return self._next()

    def next(self):
        # type: () -> Lldp
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, Lldp):
            raise Exception("Item is not an instance of Lldp")

    def lldp(self, hold_time=120, advertisement_interval=30, name=None):
        # type: (int,int,str) -> LldpIter
        """Factory method that creates an instance of the Lldp class

        Configuration of LLDP protocol IEEE Ref: https://www.ieee802.org/1/files/public/docs2002/lldp-protocol-00.pdf

        Returns: LldpIter
        """
        item = Lldp(
            parent=self._parent,
            hold_time=hold_time,
            advertisement_interval=advertisement_interval,
            name=name,
        )
        self._add(item)
        return self

    def add(self, hold_time=120, advertisement_interval=30, name=None):
        # type: (int,int,str) -> Lldp
        """Add method that creates and returns an instance of the Lldp class

        Configuration of LLDP protocol IEEE Ref: https://www.ieee802.org/1/files/public/docs2002/lldp-protocol-00.pdf

        Returns: Lldp
        """
        item = Lldp(
            parent=self._parent,
            hold_time=hold_time,
            advertisement_interval=advertisement_interval,
            name=name,
        )
        self._add(item)
        return item


class Warning(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "warnings": {
            "type": list,
            "itemtype": str,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, warnings=None):
        super(Warning, self).__init__()
        self._parent = parent
        self._set_property("warnings", warnings)

    def set(self, warnings=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def warnings(self):
        # type: () -> List[str]
        """warnings getter

        A list of any system specific warnings that have occurred while executing the request.

        Returns: List[str]
        """
        return self._get_property("warnings")

    @warnings.setter
    def warnings(self, value):
        """warnings setter

        A list of any system specific warnings that have occurred while executing the request.

        value: List[str]
        """
        self._set_property("warnings", value)


class Error(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "code": {
            "type": int,
            "format": "int32",
        },
        "kind": {
            "type": str,
            "enum": [
                "validation",
                "internal",
            ],
        },
        "errors": {
            "type": list,
            "itemtype": str,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("code", "errors")  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    VALIDATION = "validation"  # type: str
    INTERNAL = "internal"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, code=None, kind=None, errors=None):
        super(Error, self).__init__()
        self._parent = parent
        self._set_property("code", code)
        self._set_property("kind", kind)
        self._set_property("errors", errors)

    def set(self, code=None, kind=None, errors=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def code(self):
        # type: () -> int
        """code getter

        Numeric status code based on the underlying transport being used.. The API server MUST set this code explicitly based on following references:. HTTP 4xx errors: https://datatracker.ietf.org/doc/html/rfc9110#section-15.5. HTTP 5xx errors: https://datatracker.ietf.org/doc/html/rfc9110#section-15.6. gRPC errors: https://grpc.github.io/grpc/core/md_doc_statuscodes.html

        Returns: int
        """
        return self._get_property("code")

    @code.setter
    def code(self, value):
        """code setter

        Numeric status code based on the underlying transport being used.. The API server MUST set this code explicitly based on following references:. HTTP 4xx errors: https://datatracker.ietf.org/doc/html/rfc9110#section-15.5. HTTP 5xx errors: https://datatracker.ietf.org/doc/html/rfc9110#section-15.6. gRPC errors: https://grpc.github.io/grpc/core/md_doc_statuscodes.html

        value: int
        """
        if value is None:
            raise TypeError("Cannot set required property code as None")
        self._set_property("code", value)

    @property
    def kind(self):
        # type: () -> Union[Literal["internal"], Literal["validation"]]
        """kind getter

        Classification of error originating from within API server that may not be mapped to the value in `code`.. Absence of this field may indicate that the error did not originate from within API server.

        Returns: Union[Literal["internal"], Literal["validation"]]
        """
        return self._get_property("kind")

    @kind.setter
    def kind(self, value):
        """kind setter

        Classification of error originating from within API server that may not be mapped to the value in `code`.. Absence of this field may indicate that the error did not originate from within API server.

        value: Union[Literal["internal"], Literal["validation"]]
        """
        self._set_property("kind", value)

    @property
    def errors(self):
        # type: () -> List[str]
        """errors getter

        List of error messages generated while executing the request.

        Returns: List[str]
        """
        return self._get_property("errors")

    @errors.setter
    def errors(self, value):
        """errors setter

        List of error messages generated while executing the request.

        value: List[str]
        """
        if value is None:
            raise TypeError("Cannot set required property errors as None")
        self._set_property("errors", value)


class ConfigUpdate(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "flows",
            ],
        },
        "flows": {"type": "FlowsUpdate"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    FLOWS = "flows"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None):
        super(ConfigUpdate, self).__init__()
        self._parent = parent
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    @property
    def flows(self):
        # type: () -> FlowsUpdate
        """Factory property that returns an instance of the FlowsUpdate class

        A container of flows with associated properties to be updated without affecting the flows current transmit state.

        Returns: FlowsUpdate
        """
        return self._get_property("flows", FlowsUpdate, self, "flows")

    @property
    def choice(self):
        # type: () -> Union[Literal["flows"]]
        """choice getter

        TBD

        Returns: Union[Literal["flows"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["flows"]]
        """
        self._set_property("choice", value)


class FlowsUpdate(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "property_names": {
            "type": list,
            "enum": [
                "rate",
                "size",
            ],
            "itemtype": str,
        },
        "flows": {"type": "FlowIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ("property_names", "flows")  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    RATE = "rate"  # type: str
    SIZE = "size"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, property_names=None):
        super(FlowsUpdate, self).__init__()
        self._parent = parent
        self._set_property("property_names", property_names)

    def set(self, property_names=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def property_names(self):
        # type: () -> List[Union[Literal["rate"], Literal["size"]]]
        """property_names getter

        Flow properties to be updated without affecting the transmit state.

        Returns: List[Union[Literal["rate"], Literal["size"]]]
        """
        return self._get_property("property_names")

    @property_names.setter
    def property_names(self, value):
        """property_names setter

        Flow properties to be updated without affecting the transmit state.

        value: List[Union[Literal["rate"], Literal["size"]]]
        """
        if value is None:
            raise TypeError("Cannot set required property property_names as None")
        self._set_property("property_names", value)

    @property
    def flows(self):
        # type: () -> FlowIter
        """flows getter

        The list of configured flows for which given property will be updated.

        Returns: FlowIter
        """
        return self._get_property("flows", FlowIter, self._parent, self._choice)


class ControlState(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "port",
                "protocol",
                "traffic",
            ],
        },
        "port": {"type": "StatePort"},
        "protocol": {"type": "StateProtocol"},
        "traffic": {"type": "StateTraffic"},
    }  # type: Dict[str, str]

    _REQUIRED = ("choice",)  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    PORT = "port"  # type: str
    PROTOCOL = "protocol"  # type: str
    TRAFFIC = "traffic"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None):
        super(ControlState, self).__init__()
        self._parent = parent
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    @property
    def port(self):
        # type: () -> StatePort
        """Factory property that returns an instance of the StatePort class

        States associated with configured ports.

        Returns: StatePort
        """
        return self._get_property("port", StatePort, self, "port")

    @property
    def protocol(self):
        # type: () -> StateProtocol
        """Factory property that returns an instance of the StateProtocol class

        States associated with protocols on configured resources.

        Returns: StateProtocol
        """
        return self._get_property("protocol", StateProtocol, self, "protocol")

    @property
    def traffic(self):
        # type: () -> StateTraffic
        """Factory property that returns an instance of the StateTraffic class

        States associated with configured flows

        Returns: StateTraffic
        """
        return self._get_property("traffic", StateTraffic, self, "traffic")

    @property
    def choice(self):
        # type: () -> Union[Literal["port"], Literal["protocol"], Literal["traffic"]]
        """choice getter

        TBD

        Returns: Union[Literal["port"], Literal["protocol"], Literal["traffic"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["port"], Literal["protocol"], Literal["traffic"]]
        """
        if value is None:
            raise TypeError("Cannot set required property choice as None")
        self._set_property("choice", value)


class StatePort(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "link",
                "capture",
            ],
        },
        "link": {"type": "StatePortLink"},
        "capture": {"type": "StatePortCapture"},
    }  # type: Dict[str, str]

    _REQUIRED = ("choice",)  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    LINK = "link"  # type: str
    CAPTURE = "capture"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None):
        super(StatePort, self).__init__()
        self._parent = parent
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    @property
    def link(self):
        # type: () -> StatePortLink
        """Factory property that returns an instance of the StatePortLink class

        Sets the link of configured ports.

        Returns: StatePortLink
        """
        return self._get_property("link", StatePortLink, self, "link")

    @property
    def capture(self):
        # type: () -> StatePortCapture
        """Factory property that returns an instance of the StatePortCapture class

        Sets the capture state of configured ports

        Returns: StatePortCapture
        """
        return self._get_property("capture", StatePortCapture, self, "capture")

    @property
    def choice(self):
        # type: () -> Union[Literal["capture"], Literal["link"]]
        """choice getter

        TBD

        Returns: Union[Literal["capture"], Literal["link"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["capture"], Literal["link"]]
        """
        if value is None:
            raise TypeError("Cannot set required property choice as None")
        self._set_property("choice", value)


class StatePortLink(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "port_names": {
            "type": list,
            "itemtype": str,
        },
        "state": {
            "type": str,
            "enum": [
                "down",
                "up",
            ],
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("state",)  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    DOWN = "down"  # type: str
    UP = "up"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, port_names=None, state=None):
        super(StatePortLink, self).__init__()
        self._parent = parent
        self._set_property("port_names", port_names)
        self._set_property("state", state)

    def set(self, port_names=None, state=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def port_names(self):
        # type: () -> List[str]
        """port_names getter

        The names of target ports. An empty or null list will target all ports.. x-constraint:. /components/schemas/Port/properties/name. . x-constraint:. /components/schemas/Port/properties/name.

        Returns: List[str]
        """
        return self._get_property("port_names")

    @port_names.setter
    def port_names(self, value):
        """port_names setter

        The names of target ports. An empty or null list will target all ports.. x-constraint:. /components/schemas/Port/properties/name. . x-constraint:. /components/schemas/Port/properties/name.

        value: List[str]
        """
        self._set_property("port_names", value)

    @property
    def state(self):
        # type: () -> Union[Literal["down"], Literal["up"]]
        """state getter

        The link state.

        Returns: Union[Literal["down"], Literal["up"]]
        """
        return self._get_property("state")

    @state.setter
    def state(self, value):
        """state setter

        The link state.

        value: Union[Literal["down"], Literal["up"]]
        """
        if value is None:
            raise TypeError("Cannot set required property state as None")
        self._set_property("state", value)


class StatePortCapture(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "port_names": {
            "type": list,
            "itemtype": str,
        },
        "state": {
            "type": str,
            "enum": [
                "start",
                "stop",
            ],
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("state",)  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    START = "start"  # type: str
    STOP = "stop"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, port_names=None, state=None):
        super(StatePortCapture, self).__init__()
        self._parent = parent
        self._set_property("port_names", port_names)
        self._set_property("state", state)

    def set(self, port_names=None, state=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def port_names(self):
        # type: () -> List[str]
        """port_names getter

        The names of ports to which the capture state will be applied to. If the list of port_names is empty or null the state will be applied to all configured ports.. If the list is not empty any port that is not included in the list of port_names MUST be ignored and not included in the state change.. x-constraint:. /components/schemas/Port/properties/name. . x-constraint:. /components/schemas/Port/properties/name.

        Returns: List[str]
        """
        return self._get_property("port_names")

    @port_names.setter
    def port_names(self, value):
        """port_names setter

        The names of ports to which the capture state will be applied to. If the list of port_names is empty or null the state will be applied to all configured ports.. If the list is not empty any port that is not included in the list of port_names MUST be ignored and not included in the state change.. x-constraint:. /components/schemas/Port/properties/name. . x-constraint:. /components/schemas/Port/properties/name.

        value: List[str]
        """
        self._set_property("port_names", value)

    @property
    def state(self):
        # type: () -> Union[Literal["start"], Literal["stop"]]
        """state getter

        The capture state.

        Returns: Union[Literal["start"], Literal["stop"]]
        """
        return self._get_property("state")

    @state.setter
    def state(self, value):
        """state setter

        The capture state.

        value: Union[Literal["start"], Literal["stop"]]
        """
        if value is None:
            raise TypeError("Cannot set required property state as None")
        self._set_property("state", value)


class StateProtocol(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "all",
                "route",
                "lacp",
            ],
        },
        "all": {"type": "StateProtocolAll"},
        "route": {"type": "StateProtocolRoute"},
        "lacp": {"type": "StateProtocolLacp"},
    }  # type: Dict[str, str]

    _REQUIRED = ("choice",)  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    ALL = "all"  # type: str
    ROUTE = "route"  # type: str
    LACP = "lacp"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None):
        super(StateProtocol, self).__init__()
        self._parent = parent
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    @property
    def all(self):
        # type: () -> StateProtocolAll
        """Factory property that returns an instance of the StateProtocolAll class

        Sets all configured protocols to `start` or `stop` state.. Setting protocol state to `start` shall be no-op if preceding `set_config` API call was made with `config.options.protocol_options.auto_start_all` set to `true` or if all the configured protocols are already started.

        Returns: StateProtocolAll
        """
        return self._get_property("all", StateProtocolAll, self, "all")

    @property
    def route(self):
        # type: () -> StateProtocolRoute
        """Factory property that returns an instance of the StateProtocolRoute class

        Sets the state of configured routes

        Returns: StateProtocolRoute
        """
        return self._get_property("route", StateProtocolRoute, self, "route")

    @property
    def lacp(self):
        # type: () -> StateProtocolLacp
        """Factory property that returns an instance of the StateProtocolLacp class

        Sets state of configured LACP

        Returns: StateProtocolLacp
        """
        return self._get_property("lacp", StateProtocolLacp, self, "lacp")

    @property
    def choice(self):
        # type: () -> Union[Literal["all"], Literal["lacp"], Literal["route"]]
        """choice getter

        TBD

        Returns: Union[Literal["all"], Literal["lacp"], Literal["route"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["all"], Literal["lacp"], Literal["route"]]
        """
        if value is None:
            raise TypeError("Cannot set required property choice as None")
        self._set_property("choice", value)


class StateProtocolAll(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "state": {
            "type": str,
            "enum": [
                "start",
                "stop",
            ],
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("state",)  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    START = "start"  # type: str
    STOP = "stop"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, state=None):
        super(StateProtocolAll, self).__init__()
        self._parent = parent
        self._set_property("state", state)

    def set(self, state=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def state(self):
        # type: () -> Union[Literal["start"], Literal["stop"]]
        """state getter

        Protocol states

        Returns: Union[Literal["start"], Literal["stop"]]
        """
        return self._get_property("state")

    @state.setter
    def state(self, value):
        """state setter

        Protocol states

        value: Union[Literal["start"], Literal["stop"]]
        """
        if value is None:
            raise TypeError("Cannot set required property state as None")
        self._set_property("state", value)


class StateProtocolRoute(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "names": {
            "type": list,
            "itemtype": str,
        },
        "state": {
            "type": str,
            "enum": [
                "advertise",
                "withdraw",
            ],
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("state",)  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    ADVERTISE = "advertise"  # type: str
    WITHDRAW = "withdraw"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, names=None, state=None):
        super(StateProtocolRoute, self).__init__()
        self._parent = parent
        self._set_property("names", names)
        self._set_property("state", state)

    def set(self, names=None, state=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def names(self):
        # type: () -> List[str]
        """names getter

        The names of device route objects to control. If no names are specified then all route objects that match the x-constraint will be affected.. x-constraint:. /components/schemas/Bgp.V4RouteRange/properties/name. /components/schemas/Bgp.V6RouteRange/properties/name. /components/schemas/Isis.V4RouteRange/properties/name. /components/schemas/Isis.V6RouteRange/properties/name. . x-constraint:. /components/schemas/Bgp.V4RouteRange/properties/name. /components/schemas/Bgp.V6RouteRange/properties/name. /components/schemas/Isis.V4RouteRange/properties/name. /components/schemas/Isis.V6RouteRange/properties/name.

        Returns: List[str]
        """
        return self._get_property("names")

    @names.setter
    def names(self, value):
        """names setter

        The names of device route objects to control. If no names are specified then all route objects that match the x-constraint will be affected.. x-constraint:. /components/schemas/Bgp.V4RouteRange/properties/name. /components/schemas/Bgp.V6RouteRange/properties/name. /components/schemas/Isis.V4RouteRange/properties/name. /components/schemas/Isis.V6RouteRange/properties/name. . x-constraint:. /components/schemas/Bgp.V4RouteRange/properties/name. /components/schemas/Bgp.V6RouteRange/properties/name. /components/schemas/Isis.V4RouteRange/properties/name. /components/schemas/Isis.V6RouteRange/properties/name.

        value: List[str]
        """
        self._set_property("names", value)

    @property
    def state(self):
        # type: () -> Union[Literal["advertise"], Literal["withdraw"]]
        """state getter

        Route states

        Returns: Union[Literal["advertise"], Literal["withdraw"]]
        """
        return self._get_property("state")

    @state.setter
    def state(self, value):
        """state setter

        Route states

        value: Union[Literal["advertise"], Literal["withdraw"]]
        """
        if value is None:
            raise TypeError("Cannot set required property state as None")
        self._set_property("state", value)


class StateProtocolLacp(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "admin",
            ],
        },
        "admin": {"type": "StateProtocolLacpAdmin"},
    }  # type: Dict[str, str]

    _REQUIRED = ("choice",)  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    ADMIN = "admin"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None):
        super(StateProtocolLacp, self).__init__()
        self._parent = parent
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    @property
    def admin(self):
        # type: () -> StateProtocolLacpAdmin
        """Factory property that returns an instance of the StateProtocolLacpAdmin class

        Sets admin state of LACP configured on LAG members

        Returns: StateProtocolLacpAdmin
        """
        return self._get_property("admin", StateProtocolLacpAdmin, self, "admin")

    @property
    def choice(self):
        # type: () -> Union[Literal["admin"]]
        """choice getter

        TBD

        Returns: Union[Literal["admin"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["admin"]]
        """
        if value is None:
            raise TypeError("Cannot set required property choice as None")
        self._set_property("choice", value)


class StateProtocolLacpAdmin(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "lag_member_names": {
            "type": list,
            "itemtype": str,
        },
        "state": {
            "type": str,
            "enum": [
                "down",
                "up",
            ],
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("state",)  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    DOWN = "down"  # type: str
    UP = "up"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, lag_member_names=None, state=None):
        super(StateProtocolLacpAdmin, self).__init__()
        self._parent = parent
        self._set_property("lag_member_names", lag_member_names)
        self._set_property("state", state)

    def set(self, lag_member_names=None, state=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def lag_member_names(self):
        # type: () -> List[str]
        """lag_member_names getter

        The names of LAG members (ports) for which the state has to be applied. An empty or null list will control all LAG members.. x-constraint:. /components/schemas/Port/properties/name. . x-constraint:. /components/schemas/Port/properties/name.

        Returns: List[str]
        """
        return self._get_property("lag_member_names")

    @lag_member_names.setter
    def lag_member_names(self, value):
        """lag_member_names setter

        The names of LAG members (ports) for which the state has to be applied. An empty or null list will control all LAG members.. x-constraint:. /components/schemas/Port/properties/name. . x-constraint:. /components/schemas/Port/properties/name.

        value: List[str]
        """
        self._set_property("lag_member_names", value)

    @property
    def state(self):
        # type: () -> Union[Literal["down"], Literal["up"]]
        """state getter

        The LACP Member admin state. 'up' will send LACPDUs with 'sync' flag set on selected member ports. 'down' will send LACPDUs with 'sync' flag unset on selected member ports.

        Returns: Union[Literal["down"], Literal["up"]]
        """
        return self._get_property("state")

    @state.setter
    def state(self, value):
        """state setter

        The LACP Member admin state. 'up' will send LACPDUs with 'sync' flag set on selected member ports. 'down' will send LACPDUs with 'sync' flag unset on selected member ports.

        value: Union[Literal["down"], Literal["up"]]
        """
        if value is None:
            raise TypeError("Cannot set required property state as None")
        self._set_property("state", value)


class StateTraffic(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "flow_transmit",
            ],
        },
        "flow_transmit": {"type": "StateTrafficFlowTransmit"},
    }  # type: Dict[str, str]

    _REQUIRED = ("choice",)  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    FLOW_TRANSMIT = "flow_transmit"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None):
        super(StateTraffic, self).__init__()
        self._parent = parent
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    @property
    def flow_transmit(self):
        # type: () -> StateTrafficFlowTransmit
        """Factory property that returns an instance of the StateTrafficFlowTransmit class

        Provides state control of flow transmission.

        Returns: StateTrafficFlowTransmit
        """
        return self._get_property(
            "flow_transmit", StateTrafficFlowTransmit, self, "flow_transmit"
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["flow_transmit"]]
        """choice getter

        TBD

        Returns: Union[Literal["flow_transmit"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["flow_transmit"]]
        """
        if value is None:
            raise TypeError("Cannot set required property choice as None")
        self._set_property("choice", value)


class StateTrafficFlowTransmit(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "flow_names": {
            "type": list,
            "itemtype": str,
        },
        "state": {
            "type": str,
            "enum": [
                "pause",
                "resume",
                "start",
                "stop",
            ],
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("state",)  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    PAUSE = "pause"  # type: str
    RESUME = "resume"  # type: str
    START = "start"  # type: str
    STOP = "stop"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, flow_names=None, state=None):
        super(StateTrafficFlowTransmit, self).__init__()
        self._parent = parent
        self._set_property("flow_names", flow_names)
        self._set_property("state", state)

    def set(self, flow_names=None, state=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def flow_names(self):
        # type: () -> List[str]
        """flow_names getter

        The names of flows to which the transmit state will be applied to. If the list of flow_names is empty or null the state will be applied to all configured flows.. If the list is not empty any flow that is not included in the list of flow_names MUST be ignored and not included in the state change.. x-constraint:. /components/schemas/Flow/properties/name. . x-constraint:. /components/schemas/Flow/properties/name.

        Returns: List[str]
        """
        return self._get_property("flow_names")

    @flow_names.setter
    def flow_names(self, value):
        """flow_names setter

        The names of flows to which the transmit state will be applied to. If the list of flow_names is empty or null the state will be applied to all configured flows.. If the list is not empty any flow that is not included in the list of flow_names MUST be ignored and not included in the state change.. x-constraint:. /components/schemas/Flow/properties/name. . x-constraint:. /components/schemas/Flow/properties/name.

        value: List[str]
        """
        self._set_property("flow_names", value)

    @property
    def state(self):
        # type: () -> Union[Literal["pause"], Literal["resume"], Literal["start"], Literal["stop"]]
        """state getter

        The transmit state.. If the value of the state property is 'start' then all flows defined by the 'flow_names' property will be started and the metric counters MUST be cleared prior to starting the flow(s).. If the value of the state property is 'stop' then all flows defined by the 'flow_names' property will be stopped and the metric counters MUST NOT be cleared.. If the value of the state property is 'pause' then all flows defined by the 'flow_names' property will be paused and the metric counters MUST NOT be cleared.. If the value of the state property is 'resume' then any paused flows defined by the 'flow_names' property will start transmit at the point at which they were paused. Any flow that is stopped will start transmit at the beginning of the flow. The flow(s) MUST NOT have their metric counters cleared.

        Returns: Union[Literal["pause"], Literal["resume"], Literal["start"], Literal["stop"]]
        """
        return self._get_property("state")

    @state.setter
    def state(self, value):
        """state setter

        The transmit state.. If the value of the state property is 'start' then all flows defined by the 'flow_names' property will be started and the metric counters MUST be cleared prior to starting the flow(s).. If the value of the state property is 'stop' then all flows defined by the 'flow_names' property will be stopped and the metric counters MUST NOT be cleared.. If the value of the state property is 'pause' then all flows defined by the 'flow_names' property will be paused and the metric counters MUST NOT be cleared.. If the value of the state property is 'resume' then any paused flows defined by the 'flow_names' property will start transmit at the point at which they were paused. Any flow that is stopped will start transmit at the beginning of the flow. The flow(s) MUST NOT have their metric counters cleared.

        value: Union[Literal["pause"], Literal["resume"], Literal["start"], Literal["stop"]]
        """
        if value is None:
            raise TypeError("Cannot set required property state as None")
        self._set_property("state", value)


class ControlAction(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "protocol",
            ],
        },
        "protocol": {"type": "ActionProtocol"},
    }  # type: Dict[str, str]

    _REQUIRED = ("choice",)  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    PROTOCOL = "protocol"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None):
        super(ControlAction, self).__init__()
        self._parent = parent
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    @property
    def protocol(self):
        # type: () -> ActionProtocol
        """Factory property that returns an instance of the ActionProtocol class

        Actions associated with protocols on configured resources.

        Returns: ActionProtocol
        """
        return self._get_property("protocol", ActionProtocol, self, "protocol")

    @property
    def choice(self):
        # type: () -> Union[Literal["protocol"]]
        """choice getter

        TBD

        Returns: Union[Literal["protocol"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["protocol"]]
        """
        if value is None:
            raise TypeError("Cannot set required property choice as None")
        self._set_property("choice", value)


class ActionProtocol(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "ipv4",
                "ipv6",
                "bgp",
            ],
        },
        "ipv4": {"type": "ActionProtocolIpv4"},
        "ipv6": {"type": "ActionProtocolIpv6"},
        "bgp": {"type": "ActionProtocolBgp"},
    }  # type: Dict[str, str]

    _REQUIRED = ("choice",)  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    IPV4 = "ipv4"  # type: str
    IPV6 = "ipv6"  # type: str
    BGP = "bgp"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None):
        super(ActionProtocol, self).__init__()
        self._parent = parent
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    @property
    def ipv4(self):
        # type: () -> ActionProtocolIpv4
        """Factory property that returns an instance of the ActionProtocolIpv4 class

        Actions associated with IPv4 on configured resources.

        Returns: ActionProtocolIpv4
        """
        return self._get_property("ipv4", ActionProtocolIpv4, self, "ipv4")

    @property
    def ipv6(self):
        # type: () -> ActionProtocolIpv6
        """Factory property that returns an instance of the ActionProtocolIpv6 class

        Actions associated with IPv6 on configured resources.

        Returns: ActionProtocolIpv6
        """
        return self._get_property("ipv6", ActionProtocolIpv6, self, "ipv6")

    @property
    def bgp(self):
        # type: () -> ActionProtocolBgp
        """Factory property that returns an instance of the ActionProtocolBgp class

        Actions associated with BGP on configured resources.

        Returns: ActionProtocolBgp
        """
        return self._get_property("bgp", ActionProtocolBgp, self, "bgp")

    @property
    def choice(self):
        # type: () -> Union[Literal["bgp"], Literal["ipv4"], Literal["ipv6"]]
        """choice getter

        TBD

        Returns: Union[Literal["bgp"], Literal["ipv4"], Literal["ipv6"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["bgp"], Literal["ipv4"], Literal["ipv6"]]
        """
        if value is None:
            raise TypeError("Cannot set required property choice as None")
        self._set_property("choice", value)


class ActionProtocolIpv4(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "ping",
            ],
        },
        "ping": {"type": "ActionProtocolIpv4Ping"},
    }  # type: Dict[str, str]

    _REQUIRED = ("choice",)  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    PING = "ping"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None):
        super(ActionProtocolIpv4, self).__init__()
        self._parent = parent
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    @property
    def ping(self):
        # type: () -> ActionProtocolIpv4Ping
        """Factory property that returns an instance of the ActionProtocolIpv4Ping class

        Request for initiating ping between multiple source and destination pairs.

        Returns: ActionProtocolIpv4Ping
        """
        return self._get_property("ping", ActionProtocolIpv4Ping, self, "ping")

    @property
    def choice(self):
        # type: () -> Union[Literal["ping"]]
        """choice getter

        TBD

        Returns: Union[Literal["ping"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["ping"]]
        """
        if value is None:
            raise TypeError("Cannot set required property choice as None")
        self._set_property("choice", value)


class ActionProtocolIpv4Ping(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "requests": {"type": "ActionProtocolIpv4PingRequestIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None):
        super(ActionProtocolIpv4Ping, self).__init__()
        self._parent = parent

    @property
    def requests(self):
        # type: () -> ActionProtocolIpv4PingRequestIter
        """requests getter

        List of IPv4 ping requests.

        Returns: ActionProtocolIpv4PingRequestIter
        """
        return self._get_property(
            "requests", ActionProtocolIpv4PingRequestIter, self._parent, self._choice
        )


class ActionProtocolIpv4PingRequest(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "src_name": {"type": str},
        "dst_ip": {
            "type": str,
            "format": "ipv4",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {
        "self": "ActionProtocolIpv4PingRequest is under_review, Most ping request parameters are still TBD.",
    }  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, src_name=None, dst_ip=None):
        super(ActionProtocolIpv4PingRequest, self).__init__()
        self._parent = parent
        self._set_property("src_name", src_name)
        self._set_property("dst_ip", dst_ip)

    def set(self, src_name=None, dst_ip=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def src_name(self):
        # type: () -> str
        """src_name getter

        Name of source IPv4 interface to be used.. x-constraint:. /components/schemas/Device.Ipv4/properties/name. . x-constraint:. /components/schemas/Device.Ipv4/properties/name.

        Returns: str
        """
        return self._get_property("src_name")

    @src_name.setter
    def src_name(self, value):
        """src_name setter

        Name of source IPv4 interface to be used.. x-constraint:. /components/schemas/Device.Ipv4/properties/name. . x-constraint:. /components/schemas/Device.Ipv4/properties/name.

        value: str
        """
        self._set_property("src_name", value)

    @property
    def dst_ip(self):
        # type: () -> str
        """dst_ip getter

        Destination IPv4 address to ping.

        Returns: str
        """
        return self._get_property("dst_ip")

    @dst_ip.setter
    def dst_ip(self, value):
        """dst_ip setter

        Destination IPv4 address to ping.

        value: str
        """
        self._set_property("dst_ip", value)


class ActionProtocolIpv4PingRequestIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(ActionProtocolIpv4PingRequestIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[ActionProtocolIpv4PingRequest]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> ActionProtocolIpv4PingRequestIter
        return self._iter()

    def __next__(self):
        # type: () -> ActionProtocolIpv4PingRequest
        return self._next()

    def next(self):
        # type: () -> ActionProtocolIpv4PingRequest
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, ActionProtocolIpv4PingRequest):
            raise Exception("Item is not an instance of ActionProtocolIpv4PingRequest")

    def pingrequest(self, src_name=None, dst_ip=None):
        # type: (str,str) -> ActionProtocolIpv4PingRequestIter
        """Factory method that creates an instance of the ActionProtocolIpv4PingRequest class

        Under Review: Most ping request parameters are still TBD.. Under Review: Most ping request parameters are still TBD.. Request for initiating ping between single source and destination pair.. For ping request, IPv4 ICMP Echo Request shall be sent and wait for ping response to either succeed or time out. The API wait timeout for each request shall be 300ms.

        Returns: ActionProtocolIpv4PingRequestIter
        """
        item = ActionProtocolIpv4PingRequest(
            parent=self._parent, src_name=src_name, dst_ip=dst_ip
        )
        self._add(item)
        return self

    def add(self, src_name=None, dst_ip=None):
        # type: (str,str) -> ActionProtocolIpv4PingRequest
        """Add method that creates and returns an instance of the ActionProtocolIpv4PingRequest class

        Under Review: Most ping request parameters are still TBD.. Under Review: Most ping request parameters are still TBD.. Request for initiating ping between single source and destination pair.. For ping request, IPv4 ICMP Echo Request shall be sent and wait for ping response to either succeed or time out. The API wait timeout for each request shall be 300ms.

        Returns: ActionProtocolIpv4PingRequest
        """
        item = ActionProtocolIpv4PingRequest(
            parent=self._parent, src_name=src_name, dst_ip=dst_ip
        )
        self._add(item)
        return item


class ActionProtocolIpv6(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "ping",
            ],
        },
        "ping": {"type": "ActionProtocolIpv6Ping"},
    }  # type: Dict[str, str]

    _REQUIRED = ("choice",)  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    PING = "ping"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None):
        super(ActionProtocolIpv6, self).__init__()
        self._parent = parent
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    @property
    def ping(self):
        # type: () -> ActionProtocolIpv6Ping
        """Factory property that returns an instance of the ActionProtocolIpv6Ping class

        Request for initiating ping between multiple source and destination pairs.

        Returns: ActionProtocolIpv6Ping
        """
        return self._get_property("ping", ActionProtocolIpv6Ping, self, "ping")

    @property
    def choice(self):
        # type: () -> Union[Literal["ping"]]
        """choice getter

        TBD

        Returns: Union[Literal["ping"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["ping"]]
        """
        if value is None:
            raise TypeError("Cannot set required property choice as None")
        self._set_property("choice", value)


class ActionProtocolIpv6Ping(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "requests": {"type": "ActionProtocolIpv6PingRequestIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None):
        super(ActionProtocolIpv6Ping, self).__init__()
        self._parent = parent

    @property
    def requests(self):
        # type: () -> ActionProtocolIpv6PingRequestIter
        """requests getter

        List of IPv6 ping requests.

        Returns: ActionProtocolIpv6PingRequestIter
        """
        return self._get_property(
            "requests", ActionProtocolIpv6PingRequestIter, self._parent, self._choice
        )


class ActionProtocolIpv6PingRequest(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "src_name": {"type": str},
        "dst_ip": {
            "type": str,
            "format": "ipv6",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {
        "self": "ActionProtocolIpv6PingRequest is under_review, Most ping request parameters are still TBD.",
    }  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, src_name=None, dst_ip=None):
        super(ActionProtocolIpv6PingRequest, self).__init__()
        self._parent = parent
        self._set_property("src_name", src_name)
        self._set_property("dst_ip", dst_ip)

    def set(self, src_name=None, dst_ip=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def src_name(self):
        # type: () -> str
        """src_name getter

        Name of source IPv6 interface to be used.. x-constraint:. /components/schemas/Device.Ipv6/properties/name. . x-constraint:. /components/schemas/Device.Ipv6/properties/name.

        Returns: str
        """
        return self._get_property("src_name")

    @src_name.setter
    def src_name(self, value):
        """src_name setter

        Name of source IPv6 interface to be used.. x-constraint:. /components/schemas/Device.Ipv6/properties/name. . x-constraint:. /components/schemas/Device.Ipv6/properties/name.

        value: str
        """
        self._set_property("src_name", value)

    @property
    def dst_ip(self):
        # type: () -> str
        """dst_ip getter

        Destination IPv6 address to ping.

        Returns: str
        """
        return self._get_property("dst_ip")

    @dst_ip.setter
    def dst_ip(self, value):
        """dst_ip setter

        Destination IPv6 address to ping.

        value: str
        """
        self._set_property("dst_ip", value)


class ActionProtocolIpv6PingRequestIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(ActionProtocolIpv6PingRequestIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[ActionProtocolIpv6PingRequest]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> ActionProtocolIpv6PingRequestIter
        return self._iter()

    def __next__(self):
        # type: () -> ActionProtocolIpv6PingRequest
        return self._next()

    def next(self):
        # type: () -> ActionProtocolIpv6PingRequest
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, ActionProtocolIpv6PingRequest):
            raise Exception("Item is not an instance of ActionProtocolIpv6PingRequest")

    def pingrequest(self, src_name=None, dst_ip=None):
        # type: (str,str) -> ActionProtocolIpv6PingRequestIter
        """Factory method that creates an instance of the ActionProtocolIpv6PingRequest class

        Under Review: Most ping request parameters are still TBD.. Under Review: Most ping request parameters are still TBD.. Request for initiating ping between single source and destination pair.. For ping request, IPv6 ICMP Echo Request shall be sent and wait for ping response to either succeed or time out. The API wait timeout for each request shall be 300ms.

        Returns: ActionProtocolIpv6PingRequestIter
        """
        item = ActionProtocolIpv6PingRequest(
            parent=self._parent, src_name=src_name, dst_ip=dst_ip
        )
        self._add(item)
        return self

    def add(self, src_name=None, dst_ip=None):
        # type: (str,str) -> ActionProtocolIpv6PingRequest
        """Add method that creates and returns an instance of the ActionProtocolIpv6PingRequest class

        Under Review: Most ping request parameters are still TBD.. Under Review: Most ping request parameters are still TBD.. Request for initiating ping between single source and destination pair.. For ping request, IPv6 ICMP Echo Request shall be sent and wait for ping response to either succeed or time out. The API wait timeout for each request shall be 300ms.

        Returns: ActionProtocolIpv6PingRequest
        """
        item = ActionProtocolIpv6PingRequest(
            parent=self._parent, src_name=src_name, dst_ip=dst_ip
        )
        self._add(item)
        return item


class ActionProtocolBgp(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "notification",
                "initiate_graceful_restart",
            ],
        },
        "notification": {"type": "ActionProtocolBgpNotification"},
        "initiate_graceful_restart": {
            "type": "ActionProtocolBgpInitiateGracefulRestart"
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("choice",)  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    NOTIFICATION = "notification"  # type: str
    INITIATE_GRACEFUL_RESTART = "initiate_graceful_restart"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None):
        super(ActionProtocolBgp, self).__init__()
        self._parent = parent
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    @property
    def notification(self):
        # type: () -> ActionProtocolBgpNotification
        """Factory property that returns an instance of the ActionProtocolBgpNotification class

        A NOTIFICATION message is sent when an error is detected with the BGP session, such as hold timer expiring, misconfigured AS number or BGP session reset is requested. This causes the BGP connection to close. Send explicit NOTIFICATIONs for list of specified BGP peers. If user wants to send custom Error Code and Error Subcode the custom object should be configured. user can send IANA defined BGP NOTIFICATIONs according to https://www.iana.org/assignments/bgp-parameters/bgp-parameters.xhtml.

        Returns: ActionProtocolBgpNotification
        """
        return self._get_property(
            "notification", ActionProtocolBgpNotification, self, "notification"
        )

    @property
    def initiate_graceful_restart(self):
        # type: () -> ActionProtocolBgpInitiateGracefulRestart
        """Factory property that returns an instance of the ActionProtocolBgpInitiateGracefulRestart class

        Initiates BGP Graceful Restart process for the selected BGP peers. If no name is specified then Graceful Restart will be sent to all configured BGP peers.

        Returns: ActionProtocolBgpInitiateGracefulRestart
        """
        return self._get_property(
            "initiate_graceful_restart",
            ActionProtocolBgpInitiateGracefulRestart,
            self,
            "initiate_graceful_restart",
        )

    @property
    def choice(self):
        # type: () -> Union[Literal["initiate_graceful_restart"], Literal["notification"]]
        """choice getter

        TBD

        Returns: Union[Literal["initiate_graceful_restart"], Literal["notification"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["initiate_graceful_restart"], Literal["notification"]]
        """
        if value is None:
            raise TypeError("Cannot set required property choice as None")
        self._set_property("choice", value)


class ActionProtocolBgpNotification(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "names": {
            "type": list,
            "itemtype": str,
        },
        "choice": {
            "type": str,
            "enum": [
                "cease",
                "message_header_error",
                "open_message_error",
                "update_message_error",
                "hold_timer_expired",
                "finite_state_machine_error",
                "custom",
            ],
        },
        "cease": {"type": "DeviceBgpCeaseError"},
        "message_header_error": {"type": "DeviceBgpMessageHeaderError"},
        "open_message_error": {"type": "DeviceBgpOpenMessageError"},
        "update_message_error": {"type": "DeviceBgpUpdateMessageError"},
        "hold_timer_expired": {"type": "DeviceBgpHoldTimerExpired"},
        "finite_state_machine_error": {"type": "DeviceBgpFiniteStateMachineError"},
        "custom": {"type": "DeviceBgpCustomError"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "cease",
    }  # type: Dict[str, Union(type)]

    CEASE = "cease"  # type: str
    MESSAGE_HEADER_ERROR = "message_header_error"  # type: str
    OPEN_MESSAGE_ERROR = "open_message_error"  # type: str
    UPDATE_MESSAGE_ERROR = "update_message_error"  # type: str
    HOLD_TIMER_EXPIRED = "hold_timer_expired"  # type: str
    FINITE_STATE_MACHINE_ERROR = "finite_state_machine_error"  # type: str
    CUSTOM = "custom"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, names=None):
        super(ActionProtocolBgpNotification, self).__init__()
        self._parent = parent
        self._set_property("names", names)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, names=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def cease(self):
        # type: () -> DeviceBgpCeaseError
        """Factory property that returns an instance of the DeviceBgpCeaseError class

        In the absence of any fatal errors, BGP peer can close its BGP connection by sending the NOTIFICATION message with the Error Code Cease.

        Returns: DeviceBgpCeaseError
        """
        return self._get_property("cease", DeviceBgpCeaseError, self, "cease")

    @property
    def message_header_error(self):
        # type: () -> DeviceBgpMessageHeaderError
        """Factory property that returns an instance of the DeviceBgpMessageHeaderError class

        All errors detected while processing the Message Header are indicated by sending the NOTIFICATION message with the Error Code-Message Header Error. The Error Subcode elaborates on the specific nature of the error.

        Returns: DeviceBgpMessageHeaderError
        """
        return self._get_property(
            "message_header_error",
            DeviceBgpMessageHeaderError,
            self,
            "message_header_error",
        )

    @property
    def open_message_error(self):
        # type: () -> DeviceBgpOpenMessageError
        """Factory property that returns an instance of the DeviceBgpOpenMessageError class

        All errors detected while processing the OPEN message are indicated by sending the NOTIFICATION message with the Error Code-Open Message Error. The Error Subcode elaborates on the specific nature of the error.

        Returns: DeviceBgpOpenMessageError
        """
        return self._get_property(
            "open_message_error", DeviceBgpOpenMessageError, self, "open_message_error"
        )

    @property
    def update_message_error(self):
        # type: () -> DeviceBgpUpdateMessageError
        """Factory property that returns an instance of the DeviceBgpUpdateMessageError class

        All errors detected while processing the UPDATE message are indicated by sending the NOTIFICATION message with the Error Code-Update Message Error. The Error Subcode elaborates on the specific nature of the error.

        Returns: DeviceBgpUpdateMessageError
        """
        return self._get_property(
            "update_message_error",
            DeviceBgpUpdateMessageError,
            self,
            "update_message_error",
        )

    @property
    def hold_timer_expired(self):
        # type: () -> DeviceBgpHoldTimerExpired
        """Factory property that returns an instance of the DeviceBgpHoldTimerExpired class

        If system does not receive successive KEEPALIVE, UPDATE, and/or NOTIFICATION messages within the period specified in the Hold Time field of the OPEN message, then the NOTIFICATION message with the Hold Timer Expired Error Code(Error Code 4) is sent and the BGP connection is closed. The Sub Code used is 0. If user wants to use non zero Sub Code then CustomError can be used.

        Returns: DeviceBgpHoldTimerExpired
        """
        return self._get_property(
            "hold_timer_expired", DeviceBgpHoldTimerExpired, self, "hold_timer_expired"
        )

    @property
    def finite_state_machine_error(self):
        # type: () -> DeviceBgpFiniteStateMachineError
        """Factory property that returns an instance of the DeviceBgpFiniteStateMachineError class

        Any error detected by the BGP Finite State Machine (e.g., receipt of an unexpected event) is indicated by sending the NOTIFICATION message with the Error Code-Finite State Machine Error(Error Code 5). The Sub Code used is 0. If user wants to use non zero Sub Code then CustomError can be used.

        Returns: DeviceBgpFiniteStateMachineError
        """
        return self._get_property(
            "finite_state_machine_error",
            DeviceBgpFiniteStateMachineError,
            self,
            "finite_state_machine_error",
        )

    @property
    def custom(self):
        # type: () -> DeviceBgpCustomError
        """Factory property that returns an instance of the DeviceBgpCustomError class

        A BGP peer can send NOTIFICATION message with user defined Error Code and Error Subcode.

        Returns: DeviceBgpCustomError
        """
        return self._get_property("custom", DeviceBgpCustomError, self, "custom")

    @property
    def names(self):
        # type: () -> List[str]
        """names getter

        The names of BGP Peers to send NOTIFICATION to. If no name is specified then NOTIFICATION will be sent to all configured BGP peers.. x-constraint:. /components/schemas/Device.Bgp/properties/name. . x-constraint:. /components/schemas/Device.Bgp/properties/name.

        Returns: List[str]
        """
        return self._get_property("names")

    @names.setter
    def names(self, value):
        """names setter

        The names of BGP Peers to send NOTIFICATION to. If no name is specified then NOTIFICATION will be sent to all configured BGP peers.. x-constraint:. /components/schemas/Device.Bgp/properties/name. . x-constraint:. /components/schemas/Device.Bgp/properties/name.

        value: List[str]
        """
        self._set_property("names", value)

    @property
    def choice(self):
        # type: () -> Union[Literal["cease"], Literal["custom"], Literal["finite_state_machine_error"], Literal["hold_timer_expired"], Literal["message_header_error"], Literal["open_message_error"], Literal["update_message_error"]]
        """choice getter

        Each BGP NOTIFICATION message includes an Error Code field indicating what type of problem occurred. For certain Error Codes, an Error Subcode field provides additional details about the specific nature of the problem. The choice value will provide the Error Code used in NOTIFICATION message. The Subcode can be set for each of the corresponding errors except for Hold Timer Expired error and BGP Finite State Machine error. In both of these cases Subcode will be sent. If user wants to use non zero Sub Code then custom choice can be used.

        Returns: Union[Literal["cease"], Literal["custom"], Literal["finite_state_machine_error"], Literal["hold_timer_expired"], Literal["message_header_error"], Literal["open_message_error"], Literal["update_message_error"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        Each BGP NOTIFICATION message includes an Error Code field indicating what type of problem occurred. For certain Error Codes, an Error Subcode field provides additional details about the specific nature of the problem. The choice value will provide the Error Code used in NOTIFICATION message. The Subcode can be set for each of the corresponding errors except for Hold Timer Expired error and BGP Finite State Machine error. In both of these cases Subcode will be sent. If user wants to use non zero Sub Code then custom choice can be used.

        value: Union[Literal["cease"], Literal["custom"], Literal["finite_state_machine_error"], Literal["hold_timer_expired"], Literal["message_header_error"], Literal["open_message_error"], Literal["update_message_error"]]
        """
        self._set_property("choice", value)


class DeviceBgpCeaseError(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "subcode": {
            "type": str,
            "enum": [
                "admin_reset_code6_subcode4",
                "admin_shutdown_code6_subcode2",
                "bfd_session_down_code6_subcode9",
                "connection_collision_resolution_code6_subcode7",
                "connection_reject_code6_subcode5",
                "max_number_prefix_reached_code6_subcode1",
                "other_config_changes_code6_subcode6",
                "out_of_resources_code6_subcode8",
                "peer_deleted_code6_subcode3",
            ],
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "subcode": "admin_shutdown_code6_subcode2",
    }  # type: Dict[str, Union(type)]

    ADMIN_RESET_CODE6_SUBCODE4 = "admin_reset_code6_subcode4"  # type: str
    ADMIN_SHUTDOWN_CODE6_SUBCODE2 = "admin_shutdown_code6_subcode2"  # type: str
    BFD_SESSION_DOWN_CODE6_SUBCODE9 = "bfd_session_down_code6_subcode9"  # type: str
    CONNECTION_COLLISION_RESOLUTION_CODE6_SUBCODE7 = (
        "connection_collision_resolution_code6_subcode7"
    )  # type: str
    CONNECTION_REJECT_CODE6_SUBCODE5 = "connection_reject_code6_subcode5"  # type: str
    MAX_NUMBER_PREFIX_REACHED_CODE6_SUBCODE1 = (
        "max_number_prefix_reached_code6_subcode1"
    )  # type: str
    OTHER_CONFIG_CHANGES_CODE6_SUBCODE6 = (
        "other_config_changes_code6_subcode6"
    )  # type: str
    OUT_OF_RESOURCES_CODE6_SUBCODE8 = "out_of_resources_code6_subcode8"  # type: str
    PEER_DELETED_CODE6_SUBCODE3 = "peer_deleted_code6_subcode3"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, subcode="admin_shutdown_code6_subcode2"):
        super(DeviceBgpCeaseError, self).__init__()
        self._parent = parent
        self._set_property("subcode", subcode)

    def set(self, subcode=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def subcode(self):
        # type: () -> Union[Literal["admin_reset_code6_subcode4"], Literal["admin_shutdown_code6_subcode2"], Literal["bfd_session_down_code6_subcode9"], Literal["connection_collision_resolution_code6_subcode7"], Literal["connection_reject_code6_subcode5"], Literal["max_number_prefix_reached_code6_subcode1"], Literal["other_config_changes_code6_subcode6"], Literal["out_of_resources_code6_subcode8"], Literal["peer_deleted_code6_subcode3"]]
        """subcode getter

        The Error Subcode to be sent to the peer in the Cease NOTIFICATION.

        Returns: Union[Literal["admin_reset_code6_subcode4"], Literal["admin_shutdown_code6_subcode2"], Literal["bfd_session_down_code6_subcode9"], Literal["connection_collision_resolution_code6_subcode7"], Literal["connection_reject_code6_subcode5"], Literal["max_number_prefix_reached_code6_subcode1"], Literal["other_config_changes_code6_subcode6"], Literal["out_of_resources_code6_subcode8"], Literal["peer_deleted_code6_subcode3"]]
        """
        return self._get_property("subcode")

    @subcode.setter
    def subcode(self, value):
        """subcode setter

        The Error Subcode to be sent to the peer in the Cease NOTIFICATION.

        value: Union[Literal["admin_reset_code6_subcode4"], Literal["admin_shutdown_code6_subcode2"], Literal["bfd_session_down_code6_subcode9"], Literal["connection_collision_resolution_code6_subcode7"], Literal["connection_reject_code6_subcode5"], Literal["max_number_prefix_reached_code6_subcode1"], Literal["other_config_changes_code6_subcode6"], Literal["out_of_resources_code6_subcode8"], Literal["peer_deleted_code6_subcode3"]]
        """
        self._set_property("subcode", value)


class DeviceBgpMessageHeaderError(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "subcode": {
            "type": str,
            "enum": [
                "bad_message_length_code1_subcode2",
                "bad_message_type_code1_subcode3",
                "connection_not_synchronized_code1_subcode1",
            ],
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "subcode": "connection_not_synchronized_code1_subcode1",
    }  # type: Dict[str, Union(type)]

    BAD_MESSAGE_LENGTH_CODE1_SUBCODE2 = "bad_message_length_code1_subcode2"  # type: str
    BAD_MESSAGE_TYPE_CODE1_SUBCODE3 = "bad_message_type_code1_subcode3"  # type: str
    CONNECTION_NOT_SYNCHRONIZED_CODE1_SUBCODE1 = (
        "connection_not_synchronized_code1_subcode1"
    )  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self, parent=None, subcode="connection_not_synchronized_code1_subcode1"
    ):
        super(DeviceBgpMessageHeaderError, self).__init__()
        self._parent = parent
        self._set_property("subcode", subcode)

    def set(self, subcode=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def subcode(self):
        # type: () -> Union[Literal["bad_message_length_code1_subcode2"], Literal["bad_message_type_code1_subcode3"], Literal["connection_not_synchronized_code1_subcode1"]]
        """subcode getter

        The Error Subcode indicates the specific type of error encountered during Message Header processing.

        Returns: Union[Literal["bad_message_length_code1_subcode2"], Literal["bad_message_type_code1_subcode3"], Literal["connection_not_synchronized_code1_subcode1"]]
        """
        return self._get_property("subcode")

    @subcode.setter
    def subcode(self, value):
        """subcode setter

        The Error Subcode indicates the specific type of error encountered during Message Header processing.

        value: Union[Literal["bad_message_length_code1_subcode2"], Literal["bad_message_type_code1_subcode3"], Literal["connection_not_synchronized_code1_subcode1"]]
        """
        self._set_property("subcode", value)


class DeviceBgpOpenMessageError(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "subcode": {
            "type": str,
            "enum": [
                "auth_failed_code2_subcode5",
                "error_bgp_id_code2_subcode3",
                "error_peer_as_code2_subcode2",
                "unsupported_capability_code2_subcode7",
                "unsupported_hold_time_code2_subcode6",
                "unsupported_optional_parameter_code2_subcode4",
                "unsupported_version_number_code2_subcode1",
            ],
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "subcode": "unsupported_version_number_code2_subcode1",
    }  # type: Dict[str, Union(type)]

    AUTH_FAILED_CODE2_SUBCODE5 = "auth_failed_code2_subcode5"  # type: str
    ERROR_BGP_ID_CODE2_SUBCODE3 = "error_bgp_id_code2_subcode3"  # type: str
    ERROR_PEER_AS_CODE2_SUBCODE2 = "error_peer_as_code2_subcode2"  # type: str
    UNSUPPORTED_CAPABILITY_CODE2_SUBCODE7 = (
        "unsupported_capability_code2_subcode7"
    )  # type: str
    UNSUPPORTED_HOLD_TIME_CODE2_SUBCODE6 = (
        "unsupported_hold_time_code2_subcode6"
    )  # type: str
    UNSUPPORTED_OPTIONAL_PARAMETER_CODE2_SUBCODE4 = (
        "unsupported_optional_parameter_code2_subcode4"
    )  # type: str
    UNSUPPORTED_VERSION_NUMBER_CODE2_SUBCODE1 = (
        "unsupported_version_number_code2_subcode1"
    )  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self, parent=None, subcode="unsupported_version_number_code2_subcode1"
    ):
        super(DeviceBgpOpenMessageError, self).__init__()
        self._parent = parent
        self._set_property("subcode", subcode)

    def set(self, subcode=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def subcode(self):
        # type: () -> Union[Literal["auth_failed_code2_subcode5"], Literal["error_bgp_id_code2_subcode3"], Literal["error_peer_as_code2_subcode2"], Literal["unsupported_capability_code2_subcode7"], Literal["unsupported_hold_time_code2_subcode6"], Literal["unsupported_optional_parameter_code2_subcode4"], Literal["unsupported_version_number_code2_subcode1"]]
        """subcode getter

        The Error Subcode indicates the specific type of error encountered during OPEN message processing.

        Returns: Union[Literal["auth_failed_code2_subcode5"], Literal["error_bgp_id_code2_subcode3"], Literal["error_peer_as_code2_subcode2"], Literal["unsupported_capability_code2_subcode7"], Literal["unsupported_hold_time_code2_subcode6"], Literal["unsupported_optional_parameter_code2_subcode4"], Literal["unsupported_version_number_code2_subcode1"]]
        """
        return self._get_property("subcode")

    @subcode.setter
    def subcode(self, value):
        """subcode setter

        The Error Subcode indicates the specific type of error encountered during OPEN message processing.

        value: Union[Literal["auth_failed_code2_subcode5"], Literal["error_bgp_id_code2_subcode3"], Literal["error_peer_as_code2_subcode2"], Literal["unsupported_capability_code2_subcode7"], Literal["unsupported_hold_time_code2_subcode6"], Literal["unsupported_optional_parameter_code2_subcode4"], Literal["unsupported_version_number_code2_subcode1"]]
        """
        self._set_property("subcode", value)


class DeviceBgpUpdateMessageError(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "subcode": {
            "type": str,
            "enum": [
                "abnormal_aspath_code3_subcode11",
                "as_routing_loop_code3_subcode7",
                "attrib_flags_error_code3_subcode4",
                "attrib_length_error_code3_subcode5",
                "error_optional_attrib_code3_subcode9",
                "invalid_network_field_code3_subcode10",
                "invalid_nhop_attrib_code3_subcode8",
                "invalid_origin_attrib_code3_subcode6",
                "malformed_attrib_list_code3_subcode1",
                "unrecognized_wellknown_attrib_code3_subcode2",
                "wellknown_attrib_missing_code3_subcode3",
            ],
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "subcode": "malformed_attrib_list_code3_subcode1",
    }  # type: Dict[str, Union(type)]

    ABNORMAL_ASPATH_CODE3_SUBCODE11 = "abnormal_aspath_code3_subcode11"  # type: str
    AS_ROUTING_LOOP_CODE3_SUBCODE7 = "as_routing_loop_code3_subcode7"  # type: str
    ATTRIB_FLAGS_ERROR_CODE3_SUBCODE4 = "attrib_flags_error_code3_subcode4"  # type: str
    ATTRIB_LENGTH_ERROR_CODE3_SUBCODE5 = (
        "attrib_length_error_code3_subcode5"
    )  # type: str
    ERROR_OPTIONAL_ATTRIB_CODE3_SUBCODE9 = (
        "error_optional_attrib_code3_subcode9"
    )  # type: str
    INVALID_NETWORK_FIELD_CODE3_SUBCODE10 = (
        "invalid_network_field_code3_subcode10"
    )  # type: str
    INVALID_NHOP_ATTRIB_CODE3_SUBCODE8 = (
        "invalid_nhop_attrib_code3_subcode8"
    )  # type: str
    INVALID_ORIGIN_ATTRIB_CODE3_SUBCODE6 = (
        "invalid_origin_attrib_code3_subcode6"
    )  # type: str
    MALFORMED_ATTRIB_LIST_CODE3_SUBCODE1 = (
        "malformed_attrib_list_code3_subcode1"
    )  # type: str
    UNRECOGNIZED_WELLKNOWN_ATTRIB_CODE3_SUBCODE2 = (
        "unrecognized_wellknown_attrib_code3_subcode2"
    )  # type: str
    WELLKNOWN_ATTRIB_MISSING_CODE3_SUBCODE3 = (
        "wellknown_attrib_missing_code3_subcode3"
    )  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, subcode="malformed_attrib_list_code3_subcode1"):
        super(DeviceBgpUpdateMessageError, self).__init__()
        self._parent = parent
        self._set_property("subcode", subcode)

    def set(self, subcode=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def subcode(self):
        # type: () -> Union[Literal["abnormal_aspath_code3_subcode11"], Literal["as_routing_loop_code3_subcode7"], Literal["attrib_flags_error_code3_subcode4"], Literal["attrib_length_error_code3_subcode5"], Literal["error_optional_attrib_code3_subcode9"], Literal["invalid_network_field_code3_subcode10"], Literal["invalid_nhop_attrib_code3_subcode8"], Literal["invalid_origin_attrib_code3_subcode6"], Literal["malformed_attrib_list_code3_subcode1"], Literal["unrecognized_wellknown_attrib_code3_subcode2"], Literal["wellknown_attrib_missing_code3_subcode3"]]
        """subcode getter

        The Error Subcode, the specific type of error encountered during UPDATE processing.

        Returns: Union[Literal["abnormal_aspath_code3_subcode11"], Literal["as_routing_loop_code3_subcode7"], Literal["attrib_flags_error_code3_subcode4"], Literal["attrib_length_error_code3_subcode5"], Literal["error_optional_attrib_code3_subcode9"], Literal["invalid_network_field_code3_subcode10"], Literal["invalid_nhop_attrib_code3_subcode8"], Literal["invalid_origin_attrib_code3_subcode6"], Literal["malformed_attrib_list_code3_subcode1"], Literal["unrecognized_wellknown_attrib_code3_subcode2"], Literal["wellknown_attrib_missing_code3_subcode3"]]
        """
        return self._get_property("subcode")

    @subcode.setter
    def subcode(self, value):
        """subcode setter

        The Error Subcode, the specific type of error encountered during UPDATE processing.

        value: Union[Literal["abnormal_aspath_code3_subcode11"], Literal["as_routing_loop_code3_subcode7"], Literal["attrib_flags_error_code3_subcode4"], Literal["attrib_length_error_code3_subcode5"], Literal["error_optional_attrib_code3_subcode9"], Literal["invalid_network_field_code3_subcode10"], Literal["invalid_nhop_attrib_code3_subcode8"], Literal["invalid_origin_attrib_code3_subcode6"], Literal["malformed_attrib_list_code3_subcode1"], Literal["unrecognized_wellknown_attrib_code3_subcode2"], Literal["wellknown_attrib_missing_code3_subcode3"]]
        """
        self._set_property("subcode", value)


class DeviceBgpHoldTimerExpired(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {}  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None):
        super(DeviceBgpHoldTimerExpired, self).__init__()
        self._parent = parent


class DeviceBgpFiniteStateMachineError(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {}  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None):
        super(DeviceBgpFiniteStateMachineError, self).__init__()
        self._parent = parent


class DeviceBgpCustomError(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "code": {
            "type": int,
            "format": "uint32",
        },
        "subcode": {
            "type": int,
            "format": "uint32",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, code=None, subcode=None):
        super(DeviceBgpCustomError, self).__init__()
        self._parent = parent
        self._set_property("code", code)
        self._set_property("subcode", subcode)

    def set(self, code=None, subcode=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def code(self):
        # type: () -> int
        """code getter

        The Error code to be sent in the NOTIFICATION message to peer.

        Returns: int
        """
        return self._get_property("code")

    @code.setter
    def code(self, value):
        """code setter

        The Error code to be sent in the NOTIFICATION message to peer.

        value: int
        """
        self._set_property("code", value)

    @property
    def subcode(self):
        # type: () -> int
        """subcode getter

        The Error Subcode to be sent in the NOTIFICATION message to peer.

        Returns: int
        """
        return self._get_property("subcode")

    @subcode.setter
    def subcode(self, value):
        """subcode setter

        The Error Subcode to be sent in the NOTIFICATION message to peer.

        value: int
        """
        self._set_property("subcode", value)


class ActionProtocolBgpInitiateGracefulRestart(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "peer_names": {
            "type": list,
            "itemtype": str,
        },
        "restart_delay": {
            "type": int,
            "format": "uint32",
            "maximum": 3600,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "restart_delay": 30,
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, peer_names=None, restart_delay=30):
        super(ActionProtocolBgpInitiateGracefulRestart, self).__init__()
        self._parent = parent
        self._set_property("peer_names", peer_names)
        self._set_property("restart_delay", restart_delay)

    def set(self, peer_names=None, restart_delay=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def peer_names(self):
        # type: () -> List[str]
        """peer_names getter

        The names of device BGP peers objects to control.. x-constraint:. /components/schemas/Device.Bgp/properties/name. . x-constraint:. /components/schemas/Device.Bgp/properties/name.

        Returns: List[str]
        """
        return self._get_property("peer_names")

    @peer_names.setter
    def peer_names(self, value):
        """peer_names setter

        The names of device BGP peers objects to control.. x-constraint:. /components/schemas/Device.Bgp/properties/name. . x-constraint:. /components/schemas/Device.Bgp/properties/name.

        value: List[str]
        """
        self._set_property("peer_names", value)

    @property
    def restart_delay(self):
        # type: () -> int
        """restart_delay getter

        Duration (in seconds) after which selected BGP peers will initiate Graceful restart by sending the Open Message with Restart State bit set in the Graceful Restart capability.

        Returns: int
        """
        return self._get_property("restart_delay")

    @restart_delay.setter
    def restart_delay(self, value):
        """restart_delay setter

        Duration (in seconds) after which selected BGP peers will initiate Graceful restart by sending the Open Message with Restart State bit set in the Graceful Restart capability.

        value: int
        """
        self._set_property("restart_delay", value)


class ControlActionResponse(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "warnings": {
            "type": list,
            "itemtype": str,
        },
        "response": {"type": "ActionResponse"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, warnings=None):
        super(ControlActionResponse, self).__init__()
        self._parent = parent
        self._set_property("warnings", warnings)

    def set(self, warnings=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def warnings(self):
        # type: () -> List[str]
        """warnings getter

        List of warnings generated while triggering specified action

        Returns: List[str]
        """
        return self._get_property("warnings")

    @warnings.setter
    def warnings(self, value):
        """warnings setter

        List of warnings generated while triggering specified action

        value: List[str]
        """
        self._set_property("warnings", value)

    @property
    def response(self):
        # type: () -> ActionResponse
        """response getter

        Response for action triggered against configured resources.Response for action triggered against configured resources.Response for action triggered against configured resources.

        Returns: ActionResponse
        """
        return self._get_property("response", ActionResponse)


class ActionResponse(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "protocol",
            ],
        },
        "protocol": {"type": "ActionResponseProtocol"},
    }  # type: Dict[str, str]

    _REQUIRED = ("choice",)  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    PROTOCOL = "protocol"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None):
        super(ActionResponse, self).__init__()
        self._parent = parent
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    @property
    def protocol(self):
        # type: () -> ActionResponseProtocol
        """Factory property that returns an instance of the ActionResponseProtocol class

        Response for actions associated with protocols on configured resources.

        Returns: ActionResponseProtocol
        """
        return self._get_property("protocol", ActionResponseProtocol, self, "protocol")

    @property
    def choice(self):
        # type: () -> Union[Literal["protocol"]]
        """choice getter

        TBD

        Returns: Union[Literal["protocol"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["protocol"]]
        """
        if value is None:
            raise TypeError("Cannot set required property choice as None")
        self._set_property("choice", value)


class ActionResponseProtocol(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "ipv4",
                "ipv6",
            ],
        },
        "ipv4": {"type": "ActionResponseProtocolIpv4"},
        "ipv6": {"type": "ActionResponseProtocolIpv6"},
    }  # type: Dict[str, str]

    _REQUIRED = ("choice",)  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    IPV4 = "ipv4"  # type: str
    IPV6 = "ipv6"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None):
        super(ActionResponseProtocol, self).__init__()
        self._parent = parent
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    @property
    def ipv4(self):
        # type: () -> ActionResponseProtocolIpv4
        """Factory property that returns an instance of the ActionResponseProtocolIpv4 class

        Response for actions associated with IPv4 on configured resources.

        Returns: ActionResponseProtocolIpv4
        """
        return self._get_property("ipv4", ActionResponseProtocolIpv4, self, "ipv4")

    @property
    def ipv6(self):
        # type: () -> ActionResponseProtocolIpv6
        """Factory property that returns an instance of the ActionResponseProtocolIpv6 class

        Response for actions associated with IPv6 on configured resources.

        Returns: ActionResponseProtocolIpv6
        """
        return self._get_property("ipv6", ActionResponseProtocolIpv6, self, "ipv6")

    @property
    def choice(self):
        # type: () -> Union[Literal["ipv4"], Literal["ipv6"]]
        """choice getter

        TBD

        Returns: Union[Literal["ipv4"], Literal["ipv6"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["ipv4"], Literal["ipv6"]]
        """
        if value is None:
            raise TypeError("Cannot set required property choice as None")
        self._set_property("choice", value)


class ActionResponseProtocolIpv4(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "ping",
            ],
        },
        "ping": {"type": "ActionResponseProtocolIpv4Ping"},
    }  # type: Dict[str, str]

    _REQUIRED = ("choice",)  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    PING = "ping"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None):
        super(ActionResponseProtocolIpv4, self).__init__()
        self._parent = parent
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    @property
    def ping(self):
        # type: () -> ActionResponseProtocolIpv4Ping
        """Factory property that returns an instance of the ActionResponseProtocolIpv4Ping class

        Response for ping initiated between multiple source and destination pairs.

        Returns: ActionResponseProtocolIpv4Ping
        """
        return self._get_property("ping", ActionResponseProtocolIpv4Ping, self, "ping")

    @property
    def choice(self):
        # type: () -> Union[Literal["ping"]]
        """choice getter

        TBD

        Returns: Union[Literal["ping"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["ping"]]
        """
        if value is None:
            raise TypeError("Cannot set required property choice as None")
        self._set_property("choice", value)


class ActionResponseProtocolIpv4Ping(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "responses": {"type": "ActionResponseProtocolIpv4PingResponseIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None):
        super(ActionResponseProtocolIpv4Ping, self).__init__()
        self._parent = parent

    @property
    def responses(self):
        # type: () -> ActionResponseProtocolIpv4PingResponseIter
        """responses getter

        List of responses for IPv4 ping responses.

        Returns: ActionResponseProtocolIpv4PingResponseIter
        """
        return self._get_property(
            "responses",
            ActionResponseProtocolIpv4PingResponseIter,
            self._parent,
            self._choice,
        )


class ActionResponseProtocolIpv4PingResponse(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "src_name": {"type": str},
        "dst_ip": {
            "type": str,
            "format": "ipv4",
        },
        "result": {
            "type": str,
            "enum": [
                "succeeded",
                "failed",
            ],
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("src_name", "dst_ip", "result")  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    SUCCEEDED = "succeeded"  # type: str
    FAILED = "failed"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, src_name=None, dst_ip=None, result=None):
        super(ActionResponseProtocolIpv4PingResponse, self).__init__()
        self._parent = parent
        self._set_property("src_name", src_name)
        self._set_property("dst_ip", dst_ip)
        self._set_property("result", result)

    def set(self, src_name=None, dst_ip=None, result=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def src_name(self):
        # type: () -> str
        """src_name getter

        Name of source IPv4 interface used for ping.. x-constraint:. /components/schemas/Device.Ipv4/properties/name. . x-constraint:. /components/schemas/Device.Ipv4/properties/name.

        Returns: str
        """
        return self._get_property("src_name")

    @src_name.setter
    def src_name(self, value):
        """src_name setter

        Name of source IPv4 interface used for ping.. x-constraint:. /components/schemas/Device.Ipv4/properties/name. . x-constraint:. /components/schemas/Device.Ipv4/properties/name.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property src_name as None")
        self._set_property("src_name", value)

    @property
    def dst_ip(self):
        # type: () -> str
        """dst_ip getter

        Destination IPv4 address used for ping.

        Returns: str
        """
        return self._get_property("dst_ip")

    @dst_ip.setter
    def dst_ip(self, value):
        """dst_ip setter

        Destination IPv4 address used for ping.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property dst_ip as None")
        self._set_property("dst_ip", value)

    @property
    def result(self):
        # type: () -> Union[Literal["failed"], Literal["succeeded"]]
        """result getter

        Result of the ping request.

        Returns: Union[Literal["failed"], Literal["succeeded"]]
        """
        return self._get_property("result")

    @result.setter
    def result(self, value):
        """result setter

        Result of the ping request.

        value: Union[Literal["failed"], Literal["succeeded"]]
        """
        if value is None:
            raise TypeError("Cannot set required property result as None")
        self._set_property("result", value)


class ActionResponseProtocolIpv4PingResponseIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(ActionResponseProtocolIpv4PingResponseIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[ActionResponseProtocolIpv4PingResponse]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> ActionResponseProtocolIpv4PingResponseIter
        return self._iter()

    def __next__(self):
        # type: () -> ActionResponseProtocolIpv4PingResponse
        return self._next()

    def next(self):
        # type: () -> ActionResponseProtocolIpv4PingResponse
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, ActionResponseProtocolIpv4PingResponse):
            raise Exception(
                "Item is not an instance of ActionResponseProtocolIpv4PingResponse"
            )

    def pingresponse(self, src_name=None, dst_ip=None, result=None):
        # type: (str,str,Union[Literal["failed"], Literal["succeeded"]]) -> ActionResponseProtocolIpv4PingResponseIter
        """Factory method that creates an instance of the ActionResponseProtocolIpv4PingResponse class

        Response for ping initiated between single source and destination pair.

        Returns: ActionResponseProtocolIpv4PingResponseIter
        """
        item = ActionResponseProtocolIpv4PingResponse(
            parent=self._parent, src_name=src_name, dst_ip=dst_ip, result=result
        )
        self._add(item)
        return self

    def add(self, src_name=None, dst_ip=None, result=None):
        # type: (str,str,Union[Literal["failed"], Literal["succeeded"]]) -> ActionResponseProtocolIpv4PingResponse
        """Add method that creates and returns an instance of the ActionResponseProtocolIpv4PingResponse class

        Response for ping initiated between single source and destination pair.

        Returns: ActionResponseProtocolIpv4PingResponse
        """
        item = ActionResponseProtocolIpv4PingResponse(
            parent=self._parent, src_name=src_name, dst_ip=dst_ip, result=result
        )
        self._add(item)
        return item


class ActionResponseProtocolIpv6(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "ping",
            ],
        },
        "ping": {"type": "ActionResponseProtocolIpv6Ping"},
    }  # type: Dict[str, str]

    _REQUIRED = ("choice",)  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    PING = "ping"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None):
        super(ActionResponseProtocolIpv6, self).__init__()
        self._parent = parent
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    @property
    def ping(self):
        # type: () -> ActionResponseProtocolIpv6Ping
        """Factory property that returns an instance of the ActionResponseProtocolIpv6Ping class

        Response for ping initiated between multiple source and destination pairs.

        Returns: ActionResponseProtocolIpv6Ping
        """
        return self._get_property("ping", ActionResponseProtocolIpv6Ping, self, "ping")

    @property
    def choice(self):
        # type: () -> Union[Literal["ping"]]
        """choice getter

        TBD

        Returns: Union[Literal["ping"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["ping"]]
        """
        if value is None:
            raise TypeError("Cannot set required property choice as None")
        self._set_property("choice", value)


class ActionResponseProtocolIpv6Ping(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "responses": {"type": "ActionResponseProtocolIpv6PingResponseIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None):
        super(ActionResponseProtocolIpv6Ping, self).__init__()
        self._parent = parent

    @property
    def responses(self):
        # type: () -> ActionResponseProtocolIpv6PingResponseIter
        """responses getter

        List of responses for IPv6 ping responses.

        Returns: ActionResponseProtocolIpv6PingResponseIter
        """
        return self._get_property(
            "responses",
            ActionResponseProtocolIpv6PingResponseIter,
            self._parent,
            self._choice,
        )


class ActionResponseProtocolIpv6PingResponse(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "src_name": {"type": str},
        "dst_ip": {
            "type": str,
            "format": "ipv6",
        },
        "result": {
            "type": str,
            "enum": [
                "succeeded",
                "failed",
            ],
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("src_name", "dst_ip", "result")  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    SUCCEEDED = "succeeded"  # type: str
    FAILED = "failed"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, src_name=None, dst_ip=None, result=None):
        super(ActionResponseProtocolIpv6PingResponse, self).__init__()
        self._parent = parent
        self._set_property("src_name", src_name)
        self._set_property("dst_ip", dst_ip)
        self._set_property("result", result)

    def set(self, src_name=None, dst_ip=None, result=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def src_name(self):
        # type: () -> str
        """src_name getter

        Name of source IPv6 interface used for ping.. x-constraint:. /components/schemas/Device.Ipv6/properties/name. . x-constraint:. /components/schemas/Device.Ipv6/properties/name.

        Returns: str
        """
        return self._get_property("src_name")

    @src_name.setter
    def src_name(self, value):
        """src_name setter

        Name of source IPv6 interface used for ping.. x-constraint:. /components/schemas/Device.Ipv6/properties/name. . x-constraint:. /components/schemas/Device.Ipv6/properties/name.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property src_name as None")
        self._set_property("src_name", value)

    @property
    def dst_ip(self):
        # type: () -> str
        """dst_ip getter

        Destination IPv6 address used for ping.

        Returns: str
        """
        return self._get_property("dst_ip")

    @dst_ip.setter
    def dst_ip(self, value):
        """dst_ip setter

        Destination IPv6 address used for ping.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property dst_ip as None")
        self._set_property("dst_ip", value)

    @property
    def result(self):
        # type: () -> Union[Literal["failed"], Literal["succeeded"]]
        """result getter

        Result of the ping request.

        Returns: Union[Literal["failed"], Literal["succeeded"]]
        """
        return self._get_property("result")

    @result.setter
    def result(self, value):
        """result setter

        Result of the ping request.

        value: Union[Literal["failed"], Literal["succeeded"]]
        """
        if value is None:
            raise TypeError("Cannot set required property result as None")
        self._set_property("result", value)


class ActionResponseProtocolIpv6PingResponseIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(ActionResponseProtocolIpv6PingResponseIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[ActionResponseProtocolIpv6PingResponse]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> ActionResponseProtocolIpv6PingResponseIter
        return self._iter()

    def __next__(self):
        # type: () -> ActionResponseProtocolIpv6PingResponse
        return self._next()

    def next(self):
        # type: () -> ActionResponseProtocolIpv6PingResponse
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, ActionResponseProtocolIpv6PingResponse):
            raise Exception(
                "Item is not an instance of ActionResponseProtocolIpv6PingResponse"
            )

    def pingresponse(self, src_name=None, dst_ip=None, result=None):
        # type: (str,str,Union[Literal["failed"], Literal["succeeded"]]) -> ActionResponseProtocolIpv6PingResponseIter
        """Factory method that creates an instance of the ActionResponseProtocolIpv6PingResponse class

        Response for ping initiated between single source and destination pair.

        Returns: ActionResponseProtocolIpv6PingResponseIter
        """
        item = ActionResponseProtocolIpv6PingResponse(
            parent=self._parent, src_name=src_name, dst_ip=dst_ip, result=result
        )
        self._add(item)
        return self

    def add(self, src_name=None, dst_ip=None, result=None):
        # type: (str,str,Union[Literal["failed"], Literal["succeeded"]]) -> ActionResponseProtocolIpv6PingResponse
        """Add method that creates and returns an instance of the ActionResponseProtocolIpv6PingResponse class

        Response for ping initiated between single source and destination pair.

        Returns: ActionResponseProtocolIpv6PingResponse
        """
        item = ActionResponseProtocolIpv6PingResponse(
            parent=self._parent, src_name=src_name, dst_ip=dst_ip, result=result
        )
        self._add(item)
        return item


class MetricsRequest(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "port",
                "flow",
                "bgpv4",
                "bgpv6",
                "isis",
                "lag",
                "lacp",
                "lldp",
                "rsvp",
            ],
        },
        "port": {"type": "PortMetricsRequest"},
        "flow": {"type": "FlowMetricsRequest"},
        "bgpv4": {"type": "Bgpv4MetricsRequest"},
        "bgpv6": {"type": "Bgpv6MetricsRequest"},
        "isis": {"type": "IsisMetricsRequest"},
        "lag": {"type": "LagMetricsRequest"},
        "lacp": {"type": "LacpMetricsRequest"},
        "lldp": {"type": "LldpMetricsRequest"},
        "rsvp": {"type": "RsvpMetricsRequest"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "port",
    }  # type: Dict[str, Union(type)]

    PORT = "port"  # type: str
    FLOW = "flow"  # type: str
    BGPV4 = "bgpv4"  # type: str
    BGPV6 = "bgpv6"  # type: str
    ISIS = "isis"  # type: str
    LAG = "lag"  # type: str
    LACP = "lacp"  # type: str
    LLDP = "lldp"  # type: str
    RSVP = "rsvp"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None):
        super(MetricsRequest, self).__init__()
        self._parent = parent
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    @property
    def port(self):
        # type: () -> PortMetricsRequest
        """Factory property that returns an instance of the PortMetricsRequest class

        The port result request to the traffic generator

        Returns: PortMetricsRequest
        """
        return self._get_property("port", PortMetricsRequest, self, "port")

    @property
    def flow(self):
        # type: () -> FlowMetricsRequest
        """Factory property that returns an instance of the FlowMetricsRequest class

        The container for flow metric request.

        Returns: FlowMetricsRequest
        """
        return self._get_property("flow", FlowMetricsRequest, self, "flow")

    @property
    def bgpv4(self):
        # type: () -> Bgpv4MetricsRequest
        """Factory property that returns an instance of the Bgpv4MetricsRequest class

        The request to retrieve BGPv4 per peer metrics/statistics.

        Returns: Bgpv4MetricsRequest
        """
        return self._get_property("bgpv4", Bgpv4MetricsRequest, self, "bgpv4")

    @property
    def bgpv6(self):
        # type: () -> Bgpv6MetricsRequest
        """Factory property that returns an instance of the Bgpv6MetricsRequest class

        The request to retrieve BGPv6 per peer metrics/statistics.

        Returns: Bgpv6MetricsRequest
        """
        return self._get_property("bgpv6", Bgpv6MetricsRequest, self, "bgpv6")

    @property
    def isis(self):
        # type: () -> IsisMetricsRequest
        """Factory property that returns an instance of the IsisMetricsRequest class

        The request to retrieve ISIS per Router metrics/statistics.

        Returns: IsisMetricsRequest
        """
        return self._get_property("isis", IsisMetricsRequest, self, "isis")

    @property
    def lag(self):
        # type: () -> LagMetricsRequest
        """Factory property that returns an instance of the LagMetricsRequest class

        The request to retrieve per LAG metrics/statistics.

        Returns: LagMetricsRequest
        """
        return self._get_property("lag", LagMetricsRequest, self, "lag")

    @property
    def lacp(self):
        # type: () -> LacpMetricsRequest
        """Factory property that returns an instance of the LacpMetricsRequest class

        The request to retrieve LACP per LAG member metrics/statistics.

        Returns: LacpMetricsRequest
        """
        return self._get_property("lacp", LacpMetricsRequest, self, "lacp")

    @property
    def lldp(self):
        # type: () -> LldpMetricsRequest
        """Factory property that returns an instance of the LldpMetricsRequest class

        The request to retrieve LLDP per instance metrics/statistics.

        Returns: LldpMetricsRequest
        """
        return self._get_property("lldp", LldpMetricsRequest, self, "lldp")

    @property
    def rsvp(self):
        # type: () -> RsvpMetricsRequest
        """Factory property that returns an instance of the RsvpMetricsRequest class

        The request to retrieve RSVP-TE per Router metrics/statistics.

        Returns: RsvpMetricsRequest
        """
        return self._get_property("rsvp", RsvpMetricsRequest, self, "rsvp")

    @property
    def choice(self):
        # type: () -> Union[Literal["bgpv4"], Literal["bgpv6"], Literal["flow"], Literal["isis"], Literal["lacp"], Literal["lag"], Literal["lldp"], Literal["port"], Literal["rsvp"]]
        """choice getter

        TBD

        Returns: Union[Literal["bgpv4"], Literal["bgpv6"], Literal["flow"], Literal["isis"], Literal["lacp"], Literal["lag"], Literal["lldp"], Literal["port"], Literal["rsvp"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["bgpv4"], Literal["bgpv6"], Literal["flow"], Literal["isis"], Literal["lacp"], Literal["lag"], Literal["lldp"], Literal["port"], Literal["rsvp"]]
        """
        self._set_property("choice", value)


class PortMetricsRequest(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "port_names": {
            "type": list,
            "itemtype": str,
        },
        "column_names": {
            "type": list,
            "enum": [
                "bytes_rx",
                "bytes_rx_rate",
                "bytes_tx",
                "bytes_tx_rate",
                "capture",
                "frames_rx",
                "frames_rx_rate",
                "frames_tx",
                "frames_tx_rate",
                "link",
                "location",
                "transmit",
            ],
            "itemtype": str,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    BYTES_RX = "bytes_rx"  # type: str
    BYTES_RX_RATE = "bytes_rx_rate"  # type: str
    BYTES_TX = "bytes_tx"  # type: str
    BYTES_TX_RATE = "bytes_tx_rate"  # type: str
    CAPTURE = "capture"  # type: str
    FRAMES_RX = "frames_rx"  # type: str
    FRAMES_RX_RATE = "frames_rx_rate"  # type: str
    FRAMES_TX = "frames_tx"  # type: str
    FRAMES_TX_RATE = "frames_tx_rate"  # type: str
    LINK = "link"  # type: str
    LOCATION = "location"  # type: str
    TRANSMIT = "transmit"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, port_names=None, column_names=None):
        super(PortMetricsRequest, self).__init__()
        self._parent = parent
        self._set_property("port_names", port_names)
        self._set_property("column_names", column_names)

    def set(self, port_names=None, column_names=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def port_names(self):
        # type: () -> List[str]
        """port_names getter

        The names of objects to return results for. An empty list will return all port row results.. x-constraint:. /components/schemas/Port/properties/name. . x-constraint:. /components/schemas/Port/properties/name.

        Returns: List[str]
        """
        return self._get_property("port_names")

    @port_names.setter
    def port_names(self, value):
        """port_names setter

        The names of objects to return results for. An empty list will return all port row results.. x-constraint:. /components/schemas/Port/properties/name. . x-constraint:. /components/schemas/Port/properties/name.

        value: List[str]
        """
        self._set_property("port_names", value)

    @property
    def column_names(self):
        # type: () -> List[Union[Literal["bytes_rx"], Literal["bytes_rx_rate"], Literal["bytes_tx"], Literal["bytes_tx_rate"], Literal["capture"], Literal["frames_rx"], Literal["frames_rx_rate"], Literal["frames_tx"], Literal["frames_tx_rate"], Literal["link"], Literal["location"], Literal["transmit"]]]
        """column_names getter

        The list of column names that the returned result set will contain. If the list is empty then all columns will be returned. The name of the port cannot be excluded.

        Returns: List[Union[Literal["bytes_rx"], Literal["bytes_rx_rate"], Literal["bytes_tx"], Literal["bytes_tx_rate"], Literal["capture"], Literal["frames_rx"], Literal["frames_rx_rate"], Literal["frames_tx"], Literal["frames_tx_rate"], Literal["link"], Literal["location"], Literal["transmit"]]]
        """
        return self._get_property("column_names")

    @column_names.setter
    def column_names(self, value):
        """column_names setter

        The list of column names that the returned result set will contain. If the list is empty then all columns will be returned. The name of the port cannot be excluded.

        value: List[Union[Literal["bytes_rx"], Literal["bytes_rx_rate"], Literal["bytes_tx"], Literal["bytes_tx_rate"], Literal["capture"], Literal["frames_rx"], Literal["frames_rx_rate"], Literal["frames_tx"], Literal["frames_tx_rate"], Literal["link"], Literal["location"], Literal["transmit"]]]
        """
        self._set_property("column_names", value)


class FlowMetricsRequest(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "flow_names": {
            "type": list,
            "itemtype": str,
        },
        "metric_names": {
            "type": list,
            "enum": [
                "bytes_rx",
                "bytes_tx",
                "frames_rx",
                "frames_rx_rate",
                "frames_tx",
                "frames_tx_rate",
                "transmit",
            ],
            "itemtype": str,
        },
        "tagged_metrics": {"type": "FlowTaggedMetricsFilter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    BYTES_RX = "bytes_rx"  # type: str
    BYTES_TX = "bytes_tx"  # type: str
    FRAMES_RX = "frames_rx"  # type: str
    FRAMES_RX_RATE = "frames_rx_rate"  # type: str
    FRAMES_TX = "frames_tx"  # type: str
    FRAMES_TX_RATE = "frames_tx_rate"  # type: str
    TRANSMIT = "transmit"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, flow_names=None, metric_names=None):
        super(FlowMetricsRequest, self).__init__()
        self._parent = parent
        self._set_property("flow_names", flow_names)
        self._set_property("metric_names", metric_names)

    def set(self, flow_names=None, metric_names=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def flow_names(self):
        # type: () -> List[str]
        """flow_names getter

        Flow metrics will be retrieved for these flow names.. If no flow names are specified then all flows will be returned.. x-constraint:. /components/schemas/Flow/properties/name. . x-constraint:. /components/schemas/Flow/properties/name.

        Returns: List[str]
        """
        return self._get_property("flow_names")

    @flow_names.setter
    def flow_names(self, value):
        """flow_names setter

        Flow metrics will be retrieved for these flow names.. If no flow names are specified then all flows will be returned.. x-constraint:. /components/schemas/Flow/properties/name. . x-constraint:. /components/schemas/Flow/properties/name.

        value: List[str]
        """
        self._set_property("flow_names", value)

    @property
    def metric_names(self):
        # type: () -> List[Union[Literal["bytes_rx"], Literal["bytes_tx"], Literal["frames_rx"], Literal["frames_rx_rate"], Literal["frames_tx"], Literal["frames_tx_rate"], Literal["transmit"]]]
        """metric_names getter

        The list of metric names that the returned result set will contain. If the list is empty then all metrics will be returned.

        Returns: List[Union[Literal["bytes_rx"], Literal["bytes_tx"], Literal["frames_rx"], Literal["frames_rx_rate"], Literal["frames_tx"], Literal["frames_tx_rate"], Literal["transmit"]]]
        """
        return self._get_property("metric_names")

    @metric_names.setter
    def metric_names(self, value):
        """metric_names setter

        The list of metric names that the returned result set will contain. If the list is empty then all metrics will be returned.

        value: List[Union[Literal["bytes_rx"], Literal["bytes_tx"], Literal["frames_rx"], Literal["frames_rx_rate"], Literal["frames_tx"], Literal["frames_tx_rate"], Literal["transmit"]]]
        """
        self._set_property("metric_names", value)

    @property
    def tagged_metrics(self):
        # type: () -> FlowTaggedMetricsFilter
        """tagged_metrics getter

        Filter for tagged metricsFilter for tagged metricsFilter for tagged metricsFilter for tagged metrics

        Returns: FlowTaggedMetricsFilter
        """
        return self._get_property("tagged_metrics", FlowTaggedMetricsFilter)


class FlowTaggedMetricsFilter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "include": {"type": bool},
        "include_empty_metrics": {"type": bool},
        "metric_names": {
            "type": list,
            "enum": [
                "frames_tx",
                "frames_rx",
                "bytes_tx",
                "bytes_rx",
                "frames_tx_rate",
                "frames_rx_rate",
            ],
            "itemtype": str,
        },
        "filters": {"type": "FlowMetricTagFilterIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "include": True,
        "include_empty_metrics": False,
    }  # type: Dict[str, Union(type)]

    FRAMES_TX = "frames_tx"  # type: str
    FRAMES_RX = "frames_rx"  # type: str
    BYTES_TX = "bytes_tx"  # type: str
    BYTES_RX = "bytes_rx"  # type: str
    FRAMES_TX_RATE = "frames_tx_rate"  # type: str
    FRAMES_RX_RATE = "frames_rx_rate"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self, parent=None, include=True, include_empty_metrics=False, metric_names=None
    ):
        super(FlowTaggedMetricsFilter, self).__init__()
        self._parent = parent
        self._set_property("include", include)
        self._set_property("include_empty_metrics", include_empty_metrics)
        self._set_property("metric_names", metric_names)

    def set(self, include=None, include_empty_metrics=None, metric_names=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def include(self):
        # type: () -> bool
        """include getter

        Controls inclusion/exclusion of tagged metrics when fetching flow metrics.

        Returns: bool
        """
        return self._get_property("include")

    @include.setter
    def include(self, value):
        """include setter

        Controls inclusion/exclusion of tagged metrics when fetching flow metrics.

        value: bool
        """
        self._set_property("include", value)

    @property
    def include_empty_metrics(self):
        # type: () -> bool
        """include_empty_metrics getter

        Controls inclusion/exclusion of tagged metrics where each underlying attributes has zero value or absent value.

        Returns: bool
        """
        return self._get_property("include_empty_metrics")

    @include_empty_metrics.setter
    def include_empty_metrics(self, value):
        """include_empty_metrics setter

        Controls inclusion/exclusion of tagged metrics where each underlying attributes has zero value or absent value.

        value: bool
        """
        self._set_property("include_empty_metrics", value)

    @property
    def metric_names(self):
        # type: () -> List[Union[Literal["bytes_rx"], Literal["bytes_tx"], Literal["frames_rx"], Literal["frames_rx_rate"], Literal["frames_tx"], Literal["frames_tx_rate"]]]
        """metric_names getter

        The list of metric names that the returned result set will contain. If the list is empty then all metrics will be returned.

        Returns: List[Union[Literal["bytes_rx"], Literal["bytes_tx"], Literal["frames_rx"], Literal["frames_rx_rate"], Literal["frames_tx"], Literal["frames_tx_rate"]]]
        """
        return self._get_property("metric_names")

    @metric_names.setter
    def metric_names(self, value):
        """metric_names setter

        The list of metric names that the returned result set will contain. If the list is empty then all metrics will be returned.

        value: List[Union[Literal["bytes_rx"], Literal["bytes_tx"], Literal["frames_rx"], Literal["frames_rx_rate"], Literal["frames_tx"], Literal["frames_tx_rate"]]]
        """
        self._set_property("metric_names", value)

    @property
    def filters(self):
        # type: () -> FlowMetricTagFilterIter
        """filters getter

        List of filters to selectively fetch tagged metrics with certain tag and corresponding value.

        Returns: FlowMetricTagFilterIter
        """
        return self._get_property(
            "filters", FlowMetricTagFilterIter, self._parent, self._choice
        )


class FlowMetricTagFilter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "values": {
            "type": list,
            "itemtype": str,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None, values=None):
        super(FlowMetricTagFilter, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("values", values)

    def set(self, name=None, values=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        A metric tag name that MUST exist in flow packet or. flow egress_packet configuration

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        A metric tag name that MUST exist in flow packet or. flow egress_packet configuration

        value: str
        """
        self._set_property("name", value)

    @property
    def values(self):
        # type: () -> List[str]
        """values getter

        A list of filters that can be applied to the metric tag name.. By default all values will be included in the flow metric results.

        Returns: List[str]
        """
        return self._get_property("values")

    @values.setter
    def values(self, value):
        """values setter

        A list of filters that can be applied to the metric tag name.. By default all values will be included in the flow metric results.

        value: List[str]
        """
        self._set_property("values", value)


class FlowMetricTagFilterIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(FlowMetricTagFilterIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[FlowMetricTagFilter]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> FlowMetricTagFilterIter
        return self._iter()

    def __next__(self):
        # type: () -> FlowMetricTagFilter
        return self._next()

    def next(self):
        # type: () -> FlowMetricTagFilter
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, FlowMetricTagFilter):
            raise Exception("Item is not an instance of FlowMetricTagFilter")

    def filter(self, name=None, values=None):
        # type: (str,List[str]) -> FlowMetricTagFilterIter
        """Factory method that creates an instance of the FlowMetricTagFilter class

        A container for filtering ingress and/or egress metric tags.. The Tx stats may not be applicable in both the request and response filter.

        Returns: FlowMetricTagFilterIter
        """
        item = FlowMetricTagFilter(parent=self._parent, name=name, values=values)
        self._add(item)
        return self

    def add(self, name=None, values=None):
        # type: (str,List[str]) -> FlowMetricTagFilter
        """Add method that creates and returns an instance of the FlowMetricTagFilter class

        A container for filtering ingress and/or egress metric tags.. The Tx stats may not be applicable in both the request and response filter.

        Returns: FlowMetricTagFilter
        """
        item = FlowMetricTagFilter(parent=self._parent, name=name, values=values)
        self._add(item)
        return item


class Bgpv4MetricsRequest(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "peer_names": {
            "type": list,
            "itemtype": str,
        },
        "column_names": {
            "type": list,
            "enum": [
                "end_of_rib_received",
                "fsm_state",
                "keepalives_received",
                "keepalives_sent",
                "notifications_received",
                "notifications_sent",
                "opens_received",
                "opens_sent",
                "route_withdraws_received",
                "route_withdraws_sent",
                "routes_advertised",
                "routes_received",
                "session_flap_count",
                "session_state",
                "updates_received",
                "updates_sent",
            ],
            "itemtype": str,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    END_OF_RIB_RECEIVED = "end_of_rib_received"  # type: str
    FSM_STATE = "fsm_state"  # type: str
    KEEPALIVES_RECEIVED = "keepalives_received"  # type: str
    KEEPALIVES_SENT = "keepalives_sent"  # type: str
    NOTIFICATIONS_RECEIVED = "notifications_received"  # type: str
    NOTIFICATIONS_SENT = "notifications_sent"  # type: str
    OPENS_RECEIVED = "opens_received"  # type: str
    OPENS_SENT = "opens_sent"  # type: str
    ROUTE_WITHDRAWS_RECEIVED = "route_withdraws_received"  # type: str
    ROUTE_WITHDRAWS_SENT = "route_withdraws_sent"  # type: str
    ROUTES_ADVERTISED = "routes_advertised"  # type: str
    ROUTES_RECEIVED = "routes_received"  # type: str
    SESSION_FLAP_COUNT = "session_flap_count"  # type: str
    SESSION_STATE = "session_state"  # type: str
    UPDATES_RECEIVED = "updates_received"  # type: str
    UPDATES_SENT = "updates_sent"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, peer_names=None, column_names=None):
        super(Bgpv4MetricsRequest, self).__init__()
        self._parent = parent
        self._set_property("peer_names", peer_names)
        self._set_property("column_names", column_names)

    def set(self, peer_names=None, column_names=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def peer_names(self):
        # type: () -> List[str]
        """peer_names getter

        The names of BGPv4 peers to return results for. An empty list will return results for all BGPv4 peers.. x-constraint:. /components/schemas/Bgp.V4peer/properties/name. . x-constraint:. /components/schemas/Bgp.V4peer/properties/name.

        Returns: List[str]
        """
        return self._get_property("peer_names")

    @peer_names.setter
    def peer_names(self, value):
        """peer_names setter

        The names of BGPv4 peers to return results for. An empty list will return results for all BGPv4 peers.. x-constraint:. /components/schemas/Bgp.V4peer/properties/name. . x-constraint:. /components/schemas/Bgp.V4peer/properties/name.

        value: List[str]
        """
        self._set_property("peer_names", value)

    @property
    def column_names(self):
        # type: () -> List[Union[Literal["end_of_rib_received"], Literal["fsm_state"], Literal["keepalives_received"], Literal["keepalives_sent"], Literal["notifications_received"], Literal["notifications_sent"], Literal["opens_received"], Literal["opens_sent"], Literal["route_withdraws_received"], Literal["route_withdraws_sent"], Literal["routes_advertised"], Literal["routes_received"], Literal["session_flap_count"], Literal["session_state"], Literal["updates_received"], Literal["updates_sent"]]]
        """column_names getter

        The list of column names that the returned result set will contain. If the list is empty then all columns will be returned except for any result_groups. The name of the BGPv4 peer cannot be excluded.

        Returns: List[Union[Literal["end_of_rib_received"], Literal["fsm_state"], Literal["keepalives_received"], Literal["keepalives_sent"], Literal["notifications_received"], Literal["notifications_sent"], Literal["opens_received"], Literal["opens_sent"], Literal["route_withdraws_received"], Literal["route_withdraws_sent"], Literal["routes_advertised"], Literal["routes_received"], Literal["session_flap_count"], Literal["session_state"], Literal["updates_received"], Literal["updates_sent"]]]
        """
        return self._get_property("column_names")

    @column_names.setter
    def column_names(self, value):
        """column_names setter

        The list of column names that the returned result set will contain. If the list is empty then all columns will be returned except for any result_groups. The name of the BGPv4 peer cannot be excluded.

        value: List[Union[Literal["end_of_rib_received"], Literal["fsm_state"], Literal["keepalives_received"], Literal["keepalives_sent"], Literal["notifications_received"], Literal["notifications_sent"], Literal["opens_received"], Literal["opens_sent"], Literal["route_withdraws_received"], Literal["route_withdraws_sent"], Literal["routes_advertised"], Literal["routes_received"], Literal["session_flap_count"], Literal["session_state"], Literal["updates_received"], Literal["updates_sent"]]]
        """
        self._set_property("column_names", value)


class Bgpv6MetricsRequest(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "peer_names": {
            "type": list,
            "itemtype": str,
        },
        "column_names": {
            "type": list,
            "enum": [
                "end_of_rib_received",
                "fsm_state",
                "keepalives_received",
                "keepalives_sent",
                "notifications_received",
                "notifications_sent",
                "opens_received",
                "opens_sent",
                "route_withdraws_received",
                "route_withdraws_sent",
                "routes_advertised",
                "routes_received",
                "session_flap_count",
                "session_state",
                "updates_received",
                "updates_sent",
            ],
            "itemtype": str,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    END_OF_RIB_RECEIVED = "end_of_rib_received"  # type: str
    FSM_STATE = "fsm_state"  # type: str
    KEEPALIVES_RECEIVED = "keepalives_received"  # type: str
    KEEPALIVES_SENT = "keepalives_sent"  # type: str
    NOTIFICATIONS_RECEIVED = "notifications_received"  # type: str
    NOTIFICATIONS_SENT = "notifications_sent"  # type: str
    OPENS_RECEIVED = "opens_received"  # type: str
    OPENS_SENT = "opens_sent"  # type: str
    ROUTE_WITHDRAWS_RECEIVED = "route_withdraws_received"  # type: str
    ROUTE_WITHDRAWS_SENT = "route_withdraws_sent"  # type: str
    ROUTES_ADVERTISED = "routes_advertised"  # type: str
    ROUTES_RECEIVED = "routes_received"  # type: str
    SESSION_FLAP_COUNT = "session_flap_count"  # type: str
    SESSION_STATE = "session_state"  # type: str
    UPDATES_RECEIVED = "updates_received"  # type: str
    UPDATES_SENT = "updates_sent"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, peer_names=None, column_names=None):
        super(Bgpv6MetricsRequest, self).__init__()
        self._parent = parent
        self._set_property("peer_names", peer_names)
        self._set_property("column_names", column_names)

    def set(self, peer_names=None, column_names=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def peer_names(self):
        # type: () -> List[str]
        """peer_names getter

        The names of BGPv6 peers to return results for. An empty list will return results for all BGPv6 peers.. x-constraint:. /components/schemas/Bgp.V6peer/properties/name. . x-constraint:. /components/schemas/Bgp.V6peer/properties/name.

        Returns: List[str]
        """
        return self._get_property("peer_names")

    @peer_names.setter
    def peer_names(self, value):
        """peer_names setter

        The names of BGPv6 peers to return results for. An empty list will return results for all BGPv6 peers.. x-constraint:. /components/schemas/Bgp.V6peer/properties/name. . x-constraint:. /components/schemas/Bgp.V6peer/properties/name.

        value: List[str]
        """
        self._set_property("peer_names", value)

    @property
    def column_names(self):
        # type: () -> List[Union[Literal["end_of_rib_received"], Literal["fsm_state"], Literal["keepalives_received"], Literal["keepalives_sent"], Literal["notifications_received"], Literal["notifications_sent"], Literal["opens_received"], Literal["opens_sent"], Literal["route_withdraws_received"], Literal["route_withdraws_sent"], Literal["routes_advertised"], Literal["routes_received"], Literal["session_flap_count"], Literal["session_state"], Literal["updates_received"], Literal["updates_sent"]]]
        """column_names getter

        The list of column names that the returned result set will contain. If the list is empty then all columns will be returned except for any result_groups. The name of the BGPv6 peer cannot be excluded.

        Returns: List[Union[Literal["end_of_rib_received"], Literal["fsm_state"], Literal["keepalives_received"], Literal["keepalives_sent"], Literal["notifications_received"], Literal["notifications_sent"], Literal["opens_received"], Literal["opens_sent"], Literal["route_withdraws_received"], Literal["route_withdraws_sent"], Literal["routes_advertised"], Literal["routes_received"], Literal["session_flap_count"], Literal["session_state"], Literal["updates_received"], Literal["updates_sent"]]]
        """
        return self._get_property("column_names")

    @column_names.setter
    def column_names(self, value):
        """column_names setter

        The list of column names that the returned result set will contain. If the list is empty then all columns will be returned except for any result_groups. The name of the BGPv6 peer cannot be excluded.

        value: List[Union[Literal["end_of_rib_received"], Literal["fsm_state"], Literal["keepalives_received"], Literal["keepalives_sent"], Literal["notifications_received"], Literal["notifications_sent"], Literal["opens_received"], Literal["opens_sent"], Literal["route_withdraws_received"], Literal["route_withdraws_sent"], Literal["routes_advertised"], Literal["routes_received"], Literal["session_flap_count"], Literal["session_state"], Literal["updates_received"], Literal["updates_sent"]]]
        """
        self._set_property("column_names", value)


class IsisMetricsRequest(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "router_names": {
            "type": list,
            "itemtype": str,
        },
        "column_names": {
            "type": list,
            "enum": [
                "l1_broadcast_hellos_received",
                "l1_broadcast_hellos_sent",
                "l1_csnp_received",
                "l1_csnp_sent",
                "l1_database_size",
                "l1_lsp_received",
                "l1_lsp_sent",
                "l1_point_to_point_hellos_received",
                "l1_point_to_point_hellos_sent",
                "l1_psnp_received",
                "l1_psnp_sent",
                "l1_session_flap",
                "l1_sessions_up",
                "l2_broadcast_hellos_received",
                "l2_broadcast_hellos_sent",
                "l2_csnp_received",
                "l2_csnp_sent",
                "l2_database_size",
                "l2_lsp_received",
                "l2_lsp_sent",
                "l2_point_to_point_hellos_received",
                "l2_point_to_point_hellos_sent",
                "l2_psnp_received",
                "l2_psnp_sent",
                "l2_session_flap",
                "l2_sessions_up",
            ],
            "itemtype": str,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    L1_BROADCAST_HELLOS_RECEIVED = "l1_broadcast_hellos_received"  # type: str
    L1_BROADCAST_HELLOS_SENT = "l1_broadcast_hellos_sent"  # type: str
    L1_CSNP_RECEIVED = "l1_csnp_received"  # type: str
    L1_CSNP_SENT = "l1_csnp_sent"  # type: str
    L1_DATABASE_SIZE = "l1_database_size"  # type: str
    L1_LSP_RECEIVED = "l1_lsp_received"  # type: str
    L1_LSP_SENT = "l1_lsp_sent"  # type: str
    L1_POINT_TO_POINT_HELLOS_RECEIVED = "l1_point_to_point_hellos_received"  # type: str
    L1_POINT_TO_POINT_HELLOS_SENT = "l1_point_to_point_hellos_sent"  # type: str
    L1_PSNP_RECEIVED = "l1_psnp_received"  # type: str
    L1_PSNP_SENT = "l1_psnp_sent"  # type: str
    L1_SESSION_FLAP = "l1_session_flap"  # type: str
    L1_SESSIONS_UP = "l1_sessions_up"  # type: str
    L2_BROADCAST_HELLOS_RECEIVED = "l2_broadcast_hellos_received"  # type: str
    L2_BROADCAST_HELLOS_SENT = "l2_broadcast_hellos_sent"  # type: str
    L2_CSNP_RECEIVED = "l2_csnp_received"  # type: str
    L2_CSNP_SENT = "l2_csnp_sent"  # type: str
    L2_DATABASE_SIZE = "l2_database_size"  # type: str
    L2_LSP_RECEIVED = "l2_lsp_received"  # type: str
    L2_LSP_SENT = "l2_lsp_sent"  # type: str
    L2_POINT_TO_POINT_HELLOS_RECEIVED = "l2_point_to_point_hellos_received"  # type: str
    L2_POINT_TO_POINT_HELLOS_SENT = "l2_point_to_point_hellos_sent"  # type: str
    L2_PSNP_RECEIVED = "l2_psnp_received"  # type: str
    L2_PSNP_SENT = "l2_psnp_sent"  # type: str
    L2_SESSION_FLAP = "l2_session_flap"  # type: str
    L2_SESSIONS_UP = "l2_sessions_up"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, router_names=None, column_names=None):
        super(IsisMetricsRequest, self).__init__()
        self._parent = parent
        self._set_property("router_names", router_names)
        self._set_property("column_names", column_names)

    def set(self, router_names=None, column_names=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def router_names(self):
        # type: () -> List[str]
        """router_names getter

        The names of ISIS Routers to return results for. An empty list will return results for all ISIS router.. x-constraint:. /components/schemas/Device.IsisRouter/properties/name. . x-constraint:. /components/schemas/Device.IsisRouter/properties/name.

        Returns: List[str]
        """
        return self._get_property("router_names")

    @router_names.setter
    def router_names(self, value):
        """router_names setter

        The names of ISIS Routers to return results for. An empty list will return results for all ISIS router.. x-constraint:. /components/schemas/Device.IsisRouter/properties/name. . x-constraint:. /components/schemas/Device.IsisRouter/properties/name.

        value: List[str]
        """
        self._set_property("router_names", value)

    @property
    def column_names(self):
        # type: () -> List[Union[Literal["l1_broadcast_hellos_received"], Literal["l1_broadcast_hellos_sent"], Literal["l1_csnp_received"], Literal["l1_csnp_sent"], Literal["l1_database_size"], Literal["l1_lsp_received"], Literal["l1_lsp_sent"], Literal["l1_point_to_point_hellos_received"], Literal["l1_point_to_point_hellos_sent"], Literal["l1_psnp_received"], Literal["l1_psnp_sent"], Literal["l1_session_flap"], Literal["l1_sessions_up"], Literal["l2_broadcast_hellos_received"], Literal["l2_broadcast_hellos_sent"], Literal["l2_csnp_received"], Literal["l2_csnp_sent"], Literal["l2_database_size"], Literal["l2_lsp_received"], Literal["l2_lsp_sent"], Literal["l2_point_to_point_hellos_received"], Literal["l2_point_to_point_hellos_sent"], Literal["l2_psnp_received"], Literal["l2_psnp_sent"], Literal["l2_session_flap"], Literal["l2_sessions_up"]]]
        """column_names getter

        The list of column names that the returned result set will contain. If the list is empty then all columns will be returned except for any result_groups. The name of the ISIS Router cannot be excluded.

        Returns: List[Union[Literal["l1_broadcast_hellos_received"], Literal["l1_broadcast_hellos_sent"], Literal["l1_csnp_received"], Literal["l1_csnp_sent"], Literal["l1_database_size"], Literal["l1_lsp_received"], Literal["l1_lsp_sent"], Literal["l1_point_to_point_hellos_received"], Literal["l1_point_to_point_hellos_sent"], Literal["l1_psnp_received"], Literal["l1_psnp_sent"], Literal["l1_session_flap"], Literal["l1_sessions_up"], Literal["l2_broadcast_hellos_received"], Literal["l2_broadcast_hellos_sent"], Literal["l2_csnp_received"], Literal["l2_csnp_sent"], Literal["l2_database_size"], Literal["l2_lsp_received"], Literal["l2_lsp_sent"], Literal["l2_point_to_point_hellos_received"], Literal["l2_point_to_point_hellos_sent"], Literal["l2_psnp_received"], Literal["l2_psnp_sent"], Literal["l2_session_flap"], Literal["l2_sessions_up"]]]
        """
        return self._get_property("column_names")

    @column_names.setter
    def column_names(self, value):
        """column_names setter

        The list of column names that the returned result set will contain. If the list is empty then all columns will be returned except for any result_groups. The name of the ISIS Router cannot be excluded.

        value: List[Union[Literal["l1_broadcast_hellos_received"], Literal["l1_broadcast_hellos_sent"], Literal["l1_csnp_received"], Literal["l1_csnp_sent"], Literal["l1_database_size"], Literal["l1_lsp_received"], Literal["l1_lsp_sent"], Literal["l1_point_to_point_hellos_received"], Literal["l1_point_to_point_hellos_sent"], Literal["l1_psnp_received"], Literal["l1_psnp_sent"], Literal["l1_session_flap"], Literal["l1_sessions_up"], Literal["l2_broadcast_hellos_received"], Literal["l2_broadcast_hellos_sent"], Literal["l2_csnp_received"], Literal["l2_csnp_sent"], Literal["l2_database_size"], Literal["l2_lsp_received"], Literal["l2_lsp_sent"], Literal["l2_point_to_point_hellos_received"], Literal["l2_point_to_point_hellos_sent"], Literal["l2_psnp_received"], Literal["l2_psnp_sent"], Literal["l2_session_flap"], Literal["l2_sessions_up"]]]
        """
        self._set_property("column_names", value)


class LagMetricsRequest(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "lag_names": {
            "type": list,
            "itemtype": str,
        },
        "column_names": {
            "type": list,
            "enum": [
                "bytes_rx",
                "bytes_rx_rate",
                "bytes_tx",
                "bytes_tx_rate",
                "frames_rx",
                "frames_rx_rate",
                "frames_tx",
                "frames_tx_rate",
                "member_ports_up",
                "oper_status",
            ],
            "itemtype": str,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    BYTES_RX = "bytes_rx"  # type: str
    BYTES_RX_RATE = "bytes_rx_rate"  # type: str
    BYTES_TX = "bytes_tx"  # type: str
    BYTES_TX_RATE = "bytes_tx_rate"  # type: str
    FRAMES_RX = "frames_rx"  # type: str
    FRAMES_RX_RATE = "frames_rx_rate"  # type: str
    FRAMES_TX = "frames_tx"  # type: str
    FRAMES_TX_RATE = "frames_tx_rate"  # type: str
    MEMBER_PORTS_UP = "member_ports_up"  # type: str
    OPER_STATUS = "oper_status"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, lag_names=None, column_names=None):
        super(LagMetricsRequest, self).__init__()
        self._parent = parent
        self._set_property("lag_names", lag_names)
        self._set_property("column_names", column_names)

    def set(self, lag_names=None, column_names=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def lag_names(self):
        # type: () -> List[str]
        """lag_names getter

        The names of LAGs to return results for. An empty list will return results for all LAGs.. x-constraint:. /components/schemas/Lag/properties/name. . x-constraint:. /components/schemas/Lag/properties/name.

        Returns: List[str]
        """
        return self._get_property("lag_names")

    @lag_names.setter
    def lag_names(self, value):
        """lag_names setter

        The names of LAGs to return results for. An empty list will return results for all LAGs.. x-constraint:. /components/schemas/Lag/properties/name. . x-constraint:. /components/schemas/Lag/properties/name.

        value: List[str]
        """
        self._set_property("lag_names", value)

    @property
    def column_names(self):
        # type: () -> List[Union[Literal["bytes_rx"], Literal["bytes_rx_rate"], Literal["bytes_tx"], Literal["bytes_tx_rate"], Literal["frames_rx"], Literal["frames_rx_rate"], Literal["frames_tx"], Literal["frames_tx_rate"], Literal["member_ports_up"], Literal["oper_status"]]]
        """column_names getter

        The list of column names that the returned result set will contain. If the list is empty then all columns will be returned. The name of the LAG cannot be excluded.

        Returns: List[Union[Literal["bytes_rx"], Literal["bytes_rx_rate"], Literal["bytes_tx"], Literal["bytes_tx_rate"], Literal["frames_rx"], Literal["frames_rx_rate"], Literal["frames_tx"], Literal["frames_tx_rate"], Literal["member_ports_up"], Literal["oper_status"]]]
        """
        return self._get_property("column_names")

    @column_names.setter
    def column_names(self, value):
        """column_names setter

        The list of column names that the returned result set will contain. If the list is empty then all columns will be returned. The name of the LAG cannot be excluded.

        value: List[Union[Literal["bytes_rx"], Literal["bytes_rx_rate"], Literal["bytes_tx"], Literal["bytes_tx_rate"], Literal["frames_rx"], Literal["frames_rx_rate"], Literal["frames_tx"], Literal["frames_tx_rate"], Literal["member_ports_up"], Literal["oper_status"]]]
        """
        self._set_property("column_names", value)


class LacpMetricsRequest(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "lag_names": {
            "type": list,
            "itemtype": str,
        },
        "lag_member_port_names": {
            "type": list,
            "itemtype": str,
        },
        "column_names": {
            "type": list,
            "enum": [
                "activity",
                "aggregatable",
                "collecting",
                "distributing",
                "lacp_packets_rx",
                "lacp_packets_tx",
                "lacp_rx_errors",
                "oper_key",
                "partner_id",
                "partner_key",
                "partner_port_num",
                "port_num",
                "synchronization",
                "system_id",
                "timeout",
            ],
            "itemtype": str,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    ACTIVITY = "activity"  # type: str
    AGGREGATABLE = "aggregatable"  # type: str
    COLLECTING = "collecting"  # type: str
    DISTRIBUTING = "distributing"  # type: str
    LACP_PACKETS_RX = "lacp_packets_rx"  # type: str
    LACP_PACKETS_TX = "lacp_packets_tx"  # type: str
    LACP_RX_ERRORS = "lacp_rx_errors"  # type: str
    OPER_KEY = "oper_key"  # type: str
    PARTNER_ID = "partner_id"  # type: str
    PARTNER_KEY = "partner_key"  # type: str
    PARTNER_PORT_NUM = "partner_port_num"  # type: str
    PORT_NUM = "port_num"  # type: str
    SYNCHRONIZATION = "synchronization"  # type: str
    SYSTEM_ID = "system_id"  # type: str
    TIMEOUT = "timeout"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self, parent=None, lag_names=None, lag_member_port_names=None, column_names=None
    ):
        super(LacpMetricsRequest, self).__init__()
        self._parent = parent
        self._set_property("lag_names", lag_names)
        self._set_property("lag_member_port_names", lag_member_port_names)
        self._set_property("column_names", column_names)

    def set(self, lag_names=None, lag_member_port_names=None, column_names=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def lag_names(self):
        # type: () -> List[str]
        """lag_names getter

        The names of LAG (ports group) for which LACP metrics to be returned. An empty list will return metrics for all LAGs.. x-constraint:. /components/schemas/Lag/properties/name. . x-constraint:. /components/schemas/Lag/properties/name.

        Returns: List[str]
        """
        return self._get_property("lag_names")

    @lag_names.setter
    def lag_names(self, value):
        """lag_names setter

        The names of LAG (ports group) for which LACP metrics to be returned. An empty list will return metrics for all LAGs.. x-constraint:. /components/schemas/Lag/properties/name. . x-constraint:. /components/schemas/Lag/properties/name.

        value: List[str]
        """
        self._set_property("lag_names", value)

    @property
    def lag_member_port_names(self):
        # type: () -> List[str]
        """lag_member_port_names getter

        The names of LAG members (ports) for which LACP metrics to be returned. An empty list will return metrics for all LAG members.. x-constraint:. /components/schemas/Port/properties/name. . x-constraint:. /components/schemas/Port/properties/name.

        Returns: List[str]
        """
        return self._get_property("lag_member_port_names")

    @lag_member_port_names.setter
    def lag_member_port_names(self, value):
        """lag_member_port_names setter

        The names of LAG members (ports) for which LACP metrics to be returned. An empty list will return metrics for all LAG members.. x-constraint:. /components/schemas/Port/properties/name. . x-constraint:. /components/schemas/Port/properties/name.

        value: List[str]
        """
        self._set_property("lag_member_port_names", value)

    @property
    def column_names(self):
        # type: () -> List[Union[Literal["activity"], Literal["aggregatable"], Literal["collecting"], Literal["distributing"], Literal["lacp_packets_rx"], Literal["lacp_packets_tx"], Literal["lacp_rx_errors"], Literal["oper_key"], Literal["partner_id"], Literal["partner_key"], Literal["partner_port_num"], Literal["port_num"], Literal["synchronization"], Literal["system_id"], Literal["timeout"]]]
        """column_names getter

        The list of column names that the returned result set will contain. If the list is empty then all columns will be returned. The name of LAG and LAG member can not be excluded.

        Returns: List[Union[Literal["activity"], Literal["aggregatable"], Literal["collecting"], Literal["distributing"], Literal["lacp_packets_rx"], Literal["lacp_packets_tx"], Literal["lacp_rx_errors"], Literal["oper_key"], Literal["partner_id"], Literal["partner_key"], Literal["partner_port_num"], Literal["port_num"], Literal["synchronization"], Literal["system_id"], Literal["timeout"]]]
        """
        return self._get_property("column_names")

    @column_names.setter
    def column_names(self, value):
        """column_names setter

        The list of column names that the returned result set will contain. If the list is empty then all columns will be returned. The name of LAG and LAG member can not be excluded.

        value: List[Union[Literal["activity"], Literal["aggregatable"], Literal["collecting"], Literal["distributing"], Literal["lacp_packets_rx"], Literal["lacp_packets_tx"], Literal["lacp_rx_errors"], Literal["oper_key"], Literal["partner_id"], Literal["partner_key"], Literal["partner_port_num"], Literal["port_num"], Literal["synchronization"], Literal["system_id"], Literal["timeout"]]]
        """
        self._set_property("column_names", value)


class LldpMetricsRequest(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "lldp_names": {
            "type": list,
            "itemtype": str,
        },
        "column_names": {
            "type": list,
            "enum": [
                "frames_discard",
                "frames_error_rx",
                "frames_rx",
                "frames_tx",
                "tlvs_discard",
                "tlvs_unknown",
            ],
            "itemtype": str,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    FRAMES_DISCARD = "frames_discard"  # type: str
    FRAMES_ERROR_RX = "frames_error_rx"  # type: str
    FRAMES_RX = "frames_rx"  # type: str
    FRAMES_TX = "frames_tx"  # type: str
    TLVS_DISCARD = "tlvs_discard"  # type: str
    TLVS_UNKNOWN = "tlvs_unknown"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, lldp_names=None, column_names=None):
        super(LldpMetricsRequest, self).__init__()
        self._parent = parent
        self._set_property("lldp_names", lldp_names)
        self._set_property("column_names", column_names)

    def set(self, lldp_names=None, column_names=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def lldp_names(self):
        # type: () -> List[str]
        """lldp_names getter

        The names of LLDP instances to return results for. An empty list will return results for all LLDP instances.. x-constraint:. /components/schemas/Lldp/properties/name. . x-constraint:. /components/schemas/Lldp/properties/name.

        Returns: List[str]
        """
        return self._get_property("lldp_names")

    @lldp_names.setter
    def lldp_names(self, value):
        """lldp_names setter

        The names of LLDP instances to return results for. An empty list will return results for all LLDP instances.. x-constraint:. /components/schemas/Lldp/properties/name. . x-constraint:. /components/schemas/Lldp/properties/name.

        value: List[str]
        """
        self._set_property("lldp_names", value)

    @property
    def column_names(self):
        # type: () -> List[Union[Literal["frames_discard"], Literal["frames_error_rx"], Literal["frames_rx"], Literal["frames_tx"], Literal["tlvs_discard"], Literal["tlvs_unknown"]]]
        """column_names getter

        The requested list of column names for the result set. If the list is empty then metrics for all columns will be returned. The name of LLDP instance can not be excluded.

        Returns: List[Union[Literal["frames_discard"], Literal["frames_error_rx"], Literal["frames_rx"], Literal["frames_tx"], Literal["tlvs_discard"], Literal["tlvs_unknown"]]]
        """
        return self._get_property("column_names")

    @column_names.setter
    def column_names(self, value):
        """column_names setter

        The requested list of column names for the result set. If the list is empty then metrics for all columns will be returned. The name of LLDP instance can not be excluded.

        value: List[Union[Literal["frames_discard"], Literal["frames_error_rx"], Literal["frames_rx"], Literal["frames_tx"], Literal["tlvs_discard"], Literal["tlvs_unknown"]]]
        """
        self._set_property("column_names", value)


class RsvpMetricsRequest(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "router_names": {
            "type": list,
            "itemtype": str,
        },
        "column_names": {
            "type": list,
            "enum": [
                "acks_rx",
                "acks_tx",
                "bundle_rx",
                "bundle_tx",
                "egress_p2p_lsps_up",
                "hellos_rx",
                "hellos_tx",
                "ingress_p2p_lsps_configured",
                "ingress_p2p_lsps_up",
                "lsp_flap_count",
                "nacks_rx",
                "nacks_tx",
                "path_errors_rx",
                "path_errors_tx",
                "path_reevaluation_request_tx",
                "path_reoptimizations",
                "path_tears_rx",
                "path_tears_tx",
                "paths_rx",
                "paths_tx",
                "resv_conf_rx",
                "resv_conf_tx",
                "resv_errors_rx",
                "resv_errors_tx",
                "resv_tears_rx",
                "resv_tears_tx",
                "resvs_rx",
                "resvs_tx",
                "srefresh_rx",
                "srefresh_tx",
            ],
            "itemtype": str,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    ACKS_RX = "acks_rx"  # type: str
    ACKS_TX = "acks_tx"  # type: str
    BUNDLE_RX = "bundle_rx"  # type: str
    BUNDLE_TX = "bundle_tx"  # type: str
    EGRESS_P2P_LSPS_UP = "egress_p2p_lsps_up"  # type: str
    HELLOS_RX = "hellos_rx"  # type: str
    HELLOS_TX = "hellos_tx"  # type: str
    INGRESS_P2P_LSPS_CONFIGURED = "ingress_p2p_lsps_configured"  # type: str
    INGRESS_P2P_LSPS_UP = "ingress_p2p_lsps_up"  # type: str
    LSP_FLAP_COUNT = "lsp_flap_count"  # type: str
    NACKS_RX = "nacks_rx"  # type: str
    NACKS_TX = "nacks_tx"  # type: str
    PATH_ERRORS_RX = "path_errors_rx"  # type: str
    PATH_ERRORS_TX = "path_errors_tx"  # type: str
    PATH_REEVALUATION_REQUEST_TX = "path_reevaluation_request_tx"  # type: str
    PATH_REOPTIMIZATIONS = "path_reoptimizations"  # type: str
    PATH_TEARS_RX = "path_tears_rx"  # type: str
    PATH_TEARS_TX = "path_tears_tx"  # type: str
    PATHS_RX = "paths_rx"  # type: str
    PATHS_TX = "paths_tx"  # type: str
    RESV_CONF_RX = "resv_conf_rx"  # type: str
    RESV_CONF_TX = "resv_conf_tx"  # type: str
    RESV_ERRORS_RX = "resv_errors_rx"  # type: str
    RESV_ERRORS_TX = "resv_errors_tx"  # type: str
    RESV_TEARS_RX = "resv_tears_rx"  # type: str
    RESV_TEARS_TX = "resv_tears_tx"  # type: str
    RESVS_RX = "resvs_rx"  # type: str
    RESVS_TX = "resvs_tx"  # type: str
    SREFRESH_RX = "srefresh_rx"  # type: str
    SREFRESH_TX = "srefresh_tx"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, router_names=None, column_names=None):
        super(RsvpMetricsRequest, self).__init__()
        self._parent = parent
        self._set_property("router_names", router_names)
        self._set_property("column_names", column_names)

    def set(self, router_names=None, column_names=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def router_names(self):
        # type: () -> List[str]
        """router_names getter

        The names of RSVP-TE Routers to return results for. An empty list as input will return results for all RSVP-TE routers.. x-constraint:. /components/schemas/Device.Rsvp/properties/name. . x-constraint:. /components/schemas/Device.Rsvp/properties/name.

        Returns: List[str]
        """
        return self._get_property("router_names")

    @router_names.setter
    def router_names(self, value):
        """router_names setter

        The names of RSVP-TE Routers to return results for. An empty list as input will return results for all RSVP-TE routers.. x-constraint:. /components/schemas/Device.Rsvp/properties/name. . x-constraint:. /components/schemas/Device.Rsvp/properties/name.

        value: List[str]
        """
        self._set_property("router_names", value)

    @property
    def column_names(self):
        # type: () -> List[Union[Literal["acks_rx"], Literal["acks_tx"], Literal["bundle_rx"], Literal["bundle_tx"], Literal["egress_p2p_lsps_up"], Literal["hellos_rx"], Literal["hellos_tx"], Literal["ingress_p2p_lsps_configured"], Literal["ingress_p2p_lsps_up"], Literal["lsp_flap_count"], Literal["nacks_rx"], Literal["nacks_tx"], Literal["path_errors_rx"], Literal["path_errors_tx"], Literal["path_reevaluation_request_tx"], Literal["path_reoptimizations"], Literal["path_tears_rx"], Literal["path_tears_tx"], Literal["paths_rx"], Literal["paths_tx"], Literal["resv_conf_rx"], Literal["resv_conf_tx"], Literal["resv_errors_rx"], Literal["resv_errors_tx"], Literal["resv_tears_rx"], Literal["resv_tears_tx"], Literal["resvs_rx"], Literal["resvs_tx"], Literal["srefresh_rx"], Literal["srefresh_tx"]]]
        """column_names getter

        The list of column names that the returned result set will contain. If the input list is empty then all columns will be returned except for any result_groups.

        Returns: List[Union[Literal["acks_rx"], Literal["acks_tx"], Literal["bundle_rx"], Literal["bundle_tx"], Literal["egress_p2p_lsps_up"], Literal["hellos_rx"], Literal["hellos_tx"], Literal["ingress_p2p_lsps_configured"], Literal["ingress_p2p_lsps_up"], Literal["lsp_flap_count"], Literal["nacks_rx"], Literal["nacks_tx"], Literal["path_errors_rx"], Literal["path_errors_tx"], Literal["path_reevaluation_request_tx"], Literal["path_reoptimizations"], Literal["path_tears_rx"], Literal["path_tears_tx"], Literal["paths_rx"], Literal["paths_tx"], Literal["resv_conf_rx"], Literal["resv_conf_tx"], Literal["resv_errors_rx"], Literal["resv_errors_tx"], Literal["resv_tears_rx"], Literal["resv_tears_tx"], Literal["resvs_rx"], Literal["resvs_tx"], Literal["srefresh_rx"], Literal["srefresh_tx"]]]
        """
        return self._get_property("column_names")

    @column_names.setter
    def column_names(self, value):
        """column_names setter

        The list of column names that the returned result set will contain. If the input list is empty then all columns will be returned except for any result_groups.

        value: List[Union[Literal["acks_rx"], Literal["acks_tx"], Literal["bundle_rx"], Literal["bundle_tx"], Literal["egress_p2p_lsps_up"], Literal["hellos_rx"], Literal["hellos_tx"], Literal["ingress_p2p_lsps_configured"], Literal["ingress_p2p_lsps_up"], Literal["lsp_flap_count"], Literal["nacks_rx"], Literal["nacks_tx"], Literal["path_errors_rx"], Literal["path_errors_tx"], Literal["path_reevaluation_request_tx"], Literal["path_reoptimizations"], Literal["path_tears_rx"], Literal["path_tears_tx"], Literal["paths_rx"], Literal["paths_tx"], Literal["resv_conf_rx"], Literal["resv_conf_tx"], Literal["resv_errors_rx"], Literal["resv_errors_tx"], Literal["resv_tears_rx"], Literal["resv_tears_tx"], Literal["resvs_rx"], Literal["resvs_tx"], Literal["srefresh_rx"], Literal["srefresh_tx"]]]
        """
        self._set_property("column_names", value)


class MetricsResponse(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "flow_metrics",
                "port_metrics",
                "bgpv4_metrics",
                "bgpv6_metrics",
                "isis_metrics",
                "lag_metrics",
                "lacp_metrics",
                "lldp_metrics",
                "rsvp_metrics",
            ],
        },
        "port_metrics": {"type": "PortMetricIter"},
        "flow_metrics": {"type": "FlowMetricIter"},
        "bgpv4_metrics": {"type": "Bgpv4MetricIter"},
        "bgpv6_metrics": {"type": "Bgpv6MetricIter"},
        "isis_metrics": {"type": "IsisMetricIter"},
        "lag_metrics": {"type": "LagMetricIter"},
        "lacp_metrics": {"type": "LacpMetricIter"},
        "lldp_metrics": {"type": "LldpMetricIter"},
        "rsvp_metrics": {"type": "RsvpMetricIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "port_metrics",
    }  # type: Dict[str, Union(type)]

    FLOW_METRICS = "flow_metrics"  # type: str
    PORT_METRICS = "port_metrics"  # type: str
    BGPV4_METRICS = "bgpv4_metrics"  # type: str
    BGPV6_METRICS = "bgpv6_metrics"  # type: str
    ISIS_METRICS = "isis_metrics"  # type: str
    LAG_METRICS = "lag_metrics"  # type: str
    LACP_METRICS = "lacp_metrics"  # type: str
    LLDP_METRICS = "lldp_metrics"  # type: str
    RSVP_METRICS = "rsvp_metrics"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None):
        super(MetricsResponse, self).__init__()
        self._parent = parent
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    @property
    def choice(self):
        # type: () -> Union[Literal["bgpv4_metrics"], Literal["bgpv6_metrics"], Literal["flow_metrics"], Literal["isis_metrics"], Literal["lacp_metrics"], Literal["lag_metrics"], Literal["lldp_metrics"], Literal["port_metrics"], Literal["rsvp_metrics"]]
        """choice getter

        TBD

        Returns: Union[Literal["bgpv4_metrics"], Literal["bgpv6_metrics"], Literal["flow_metrics"], Literal["isis_metrics"], Literal["lacp_metrics"], Literal["lag_metrics"], Literal["lldp_metrics"], Literal["port_metrics"], Literal["rsvp_metrics"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["bgpv4_metrics"], Literal["bgpv6_metrics"], Literal["flow_metrics"], Literal["isis_metrics"], Literal["lacp_metrics"], Literal["lag_metrics"], Literal["lldp_metrics"], Literal["port_metrics"], Literal["rsvp_metrics"]]
        """
        self._set_property("choice", value)

    @property
    def port_metrics(self):
        # type: () -> PortMetricIter
        """port_metrics getter

        TBD

        Returns: PortMetricIter
        """
        return self._get_property(
            "port_metrics", PortMetricIter, self._parent, self._choice
        )

    @property
    def flow_metrics(self):
        # type: () -> FlowMetricIter
        """flow_metrics getter

        TBD

        Returns: FlowMetricIter
        """
        return self._get_property(
            "flow_metrics", FlowMetricIter, self._parent, self._choice
        )

    @property
    def bgpv4_metrics(self):
        # type: () -> Bgpv4MetricIter
        """bgpv4_metrics getter

        TBD

        Returns: Bgpv4MetricIter
        """
        return self._get_property(
            "bgpv4_metrics", Bgpv4MetricIter, self._parent, self._choice
        )

    @property
    def bgpv6_metrics(self):
        # type: () -> Bgpv6MetricIter
        """bgpv6_metrics getter

        TBD

        Returns: Bgpv6MetricIter
        """
        return self._get_property(
            "bgpv6_metrics", Bgpv6MetricIter, self._parent, self._choice
        )

    @property
    def isis_metrics(self):
        # type: () -> IsisMetricIter
        """isis_metrics getter

        TBD

        Returns: IsisMetricIter
        """
        return self._get_property(
            "isis_metrics", IsisMetricIter, self._parent, self._choice
        )

    @property
    def lag_metrics(self):
        # type: () -> LagMetricIter
        """lag_metrics getter

        TBD

        Returns: LagMetricIter
        """
        return self._get_property(
            "lag_metrics", LagMetricIter, self._parent, self._choice
        )

    @property
    def lacp_metrics(self):
        # type: () -> LacpMetricIter
        """lacp_metrics getter

        TBD

        Returns: LacpMetricIter
        """
        return self._get_property(
            "lacp_metrics", LacpMetricIter, self._parent, self._choice
        )

    @property
    def lldp_metrics(self):
        # type: () -> LldpMetricIter
        """lldp_metrics getter

        TBD

        Returns: LldpMetricIter
        """
        return self._get_property(
            "lldp_metrics", LldpMetricIter, self._parent, self._choice
        )

    @property
    def rsvp_metrics(self):
        # type: () -> RsvpMetricIter
        """rsvp_metrics getter

        TBD

        Returns: RsvpMetricIter
        """
        return self._get_property(
            "rsvp_metrics", RsvpMetricIter, self._parent, self._choice
        )


class PortMetric(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "location": {"type": str},
        "link": {
            "type": str,
            "enum": [
                "up",
                "down",
            ],
        },
        "capture": {
            "type": str,
            "enum": [
                "started",
                "stopped",
            ],
        },
        "frames_tx": {
            "type": int,
            "format": "uint64",
        },
        "frames_rx": {
            "type": int,
            "format": "uint64",
        },
        "bytes_tx": {
            "type": int,
            "format": "uint64",
        },
        "bytes_rx": {
            "type": int,
            "format": "uint64",
        },
        "frames_tx_rate": {"type": float},
        "frames_rx_rate": {"type": float},
        "bytes_tx_rate": {"type": float},
        "bytes_rx_rate": {"type": float},
        "transmit": {
            "type": str,
            "enum": [
                "started",
                "stopped",
            ],
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    UP = "up"  # type: str
    DOWN = "down"  # type: str

    STARTED = "started"  # type: str
    STOPPED = "stopped"  # type: str

    STARTED = "started"  # type: str
    STOPPED = "stopped"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        name=None,
        location=None,
        link=None,
        capture=None,
        frames_tx=None,
        frames_rx=None,
        bytes_tx=None,
        bytes_rx=None,
        frames_tx_rate=None,
        frames_rx_rate=None,
        bytes_tx_rate=None,
        bytes_rx_rate=None,
        transmit=None,
    ):
        super(PortMetric, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("location", location)
        self._set_property("link", link)
        self._set_property("capture", capture)
        self._set_property("frames_tx", frames_tx)
        self._set_property("frames_rx", frames_rx)
        self._set_property("bytes_tx", bytes_tx)
        self._set_property("bytes_rx", bytes_rx)
        self._set_property("frames_tx_rate", frames_tx_rate)
        self._set_property("frames_rx_rate", frames_rx_rate)
        self._set_property("bytes_tx_rate", bytes_tx_rate)
        self._set_property("bytes_rx_rate", bytes_rx_rate)
        self._set_property("transmit", transmit)

    def set(
        self,
        name=None,
        location=None,
        link=None,
        capture=None,
        frames_tx=None,
        frames_rx=None,
        bytes_tx=None,
        bytes_rx=None,
        frames_tx_rate=None,
        frames_rx_rate=None,
        bytes_tx_rate=None,
        bytes_rx_rate=None,
        transmit=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        The name of configured port. x-constraint:. /components/schemas/Port/properties/name. . x-constraint:. /components/schemas/Port/properties/name.

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        The name of configured port. x-constraint:. /components/schemas/Port/properties/name. . x-constraint:. /components/schemas/Port/properties/name.

        value: str
        """
        self._set_property("name", value)

    @property
    def location(self):
        # type: () -> str
        """location getter

        The state of the connection to the test port location. The format should be the configured port location along with any custom connection state message.

        Returns: str
        """
        return self._get_property("location")

    @location.setter
    def location(self, value):
        """location setter

        The state of the connection to the test port location. The format should be the configured port location along with any custom connection state message.

        value: str
        """
        self._set_property("location", value)

    @property
    def link(self):
        # type: () -> Union[Literal["down"], Literal["up"]]
        """link getter

        The state of the test port link The string can be up, down or custom error message.

        Returns: Union[Literal["down"], Literal["up"]]
        """
        return self._get_property("link")

    @link.setter
    def link(self, value):
        """link setter

        The state of the test port link The string can be up, down or custom error message.

        value: Union[Literal["down"], Literal["up"]]
        """
        self._set_property("link", value)

    @property
    def capture(self):
        # type: () -> Union[Literal["started"], Literal["stopped"]]
        """capture getter

        The state of the test port capture infrastructure. The string can be started, stopped or custom error message.

        Returns: Union[Literal["started"], Literal["stopped"]]
        """
        return self._get_property("capture")

    @capture.setter
    def capture(self, value):
        """capture setter

        The state of the test port capture infrastructure. The string can be started, stopped or custom error message.

        value: Union[Literal["started"], Literal["stopped"]]
        """
        self._set_property("capture", value)

    @property
    def frames_tx(self):
        # type: () -> int
        """frames_tx getter

        The current total number of frames transmitted

        Returns: int
        """
        return self._get_property("frames_tx")

    @frames_tx.setter
    def frames_tx(self, value):
        """frames_tx setter

        The current total number of frames transmitted

        value: int
        """
        self._set_property("frames_tx", value)

    @property
    def frames_rx(self):
        # type: () -> int
        """frames_rx getter

        The current total number of valid frames received

        Returns: int
        """
        return self._get_property("frames_rx")

    @frames_rx.setter
    def frames_rx(self, value):
        """frames_rx setter

        The current total number of valid frames received

        value: int
        """
        self._set_property("frames_rx", value)

    @property
    def bytes_tx(self):
        # type: () -> int
        """bytes_tx getter

        The current total number of bytes transmitted

        Returns: int
        """
        return self._get_property("bytes_tx")

    @bytes_tx.setter
    def bytes_tx(self, value):
        """bytes_tx setter

        The current total number of bytes transmitted

        value: int
        """
        self._set_property("bytes_tx", value)

    @property
    def bytes_rx(self):
        # type: () -> int
        """bytes_rx getter

        The current total number of valid bytes received

        Returns: int
        """
        return self._get_property("bytes_rx")

    @bytes_rx.setter
    def bytes_rx(self, value):
        """bytes_rx setter

        The current total number of valid bytes received

        value: int
        """
        self._set_property("bytes_rx", value)

    @property
    def frames_tx_rate(self):
        # type: () -> float
        """frames_tx_rate getter

        The current rate of frames transmitted

        Returns: float
        """
        return self._get_property("frames_tx_rate")

    @frames_tx_rate.setter
    def frames_tx_rate(self, value):
        """frames_tx_rate setter

        The current rate of frames transmitted

        value: float
        """
        self._set_property("frames_tx_rate", value)

    @property
    def frames_rx_rate(self):
        # type: () -> float
        """frames_rx_rate getter

        The current rate of valid frames received

        Returns: float
        """
        return self._get_property("frames_rx_rate")

    @frames_rx_rate.setter
    def frames_rx_rate(self, value):
        """frames_rx_rate setter

        The current rate of valid frames received

        value: float
        """
        self._set_property("frames_rx_rate", value)

    @property
    def bytes_tx_rate(self):
        # type: () -> float
        """bytes_tx_rate getter

        The current rate of bytes transmitted

        Returns: float
        """
        return self._get_property("bytes_tx_rate")

    @bytes_tx_rate.setter
    def bytes_tx_rate(self, value):
        """bytes_tx_rate setter

        The current rate of bytes transmitted

        value: float
        """
        self._set_property("bytes_tx_rate", value)

    @property
    def bytes_rx_rate(self):
        # type: () -> float
        """bytes_rx_rate getter

        The current rate of bytes received

        Returns: float
        """
        return self._get_property("bytes_rx_rate")

    @bytes_rx_rate.setter
    def bytes_rx_rate(self, value):
        """bytes_rx_rate setter

        The current rate of bytes received

        value: float
        """
        self._set_property("bytes_rx_rate", value)

    @property
    def transmit(self):
        # type: () -> Union[Literal["started"], Literal["stopped"]]
        """transmit getter

        The transmit state of the flow.

        Returns: Union[Literal["started"], Literal["stopped"]]
        """
        return self._get_property("transmit")

    @transmit.setter
    def transmit(self, value):
        """transmit setter

        The transmit state of the flow.

        value: Union[Literal["started"], Literal["stopped"]]
        """
        self._set_property("transmit", value)


class PortMetricIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(PortMetricIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[PortMetric]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> PortMetricIter
        return self._iter()

    def __next__(self):
        # type: () -> PortMetric
        return self._next()

    def next(self):
        # type: () -> PortMetric
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, PortMetric):
            raise Exception("Item is not an instance of PortMetric")

    def metric(
        self,
        name=None,
        location=None,
        link=None,
        capture=None,
        frames_tx=None,
        frames_rx=None,
        bytes_tx=None,
        bytes_rx=None,
        frames_tx_rate=None,
        frames_rx_rate=None,
        bytes_tx_rate=None,
        bytes_rx_rate=None,
        transmit=None,
    ):
        # type: (str,str,Union[Literal["down"], Literal["up"]],Union[Literal["started"], Literal["stopped"]],int,int,int,int,float,float,float,float,Union[Literal["started"], Literal["stopped"]]) -> PortMetricIter
        """Factory method that creates an instance of the PortMetric class

        TBD

        Returns: PortMetricIter
        """
        item = PortMetric(
            parent=self._parent,
            name=name,
            location=location,
            link=link,
            capture=capture,
            frames_tx=frames_tx,
            frames_rx=frames_rx,
            bytes_tx=bytes_tx,
            bytes_rx=bytes_rx,
            frames_tx_rate=frames_tx_rate,
            frames_rx_rate=frames_rx_rate,
            bytes_tx_rate=bytes_tx_rate,
            bytes_rx_rate=bytes_rx_rate,
            transmit=transmit,
        )
        self._add(item)
        return self

    def add(
        self,
        name=None,
        location=None,
        link=None,
        capture=None,
        frames_tx=None,
        frames_rx=None,
        bytes_tx=None,
        bytes_rx=None,
        frames_tx_rate=None,
        frames_rx_rate=None,
        bytes_tx_rate=None,
        bytes_rx_rate=None,
        transmit=None,
    ):
        # type: (str,str,Union[Literal["down"], Literal["up"]],Union[Literal["started"], Literal["stopped"]],int,int,int,int,float,float,float,float,Union[Literal["started"], Literal["stopped"]]) -> PortMetric
        """Add method that creates and returns an instance of the PortMetric class

        TBD

        Returns: PortMetric
        """
        item = PortMetric(
            parent=self._parent,
            name=name,
            location=location,
            link=link,
            capture=capture,
            frames_tx=frames_tx,
            frames_rx=frames_rx,
            bytes_tx=bytes_tx,
            bytes_rx=bytes_rx,
            frames_tx_rate=frames_tx_rate,
            frames_rx_rate=frames_rx_rate,
            bytes_tx_rate=bytes_tx_rate,
            bytes_rx_rate=bytes_rx_rate,
            transmit=transmit,
        )
        self._add(item)
        return item


class FlowMetric(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "port_tx": {"type": str},
        "port_rx": {"type": str},
        "transmit": {
            "type": str,
            "enum": [
                "started",
                "stopped",
                "paused",
            ],
        },
        "frames_tx": {
            "type": int,
            "format": "uint64",
        },
        "frames_rx": {
            "type": int,
            "format": "uint64",
        },
        "bytes_tx": {
            "type": int,
            "format": "uint64",
        },
        "bytes_rx": {
            "type": int,
            "format": "uint64",
        },
        "frames_tx_rate": {"type": float},
        "frames_rx_rate": {"type": float},
        "loss": {"type": float},
        "timestamps": {"type": "MetricTimestamp"},
        "latency": {"type": "MetricLatency"},
        "tagged_metrics": {"type": "FlowTaggedMetricIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    STARTED = "started"  # type: str
    STOPPED = "stopped"  # type: str
    PAUSED = "paused"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        name=None,
        port_tx=None,
        port_rx=None,
        transmit=None,
        frames_tx=None,
        frames_rx=None,
        bytes_tx=None,
        bytes_rx=None,
        frames_tx_rate=None,
        frames_rx_rate=None,
        loss=None,
    ):
        super(FlowMetric, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("port_tx", port_tx)
        self._set_property("port_rx", port_rx)
        self._set_property("transmit", transmit)
        self._set_property("frames_tx", frames_tx)
        self._set_property("frames_rx", frames_rx)
        self._set_property("bytes_tx", bytes_tx)
        self._set_property("bytes_rx", bytes_rx)
        self._set_property("frames_tx_rate", frames_tx_rate)
        self._set_property("frames_rx_rate", frames_rx_rate)
        self._set_property("loss", loss)

    def set(
        self,
        name=None,
        port_tx=None,
        port_rx=None,
        transmit=None,
        frames_tx=None,
        frames_rx=None,
        bytes_tx=None,
        bytes_rx=None,
        frames_tx_rate=None,
        frames_rx_rate=None,
        loss=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        The name of the flow

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        The name of the flow

        value: str
        """
        self._set_property("name", value)

    @property
    def port_tx(self):
        # type: () -> str
        """port_tx getter

        The name of the transmit port

        Returns: str
        """
        return self._get_property("port_tx")

    @port_tx.setter
    def port_tx(self, value):
        """port_tx setter

        The name of the transmit port

        value: str
        """
        self._set_property("port_tx", value)

    @property
    def port_rx(self):
        # type: () -> str
        """port_rx getter

        The name of the receive port

        Returns: str
        """
        return self._get_property("port_rx")

    @port_rx.setter
    def port_rx(self, value):
        """port_rx setter

        The name of the receive port

        value: str
        """
        self._set_property("port_rx", value)

    @property
    def transmit(self):
        # type: () -> Union[Literal["paused"], Literal["started"], Literal["stopped"]]
        """transmit getter

        The transmit state of the flow.

        Returns: Union[Literal["paused"], Literal["started"], Literal["stopped"]]
        """
        return self._get_property("transmit")

    @transmit.setter
    def transmit(self, value):
        """transmit setter

        The transmit state of the flow.

        value: Union[Literal["paused"], Literal["started"], Literal["stopped"]]
        """
        self._set_property("transmit", value)

    @property
    def frames_tx(self):
        # type: () -> int
        """frames_tx getter

        The current total number of frames transmitted

        Returns: int
        """
        return self._get_property("frames_tx")

    @frames_tx.setter
    def frames_tx(self, value):
        """frames_tx setter

        The current total number of frames transmitted

        value: int
        """
        self._set_property("frames_tx", value)

    @property
    def frames_rx(self):
        # type: () -> int
        """frames_rx getter

        The current total number of valid frames received

        Returns: int
        """
        return self._get_property("frames_rx")

    @frames_rx.setter
    def frames_rx(self, value):
        """frames_rx setter

        The current total number of valid frames received

        value: int
        """
        self._set_property("frames_rx", value)

    @property
    def bytes_tx(self):
        # type: () -> int
        """bytes_tx getter

        The current total number of bytes transmitted

        Returns: int
        """
        return self._get_property("bytes_tx")

    @bytes_tx.setter
    def bytes_tx(self, value):
        """bytes_tx setter

        The current total number of bytes transmitted

        value: int
        """
        self._set_property("bytes_tx", value)

    @property
    def bytes_rx(self):
        # type: () -> int
        """bytes_rx getter

        The current total number of bytes received

        Returns: int
        """
        return self._get_property("bytes_rx")

    @bytes_rx.setter
    def bytes_rx(self, value):
        """bytes_rx setter

        The current total number of bytes received

        value: int
        """
        self._set_property("bytes_rx", value)

    @property
    def frames_tx_rate(self):
        # type: () -> float
        """frames_tx_rate getter

        The current rate of frames transmitted

        Returns: float
        """
        return self._get_property("frames_tx_rate")

    @frames_tx_rate.setter
    def frames_tx_rate(self, value):
        """frames_tx_rate setter

        The current rate of frames transmitted

        value: float
        """
        self._set_property("frames_tx_rate", value)

    @property
    def frames_rx_rate(self):
        # type: () -> float
        """frames_rx_rate getter

        The current rate of valid frames received

        Returns: float
        """
        return self._get_property("frames_rx_rate")

    @frames_rx_rate.setter
    def frames_rx_rate(self, value):
        """frames_rx_rate setter

        The current rate of valid frames received

        value: float
        """
        self._set_property("frames_rx_rate", value)

    @property
    def loss(self):
        # type: () -> float
        """loss getter

        The percentage of lost frames

        Returns: float
        """
        return self._get_property("loss")

    @loss.setter
    def loss(self, value):
        """loss setter

        The percentage of lost frames

        value: float
        """
        self._set_property("loss", value)

    @property
    def timestamps(self):
        # type: () -> MetricTimestamp
        """timestamps getter

        The container for timestamp metrics.. The container will be empty if the timestamp has not been configured for. the flow.The container for timestamp metrics.. The container will be empty if the timestamp has not been configured for. the flow.The container for timestamp metrics.. The container will be empty if the timestamp has not been configured for. the flow.

        Returns: MetricTimestamp
        """
        return self._get_property("timestamps", MetricTimestamp)

    @property
    def latency(self):
        # type: () -> MetricLatency
        """latency getter

        The container for latency metrics. The min/max/avg values are dependent on the type of latency measurement mode that is configured.. The container will be empty if the latency has not been configured for. the flow.The container for latency metrics. The min/max/avg values are dependent on the type of latency measurement mode that is configured.. The container will be empty if the latency has not been configured for. the flow.The container for latency metrics. The min/max/avg values are dependent on the type of latency measurement mode that is configured.. The container will be empty if the latency has not been configured for. the flow.

        Returns: MetricLatency
        """
        return self._get_property("latency", MetricLatency)

    @property
    def tagged_metrics(self):
        # type: () -> FlowTaggedMetricIter
        """tagged_metrics getter

        List of metrics corresponding to set of values applicable. for configured metric tags in ingress or egress packet header fields of corresponding flow.. The container is keyed by list of tag-value pairs.

        Returns: FlowTaggedMetricIter
        """
        return self._get_property(
            "tagged_metrics", FlowTaggedMetricIter, self._parent, self._choice
        )


class MetricTimestamp(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "first_timestamp_ns": {
            "type": float,
            "format": "double",
        },
        "last_timestamp_ns": {
            "type": float,
            "format": "double",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, first_timestamp_ns=None, last_timestamp_ns=None):
        super(MetricTimestamp, self).__init__()
        self._parent = parent
        self._set_property("first_timestamp_ns", first_timestamp_ns)
        self._set_property("last_timestamp_ns", last_timestamp_ns)

    def set(self, first_timestamp_ns=None, last_timestamp_ns=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def first_timestamp_ns(self):
        # type: () -> float
        """first_timestamp_ns getter

        First timestamp in nanoseconds

        Returns: float
        """
        return self._get_property("first_timestamp_ns")

    @first_timestamp_ns.setter
    def first_timestamp_ns(self, value):
        """first_timestamp_ns setter

        First timestamp in nanoseconds

        value: float
        """
        self._set_property("first_timestamp_ns", value)

    @property
    def last_timestamp_ns(self):
        # type: () -> float
        """last_timestamp_ns getter

        Last timestamp in nanoseconds

        Returns: float
        """
        return self._get_property("last_timestamp_ns")

    @last_timestamp_ns.setter
    def last_timestamp_ns(self, value):
        """last_timestamp_ns setter

        Last timestamp in nanoseconds

        value: float
        """
        self._set_property("last_timestamp_ns", value)


class MetricLatency(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "minimum_ns": {
            "type": float,
            "format": "double",
        },
        "maximum_ns": {
            "type": float,
            "format": "double",
        },
        "average_ns": {
            "type": float,
            "format": "double",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, minimum_ns=None, maximum_ns=None, average_ns=None):
        super(MetricLatency, self).__init__()
        self._parent = parent
        self._set_property("minimum_ns", minimum_ns)
        self._set_property("maximum_ns", maximum_ns)
        self._set_property("average_ns", average_ns)

    def set(self, minimum_ns=None, maximum_ns=None, average_ns=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def minimum_ns(self):
        # type: () -> float
        """minimum_ns getter

        Minimum latency in nanoseconds

        Returns: float
        """
        return self._get_property("minimum_ns")

    @minimum_ns.setter
    def minimum_ns(self, value):
        """minimum_ns setter

        Minimum latency in nanoseconds

        value: float
        """
        self._set_property("minimum_ns", value)

    @property
    def maximum_ns(self):
        # type: () -> float
        """maximum_ns getter

        Maximum latency in nanoseconds

        Returns: float
        """
        return self._get_property("maximum_ns")

    @maximum_ns.setter
    def maximum_ns(self, value):
        """maximum_ns setter

        Maximum latency in nanoseconds

        value: float
        """
        self._set_property("maximum_ns", value)

    @property
    def average_ns(self):
        # type: () -> float
        """average_ns getter

        Average latency in nanoseconds

        Returns: float
        """
        return self._get_property("average_ns")

    @average_ns.setter
    def average_ns(self, value):
        """average_ns setter

        Average latency in nanoseconds

        value: float
        """
        self._set_property("average_ns", value)


class FlowTaggedMetric(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "tags": {"type": "FlowMetricTagIter"},
        "frames_tx": {
            "type": int,
            "format": "uint64",
        },
        "frames_rx": {
            "type": int,
            "format": "uint64",
        },
        "bytes_tx": {
            "type": int,
            "format": "uint64",
        },
        "bytes_rx": {
            "type": int,
            "format": "uint64",
        },
        "frames_tx_rate": {"type": float},
        "frames_rx_rate": {"type": float},
        "loss": {"type": float},
        "timestamps": {"type": "MetricTimestamp"},
        "latency": {"type": "MetricLatency"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        frames_tx=None,
        frames_rx=None,
        bytes_tx=None,
        bytes_rx=None,
        frames_tx_rate=None,
        frames_rx_rate=None,
        loss=None,
    ):
        super(FlowTaggedMetric, self).__init__()
        self._parent = parent
        self._set_property("frames_tx", frames_tx)
        self._set_property("frames_rx", frames_rx)
        self._set_property("bytes_tx", bytes_tx)
        self._set_property("bytes_rx", bytes_rx)
        self._set_property("frames_tx_rate", frames_tx_rate)
        self._set_property("frames_rx_rate", frames_rx_rate)
        self._set_property("loss", loss)

    def set(
        self,
        frames_tx=None,
        frames_rx=None,
        bytes_tx=None,
        bytes_rx=None,
        frames_tx_rate=None,
        frames_rx_rate=None,
        loss=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def tags(self):
        # type: () -> FlowMetricTagIter
        """tags getter

        List of tag and value pairs

        Returns: FlowMetricTagIter
        """
        return self._get_property("tags", FlowMetricTagIter, self._parent, self._choice)

    @property
    def frames_tx(self):
        # type: () -> int
        """frames_tx getter

        The current total number of frames transmitted

        Returns: int
        """
        return self._get_property("frames_tx")

    @frames_tx.setter
    def frames_tx(self, value):
        """frames_tx setter

        The current total number of frames transmitted

        value: int
        """
        self._set_property("frames_tx", value)

    @property
    def frames_rx(self):
        # type: () -> int
        """frames_rx getter

        The current total number of valid frames received

        Returns: int
        """
        return self._get_property("frames_rx")

    @frames_rx.setter
    def frames_rx(self, value):
        """frames_rx setter

        The current total number of valid frames received

        value: int
        """
        self._set_property("frames_rx", value)

    @property
    def bytes_tx(self):
        # type: () -> int
        """bytes_tx getter

        The current total number of bytes transmitted

        Returns: int
        """
        return self._get_property("bytes_tx")

    @bytes_tx.setter
    def bytes_tx(self, value):
        """bytes_tx setter

        The current total number of bytes transmitted

        value: int
        """
        self._set_property("bytes_tx", value)

    @property
    def bytes_rx(self):
        # type: () -> int
        """bytes_rx getter

        The current total number of bytes received

        Returns: int
        """
        return self._get_property("bytes_rx")

    @bytes_rx.setter
    def bytes_rx(self, value):
        """bytes_rx setter

        The current total number of bytes received

        value: int
        """
        self._set_property("bytes_rx", value)

    @property
    def frames_tx_rate(self):
        # type: () -> float
        """frames_tx_rate getter

        The current rate of frames transmitted

        Returns: float
        """
        return self._get_property("frames_tx_rate")

    @frames_tx_rate.setter
    def frames_tx_rate(self, value):
        """frames_tx_rate setter

        The current rate of frames transmitted

        value: float
        """
        self._set_property("frames_tx_rate", value)

    @property
    def frames_rx_rate(self):
        # type: () -> float
        """frames_rx_rate getter

        The current rate of valid frames received

        Returns: float
        """
        return self._get_property("frames_rx_rate")

    @frames_rx_rate.setter
    def frames_rx_rate(self, value):
        """frames_rx_rate setter

        The current rate of valid frames received

        value: float
        """
        self._set_property("frames_rx_rate", value)

    @property
    def loss(self):
        # type: () -> float
        """loss getter

        The percentage of lost frames

        Returns: float
        """
        return self._get_property("loss")

    @loss.setter
    def loss(self, value):
        """loss setter

        The percentage of lost frames

        value: float
        """
        self._set_property("loss", value)

    @property
    def timestamps(self):
        # type: () -> MetricTimestamp
        """timestamps getter

        The container for timestamp metrics.. The container will be empty if the timestamp has not been configured for. the flow.The container for timestamp metrics.. The container will be empty if the timestamp has not been configured for. the flow.The container for timestamp metrics.. The container will be empty if the timestamp has not been configured for. the flow.

        Returns: MetricTimestamp
        """
        return self._get_property("timestamps", MetricTimestamp)

    @property
    def latency(self):
        # type: () -> MetricLatency
        """latency getter

        The container for latency metrics. The min/max/avg values are dependent on the type of latency measurement mode that is configured.. The container will be empty if the latency has not been configured for. the flow.The container for latency metrics. The min/max/avg values are dependent on the type of latency measurement mode that is configured.. The container will be empty if the latency has not been configured for. the flow.The container for latency metrics. The min/max/avg values are dependent on the type of latency measurement mode that is configured.. The container will be empty if the latency has not been configured for. the flow.

        Returns: MetricLatency
        """
        return self._get_property("latency", MetricLatency)


class FlowMetricTag(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "value": {"type": "FlowMetricTagValue"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, name=None):
        super(FlowMetricTag, self).__init__()
        self._parent = parent
        self._set_property("name", name)

    def set(self, name=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        Name of packet field metric tag

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        Name of packet field metric tag

        value: str
        """
        self._set_property("name", value)

    @property
    def value(self):
        # type: () -> FlowMetricTagValue
        """value getter

        A container for metric tag valueA container for metric tag valueA container for metric tag value

        Returns: FlowMetricTagValue
        """
        return self._get_property("value", FlowMetricTagValue)


class FlowMetricTagValue(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "hex",
                "str",
            ],
        },
        "hex": {
            "type": str,
            "format": "hex",
        },
        "str": {"type": str},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "hex",
    }  # type: Dict[str, Union(type)]

    HEX = "hex"  # type: str
    STR = "str"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None, hex=None, str=None):
        super(FlowMetricTagValue, self).__init__()
        self._parent = parent
        self._set_property("hex", hex)
        self._set_property("str", str)
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    def set(self, hex=None, str=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def choice(self):
        # type: () -> Union[Literal["hex"], Literal["str"]]
        """choice getter

        Available formats for metric tag value

        Returns: Union[Literal["hex"], Literal["str"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        Available formats for metric tag value

        value: Union[Literal["hex"], Literal["str"]]
        """
        self._set_property("choice", value)

    @property
    def hex(self):
        # type: () -> str
        """hex getter

        Value represented in hexadecimal format

        Returns: str
        """
        return self._get_property("hex")

    @hex.setter
    def hex(self, value):
        """hex setter

        Value represented in hexadecimal format

        value: str
        """
        self._set_property("hex", value, "hex")

    @property
    def str(self):
        # type: () -> str
        """str getter

        Value represented in string format

        Returns: str
        """
        return self._get_property("str")

    @str.setter
    def str(self, value):
        """str setter

        Value represented in string format

        value: str
        """
        self._set_property("str", value, "str")


class FlowMetricTagIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(FlowMetricTagIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[FlowMetricTag]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> FlowMetricTagIter
        return self._iter()

    def __next__(self):
        # type: () -> FlowMetricTag
        return self._next()

    def next(self):
        # type: () -> FlowMetricTag
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, FlowMetricTag):
            raise Exception("Item is not an instance of FlowMetricTag")

    def metrictag(self, name=None):
        # type: (str) -> FlowMetricTagIter
        """Factory method that creates an instance of the FlowMetricTag class

        TBD

        Returns: FlowMetricTagIter
        """
        item = FlowMetricTag(parent=self._parent, name=name)
        self._add(item)
        return self

    def add(self, name=None):
        # type: (str) -> FlowMetricTag
        """Add method that creates and returns an instance of the FlowMetricTag class

        TBD

        Returns: FlowMetricTag
        """
        item = FlowMetricTag(parent=self._parent, name=name)
        self._add(item)
        return item


class FlowTaggedMetricIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(FlowTaggedMetricIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[FlowTaggedMetric]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> FlowTaggedMetricIter
        return self._iter()

    def __next__(self):
        # type: () -> FlowTaggedMetric
        return self._next()

    def next(self):
        # type: () -> FlowTaggedMetric
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, FlowTaggedMetric):
            raise Exception("Item is not an instance of FlowTaggedMetric")

    def taggedmetric(
        self,
        frames_tx=None,
        frames_rx=None,
        bytes_tx=None,
        bytes_rx=None,
        frames_tx_rate=None,
        frames_rx_rate=None,
        loss=None,
    ):
        # type: (int,int,int,int,float,float,float) -> FlowTaggedMetricIter
        """Factory method that creates an instance of the FlowTaggedMetric class

        Metrics for each set of values applicable for configured. metric tags in ingress or egress packet header fields of corresponding flow.. The container is keyed by list of tag-value pairs.

        Returns: FlowTaggedMetricIter
        """
        item = FlowTaggedMetric(
            parent=self._parent,
            frames_tx=frames_tx,
            frames_rx=frames_rx,
            bytes_tx=bytes_tx,
            bytes_rx=bytes_rx,
            frames_tx_rate=frames_tx_rate,
            frames_rx_rate=frames_rx_rate,
            loss=loss,
        )
        self._add(item)
        return self

    def add(
        self,
        frames_tx=None,
        frames_rx=None,
        bytes_tx=None,
        bytes_rx=None,
        frames_tx_rate=None,
        frames_rx_rate=None,
        loss=None,
    ):
        # type: (int,int,int,int,float,float,float) -> FlowTaggedMetric
        """Add method that creates and returns an instance of the FlowTaggedMetric class

        Metrics for each set of values applicable for configured. metric tags in ingress or egress packet header fields of corresponding flow.. The container is keyed by list of tag-value pairs.

        Returns: FlowTaggedMetric
        """
        item = FlowTaggedMetric(
            parent=self._parent,
            frames_tx=frames_tx,
            frames_rx=frames_rx,
            bytes_tx=bytes_tx,
            bytes_rx=bytes_rx,
            frames_tx_rate=frames_tx_rate,
            frames_rx_rate=frames_rx_rate,
            loss=loss,
        )
        self._add(item)
        return item


class FlowMetricIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(FlowMetricIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[FlowMetric]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> FlowMetricIter
        return self._iter()

    def __next__(self):
        # type: () -> FlowMetric
        return self._next()

    def next(self):
        # type: () -> FlowMetric
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, FlowMetric):
            raise Exception("Item is not an instance of FlowMetric")

    def metric(
        self,
        name=None,
        port_tx=None,
        port_rx=None,
        transmit=None,
        frames_tx=None,
        frames_rx=None,
        bytes_tx=None,
        bytes_rx=None,
        frames_tx_rate=None,
        frames_rx_rate=None,
        loss=None,
    ):
        # type: (str,str,str,Union[Literal["paused"], Literal["started"], Literal["stopped"]],int,int,int,int,float,float,float) -> FlowMetricIter
        """Factory method that creates an instance of the FlowMetric class

        A container for flow metrics.. The container is keyed by the name, port_tx and port_rx.

        Returns: FlowMetricIter
        """
        item = FlowMetric(
            parent=self._parent,
            name=name,
            port_tx=port_tx,
            port_rx=port_rx,
            transmit=transmit,
            frames_tx=frames_tx,
            frames_rx=frames_rx,
            bytes_tx=bytes_tx,
            bytes_rx=bytes_rx,
            frames_tx_rate=frames_tx_rate,
            frames_rx_rate=frames_rx_rate,
            loss=loss,
        )
        self._add(item)
        return self

    def add(
        self,
        name=None,
        port_tx=None,
        port_rx=None,
        transmit=None,
        frames_tx=None,
        frames_rx=None,
        bytes_tx=None,
        bytes_rx=None,
        frames_tx_rate=None,
        frames_rx_rate=None,
        loss=None,
    ):
        # type: (str,str,str,Union[Literal["paused"], Literal["started"], Literal["stopped"]],int,int,int,int,float,float,float) -> FlowMetric
        """Add method that creates and returns an instance of the FlowMetric class

        A container for flow metrics.. The container is keyed by the name, port_tx and port_rx.

        Returns: FlowMetric
        """
        item = FlowMetric(
            parent=self._parent,
            name=name,
            port_tx=port_tx,
            port_rx=port_rx,
            transmit=transmit,
            frames_tx=frames_tx,
            frames_rx=frames_rx,
            bytes_tx=bytes_tx,
            bytes_rx=bytes_rx,
            frames_tx_rate=frames_tx_rate,
            frames_rx_rate=frames_rx_rate,
            loss=loss,
        )
        self._add(item)
        return item


class Bgpv4Metric(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "session_state": {
            "type": str,
            "enum": [
                "up",
                "down",
            ],
        },
        "session_flap_count": {
            "type": int,
            "format": "uint64",
        },
        "routes_advertised": {
            "type": int,
            "format": "uint64",
        },
        "routes_received": {
            "type": int,
            "format": "uint64",
        },
        "route_withdraws_sent": {
            "type": int,
            "format": "uint64",
        },
        "route_withdraws_received": {
            "type": int,
            "format": "uint64",
        },
        "updates_sent": {
            "type": int,
            "format": "uint64",
        },
        "updates_received": {
            "type": int,
            "format": "uint64",
        },
        "opens_sent": {
            "type": int,
            "format": "uint64",
        },
        "opens_received": {
            "type": int,
            "format": "uint64",
        },
        "keepalives_sent": {
            "type": int,
            "format": "uint64",
        },
        "keepalives_received": {
            "type": int,
            "format": "uint64",
        },
        "notifications_sent": {
            "type": int,
            "format": "uint64",
        },
        "notifications_received": {
            "type": int,
            "format": "uint64",
        },
        "fsm_state": {
            "type": str,
            "enum": [
                "idle",
                "connect",
                "active",
                "opensent",
                "openconfirm",
                "established",
            ],
        },
        "end_of_rib_received": {
            "type": int,
            "format": "uint64",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    UP = "up"  # type: str
    DOWN = "down"  # type: str

    IDLE = "idle"  # type: str
    CONNECT = "connect"  # type: str
    ACTIVE = "active"  # type: str
    OPENSENT = "opensent"  # type: str
    OPENCONFIRM = "openconfirm"  # type: str
    ESTABLISHED = "established"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        name=None,
        session_state=None,
        session_flap_count=None,
        routes_advertised=None,
        routes_received=None,
        route_withdraws_sent=None,
        route_withdraws_received=None,
        updates_sent=None,
        updates_received=None,
        opens_sent=None,
        opens_received=None,
        keepalives_sent=None,
        keepalives_received=None,
        notifications_sent=None,
        notifications_received=None,
        fsm_state=None,
        end_of_rib_received=None,
    ):
        super(Bgpv4Metric, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("session_state", session_state)
        self._set_property("session_flap_count", session_flap_count)
        self._set_property("routes_advertised", routes_advertised)
        self._set_property("routes_received", routes_received)
        self._set_property("route_withdraws_sent", route_withdraws_sent)
        self._set_property("route_withdraws_received", route_withdraws_received)
        self._set_property("updates_sent", updates_sent)
        self._set_property("updates_received", updates_received)
        self._set_property("opens_sent", opens_sent)
        self._set_property("opens_received", opens_received)
        self._set_property("keepalives_sent", keepalives_sent)
        self._set_property("keepalives_received", keepalives_received)
        self._set_property("notifications_sent", notifications_sent)
        self._set_property("notifications_received", notifications_received)
        self._set_property("fsm_state", fsm_state)
        self._set_property("end_of_rib_received", end_of_rib_received)

    def set(
        self,
        name=None,
        session_state=None,
        session_flap_count=None,
        routes_advertised=None,
        routes_received=None,
        route_withdraws_sent=None,
        route_withdraws_received=None,
        updates_sent=None,
        updates_received=None,
        opens_sent=None,
        opens_received=None,
        keepalives_sent=None,
        keepalives_received=None,
        notifications_sent=None,
        notifications_received=None,
        fsm_state=None,
        end_of_rib_received=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        The name of configured BGPv4 peer.

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        The name of configured BGPv4 peer.

        value: str
        """
        self._set_property("name", value)

    @property
    def session_state(self):
        # type: () -> Union[Literal["down"], Literal["up"]]
        """session_state getter

        Session state as up or down. Up refers to an Established state and Down refers to any other state.

        Returns: Union[Literal["down"], Literal["up"]]
        """
        return self._get_property("session_state")

    @session_state.setter
    def session_state(self, value):
        """session_state setter

        Session state as up or down. Up refers to an Established state and Down refers to any other state.

        value: Union[Literal["down"], Literal["up"]]
        """
        self._set_property("session_state", value)

    @property
    def session_flap_count(self):
        # type: () -> int
        """session_flap_count getter

        Number of times the session went from Up to Down state.

        Returns: int
        """
        return self._get_property("session_flap_count")

    @session_flap_count.setter
    def session_flap_count(self, value):
        """session_flap_count setter

        Number of times the session went from Up to Down state.

        value: int
        """
        self._set_property("session_flap_count", value)

    @property
    def routes_advertised(self):
        # type: () -> int
        """routes_advertised getter

        Number of routes advertised.

        Returns: int
        """
        return self._get_property("routes_advertised")

    @routes_advertised.setter
    def routes_advertised(self, value):
        """routes_advertised setter

        Number of routes advertised.

        value: int
        """
        self._set_property("routes_advertised", value)

    @property
    def routes_received(self):
        # type: () -> int
        """routes_received getter

        Number of routes received.

        Returns: int
        """
        return self._get_property("routes_received")

    @routes_received.setter
    def routes_received(self, value):
        """routes_received setter

        Number of routes received.

        value: int
        """
        self._set_property("routes_received", value)

    @property
    def route_withdraws_sent(self):
        # type: () -> int
        """route_withdraws_sent getter

        Number of route withdraws sent.

        Returns: int
        """
        return self._get_property("route_withdraws_sent")

    @route_withdraws_sent.setter
    def route_withdraws_sent(self, value):
        """route_withdraws_sent setter

        Number of route withdraws sent.

        value: int
        """
        self._set_property("route_withdraws_sent", value)

    @property
    def route_withdraws_received(self):
        # type: () -> int
        """route_withdraws_received getter

        Number of route withdraws received.

        Returns: int
        """
        return self._get_property("route_withdraws_received")

    @route_withdraws_received.setter
    def route_withdraws_received(self, value):
        """route_withdraws_received setter

        Number of route withdraws received.

        value: int
        """
        self._set_property("route_withdraws_received", value)

    @property
    def updates_sent(self):
        # type: () -> int
        """updates_sent getter

        Number of Update messages sent.

        Returns: int
        """
        return self._get_property("updates_sent")

    @updates_sent.setter
    def updates_sent(self, value):
        """updates_sent setter

        Number of Update messages sent.

        value: int
        """
        self._set_property("updates_sent", value)

    @property
    def updates_received(self):
        # type: () -> int
        """updates_received getter

        Number of Update messages received.

        Returns: int
        """
        return self._get_property("updates_received")

    @updates_received.setter
    def updates_received(self, value):
        """updates_received setter

        Number of Update messages received.

        value: int
        """
        self._set_property("updates_received", value)

    @property
    def opens_sent(self):
        # type: () -> int
        """opens_sent getter

        Number of Open messages sent.

        Returns: int
        """
        return self._get_property("opens_sent")

    @opens_sent.setter
    def opens_sent(self, value):
        """opens_sent setter

        Number of Open messages sent.

        value: int
        """
        self._set_property("opens_sent", value)

    @property
    def opens_received(self):
        # type: () -> int
        """opens_received getter

        Number of Open messages received.

        Returns: int
        """
        return self._get_property("opens_received")

    @opens_received.setter
    def opens_received(self, value):
        """opens_received setter

        Number of Open messages received.

        value: int
        """
        self._set_property("opens_received", value)

    @property
    def keepalives_sent(self):
        # type: () -> int
        """keepalives_sent getter

        Number of Keepalive messages sent.

        Returns: int
        """
        return self._get_property("keepalives_sent")

    @keepalives_sent.setter
    def keepalives_sent(self, value):
        """keepalives_sent setter

        Number of Keepalive messages sent.

        value: int
        """
        self._set_property("keepalives_sent", value)

    @property
    def keepalives_received(self):
        # type: () -> int
        """keepalives_received getter

        Number of Keepalive messages received.

        Returns: int
        """
        return self._get_property("keepalives_received")

    @keepalives_received.setter
    def keepalives_received(self, value):
        """keepalives_received setter

        Number of Keepalive messages received.

        value: int
        """
        self._set_property("keepalives_received", value)

    @property
    def notifications_sent(self):
        # type: () -> int
        """notifications_sent getter

        Number of Notification messages sent.

        Returns: int
        """
        return self._get_property("notifications_sent")

    @notifications_sent.setter
    def notifications_sent(self, value):
        """notifications_sent setter

        Number of Notification messages sent.

        value: int
        """
        self._set_property("notifications_sent", value)

    @property
    def notifications_received(self):
        # type: () -> int
        """notifications_received getter

        Number of Notification messages received.

        Returns: int
        """
        return self._get_property("notifications_received")

    @notifications_received.setter
    def notifications_received(self, value):
        """notifications_received setter

        Number of Notification messages received.

        value: int
        """
        self._set_property("notifications_received", value)

    @property
    def fsm_state(self):
        # type: () -> Union[Literal["active"], Literal["connect"], Literal["established"], Literal["idle"], Literal["openconfirm"], Literal["opensent"]]
        """fsm_state getter

        BGP peer FSM (Finite State Machine) state as Idle, Connect, Active, OpenSent, OpenConfirm and Established. In all the states except Established the BGP session is down. Idle refers to the Idle state of the FSM. Connect refers to the state where the session is waiting for the underlying transport session to be established. Active refers to the state where the session is awaiting for connection from the remote peer. OpenSent refers to the state where the session is in the process of being established. The local system has sent an OPEN message. OpenConfirm refers to the state where the session is in the process of being established. The local system has sent and received an OPEN message and is awaiting NOTIFICATION or KEEPALIVE message from remote peer. Established refers to the state where the BGP session with the peer is established.

        Returns: Union[Literal["active"], Literal["connect"], Literal["established"], Literal["idle"], Literal["openconfirm"], Literal["opensent"]]
        """
        return self._get_property("fsm_state")

    @fsm_state.setter
    def fsm_state(self, value):
        """fsm_state setter

        BGP peer FSM (Finite State Machine) state as Idle, Connect, Active, OpenSent, OpenConfirm and Established. In all the states except Established the BGP session is down. Idle refers to the Idle state of the FSM. Connect refers to the state where the session is waiting for the underlying transport session to be established. Active refers to the state where the session is awaiting for connection from the remote peer. OpenSent refers to the state where the session is in the process of being established. The local system has sent an OPEN message. OpenConfirm refers to the state where the session is in the process of being established. The local system has sent and received an OPEN message and is awaiting NOTIFICATION or KEEPALIVE message from remote peer. Established refers to the state where the BGP session with the peer is established.

        value: Union[Literal["active"], Literal["connect"], Literal["established"], Literal["idle"], Literal["openconfirm"], Literal["opensent"]]
        """
        self._set_property("fsm_state", value)

    @property
    def end_of_rib_received(self):
        # type: () -> int
        """end_of_rib_received getter

        Number of End-of-RIB markers received indicating the completion of the initial routing update for particular <AFI, SAFI> address family after the session is established. For the IPv4 unicast address family, the End-of-RIB marker is an UPDATE message with the minimum length. For any other address family, it is an UPDATE message that contains only the MP_UNREACH_NLRI attribute with no withdrawn routes for that <AFI, SAFI>.

        Returns: int
        """
        return self._get_property("end_of_rib_received")

    @end_of_rib_received.setter
    def end_of_rib_received(self, value):
        """end_of_rib_received setter

        Number of End-of-RIB markers received indicating the completion of the initial routing update for particular <AFI, SAFI> address family after the session is established. For the IPv4 unicast address family, the End-of-RIB marker is an UPDATE message with the minimum length. For any other address family, it is an UPDATE message that contains only the MP_UNREACH_NLRI attribute with no withdrawn routes for that <AFI, SAFI>.

        value: int
        """
        self._set_property("end_of_rib_received", value)


class Bgpv4MetricIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(Bgpv4MetricIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[Bgpv4Metric]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> Bgpv4MetricIter
        return self._iter()

    def __next__(self):
        # type: () -> Bgpv4Metric
        return self._next()

    def next(self):
        # type: () -> Bgpv4Metric
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, Bgpv4Metric):
            raise Exception("Item is not an instance of Bgpv4Metric")

    def metric(
        self,
        name=None,
        session_state=None,
        session_flap_count=None,
        routes_advertised=None,
        routes_received=None,
        route_withdraws_sent=None,
        route_withdraws_received=None,
        updates_sent=None,
        updates_received=None,
        opens_sent=None,
        opens_received=None,
        keepalives_sent=None,
        keepalives_received=None,
        notifications_sent=None,
        notifications_received=None,
        fsm_state=None,
        end_of_rib_received=None,
    ):
        # type: (str,Union[Literal["down"], Literal["up"]],int,int,int,int,int,int,int,int,int,int,int,int,int,Union[Literal["active"], Literal["connect"], Literal["established"], Literal["idle"], Literal["openconfirm"], Literal["opensent"]],int) -> Bgpv4MetricIter
        """Factory method that creates an instance of the Bgpv4Metric class

        BGPv4 per peer statistics information.

        Returns: Bgpv4MetricIter
        """
        item = Bgpv4Metric(
            parent=self._parent,
            name=name,
            session_state=session_state,
            session_flap_count=session_flap_count,
            routes_advertised=routes_advertised,
            routes_received=routes_received,
            route_withdraws_sent=route_withdraws_sent,
            route_withdraws_received=route_withdraws_received,
            updates_sent=updates_sent,
            updates_received=updates_received,
            opens_sent=opens_sent,
            opens_received=opens_received,
            keepalives_sent=keepalives_sent,
            keepalives_received=keepalives_received,
            notifications_sent=notifications_sent,
            notifications_received=notifications_received,
            fsm_state=fsm_state,
            end_of_rib_received=end_of_rib_received,
        )
        self._add(item)
        return self

    def add(
        self,
        name=None,
        session_state=None,
        session_flap_count=None,
        routes_advertised=None,
        routes_received=None,
        route_withdraws_sent=None,
        route_withdraws_received=None,
        updates_sent=None,
        updates_received=None,
        opens_sent=None,
        opens_received=None,
        keepalives_sent=None,
        keepalives_received=None,
        notifications_sent=None,
        notifications_received=None,
        fsm_state=None,
        end_of_rib_received=None,
    ):
        # type: (str,Union[Literal["down"], Literal["up"]],int,int,int,int,int,int,int,int,int,int,int,int,int,Union[Literal["active"], Literal["connect"], Literal["established"], Literal["idle"], Literal["openconfirm"], Literal["opensent"]],int) -> Bgpv4Metric
        """Add method that creates and returns an instance of the Bgpv4Metric class

        BGPv4 per peer statistics information.

        Returns: Bgpv4Metric
        """
        item = Bgpv4Metric(
            parent=self._parent,
            name=name,
            session_state=session_state,
            session_flap_count=session_flap_count,
            routes_advertised=routes_advertised,
            routes_received=routes_received,
            route_withdraws_sent=route_withdraws_sent,
            route_withdraws_received=route_withdraws_received,
            updates_sent=updates_sent,
            updates_received=updates_received,
            opens_sent=opens_sent,
            opens_received=opens_received,
            keepalives_sent=keepalives_sent,
            keepalives_received=keepalives_received,
            notifications_sent=notifications_sent,
            notifications_received=notifications_received,
            fsm_state=fsm_state,
            end_of_rib_received=end_of_rib_received,
        )
        self._add(item)
        return item


class Bgpv6Metric(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "session_state": {
            "type": str,
            "enum": [
                "up",
                "down",
            ],
        },
        "session_flap_count": {
            "type": int,
            "format": "uint64",
        },
        "routes_advertised": {
            "type": int,
            "format": "uint64",
        },
        "routes_received": {
            "type": int,
            "format": "uint64",
        },
        "route_withdraws_sent": {
            "type": int,
            "format": "uint64",
        },
        "route_withdraws_received": {
            "type": int,
            "format": "uint64",
        },
        "updates_sent": {
            "type": int,
            "format": "uint64",
        },
        "updates_received": {
            "type": int,
            "format": "uint64",
        },
        "opens_sent": {
            "type": int,
            "format": "uint64",
        },
        "opens_received": {
            "type": int,
            "format": "uint64",
        },
        "keepalives_sent": {
            "type": int,
            "format": "uint64",
        },
        "keepalives_received": {
            "type": int,
            "format": "uint64",
        },
        "notifications_sent": {
            "type": int,
            "format": "uint64",
        },
        "notifications_received": {
            "type": int,
            "format": "uint64",
        },
        "fsm_state": {
            "type": str,
            "enum": [
                "idle",
                "connect",
                "active",
                "opensent",
                "openconfirm",
                "established",
            ],
        },
        "end_of_rib_received": {
            "type": int,
            "format": "uint64",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    UP = "up"  # type: str
    DOWN = "down"  # type: str

    IDLE = "idle"  # type: str
    CONNECT = "connect"  # type: str
    ACTIVE = "active"  # type: str
    OPENSENT = "opensent"  # type: str
    OPENCONFIRM = "openconfirm"  # type: str
    ESTABLISHED = "established"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        name=None,
        session_state=None,
        session_flap_count=None,
        routes_advertised=None,
        routes_received=None,
        route_withdraws_sent=None,
        route_withdraws_received=None,
        updates_sent=None,
        updates_received=None,
        opens_sent=None,
        opens_received=None,
        keepalives_sent=None,
        keepalives_received=None,
        notifications_sent=None,
        notifications_received=None,
        fsm_state=None,
        end_of_rib_received=None,
    ):
        super(Bgpv6Metric, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("session_state", session_state)
        self._set_property("session_flap_count", session_flap_count)
        self._set_property("routes_advertised", routes_advertised)
        self._set_property("routes_received", routes_received)
        self._set_property("route_withdraws_sent", route_withdraws_sent)
        self._set_property("route_withdraws_received", route_withdraws_received)
        self._set_property("updates_sent", updates_sent)
        self._set_property("updates_received", updates_received)
        self._set_property("opens_sent", opens_sent)
        self._set_property("opens_received", opens_received)
        self._set_property("keepalives_sent", keepalives_sent)
        self._set_property("keepalives_received", keepalives_received)
        self._set_property("notifications_sent", notifications_sent)
        self._set_property("notifications_received", notifications_received)
        self._set_property("fsm_state", fsm_state)
        self._set_property("end_of_rib_received", end_of_rib_received)

    def set(
        self,
        name=None,
        session_state=None,
        session_flap_count=None,
        routes_advertised=None,
        routes_received=None,
        route_withdraws_sent=None,
        route_withdraws_received=None,
        updates_sent=None,
        updates_received=None,
        opens_sent=None,
        opens_received=None,
        keepalives_sent=None,
        keepalives_received=None,
        notifications_sent=None,
        notifications_received=None,
        fsm_state=None,
        end_of_rib_received=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        The name of configured BGPv6 peer.

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        The name of configured BGPv6 peer.

        value: str
        """
        self._set_property("name", value)

    @property
    def session_state(self):
        # type: () -> Union[Literal["down"], Literal["up"]]
        """session_state getter

        Session state as up or down. Up refers to an Established state and Down refers to any other state.

        Returns: Union[Literal["down"], Literal["up"]]
        """
        return self._get_property("session_state")

    @session_state.setter
    def session_state(self, value):
        """session_state setter

        Session state as up or down. Up refers to an Established state and Down refers to any other state.

        value: Union[Literal["down"], Literal["up"]]
        """
        self._set_property("session_state", value)

    @property
    def session_flap_count(self):
        # type: () -> int
        """session_flap_count getter

        Number of times the session went from Up to Down state.

        Returns: int
        """
        return self._get_property("session_flap_count")

    @session_flap_count.setter
    def session_flap_count(self, value):
        """session_flap_count setter

        Number of times the session went from Up to Down state.

        value: int
        """
        self._set_property("session_flap_count", value)

    @property
    def routes_advertised(self):
        # type: () -> int
        """routes_advertised getter

        Number of routes advertised.

        Returns: int
        """
        return self._get_property("routes_advertised")

    @routes_advertised.setter
    def routes_advertised(self, value):
        """routes_advertised setter

        Number of routes advertised.

        value: int
        """
        self._set_property("routes_advertised", value)

    @property
    def routes_received(self):
        # type: () -> int
        """routes_received getter

        Number of routes received.

        Returns: int
        """
        return self._get_property("routes_received")

    @routes_received.setter
    def routes_received(self, value):
        """routes_received setter

        Number of routes received.

        value: int
        """
        self._set_property("routes_received", value)

    @property
    def route_withdraws_sent(self):
        # type: () -> int
        """route_withdraws_sent getter

        Number of route withdraws sent.

        Returns: int
        """
        return self._get_property("route_withdraws_sent")

    @route_withdraws_sent.setter
    def route_withdraws_sent(self, value):
        """route_withdraws_sent setter

        Number of route withdraws sent.

        value: int
        """
        self._set_property("route_withdraws_sent", value)

    @property
    def route_withdraws_received(self):
        # type: () -> int
        """route_withdraws_received getter

        Number of route withdraws received.

        Returns: int
        """
        return self._get_property("route_withdraws_received")

    @route_withdraws_received.setter
    def route_withdraws_received(self, value):
        """route_withdraws_received setter

        Number of route withdraws received.

        value: int
        """
        self._set_property("route_withdraws_received", value)

    @property
    def updates_sent(self):
        # type: () -> int
        """updates_sent getter

        Number of Update messages sent.

        Returns: int
        """
        return self._get_property("updates_sent")

    @updates_sent.setter
    def updates_sent(self, value):
        """updates_sent setter

        Number of Update messages sent.

        value: int
        """
        self._set_property("updates_sent", value)

    @property
    def updates_received(self):
        # type: () -> int
        """updates_received getter

        Number of Update messages received.

        Returns: int
        """
        return self._get_property("updates_received")

    @updates_received.setter
    def updates_received(self, value):
        """updates_received setter

        Number of Update messages received.

        value: int
        """
        self._set_property("updates_received", value)

    @property
    def opens_sent(self):
        # type: () -> int
        """opens_sent getter

        Number of Open messages sent.

        Returns: int
        """
        return self._get_property("opens_sent")

    @opens_sent.setter
    def opens_sent(self, value):
        """opens_sent setter

        Number of Open messages sent.

        value: int
        """
        self._set_property("opens_sent", value)

    @property
    def opens_received(self):
        # type: () -> int
        """opens_received getter

        Number of Open messages received.

        Returns: int
        """
        return self._get_property("opens_received")

    @opens_received.setter
    def opens_received(self, value):
        """opens_received setter

        Number of Open messages received.

        value: int
        """
        self._set_property("opens_received", value)

    @property
    def keepalives_sent(self):
        # type: () -> int
        """keepalives_sent getter

        Number of Keepalive messages sent.

        Returns: int
        """
        return self._get_property("keepalives_sent")

    @keepalives_sent.setter
    def keepalives_sent(self, value):
        """keepalives_sent setter

        Number of Keepalive messages sent.

        value: int
        """
        self._set_property("keepalives_sent", value)

    @property
    def keepalives_received(self):
        # type: () -> int
        """keepalives_received getter

        Number of Keepalive messages received.

        Returns: int
        """
        return self._get_property("keepalives_received")

    @keepalives_received.setter
    def keepalives_received(self, value):
        """keepalives_received setter

        Number of Keepalive messages received.

        value: int
        """
        self._set_property("keepalives_received", value)

    @property
    def notifications_sent(self):
        # type: () -> int
        """notifications_sent getter

        Number of Notification messages sent.

        Returns: int
        """
        return self._get_property("notifications_sent")

    @notifications_sent.setter
    def notifications_sent(self, value):
        """notifications_sent setter

        Number of Notification messages sent.

        value: int
        """
        self._set_property("notifications_sent", value)

    @property
    def notifications_received(self):
        # type: () -> int
        """notifications_received getter

        Number of Notification messages received.

        Returns: int
        """
        return self._get_property("notifications_received")

    @notifications_received.setter
    def notifications_received(self, value):
        """notifications_received setter

        Number of Notification messages received.

        value: int
        """
        self._set_property("notifications_received", value)

    @property
    def fsm_state(self):
        # type: () -> Union[Literal["active"], Literal["connect"], Literal["established"], Literal["idle"], Literal["openconfirm"], Literal["opensent"]]
        """fsm_state getter

        BGP peer FSM (Finite State Machine) state as Idle, Connect, Active, OpenSent, OpenConfirm and Established. In all the states except Established the BGP session is down. Idle refers to the Idle state of the FSM. Connect refers to the state where the session is waiting for the underlying transport session to be established. Active refers to the state where the session is awaiting for connection from the remote peer. OpenSent refers to the state where the session is in the process of being established. The local system has sent an OPEN message. OpenConfirm refers to the state where the session is in the process of being established. The local system has sent and received an OPEN message and is awaiting NOTIFICATION or KEEPALIVE message from remote peer. Established refers to the state where the BGP session with the peer is established.

        Returns: Union[Literal["active"], Literal["connect"], Literal["established"], Literal["idle"], Literal["openconfirm"], Literal["opensent"]]
        """
        return self._get_property("fsm_state")

    @fsm_state.setter
    def fsm_state(self, value):
        """fsm_state setter

        BGP peer FSM (Finite State Machine) state as Idle, Connect, Active, OpenSent, OpenConfirm and Established. In all the states except Established the BGP session is down. Idle refers to the Idle state of the FSM. Connect refers to the state where the session is waiting for the underlying transport session to be established. Active refers to the state where the session is awaiting for connection from the remote peer. OpenSent refers to the state where the session is in the process of being established. The local system has sent an OPEN message. OpenConfirm refers to the state where the session is in the process of being established. The local system has sent and received an OPEN message and is awaiting NOTIFICATION or KEEPALIVE message from remote peer. Established refers to the state where the BGP session with the peer is established.

        value: Union[Literal["active"], Literal["connect"], Literal["established"], Literal["idle"], Literal["openconfirm"], Literal["opensent"]]
        """
        self._set_property("fsm_state", value)

    @property
    def end_of_rib_received(self):
        # type: () -> int
        """end_of_rib_received getter

        Number of End-of-RIB markers received indicating the completion of the initial routing update for particular <AFI, SAFI> address family after the session is established. For the IPv4 unicast address family, the End-of-RIB marker is an UPDATE message with the minimum length. For any other address family, it is an UPDATE message that contains only the MP_UNREACH_NLRI attribute with no withdrawn routes for that <AFI, SAFI>.

        Returns: int
        """
        return self._get_property("end_of_rib_received")

    @end_of_rib_received.setter
    def end_of_rib_received(self, value):
        """end_of_rib_received setter

        Number of End-of-RIB markers received indicating the completion of the initial routing update for particular <AFI, SAFI> address family after the session is established. For the IPv4 unicast address family, the End-of-RIB marker is an UPDATE message with the minimum length. For any other address family, it is an UPDATE message that contains only the MP_UNREACH_NLRI attribute with no withdrawn routes for that <AFI, SAFI>.

        value: int
        """
        self._set_property("end_of_rib_received", value)


class Bgpv6MetricIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(Bgpv6MetricIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[Bgpv6Metric]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> Bgpv6MetricIter
        return self._iter()

    def __next__(self):
        # type: () -> Bgpv6Metric
        return self._next()

    def next(self):
        # type: () -> Bgpv6Metric
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, Bgpv6Metric):
            raise Exception("Item is not an instance of Bgpv6Metric")

    def metric(
        self,
        name=None,
        session_state=None,
        session_flap_count=None,
        routes_advertised=None,
        routes_received=None,
        route_withdraws_sent=None,
        route_withdraws_received=None,
        updates_sent=None,
        updates_received=None,
        opens_sent=None,
        opens_received=None,
        keepalives_sent=None,
        keepalives_received=None,
        notifications_sent=None,
        notifications_received=None,
        fsm_state=None,
        end_of_rib_received=None,
    ):
        # type: (str,Union[Literal["down"], Literal["up"]],int,int,int,int,int,int,int,int,int,int,int,int,int,Union[Literal["active"], Literal["connect"], Literal["established"], Literal["idle"], Literal["openconfirm"], Literal["opensent"]],int) -> Bgpv6MetricIter
        """Factory method that creates an instance of the Bgpv6Metric class

        BGPv6 per peer statistics information.

        Returns: Bgpv6MetricIter
        """
        item = Bgpv6Metric(
            parent=self._parent,
            name=name,
            session_state=session_state,
            session_flap_count=session_flap_count,
            routes_advertised=routes_advertised,
            routes_received=routes_received,
            route_withdraws_sent=route_withdraws_sent,
            route_withdraws_received=route_withdraws_received,
            updates_sent=updates_sent,
            updates_received=updates_received,
            opens_sent=opens_sent,
            opens_received=opens_received,
            keepalives_sent=keepalives_sent,
            keepalives_received=keepalives_received,
            notifications_sent=notifications_sent,
            notifications_received=notifications_received,
            fsm_state=fsm_state,
            end_of_rib_received=end_of_rib_received,
        )
        self._add(item)
        return self

    def add(
        self,
        name=None,
        session_state=None,
        session_flap_count=None,
        routes_advertised=None,
        routes_received=None,
        route_withdraws_sent=None,
        route_withdraws_received=None,
        updates_sent=None,
        updates_received=None,
        opens_sent=None,
        opens_received=None,
        keepalives_sent=None,
        keepalives_received=None,
        notifications_sent=None,
        notifications_received=None,
        fsm_state=None,
        end_of_rib_received=None,
    ):
        # type: (str,Union[Literal["down"], Literal["up"]],int,int,int,int,int,int,int,int,int,int,int,int,int,Union[Literal["active"], Literal["connect"], Literal["established"], Literal["idle"], Literal["openconfirm"], Literal["opensent"]],int) -> Bgpv6Metric
        """Add method that creates and returns an instance of the Bgpv6Metric class

        BGPv6 per peer statistics information.

        Returns: Bgpv6Metric
        """
        item = Bgpv6Metric(
            parent=self._parent,
            name=name,
            session_state=session_state,
            session_flap_count=session_flap_count,
            routes_advertised=routes_advertised,
            routes_received=routes_received,
            route_withdraws_sent=route_withdraws_sent,
            route_withdraws_received=route_withdraws_received,
            updates_sent=updates_sent,
            updates_received=updates_received,
            opens_sent=opens_sent,
            opens_received=opens_received,
            keepalives_sent=keepalives_sent,
            keepalives_received=keepalives_received,
            notifications_sent=notifications_sent,
            notifications_received=notifications_received,
            fsm_state=fsm_state,
            end_of_rib_received=end_of_rib_received,
        )
        self._add(item)
        return item


class IsisMetric(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "l1_sessions_up": {
            "type": int,
            "format": "uint32",
        },
        "l1_session_flap": {
            "type": int,
            "format": "uint64",
        },
        "l1_broadcast_hellos_sent": {
            "type": int,
            "format": "uint64",
        },
        "l1_broadcast_hellos_received": {
            "type": int,
            "format": "uint64",
        },
        "l1_point_to_point_hellos_sent": {
            "type": int,
            "format": "uint64",
        },
        "l1_point_to_point_hellos_received": {
            "type": int,
            "format": "uint64",
        },
        "l1_database_size": {
            "type": int,
            "format": "uint64",
        },
        "l1_psnp_sent": {
            "type": int,
            "format": "uint64",
        },
        "l1_psnp_received": {
            "type": int,
            "format": "uint64",
        },
        "l1_csnp_sent": {
            "type": int,
            "format": "uint64",
        },
        "l1_csnp_received": {
            "type": int,
            "format": "uint64",
        },
        "l1_lsp_sent": {
            "type": int,
            "format": "uint64",
        },
        "l1_lsp_received": {
            "type": int,
            "format": "uint64",
        },
        "l2_sessions_up": {
            "type": int,
            "format": "uint32",
        },
        "l2_session_flap": {
            "type": int,
            "format": "uint64",
        },
        "l2_broadcast_hellos_sent": {
            "type": int,
            "format": "uint64",
        },
        "l2_broadcast_hellos_received": {
            "type": int,
            "format": "uint64",
        },
        "l2_point_to_point_hellos_sent": {
            "type": int,
            "format": "uint64",
        },
        "l2_point_to_point_hellos_received": {
            "type": int,
            "format": "uint64",
        },
        "l2_database_size": {
            "type": int,
            "format": "uint64",
        },
        "l2_psnp_sent": {
            "type": int,
            "format": "uint64",
        },
        "l2_psnp_received": {
            "type": int,
            "format": "uint64",
        },
        "l2_csnp_sent": {
            "type": int,
            "format": "uint64",
        },
        "l2_csnp_received": {
            "type": int,
            "format": "uint64",
        },
        "l2_lsp_sent": {
            "type": int,
            "format": "uint64",
        },
        "l2_lsp_received": {
            "type": int,
            "format": "uint64",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        name=None,
        l1_sessions_up=None,
        l1_session_flap=None,
        l1_broadcast_hellos_sent=None,
        l1_broadcast_hellos_received=None,
        l1_point_to_point_hellos_sent=None,
        l1_point_to_point_hellos_received=None,
        l1_database_size=None,
        l1_psnp_sent=None,
        l1_psnp_received=None,
        l1_csnp_sent=None,
        l1_csnp_received=None,
        l1_lsp_sent=None,
        l1_lsp_received=None,
        l2_sessions_up=None,
        l2_session_flap=None,
        l2_broadcast_hellos_sent=None,
        l2_broadcast_hellos_received=None,
        l2_point_to_point_hellos_sent=None,
        l2_point_to_point_hellos_received=None,
        l2_database_size=None,
        l2_psnp_sent=None,
        l2_psnp_received=None,
        l2_csnp_sent=None,
        l2_csnp_received=None,
        l2_lsp_sent=None,
        l2_lsp_received=None,
    ):
        super(IsisMetric, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("l1_sessions_up", l1_sessions_up)
        self._set_property("l1_session_flap", l1_session_flap)
        self._set_property("l1_broadcast_hellos_sent", l1_broadcast_hellos_sent)
        self._set_property("l1_broadcast_hellos_received", l1_broadcast_hellos_received)
        self._set_property(
            "l1_point_to_point_hellos_sent", l1_point_to_point_hellos_sent
        )
        self._set_property(
            "l1_point_to_point_hellos_received", l1_point_to_point_hellos_received
        )
        self._set_property("l1_database_size", l1_database_size)
        self._set_property("l1_psnp_sent", l1_psnp_sent)
        self._set_property("l1_psnp_received", l1_psnp_received)
        self._set_property("l1_csnp_sent", l1_csnp_sent)
        self._set_property("l1_csnp_received", l1_csnp_received)
        self._set_property("l1_lsp_sent", l1_lsp_sent)
        self._set_property("l1_lsp_received", l1_lsp_received)
        self._set_property("l2_sessions_up", l2_sessions_up)
        self._set_property("l2_session_flap", l2_session_flap)
        self._set_property("l2_broadcast_hellos_sent", l2_broadcast_hellos_sent)
        self._set_property("l2_broadcast_hellos_received", l2_broadcast_hellos_received)
        self._set_property(
            "l2_point_to_point_hellos_sent", l2_point_to_point_hellos_sent
        )
        self._set_property(
            "l2_point_to_point_hellos_received", l2_point_to_point_hellos_received
        )
        self._set_property("l2_database_size", l2_database_size)
        self._set_property("l2_psnp_sent", l2_psnp_sent)
        self._set_property("l2_psnp_received", l2_psnp_received)
        self._set_property("l2_csnp_sent", l2_csnp_sent)
        self._set_property("l2_csnp_received", l2_csnp_received)
        self._set_property("l2_lsp_sent", l2_lsp_sent)
        self._set_property("l2_lsp_received", l2_lsp_received)

    def set(
        self,
        name=None,
        l1_sessions_up=None,
        l1_session_flap=None,
        l1_broadcast_hellos_sent=None,
        l1_broadcast_hellos_received=None,
        l1_point_to_point_hellos_sent=None,
        l1_point_to_point_hellos_received=None,
        l1_database_size=None,
        l1_psnp_sent=None,
        l1_psnp_received=None,
        l1_csnp_sent=None,
        l1_csnp_received=None,
        l1_lsp_sent=None,
        l1_lsp_received=None,
        l2_sessions_up=None,
        l2_session_flap=None,
        l2_broadcast_hellos_sent=None,
        l2_broadcast_hellos_received=None,
        l2_point_to_point_hellos_sent=None,
        l2_point_to_point_hellos_received=None,
        l2_database_size=None,
        l2_psnp_sent=None,
        l2_psnp_received=None,
        l2_csnp_sent=None,
        l2_csnp_received=None,
        l2_lsp_sent=None,
        l2_lsp_received=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        The name of configured ISIS router.

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        The name of configured ISIS router.

        value: str
        """
        self._set_property("name", value)

    @property
    def l1_sessions_up(self):
        # type: () -> int
        """l1_sessions_up getter

        The number of Level (L1) sessions that are fully up.

        Returns: int
        """
        return self._get_property("l1_sessions_up")

    @l1_sessions_up.setter
    def l1_sessions_up(self, value):
        """l1_sessions_up setter

        The number of Level (L1) sessions that are fully up.

        value: int
        """
        self._set_property("l1_sessions_up", value)

    @property
    def l1_session_flap(self):
        # type: () -> int
        """l1_session_flap getter

        The number of Level Sessions Flap.

        Returns: int
        """
        return self._get_property("l1_session_flap")

    @l1_session_flap.setter
    def l1_session_flap(self, value):
        """l1_session_flap setter

        The number of Level Sessions Flap.

        value: int
        """
        self._set_property("l1_session_flap", value)

    @property
    def l1_broadcast_hellos_sent(self):
        # type: () -> int
        """l1_broadcast_hellos_sent getter

        Number of Level Hello messages sent.

        Returns: int
        """
        return self._get_property("l1_broadcast_hellos_sent")

    @l1_broadcast_hellos_sent.setter
    def l1_broadcast_hellos_sent(self, value):
        """l1_broadcast_hellos_sent setter

        Number of Level Hello messages sent.

        value: int
        """
        self._set_property("l1_broadcast_hellos_sent", value)

    @property
    def l1_broadcast_hellos_received(self):
        # type: () -> int
        """l1_broadcast_hellos_received getter

        Number of Level Hello messages received.

        Returns: int
        """
        return self._get_property("l1_broadcast_hellos_received")

    @l1_broadcast_hellos_received.setter
    def l1_broadcast_hellos_received(self, value):
        """l1_broadcast_hellos_received setter

        Number of Level Hello messages received.

        value: int
        """
        self._set_property("l1_broadcast_hellos_received", value)

    @property
    def l1_point_to_point_hellos_sent(self):
        # type: () -> int
        """l1_point_to_point_hellos_sent getter

        Number of Level Point-to-Point(P2P) Hello messages sent.

        Returns: int
        """
        return self._get_property("l1_point_to_point_hellos_sent")

    @l1_point_to_point_hellos_sent.setter
    def l1_point_to_point_hellos_sent(self, value):
        """l1_point_to_point_hellos_sent setter

        Number of Level Point-to-Point(P2P) Hello messages sent.

        value: int
        """
        self._set_property("l1_point_to_point_hellos_sent", value)

    @property
    def l1_point_to_point_hellos_received(self):
        # type: () -> int
        """l1_point_to_point_hellos_received getter

        Number of Level Point-to-Point(P2P) Hello messages received.

        Returns: int
        """
        return self._get_property("l1_point_to_point_hellos_received")

    @l1_point_to_point_hellos_received.setter
    def l1_point_to_point_hellos_received(self, value):
        """l1_point_to_point_hellos_received setter

        Number of Level Point-to-Point(P2P) Hello messages received.

        value: int
        """
        self._set_property("l1_point_to_point_hellos_received", value)

    @property
    def l1_database_size(self):
        # type: () -> int
        """l1_database_size getter

        Number of Link State Updates (LSPs) in the Level LSP Databases.

        Returns: int
        """
        return self._get_property("l1_database_size")

    @l1_database_size.setter
    def l1_database_size(self, value):
        """l1_database_size setter

        Number of Link State Updates (LSPs) in the Level LSP Databases.

        value: int
        """
        self._set_property("l1_database_size", value)

    @property
    def l1_psnp_sent(self):
        # type: () -> int
        """l1_psnp_sent getter

        Number of Level (L1) Partial Sequence Number Packet (PSNPs) sent.

        Returns: int
        """
        return self._get_property("l1_psnp_sent")

    @l1_psnp_sent.setter
    def l1_psnp_sent(self, value):
        """l1_psnp_sent setter

        Number of Level (L1) Partial Sequence Number Packet (PSNPs) sent.

        value: int
        """
        self._set_property("l1_psnp_sent", value)

    @property
    def l1_psnp_received(self):
        # type: () -> int
        """l1_psnp_received getter

        Number of Level (L1) Complete Sequence Number Packet (PSNPs) received.

        Returns: int
        """
        return self._get_property("l1_psnp_received")

    @l1_psnp_received.setter
    def l1_psnp_received(self, value):
        """l1_psnp_received setter

        Number of Level (L1) Complete Sequence Number Packet (PSNPs) received.

        value: int
        """
        self._set_property("l1_psnp_received", value)

    @property
    def l1_csnp_sent(self):
        # type: () -> int
        """l1_csnp_sent getter

        Number of Level (L1) Complete Sequence Number Packet (CSNPs) sent.

        Returns: int
        """
        return self._get_property("l1_csnp_sent")

    @l1_csnp_sent.setter
    def l1_csnp_sent(self, value):
        """l1_csnp_sent setter

        Number of Level (L1) Complete Sequence Number Packet (CSNPs) sent.

        value: int
        """
        self._set_property("l1_csnp_sent", value)

    @property
    def l1_csnp_received(self):
        # type: () -> int
        """l1_csnp_received getter

        Number of Level (L1) Complete Sequence Number Packet (CSNPs) received.

        Returns: int
        """
        return self._get_property("l1_csnp_received")

    @l1_csnp_received.setter
    def l1_csnp_received(self, value):
        """l1_csnp_received setter

        Number of Level (L1) Complete Sequence Number Packet (CSNPs) received.

        value: int
        """
        self._set_property("l1_csnp_received", value)

    @property
    def l1_lsp_sent(self):
        # type: () -> int
        """l1_lsp_sent getter

        Number of Level (L1) Link State Protocol Data Units (LSPs) sent.

        Returns: int
        """
        return self._get_property("l1_lsp_sent")

    @l1_lsp_sent.setter
    def l1_lsp_sent(self, value):
        """l1_lsp_sent setter

        Number of Level (L1) Link State Protocol Data Units (LSPs) sent.

        value: int
        """
        self._set_property("l1_lsp_sent", value)

    @property
    def l1_lsp_received(self):
        # type: () -> int
        """l1_lsp_received getter

        Number of Level (L1) Link State Protocol Data Units (LSPs) received.

        Returns: int
        """
        return self._get_property("l1_lsp_received")

    @l1_lsp_received.setter
    def l1_lsp_received(self, value):
        """l1_lsp_received setter

        Number of Level (L1) Link State Protocol Data Units (LSPs) received.

        value: int
        """
        self._set_property("l1_lsp_received", value)

    @property
    def l2_sessions_up(self):
        # type: () -> int
        """l2_sessions_up getter

        The number of Level (L2) sessions that are fully up.

        Returns: int
        """
        return self._get_property("l2_sessions_up")

    @l2_sessions_up.setter
    def l2_sessions_up(self, value):
        """l2_sessions_up setter

        The number of Level (L2) sessions that are fully up.

        value: int
        """
        self._set_property("l2_sessions_up", value)

    @property
    def l2_session_flap(self):
        # type: () -> int
        """l2_session_flap getter

        The number of Level Sessions Flap.

        Returns: int
        """
        return self._get_property("l2_session_flap")

    @l2_session_flap.setter
    def l2_session_flap(self, value):
        """l2_session_flap setter

        The number of Level Sessions Flap.

        value: int
        """
        self._set_property("l2_session_flap", value)

    @property
    def l2_broadcast_hellos_sent(self):
        # type: () -> int
        """l2_broadcast_hellos_sent getter

        Number of Level Hello messages sent.

        Returns: int
        """
        return self._get_property("l2_broadcast_hellos_sent")

    @l2_broadcast_hellos_sent.setter
    def l2_broadcast_hellos_sent(self, value):
        """l2_broadcast_hellos_sent setter

        Number of Level Hello messages sent.

        value: int
        """
        self._set_property("l2_broadcast_hellos_sent", value)

    @property
    def l2_broadcast_hellos_received(self):
        # type: () -> int
        """l2_broadcast_hellos_received getter

        Number of Level Hello messages received.

        Returns: int
        """
        return self._get_property("l2_broadcast_hellos_received")

    @l2_broadcast_hellos_received.setter
    def l2_broadcast_hellos_received(self, value):
        """l2_broadcast_hellos_received setter

        Number of Level Hello messages received.

        value: int
        """
        self._set_property("l2_broadcast_hellos_received", value)

    @property
    def l2_point_to_point_hellos_sent(self):
        # type: () -> int
        """l2_point_to_point_hellos_sent getter

        Number of Level Point-to-Point(P2P) Hello messages sent.

        Returns: int
        """
        return self._get_property("l2_point_to_point_hellos_sent")

    @l2_point_to_point_hellos_sent.setter
    def l2_point_to_point_hellos_sent(self, value):
        """l2_point_to_point_hellos_sent setter

        Number of Level Point-to-Point(P2P) Hello messages sent.

        value: int
        """
        self._set_property("l2_point_to_point_hellos_sent", value)

    @property
    def l2_point_to_point_hellos_received(self):
        # type: () -> int
        """l2_point_to_point_hellos_received getter

        Number of Level Point-to-Point(P2P) Hello messages received.

        Returns: int
        """
        return self._get_property("l2_point_to_point_hellos_received")

    @l2_point_to_point_hellos_received.setter
    def l2_point_to_point_hellos_received(self, value):
        """l2_point_to_point_hellos_received setter

        Number of Level Point-to-Point(P2P) Hello messages received.

        value: int
        """
        self._set_property("l2_point_to_point_hellos_received", value)

    @property
    def l2_database_size(self):
        # type: () -> int
        """l2_database_size getter

        Number of Link State Updates (LSPs) in the Level LSP Databases.

        Returns: int
        """
        return self._get_property("l2_database_size")

    @l2_database_size.setter
    def l2_database_size(self, value):
        """l2_database_size setter

        Number of Link State Updates (LSPs) in the Level LSP Databases.

        value: int
        """
        self._set_property("l2_database_size", value)

    @property
    def l2_psnp_sent(self):
        # type: () -> int
        """l2_psnp_sent getter

        Number of Level (L2) Partial Sequence Number Packet (PSNPs) sent.

        Returns: int
        """
        return self._get_property("l2_psnp_sent")

    @l2_psnp_sent.setter
    def l2_psnp_sent(self, value):
        """l2_psnp_sent setter

        Number of Level (L2) Partial Sequence Number Packet (PSNPs) sent.

        value: int
        """
        self._set_property("l2_psnp_sent", value)

    @property
    def l2_psnp_received(self):
        # type: () -> int
        """l2_psnp_received getter

        Number of Level (L2) Complete Sequence Number Packet (PSNPs) received.

        Returns: int
        """
        return self._get_property("l2_psnp_received")

    @l2_psnp_received.setter
    def l2_psnp_received(self, value):
        """l2_psnp_received setter

        Number of Level (L2) Complete Sequence Number Packet (PSNPs) received.

        value: int
        """
        self._set_property("l2_psnp_received", value)

    @property
    def l2_csnp_sent(self):
        # type: () -> int
        """l2_csnp_sent getter

        Number of Level (L2) Complete Sequence Number Packet (CSNPs) sent.

        Returns: int
        """
        return self._get_property("l2_csnp_sent")

    @l2_csnp_sent.setter
    def l2_csnp_sent(self, value):
        """l2_csnp_sent setter

        Number of Level (L2) Complete Sequence Number Packet (CSNPs) sent.

        value: int
        """
        self._set_property("l2_csnp_sent", value)

    @property
    def l2_csnp_received(self):
        # type: () -> int
        """l2_csnp_received getter

        Number of Level (L2) Complete Sequence Number Packet (CSNPs) received.

        Returns: int
        """
        return self._get_property("l2_csnp_received")

    @l2_csnp_received.setter
    def l2_csnp_received(self, value):
        """l2_csnp_received setter

        Number of Level (L2) Complete Sequence Number Packet (CSNPs) received.

        value: int
        """
        self._set_property("l2_csnp_received", value)

    @property
    def l2_lsp_sent(self):
        # type: () -> int
        """l2_lsp_sent getter

        Number of Level (L2) Link State Protocol Data Units (LSPs) sent.

        Returns: int
        """
        return self._get_property("l2_lsp_sent")

    @l2_lsp_sent.setter
    def l2_lsp_sent(self, value):
        """l2_lsp_sent setter

        Number of Level (L2) Link State Protocol Data Units (LSPs) sent.

        value: int
        """
        self._set_property("l2_lsp_sent", value)

    @property
    def l2_lsp_received(self):
        # type: () -> int
        """l2_lsp_received getter

        Number of Level (L2) Link State Protocol Data Units (LSPs) received.

        Returns: int
        """
        return self._get_property("l2_lsp_received")

    @l2_lsp_received.setter
    def l2_lsp_received(self, value):
        """l2_lsp_received setter

        Number of Level (L2) Link State Protocol Data Units (LSPs) received.

        value: int
        """
        self._set_property("l2_lsp_received", value)


class IsisMetricIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(IsisMetricIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[IsisMetric]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> IsisMetricIter
        return self._iter()

    def __next__(self):
        # type: () -> IsisMetric
        return self._next()

    def next(self):
        # type: () -> IsisMetric
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, IsisMetric):
            raise Exception("Item is not an instance of IsisMetric")

    def metric(
        self,
        name=None,
        l1_sessions_up=None,
        l1_session_flap=None,
        l1_broadcast_hellos_sent=None,
        l1_broadcast_hellos_received=None,
        l1_point_to_point_hellos_sent=None,
        l1_point_to_point_hellos_received=None,
        l1_database_size=None,
        l1_psnp_sent=None,
        l1_psnp_received=None,
        l1_csnp_sent=None,
        l1_csnp_received=None,
        l1_lsp_sent=None,
        l1_lsp_received=None,
        l2_sessions_up=None,
        l2_session_flap=None,
        l2_broadcast_hellos_sent=None,
        l2_broadcast_hellos_received=None,
        l2_point_to_point_hellos_sent=None,
        l2_point_to_point_hellos_received=None,
        l2_database_size=None,
        l2_psnp_sent=None,
        l2_psnp_received=None,
        l2_csnp_sent=None,
        l2_csnp_received=None,
        l2_lsp_sent=None,
        l2_lsp_received=None,
    ):
        # type: (str,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int) -> IsisMetricIter
        """Factory method that creates an instance of the IsisMetric class

        ISIS per router statistics information.

        Returns: IsisMetricIter
        """
        item = IsisMetric(
            parent=self._parent,
            name=name,
            l1_sessions_up=l1_sessions_up,
            l1_session_flap=l1_session_flap,
            l1_broadcast_hellos_sent=l1_broadcast_hellos_sent,
            l1_broadcast_hellos_received=l1_broadcast_hellos_received,
            l1_point_to_point_hellos_sent=l1_point_to_point_hellos_sent,
            l1_point_to_point_hellos_received=l1_point_to_point_hellos_received,
            l1_database_size=l1_database_size,
            l1_psnp_sent=l1_psnp_sent,
            l1_psnp_received=l1_psnp_received,
            l1_csnp_sent=l1_csnp_sent,
            l1_csnp_received=l1_csnp_received,
            l1_lsp_sent=l1_lsp_sent,
            l1_lsp_received=l1_lsp_received,
            l2_sessions_up=l2_sessions_up,
            l2_session_flap=l2_session_flap,
            l2_broadcast_hellos_sent=l2_broadcast_hellos_sent,
            l2_broadcast_hellos_received=l2_broadcast_hellos_received,
            l2_point_to_point_hellos_sent=l2_point_to_point_hellos_sent,
            l2_point_to_point_hellos_received=l2_point_to_point_hellos_received,
            l2_database_size=l2_database_size,
            l2_psnp_sent=l2_psnp_sent,
            l2_psnp_received=l2_psnp_received,
            l2_csnp_sent=l2_csnp_sent,
            l2_csnp_received=l2_csnp_received,
            l2_lsp_sent=l2_lsp_sent,
            l2_lsp_received=l2_lsp_received,
        )
        self._add(item)
        return self

    def add(
        self,
        name=None,
        l1_sessions_up=None,
        l1_session_flap=None,
        l1_broadcast_hellos_sent=None,
        l1_broadcast_hellos_received=None,
        l1_point_to_point_hellos_sent=None,
        l1_point_to_point_hellos_received=None,
        l1_database_size=None,
        l1_psnp_sent=None,
        l1_psnp_received=None,
        l1_csnp_sent=None,
        l1_csnp_received=None,
        l1_lsp_sent=None,
        l1_lsp_received=None,
        l2_sessions_up=None,
        l2_session_flap=None,
        l2_broadcast_hellos_sent=None,
        l2_broadcast_hellos_received=None,
        l2_point_to_point_hellos_sent=None,
        l2_point_to_point_hellos_received=None,
        l2_database_size=None,
        l2_psnp_sent=None,
        l2_psnp_received=None,
        l2_csnp_sent=None,
        l2_csnp_received=None,
        l2_lsp_sent=None,
        l2_lsp_received=None,
    ):
        # type: (str,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int) -> IsisMetric
        """Add method that creates and returns an instance of the IsisMetric class

        ISIS per router statistics information.

        Returns: IsisMetric
        """
        item = IsisMetric(
            parent=self._parent,
            name=name,
            l1_sessions_up=l1_sessions_up,
            l1_session_flap=l1_session_flap,
            l1_broadcast_hellos_sent=l1_broadcast_hellos_sent,
            l1_broadcast_hellos_received=l1_broadcast_hellos_received,
            l1_point_to_point_hellos_sent=l1_point_to_point_hellos_sent,
            l1_point_to_point_hellos_received=l1_point_to_point_hellos_received,
            l1_database_size=l1_database_size,
            l1_psnp_sent=l1_psnp_sent,
            l1_psnp_received=l1_psnp_received,
            l1_csnp_sent=l1_csnp_sent,
            l1_csnp_received=l1_csnp_received,
            l1_lsp_sent=l1_lsp_sent,
            l1_lsp_received=l1_lsp_received,
            l2_sessions_up=l2_sessions_up,
            l2_session_flap=l2_session_flap,
            l2_broadcast_hellos_sent=l2_broadcast_hellos_sent,
            l2_broadcast_hellos_received=l2_broadcast_hellos_received,
            l2_point_to_point_hellos_sent=l2_point_to_point_hellos_sent,
            l2_point_to_point_hellos_received=l2_point_to_point_hellos_received,
            l2_database_size=l2_database_size,
            l2_psnp_sent=l2_psnp_sent,
            l2_psnp_received=l2_psnp_received,
            l2_csnp_sent=l2_csnp_sent,
            l2_csnp_received=l2_csnp_received,
            l2_lsp_sent=l2_lsp_sent,
            l2_lsp_received=l2_lsp_received,
        )
        self._add(item)
        return item


class LagMetric(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "oper_status": {
            "type": str,
            "enum": [
                "up",
                "down",
            ],
        },
        "member_ports_up": {
            "type": int,
            "format": "uint32",
        },
        "frames_tx": {
            "type": int,
            "format": "uint64",
        },
        "frames_rx": {
            "type": int,
            "format": "uint64",
        },
        "bytes_tx": {
            "type": int,
            "format": "uint64",
        },
        "bytes_rx": {
            "type": int,
            "format": "uint64",
            "minimum": 0,
        },
        "frames_tx_rate": {"type": float},
        "frames_rx_rate": {"type": float},
        "bytes_tx_rate": {"type": float},
        "bytes_rx_rate": {"type": float},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    UP = "up"  # type: str
    DOWN = "down"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        name=None,
        oper_status=None,
        member_ports_up=None,
        frames_tx=None,
        frames_rx=None,
        bytes_tx=None,
        bytes_rx=None,
        frames_tx_rate=None,
        frames_rx_rate=None,
        bytes_tx_rate=None,
        bytes_rx_rate=None,
    ):
        super(LagMetric, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("oper_status", oper_status)
        self._set_property("member_ports_up", member_ports_up)
        self._set_property("frames_tx", frames_tx)
        self._set_property("frames_rx", frames_rx)
        self._set_property("bytes_tx", bytes_tx)
        self._set_property("bytes_rx", bytes_rx)
        self._set_property("frames_tx_rate", frames_tx_rate)
        self._set_property("frames_rx_rate", frames_rx_rate)
        self._set_property("bytes_tx_rate", bytes_tx_rate)
        self._set_property("bytes_rx_rate", bytes_rx_rate)

    def set(
        self,
        name=None,
        oper_status=None,
        member_ports_up=None,
        frames_tx=None,
        frames_rx=None,
        bytes_tx=None,
        bytes_rx=None,
        frames_tx_rate=None,
        frames_rx_rate=None,
        bytes_tx_rate=None,
        bytes_rx_rate=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        The name of configured LAG. x-constraint:. /components/schemas/Lag/properties/name. . x-constraint:. /components/schemas/Lag/properties/name.

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        The name of configured LAG. x-constraint:. /components/schemas/Lag/properties/name. . x-constraint:. /components/schemas/Lag/properties/name.

        value: str
        """
        self._set_property("name", value)

    @property
    def oper_status(self):
        # type: () -> Union[Literal["down"], Literal["up"]]
        """oper_status getter

        The current operational state of the LAG. The state can be up or down. State 'up' indicates member_ports_up >= min_links.

        Returns: Union[Literal["down"], Literal["up"]]
        """
        return self._get_property("oper_status")

    @oper_status.setter
    def oper_status(self, value):
        """oper_status setter

        The current operational state of the LAG. The state can be up or down. State 'up' indicates member_ports_up >= min_links.

        value: Union[Literal["down"], Literal["up"]]
        """
        self._set_property("oper_status", value)

    @property
    def member_ports_up(self):
        # type: () -> int
        """member_ports_up getter

        The number of LAG member ports up.

        Returns: int
        """
        return self._get_property("member_ports_up")

    @member_ports_up.setter
    def member_ports_up(self, value):
        """member_ports_up setter

        The number of LAG member ports up.

        value: int
        """
        self._set_property("member_ports_up", value)

    @property
    def frames_tx(self):
        # type: () -> int
        """frames_tx getter

        The current total number of frames transmitted.

        Returns: int
        """
        return self._get_property("frames_tx")

    @frames_tx.setter
    def frames_tx(self, value):
        """frames_tx setter

        The current total number of frames transmitted.

        value: int
        """
        self._set_property("frames_tx", value)

    @property
    def frames_rx(self):
        # type: () -> int
        """frames_rx getter

        The current total number of valid frames received.

        Returns: int
        """
        return self._get_property("frames_rx")

    @frames_rx.setter
    def frames_rx(self, value):
        """frames_rx setter

        The current total number of valid frames received.

        value: int
        """
        self._set_property("frames_rx", value)

    @property
    def bytes_tx(self):
        # type: () -> int
        """bytes_tx getter

        The current total number of bytes transmitted.

        Returns: int
        """
        return self._get_property("bytes_tx")

    @bytes_tx.setter
    def bytes_tx(self, value):
        """bytes_tx setter

        The current total number of bytes transmitted.

        value: int
        """
        self._set_property("bytes_tx", value)

    @property
    def bytes_rx(self):
        # type: () -> int
        """bytes_rx getter

        The current total number of valid bytes received.

        Returns: int
        """
        return self._get_property("bytes_rx")

    @bytes_rx.setter
    def bytes_rx(self, value):
        """bytes_rx setter

        The current total number of valid bytes received.

        value: int
        """
        self._set_property("bytes_rx", value)

    @property
    def frames_tx_rate(self):
        # type: () -> float
        """frames_tx_rate getter

        The current rate of frames transmitted.

        Returns: float
        """
        return self._get_property("frames_tx_rate")

    @frames_tx_rate.setter
    def frames_tx_rate(self, value):
        """frames_tx_rate setter

        The current rate of frames transmitted.

        value: float
        """
        self._set_property("frames_tx_rate", value)

    @property
    def frames_rx_rate(self):
        # type: () -> float
        """frames_rx_rate getter

        The current rate of valid frames received.

        Returns: float
        """
        return self._get_property("frames_rx_rate")

    @frames_rx_rate.setter
    def frames_rx_rate(self, value):
        """frames_rx_rate setter

        The current rate of valid frames received.

        value: float
        """
        self._set_property("frames_rx_rate", value)

    @property
    def bytes_tx_rate(self):
        # type: () -> float
        """bytes_tx_rate getter

        The current rate of bytes transmitted.

        Returns: float
        """
        return self._get_property("bytes_tx_rate")

    @bytes_tx_rate.setter
    def bytes_tx_rate(self, value):
        """bytes_tx_rate setter

        The current rate of bytes transmitted.

        value: float
        """
        self._set_property("bytes_tx_rate", value)

    @property
    def bytes_rx_rate(self):
        # type: () -> float
        """bytes_rx_rate getter

        The current rate of bytes received.

        Returns: float
        """
        return self._get_property("bytes_rx_rate")

    @bytes_rx_rate.setter
    def bytes_rx_rate(self, value):
        """bytes_rx_rate setter

        The current rate of bytes received.

        value: float
        """
        self._set_property("bytes_rx_rate", value)


class LagMetricIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(LagMetricIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[LagMetric]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> LagMetricIter
        return self._iter()

    def __next__(self):
        # type: () -> LagMetric
        return self._next()

    def next(self):
        # type: () -> LagMetric
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, LagMetric):
            raise Exception("Item is not an instance of LagMetric")

    def metric(
        self,
        name=None,
        oper_status=None,
        member_ports_up=None,
        frames_tx=None,
        frames_rx=None,
        bytes_tx=None,
        bytes_rx=None,
        frames_tx_rate=None,
        frames_rx_rate=None,
        bytes_tx_rate=None,
        bytes_rx_rate=None,
    ):
        # type: (str,Union[Literal["down"], Literal["up"]],int,int,int,int,int,float,float,float,float) -> LagMetricIter
        """Factory method that creates an instance of the LagMetric class

        TBD

        Returns: LagMetricIter
        """
        item = LagMetric(
            parent=self._parent,
            name=name,
            oper_status=oper_status,
            member_ports_up=member_ports_up,
            frames_tx=frames_tx,
            frames_rx=frames_rx,
            bytes_tx=bytes_tx,
            bytes_rx=bytes_rx,
            frames_tx_rate=frames_tx_rate,
            frames_rx_rate=frames_rx_rate,
            bytes_tx_rate=bytes_tx_rate,
            bytes_rx_rate=bytes_rx_rate,
        )
        self._add(item)
        return self

    def add(
        self,
        name=None,
        oper_status=None,
        member_ports_up=None,
        frames_tx=None,
        frames_rx=None,
        bytes_tx=None,
        bytes_rx=None,
        frames_tx_rate=None,
        frames_rx_rate=None,
        bytes_tx_rate=None,
        bytes_rx_rate=None,
    ):
        # type: (str,Union[Literal["down"], Literal["up"]],int,int,int,int,int,float,float,float,float) -> LagMetric
        """Add method that creates and returns an instance of the LagMetric class

        TBD

        Returns: LagMetric
        """
        item = LagMetric(
            parent=self._parent,
            name=name,
            oper_status=oper_status,
            member_ports_up=member_ports_up,
            frames_tx=frames_tx,
            frames_rx=frames_rx,
            bytes_tx=bytes_tx,
            bytes_rx=bytes_rx,
            frames_tx_rate=frames_tx_rate,
            frames_rx_rate=frames_rx_rate,
            bytes_tx_rate=bytes_tx_rate,
            bytes_rx_rate=bytes_rx_rate,
        )
        self._add(item)
        return item


class LacpMetric(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "lag_name": {"type": str},
        "lag_member_port_name": {"type": str},
        "lacp_packets_rx": {
            "type": int,
            "format": "uint64",
        },
        "lacp_packets_tx": {
            "type": int,
            "format": "uint64",
        },
        "lacp_rx_errors": {
            "type": int,
            "format": "uint64",
        },
        "activity": {
            "type": str,
            "enum": [
                "active",
                "passive",
            ],
        },
        "timeout": {
            "type": str,
            "enum": [
                "short",
                "long",
            ],
        },
        "synchronization": {
            "type": str,
            "enum": [
                "in_sync",
                "out_sync",
            ],
        },
        "aggregatable": {"type": bool},
        "collecting": {"type": bool},
        "distributing": {"type": bool},
        "system_id": {
            "type": str,
            "format": "mac",
        },
        "oper_key": {
            "type": int,
            "format": "uint32",
        },
        "partner_id": {
            "type": str,
            "format": "mac",
        },
        "partner_key": {
            "type": int,
            "format": "uint32",
        },
        "port_num": {
            "type": int,
            "format": "uint32",
        },
        "partner_port_num": {
            "type": int,
            "format": "uint32",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    ACTIVE = "active"  # type: str
    PASSIVE = "passive"  # type: str

    SHORT = "short"  # type: str
    LONG = "long"  # type: str

    IN_SYNC = "in_sync"  # type: str
    OUT_SYNC = "out_sync"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        lag_name=None,
        lag_member_port_name=None,
        lacp_packets_rx=None,
        lacp_packets_tx=None,
        lacp_rx_errors=None,
        activity=None,
        timeout=None,
        synchronization=None,
        aggregatable=None,
        collecting=None,
        distributing=None,
        system_id=None,
        oper_key=None,
        partner_id=None,
        partner_key=None,
        port_num=None,
        partner_port_num=None,
    ):
        super(LacpMetric, self).__init__()
        self._parent = parent
        self._set_property("lag_name", lag_name)
        self._set_property("lag_member_port_name", lag_member_port_name)
        self._set_property("lacp_packets_rx", lacp_packets_rx)
        self._set_property("lacp_packets_tx", lacp_packets_tx)
        self._set_property("lacp_rx_errors", lacp_rx_errors)
        self._set_property("activity", activity)
        self._set_property("timeout", timeout)
        self._set_property("synchronization", synchronization)
        self._set_property("aggregatable", aggregatable)
        self._set_property("collecting", collecting)
        self._set_property("distributing", distributing)
        self._set_property("system_id", system_id)
        self._set_property("oper_key", oper_key)
        self._set_property("partner_id", partner_id)
        self._set_property("partner_key", partner_key)
        self._set_property("port_num", port_num)
        self._set_property("partner_port_num", partner_port_num)

    def set(
        self,
        lag_name=None,
        lag_member_port_name=None,
        lacp_packets_rx=None,
        lacp_packets_tx=None,
        lacp_rx_errors=None,
        activity=None,
        timeout=None,
        synchronization=None,
        aggregatable=None,
        collecting=None,
        distributing=None,
        system_id=None,
        oper_key=None,
        partner_id=None,
        partner_key=None,
        port_num=None,
        partner_port_num=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def lag_name(self):
        # type: () -> str
        """lag_name getter

        The name of LAG (ports group) configured with LACP.

        Returns: str
        """
        return self._get_property("lag_name")

    @lag_name.setter
    def lag_name(self, value):
        """lag_name setter

        The name of LAG (ports group) configured with LACP.

        value: str
        """
        self._set_property("lag_name", value)

    @property
    def lag_member_port_name(self):
        # type: () -> str
        """lag_member_port_name getter

        The name of LAG member (port) configured with LACP.

        Returns: str
        """
        return self._get_property("lag_member_port_name")

    @lag_member_port_name.setter
    def lag_member_port_name(self, value):
        """lag_member_port_name setter

        The name of LAG member (port) configured with LACP.

        value: str
        """
        self._set_property("lag_member_port_name", value)

    @property
    def lacp_packets_rx(self):
        # type: () -> int
        """lacp_packets_rx getter

        Number of LACPDUs received.

        Returns: int
        """
        return self._get_property("lacp_packets_rx")

    @lacp_packets_rx.setter
    def lacp_packets_rx(self, value):
        """lacp_packets_rx setter

        Number of LACPDUs received.

        value: int
        """
        self._set_property("lacp_packets_rx", value)

    @property
    def lacp_packets_tx(self):
        # type: () -> int
        """lacp_packets_tx getter

        Number of LACPDUs transmitted.

        Returns: int
        """
        return self._get_property("lacp_packets_tx")

    @lacp_packets_tx.setter
    def lacp_packets_tx(self, value):
        """lacp_packets_tx setter

        Number of LACPDUs transmitted.

        value: int
        """
        self._set_property("lacp_packets_tx", value)

    @property
    def lacp_rx_errors(self):
        # type: () -> int
        """lacp_rx_errors getter

        Number of LACPDUs receive packet errors.

        Returns: int
        """
        return self._get_property("lacp_rx_errors")

    @lacp_rx_errors.setter
    def lacp_rx_errors(self, value):
        """lacp_rx_errors setter

        Number of LACPDUs receive packet errors.

        value: int
        """
        self._set_property("lacp_rx_errors", value)

    @property
    def activity(self):
        # type: () -> Union[Literal["active"], Literal["passive"]]
        """activity getter

        Indicates participant is active or passive.

        Returns: Union[Literal["active"], Literal["passive"]]
        """
        return self._get_property("activity")

    @activity.setter
    def activity(self, value):
        """activity setter

        Indicates participant is active or passive.

        value: Union[Literal["active"], Literal["passive"]]
        """
        self._set_property("activity", value)

    @property
    def timeout(self):
        # type: () -> Union[Literal["long"], Literal["short"]]
        """timeout getter

        The timeout type (short or long) used by the participant.

        Returns: Union[Literal["long"], Literal["short"]]
        """
        return self._get_property("timeout")

    @timeout.setter
    def timeout(self, value):
        """timeout setter

        The timeout type (short or long) used by the participant.

        value: Union[Literal["long"], Literal["short"]]
        """
        self._set_property("timeout", value)

    @property
    def synchronization(self):
        # type: () -> Union[Literal["in_sync"], Literal["out_sync"]]
        """synchronization getter

        Indicates whether the participant is in-sync or out-of-sync.

        Returns: Union[Literal["in_sync"], Literal["out_sync"]]
        """
        return self._get_property("synchronization")

    @synchronization.setter
    def synchronization(self, value):
        """synchronization setter

        Indicates whether the participant is in-sync or out-of-sync.

        value: Union[Literal["in_sync"], Literal["out_sync"]]
        """
        self._set_property("synchronization", value)

    @property
    def aggregatable(self):
        # type: () -> bool
        """aggregatable getter

        A true value indicates that the participant will allow the link to be used as part of the aggregate. false value indicates the link should be used as an individual link.

        Returns: bool
        """
        return self._get_property("aggregatable")

    @aggregatable.setter
    def aggregatable(self, value):
        """aggregatable setter

        A true value indicates that the participant will allow the link to be used as part of the aggregate. false value indicates the link should be used as an individual link.

        value: bool
        """
        self._set_property("aggregatable", value)

    @property
    def collecting(self):
        # type: () -> bool
        """collecting getter

        If true, the participant is collecting incoming frames on the link, otherwise false.

        Returns: bool
        """
        return self._get_property("collecting")

    @collecting.setter
    def collecting(self, value):
        """collecting setter

        If true, the participant is collecting incoming frames on the link, otherwise false.

        value: bool
        """
        self._set_property("collecting", value)

    @property
    def distributing(self):
        # type: () -> bool
        """distributing getter

        When true, the participant is distributing outgoing frames; when false, distribution is disabled.

        Returns: bool
        """
        return self._get_property("distributing")

    @distributing.setter
    def distributing(self, value):
        """distributing setter

        When true, the participant is distributing outgoing frames; when false, distribution is disabled.

        value: bool
        """
        self._set_property("distributing", value)

    @property
    def system_id(self):
        # type: () -> str
        """system_id getter

        MAC address that defines the local system ID for the aggregate interface.

        Returns: str
        """
        return self._get_property("system_id")

    @system_id.setter
    def system_id(self, value):
        """system_id setter

        MAC address that defines the local system ID for the aggregate interface.

        value: str
        """
        self._set_property("system_id", value)

    @property
    def oper_key(self):
        # type: () -> int
        """oper_key getter

        Current operational value of the key for the aggregate interface.

        Returns: int
        """
        return self._get_property("oper_key")

    @oper_key.setter
    def oper_key(self, value):
        """oper_key setter

        Current operational value of the key for the aggregate interface.

        value: int
        """
        self._set_property("oper_key", value)

    @property
    def partner_id(self):
        # type: () -> str
        """partner_id getter

        MAC address representing the protocol partner's interface system ID.

        Returns: str
        """
        return self._get_property("partner_id")

    @partner_id.setter
    def partner_id(self, value):
        """partner_id setter

        MAC address representing the protocol partner's interface system ID.

        value: str
        """
        self._set_property("partner_id", value)

    @property
    def partner_key(self):
        # type: () -> int
        """partner_key getter

        Operational value of the protocol partner's key.

        Returns: int
        """
        return self._get_property("partner_key")

    @partner_key.setter
    def partner_key(self, value):
        """partner_key setter

        Operational value of the protocol partner's key.

        value: int
        """
        self._set_property("partner_key", value)

    @property
    def port_num(self):
        # type: () -> int
        """port_num getter

        Port number of the local (actor) aggregation member.

        Returns: int
        """
        return self._get_property("port_num")

    @port_num.setter
    def port_num(self, value):
        """port_num setter

        Port number of the local (actor) aggregation member.

        value: int
        """
        self._set_property("port_num", value)

    @property
    def partner_port_num(self):
        # type: () -> int
        """partner_port_num getter

        Port number of the partner (remote) port for this member port.

        Returns: int
        """
        return self._get_property("partner_port_num")

    @partner_port_num.setter
    def partner_port_num(self, value):
        """partner_port_num setter

        Port number of the partner (remote) port for this member port.

        value: int
        """
        self._set_property("partner_port_num", value)


class LacpMetricIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(LacpMetricIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[LacpMetric]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> LacpMetricIter
        return self._iter()

    def __next__(self):
        # type: () -> LacpMetric
        return self._next()

    def next(self):
        # type: () -> LacpMetric
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, LacpMetric):
            raise Exception("Item is not an instance of LacpMetric")

    def metric(
        self,
        lag_name=None,
        lag_member_port_name=None,
        lacp_packets_rx=None,
        lacp_packets_tx=None,
        lacp_rx_errors=None,
        activity=None,
        timeout=None,
        synchronization=None,
        aggregatable=None,
        collecting=None,
        distributing=None,
        system_id=None,
        oper_key=None,
        partner_id=None,
        partner_key=None,
        port_num=None,
        partner_port_num=None,
    ):
        # type: (str,str,int,int,int,Union[Literal["active"], Literal["passive"]],Union[Literal["long"], Literal["short"]],Union[Literal["in_sync"], Literal["out_sync"]],bool,bool,bool,str,int,str,int,int,int) -> LacpMetricIter
        """Factory method that creates an instance of the LacpMetric class

        LACP metrics (statistics) per LAG member.

        Returns: LacpMetricIter
        """
        item = LacpMetric(
            parent=self._parent,
            lag_name=lag_name,
            lag_member_port_name=lag_member_port_name,
            lacp_packets_rx=lacp_packets_rx,
            lacp_packets_tx=lacp_packets_tx,
            lacp_rx_errors=lacp_rx_errors,
            activity=activity,
            timeout=timeout,
            synchronization=synchronization,
            aggregatable=aggregatable,
            collecting=collecting,
            distributing=distributing,
            system_id=system_id,
            oper_key=oper_key,
            partner_id=partner_id,
            partner_key=partner_key,
            port_num=port_num,
            partner_port_num=partner_port_num,
        )
        self._add(item)
        return self

    def add(
        self,
        lag_name=None,
        lag_member_port_name=None,
        lacp_packets_rx=None,
        lacp_packets_tx=None,
        lacp_rx_errors=None,
        activity=None,
        timeout=None,
        synchronization=None,
        aggregatable=None,
        collecting=None,
        distributing=None,
        system_id=None,
        oper_key=None,
        partner_id=None,
        partner_key=None,
        port_num=None,
        partner_port_num=None,
    ):
        # type: (str,str,int,int,int,Union[Literal["active"], Literal["passive"]],Union[Literal["long"], Literal["short"]],Union[Literal["in_sync"], Literal["out_sync"]],bool,bool,bool,str,int,str,int,int,int) -> LacpMetric
        """Add method that creates and returns an instance of the LacpMetric class

        LACP metrics (statistics) per LAG member.

        Returns: LacpMetric
        """
        item = LacpMetric(
            parent=self._parent,
            lag_name=lag_name,
            lag_member_port_name=lag_member_port_name,
            lacp_packets_rx=lacp_packets_rx,
            lacp_packets_tx=lacp_packets_tx,
            lacp_rx_errors=lacp_rx_errors,
            activity=activity,
            timeout=timeout,
            synchronization=synchronization,
            aggregatable=aggregatable,
            collecting=collecting,
            distributing=distributing,
            system_id=system_id,
            oper_key=oper_key,
            partner_id=partner_id,
            partner_key=partner_key,
            port_num=port_num,
            partner_port_num=partner_port_num,
        )
        self._add(item)
        return item


class LldpMetric(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "frames_rx": {
            "type": int,
            "format": "uint64",
        },
        "frames_tx": {
            "type": int,
            "format": "uint64",
        },
        "frames_error_rx": {
            "type": int,
            "format": "uint64",
        },
        "frames_discard": {
            "type": int,
            "format": "uint64",
        },
        "tlvs_discard": {
            "type": int,
            "format": "uint64",
        },
        "tlvs_unknown": {
            "type": int,
            "format": "uint64",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        name=None,
        frames_rx=None,
        frames_tx=None,
        frames_error_rx=None,
        frames_discard=None,
        tlvs_discard=None,
        tlvs_unknown=None,
    ):
        super(LldpMetric, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("frames_rx", frames_rx)
        self._set_property("frames_tx", frames_tx)
        self._set_property("frames_error_rx", frames_error_rx)
        self._set_property("frames_discard", frames_discard)
        self._set_property("tlvs_discard", tlvs_discard)
        self._set_property("tlvs_unknown", tlvs_unknown)

    def set(
        self,
        name=None,
        frames_rx=None,
        frames_tx=None,
        frames_error_rx=None,
        frames_discard=None,
        tlvs_discard=None,
        tlvs_unknown=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        The name of the configured LLDP instance.

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        The name of the configured LLDP instance.

        value: str
        """
        self._set_property("name", value)

    @property
    def frames_rx(self):
        # type: () -> int
        """frames_rx getter

        Number of LLDP frames received.

        Returns: int
        """
        return self._get_property("frames_rx")

    @frames_rx.setter
    def frames_rx(self, value):
        """frames_rx setter

        Number of LLDP frames received.

        value: int
        """
        self._set_property("frames_rx", value)

    @property
    def frames_tx(self):
        # type: () -> int
        """frames_tx getter

        Number of LLDP frames transmitted.

        Returns: int
        """
        return self._get_property("frames_tx")

    @frames_tx.setter
    def frames_tx(self, value):
        """frames_tx setter

        Number of LLDP frames transmitted.

        value: int
        """
        self._set_property("frames_tx", value)

    @property
    def frames_error_rx(self):
        # type: () -> int
        """frames_error_rx getter

        Number of LLDP frames received with packet errors. This stat should be incremented based on statsFramesInErrorsTotal increment rule in section 10.3.2 of IEEE Std 802.1 AB-2005.

        Returns: int
        """
        return self._get_property("frames_error_rx")

    @frames_error_rx.setter
    def frames_error_rx(self, value):
        """frames_error_rx setter

        Number of LLDP frames received with packet errors. This stat should be incremented based on statsFramesInErrorsTotal increment rule in section 10.3.2 of IEEE Std 802.1 AB-2005.

        value: int
        """
        self._set_property("frames_error_rx", value)

    @property
    def frames_discard(self):
        # type: () -> int
        """frames_discard getter

        Number of LLDP frames received that are discarded. This stat should be incremented when one or more of the three mandatory TLVs at the beginning of the LLDPDU is missing, out of order or contains an out of range information string length. This stat should follow the validation rules in section 10.3.2 of IEEE Std 802.1 AB-2005.

        Returns: int
        """
        return self._get_property("frames_discard")

    @frames_discard.setter
    def frames_discard(self, value):
        """frames_discard setter

        Number of LLDP frames received that are discarded. This stat should be incremented when one or more of the three mandatory TLVs at the beginning of the LLDPDU is missing, out of order or contains an out of range information string length. This stat should follow the validation rules in section 10.3.2 of IEEE Std 802.1 AB-2005.

        value: int
        """
        self._set_property("frames_discard", value)

    @property
    def tlvs_discard(self):
        # type: () -> int
        """tlvs_discard getter

        Number of LLDP tlvs received that are discarded. If any TLV contains an error condition specific for that particular TLV or if any TLV extends past the physical end of the frame then these TLVs will be discarded.

        Returns: int
        """
        return self._get_property("tlvs_discard")

    @tlvs_discard.setter
    def tlvs_discard(self, value):
        """tlvs_discard setter

        Number of LLDP tlvs received that are discarded. If any TLV contains an error condition specific for that particular TLV or if any TLV extends past the physical end of the frame then these TLVs will be discarded.

        value: int
        """
        self._set_property("tlvs_discard", value)

    @property
    def tlvs_unknown(self):
        # type: () -> int
        """tlvs_unknown getter

        Number of LLDP unknown tlvs received. If the OUI of the organizationlly specific TLV and/or organizationally defined subtype are not recognized,or if TLV type value is in the range of reserved TLV types then these TLVs will be considered as unknown TLVs.

        Returns: int
        """
        return self._get_property("tlvs_unknown")

    @tlvs_unknown.setter
    def tlvs_unknown(self, value):
        """tlvs_unknown setter

        Number of LLDP unknown tlvs received. If the OUI of the organizationlly specific TLV and/or organizationally defined subtype are not recognized,or if TLV type value is in the range of reserved TLV types then these TLVs will be considered as unknown TLVs.

        value: int
        """
        self._set_property("tlvs_unknown", value)


class LldpMetricIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(LldpMetricIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[LldpMetric]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> LldpMetricIter
        return self._iter()

    def __next__(self):
        # type: () -> LldpMetric
        return self._next()

    def next(self):
        # type: () -> LldpMetric
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, LldpMetric):
            raise Exception("Item is not an instance of LldpMetric")

    def metric(
        self,
        name=None,
        frames_rx=None,
        frames_tx=None,
        frames_error_rx=None,
        frames_discard=None,
        tlvs_discard=None,
        tlvs_unknown=None,
    ):
        # type: (str,int,int,int,int,int,int) -> LldpMetricIter
        """Factory method that creates an instance of the LldpMetric class

        LLDP per instance statistics information.

        Returns: LldpMetricIter
        """
        item = LldpMetric(
            parent=self._parent,
            name=name,
            frames_rx=frames_rx,
            frames_tx=frames_tx,
            frames_error_rx=frames_error_rx,
            frames_discard=frames_discard,
            tlvs_discard=tlvs_discard,
            tlvs_unknown=tlvs_unknown,
        )
        self._add(item)
        return self

    def add(
        self,
        name=None,
        frames_rx=None,
        frames_tx=None,
        frames_error_rx=None,
        frames_discard=None,
        tlvs_discard=None,
        tlvs_unknown=None,
    ):
        # type: (str,int,int,int,int,int,int) -> LldpMetric
        """Add method that creates and returns an instance of the LldpMetric class

        LLDP per instance statistics information.

        Returns: LldpMetric
        """
        item = LldpMetric(
            parent=self._parent,
            name=name,
            frames_rx=frames_rx,
            frames_tx=frames_tx,
            frames_error_rx=frames_error_rx,
            frames_discard=frames_discard,
            tlvs_discard=tlvs_discard,
            tlvs_unknown=tlvs_unknown,
        )
        self._add(item)
        return item


class RsvpMetric(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "name": {"type": str},
        "ingress_p2p_lsps_configured": {
            "type": int,
            "format": "uint32",
        },
        "ingress_p2p_lsps_up": {
            "type": int,
            "format": "uint32",
        },
        "egress_p2p_lsps_up": {
            "type": int,
            "format": "uint32",
        },
        "lsp_flap_count": {
            "type": int,
            "format": "uint64",
        },
        "paths_tx": {
            "type": int,
            "format": "uint64",
        },
        "paths_rx": {
            "type": int,
            "format": "uint64",
        },
        "resvs_tx": {
            "type": int,
            "format": "uint64",
        },
        "resvs_rx": {
            "type": int,
            "format": "uint64",
        },
        "path_tears_tx": {
            "type": int,
            "format": "uint64",
        },
        "path_tears_rx": {
            "type": int,
            "format": "uint64",
        },
        "resv_tears_tx": {
            "type": int,
            "format": "uint64",
        },
        "resv_tears_rx": {
            "type": int,
            "format": "uint64",
        },
        "path_errors_tx": {
            "type": int,
            "format": "uint64",
        },
        "path_errors_rx": {
            "type": int,
            "format": "uint64",
        },
        "resv_errors_tx": {
            "type": int,
            "format": "uint64",
        },
        "resv_errors_rx": {
            "type": int,
            "format": "uint64",
        },
        "resv_conf_tx": {
            "type": int,
            "format": "uint64",
        },
        "resv_conf_rx": {
            "type": int,
            "format": "uint64",
        },
        "hellos_tx": {
            "type": int,
            "format": "uint64",
        },
        "hellos_rx": {
            "type": int,
            "format": "uint64",
        },
        "acks_tx": {
            "type": int,
            "format": "uint64",
        },
        "acks_rx": {
            "type": int,
            "format": "uint64",
        },
        "nacks_tx": {
            "type": int,
            "format": "uint64",
        },
        "nacks_rx": {
            "type": int,
            "format": "uint64",
        },
        "srefresh_tx": {
            "type": int,
            "format": "uint64",
        },
        "srefresh_rx": {
            "type": int,
            "format": "uint64",
        },
        "bundle_tx": {
            "type": int,
            "format": "uint64",
        },
        "bundle_rx": {
            "type": int,
            "format": "uint64",
        },
        "path_reevaluation_request_tx": {
            "type": int,
            "format": "uint64",
        },
        "path_reoptimizations": {
            "type": int,
            "format": "uint64",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        name=None,
        ingress_p2p_lsps_configured=None,
        ingress_p2p_lsps_up=None,
        egress_p2p_lsps_up=None,
        lsp_flap_count=None,
        paths_tx=None,
        paths_rx=None,
        resvs_tx=None,
        resvs_rx=None,
        path_tears_tx=None,
        path_tears_rx=None,
        resv_tears_tx=None,
        resv_tears_rx=None,
        path_errors_tx=None,
        path_errors_rx=None,
        resv_errors_tx=None,
        resv_errors_rx=None,
        resv_conf_tx=None,
        resv_conf_rx=None,
        hellos_tx=None,
        hellos_rx=None,
        acks_tx=None,
        acks_rx=None,
        nacks_tx=None,
        nacks_rx=None,
        srefresh_tx=None,
        srefresh_rx=None,
        bundle_tx=None,
        bundle_rx=None,
        path_reevaluation_request_tx=None,
        path_reoptimizations=None,
    ):
        super(RsvpMetric, self).__init__()
        self._parent = parent
        self._set_property("name", name)
        self._set_property("ingress_p2p_lsps_configured", ingress_p2p_lsps_configured)
        self._set_property("ingress_p2p_lsps_up", ingress_p2p_lsps_up)
        self._set_property("egress_p2p_lsps_up", egress_p2p_lsps_up)
        self._set_property("lsp_flap_count", lsp_flap_count)
        self._set_property("paths_tx", paths_tx)
        self._set_property("paths_rx", paths_rx)
        self._set_property("resvs_tx", resvs_tx)
        self._set_property("resvs_rx", resvs_rx)
        self._set_property("path_tears_tx", path_tears_tx)
        self._set_property("path_tears_rx", path_tears_rx)
        self._set_property("resv_tears_tx", resv_tears_tx)
        self._set_property("resv_tears_rx", resv_tears_rx)
        self._set_property("path_errors_tx", path_errors_tx)
        self._set_property("path_errors_rx", path_errors_rx)
        self._set_property("resv_errors_tx", resv_errors_tx)
        self._set_property("resv_errors_rx", resv_errors_rx)
        self._set_property("resv_conf_tx", resv_conf_tx)
        self._set_property("resv_conf_rx", resv_conf_rx)
        self._set_property("hellos_tx", hellos_tx)
        self._set_property("hellos_rx", hellos_rx)
        self._set_property("acks_tx", acks_tx)
        self._set_property("acks_rx", acks_rx)
        self._set_property("nacks_tx", nacks_tx)
        self._set_property("nacks_rx", nacks_rx)
        self._set_property("srefresh_tx", srefresh_tx)
        self._set_property("srefresh_rx", srefresh_rx)
        self._set_property("bundle_tx", bundle_tx)
        self._set_property("bundle_rx", bundle_rx)
        self._set_property("path_reevaluation_request_tx", path_reevaluation_request_tx)
        self._set_property("path_reoptimizations", path_reoptimizations)

    def set(
        self,
        name=None,
        ingress_p2p_lsps_configured=None,
        ingress_p2p_lsps_up=None,
        egress_p2p_lsps_up=None,
        lsp_flap_count=None,
        paths_tx=None,
        paths_rx=None,
        resvs_tx=None,
        resvs_rx=None,
        path_tears_tx=None,
        path_tears_rx=None,
        resv_tears_tx=None,
        resv_tears_rx=None,
        path_errors_tx=None,
        path_errors_rx=None,
        resv_errors_tx=None,
        resv_errors_rx=None,
        resv_conf_tx=None,
        resv_conf_rx=None,
        hellos_tx=None,
        hellos_rx=None,
        acks_tx=None,
        acks_rx=None,
        nacks_tx=None,
        nacks_rx=None,
        srefresh_tx=None,
        srefresh_rx=None,
        bundle_tx=None,
        bundle_rx=None,
        path_reevaluation_request_tx=None,
        path_reoptimizations=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def name(self):
        # type: () -> str
        """name getter

        The name of configured RSVP router.

        Returns: str
        """
        return self._get_property("name")

    @name.setter
    def name(self, value):
        """name setter

        The name of configured RSVP router.

        value: str
        """
        self._set_property("name", value)

    @property
    def ingress_p2p_lsps_configured(self):
        # type: () -> int
        """ingress_p2p_lsps_configured getter

        The number of ingress point-to-point LSPs configured or transiting through the RSVP router which have been initated from the test port.

        Returns: int
        """
        return self._get_property("ingress_p2p_lsps_configured")

    @ingress_p2p_lsps_configured.setter
    def ingress_p2p_lsps_configured(self, value):
        """ingress_p2p_lsps_configured setter

        The number of ingress point-to-point LSPs configured or transiting through the RSVP router which have been initated from the test port.

        value: int
        """
        self._set_property("ingress_p2p_lsps_configured", value)

    @property
    def ingress_p2p_lsps_up(self):
        # type: () -> int
        """ingress_p2p_lsps_up getter

        The number of ingress point-to-point LSPs for which Resv has been received and is currently up.

        Returns: int
        """
        return self._get_property("ingress_p2p_lsps_up")

    @ingress_p2p_lsps_up.setter
    def ingress_p2p_lsps_up(self, value):
        """ingress_p2p_lsps_up setter

        The number of ingress point-to-point LSPs for which Resv has been received and is currently up.

        value: int
        """
        self._set_property("ingress_p2p_lsps_up", value)

    @property
    def egress_p2p_lsps_up(self):
        # type: () -> int
        """egress_p2p_lsps_up getter

        The number of egress point-to-point LSPs for which Path requests were successfully processed and is currently up.

        Returns: int
        """
        return self._get_property("egress_p2p_lsps_up")

    @egress_p2p_lsps_up.setter
    def egress_p2p_lsps_up(self, value):
        """egress_p2p_lsps_up setter

        The number of egress point-to-point LSPs for which Path requests were successfully processed and is currently up.

        value: int
        """
        self._set_property("egress_p2p_lsps_up", value)

    @property
    def lsp_flap_count(self):
        # type: () -> int
        """lsp_flap_count getter

        The number of times an LSP went from up to down state either because it timed out while waiting for Refreshes or PathTear or ResvTear message was received which caused the LSP to flap.

        Returns: int
        """
        return self._get_property("lsp_flap_count")

    @lsp_flap_count.setter
    def lsp_flap_count(self, value):
        """lsp_flap_count setter

        The number of times an LSP went from up to down state either because it timed out while waiting for Refreshes or PathTear or ResvTear message was received which caused the LSP to flap.

        value: int
        """
        self._set_property("lsp_flap_count", value)

    @property
    def paths_tx(self):
        # type: () -> int
        """paths_tx getter

        The number of Path messages sent by this RSVP router.

        Returns: int
        """
        return self._get_property("paths_tx")

    @paths_tx.setter
    def paths_tx(self, value):
        """paths_tx setter

        The number of Path messages sent by this RSVP router.

        value: int
        """
        self._set_property("paths_tx", value)

    @property
    def paths_rx(self):
        # type: () -> int
        """paths_rx getter

        The number of Path messages received by this RSVP router.

        Returns: int
        """
        return self._get_property("paths_rx")

    @paths_rx.setter
    def paths_rx(self, value):
        """paths_rx setter

        The number of Path messages received by this RSVP router.

        value: int
        """
        self._set_property("paths_rx", value)

    @property
    def resvs_tx(self):
        # type: () -> int
        """resvs_tx getter

        The number of Resv messages sent by this RSVP router.

        Returns: int
        """
        return self._get_property("resvs_tx")

    @resvs_tx.setter
    def resvs_tx(self, value):
        """resvs_tx setter

        The number of Resv messages sent by this RSVP router.

        value: int
        """
        self._set_property("resvs_tx", value)

    @property
    def resvs_rx(self):
        # type: () -> int
        """resvs_rx getter

        The number of Resv messages received by this RSVP router.

        Returns: int
        """
        return self._get_property("resvs_rx")

    @resvs_rx.setter
    def resvs_rx(self, value):
        """resvs_rx setter

        The number of Resv messages received by this RSVP router.

        value: int
        """
        self._set_property("resvs_rx", value)

    @property
    def path_tears_tx(self):
        # type: () -> int
        """path_tears_tx getter

        The number of Path Tear messages sent by this RSVP router.

        Returns: int
        """
        return self._get_property("path_tears_tx")

    @path_tears_tx.setter
    def path_tears_tx(self, value):
        """path_tears_tx setter

        The number of Path Tear messages sent by this RSVP router.

        value: int
        """
        self._set_property("path_tears_tx", value)

    @property
    def path_tears_rx(self):
        # type: () -> int
        """path_tears_rx getter

        The number of Path Tear messages received by this RSVP router.

        Returns: int
        """
        return self._get_property("path_tears_rx")

    @path_tears_rx.setter
    def path_tears_rx(self, value):
        """path_tears_rx setter

        The number of Path Tear messages received by this RSVP router.

        value: int
        """
        self._set_property("path_tears_rx", value)

    @property
    def resv_tears_tx(self):
        # type: () -> int
        """resv_tears_tx getter

        The number of Resv Tear messages sent by this RSVP router.

        Returns: int
        """
        return self._get_property("resv_tears_tx")

    @resv_tears_tx.setter
    def resv_tears_tx(self, value):
        """resv_tears_tx setter

        The number of Resv Tear messages sent by this RSVP router.

        value: int
        """
        self._set_property("resv_tears_tx", value)

    @property
    def resv_tears_rx(self):
        # type: () -> int
        """resv_tears_rx getter

        The number of Resv Tear messages received by this RSVP router.

        Returns: int
        """
        return self._get_property("resv_tears_rx")

    @resv_tears_rx.setter
    def resv_tears_rx(self, value):
        """resv_tears_rx setter

        The number of Resv Tear messages received by this RSVP router.

        value: int
        """
        self._set_property("resv_tears_rx", value)

    @property
    def path_errors_tx(self):
        # type: () -> int
        """path_errors_tx getter

        The number of Path Error messages sent by this RSVP router.

        Returns: int
        """
        return self._get_property("path_errors_tx")

    @path_errors_tx.setter
    def path_errors_tx(self, value):
        """path_errors_tx setter

        The number of Path Error messages sent by this RSVP router.

        value: int
        """
        self._set_property("path_errors_tx", value)

    @property
    def path_errors_rx(self):
        # type: () -> int
        """path_errors_rx getter

        The number of Path Error messages received by this RSVP router.

        Returns: int
        """
        return self._get_property("path_errors_rx")

    @path_errors_rx.setter
    def path_errors_rx(self, value):
        """path_errors_rx setter

        The number of Path Error messages received by this RSVP router.

        value: int
        """
        self._set_property("path_errors_rx", value)

    @property
    def resv_errors_tx(self):
        # type: () -> int
        """resv_errors_tx getter

        The number of Resv Error messages sent by this RSVP router.

        Returns: int
        """
        return self._get_property("resv_errors_tx")

    @resv_errors_tx.setter
    def resv_errors_tx(self, value):
        """resv_errors_tx setter

        The number of Resv Error messages sent by this RSVP router.

        value: int
        """
        self._set_property("resv_errors_tx", value)

    @property
    def resv_errors_rx(self):
        # type: () -> int
        """resv_errors_rx getter

        The number of Resv Error messages received by this RSVP router.

        Returns: int
        """
        return self._get_property("resv_errors_rx")

    @resv_errors_rx.setter
    def resv_errors_rx(self, value):
        """resv_errors_rx setter

        The number of Resv Error messages received by this RSVP router.

        value: int
        """
        self._set_property("resv_errors_rx", value)

    @property
    def resv_conf_tx(self):
        # type: () -> int
        """resv_conf_tx getter

        The number of ResvConf messages sent by this RSVP router.

        Returns: int
        """
        return self._get_property("resv_conf_tx")

    @resv_conf_tx.setter
    def resv_conf_tx(self, value):
        """resv_conf_tx setter

        The number of ResvConf messages sent by this RSVP router.

        value: int
        """
        self._set_property("resv_conf_tx", value)

    @property
    def resv_conf_rx(self):
        # type: () -> int
        """resv_conf_rx getter

        The number of ResvConf messages received by this RSVP router.

        Returns: int
        """
        return self._get_property("resv_conf_rx")

    @resv_conf_rx.setter
    def resv_conf_rx(self, value):
        """resv_conf_rx setter

        The number of ResvConf messages received by this RSVP router.

        value: int
        """
        self._set_property("resv_conf_rx", value)

    @property
    def hellos_tx(self):
        # type: () -> int
        """hellos_tx getter

        The number of Hello messages sent by this RSVP router.

        Returns: int
        """
        return self._get_property("hellos_tx")

    @hellos_tx.setter
    def hellos_tx(self, value):
        """hellos_tx setter

        The number of Hello messages sent by this RSVP router.

        value: int
        """
        self._set_property("hellos_tx", value)

    @property
    def hellos_rx(self):
        # type: () -> int
        """hellos_rx getter

        The number of Hello messages received by this RSVP router.

        Returns: int
        """
        return self._get_property("hellos_rx")

    @hellos_rx.setter
    def hellos_rx(self, value):
        """hellos_rx setter

        The number of Hello messages received by this RSVP router.

        value: int
        """
        self._set_property("hellos_rx", value)

    @property
    def acks_tx(self):
        # type: () -> int
        """acks_tx getter

        The number of Ack messages sent by this RSVP router.

        Returns: int
        """
        return self._get_property("acks_tx")

    @acks_tx.setter
    def acks_tx(self, value):
        """acks_tx setter

        The number of Ack messages sent by this RSVP router.

        value: int
        """
        self._set_property("acks_tx", value)

    @property
    def acks_rx(self):
        # type: () -> int
        """acks_rx getter

        The number of Ack messages received by this RSVP router.

        Returns: int
        """
        return self._get_property("acks_rx")

    @acks_rx.setter
    def acks_rx(self, value):
        """acks_rx setter

        The number of Ack messages received by this RSVP router.

        value: int
        """
        self._set_property("acks_rx", value)

    @property
    def nacks_tx(self):
        # type: () -> int
        """nacks_tx getter

        The number of Nack messages sent by this RSVP router.

        Returns: int
        """
        return self._get_property("nacks_tx")

    @nacks_tx.setter
    def nacks_tx(self, value):
        """nacks_tx setter

        The number of Nack messages sent by this RSVP router.

        value: int
        """
        self._set_property("nacks_tx", value)

    @property
    def nacks_rx(self):
        # type: () -> int
        """nacks_rx getter

        The number of Nack messages received by this RSVP router.

        Returns: int
        """
        return self._get_property("nacks_rx")

    @nacks_rx.setter
    def nacks_rx(self, value):
        """nacks_rx setter

        The number of Nack messages received by this RSVP router.

        value: int
        """
        self._set_property("nacks_rx", value)

    @property
    def srefresh_tx(self):
        # type: () -> int
        """srefresh_tx getter

        The number of SRefresh messages sent by this RSVP router.

        Returns: int
        """
        return self._get_property("srefresh_tx")

    @srefresh_tx.setter
    def srefresh_tx(self, value):
        """srefresh_tx setter

        The number of SRefresh messages sent by this RSVP router.

        value: int
        """
        self._set_property("srefresh_tx", value)

    @property
    def srefresh_rx(self):
        # type: () -> int
        """srefresh_rx getter

        The number of SRefresh messages received by this RSVP router.

        Returns: int
        """
        return self._get_property("srefresh_rx")

    @srefresh_rx.setter
    def srefresh_rx(self, value):
        """srefresh_rx setter

        The number of SRefresh messages received by this RSVP router.

        value: int
        """
        self._set_property("srefresh_rx", value)

    @property
    def bundle_tx(self):
        # type: () -> int
        """bundle_tx getter

        The number of Bundle messages sent by this RSVP router.

        Returns: int
        """
        return self._get_property("bundle_tx")

    @bundle_tx.setter
    def bundle_tx(self, value):
        """bundle_tx setter

        The number of Bundle messages sent by this RSVP router.

        value: int
        """
        self._set_property("bundle_tx", value)

    @property
    def bundle_rx(self):
        # type: () -> int
        """bundle_rx getter

        The number of Bundle messages received by this RSVP router.

        Returns: int
        """
        return self._get_property("bundle_rx")

    @bundle_rx.setter
    def bundle_rx(self, value):
        """bundle_rx setter

        The number of Bundle messages received by this RSVP router.

        value: int
        """
        self._set_property("bundle_rx", value)

    @property
    def path_reevaluation_request_tx(self):
        # type: () -> int
        """path_reevaluation_request_tx getter

        The number of Path messages with Path Re-evaluation Request enabled sent by this RSVP router.

        Returns: int
        """
        return self._get_property("path_reevaluation_request_tx")

    @path_reevaluation_request_tx.setter
    def path_reevaluation_request_tx(self, value):
        """path_reevaluation_request_tx setter

        The number of Path messages with Path Re-evaluation Request enabled sent by this RSVP router.

        value: int
        """
        self._set_property("path_reevaluation_request_tx", value)

    @property
    def path_reoptimizations(self):
        # type: () -> int
        """path_reoptimizations getter

        The number of successfully completed Make-Before-Break operations on LSPs on this RSVP router.

        Returns: int
        """
        return self._get_property("path_reoptimizations")

    @path_reoptimizations.setter
    def path_reoptimizations(self, value):
        """path_reoptimizations setter

        The number of successfully completed Make-Before-Break operations on LSPs on this RSVP router.

        value: int
        """
        self._set_property("path_reoptimizations", value)


class RsvpMetricIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(RsvpMetricIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[RsvpMetric]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> RsvpMetricIter
        return self._iter()

    def __next__(self):
        # type: () -> RsvpMetric
        return self._next()

    def next(self):
        # type: () -> RsvpMetric
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, RsvpMetric):
            raise Exception("Item is not an instance of RsvpMetric")

    def metric(
        self,
        name=None,
        ingress_p2p_lsps_configured=None,
        ingress_p2p_lsps_up=None,
        egress_p2p_lsps_up=None,
        lsp_flap_count=None,
        paths_tx=None,
        paths_rx=None,
        resvs_tx=None,
        resvs_rx=None,
        path_tears_tx=None,
        path_tears_rx=None,
        resv_tears_tx=None,
        resv_tears_rx=None,
        path_errors_tx=None,
        path_errors_rx=None,
        resv_errors_tx=None,
        resv_errors_rx=None,
        resv_conf_tx=None,
        resv_conf_rx=None,
        hellos_tx=None,
        hellos_rx=None,
        acks_tx=None,
        acks_rx=None,
        nacks_tx=None,
        nacks_rx=None,
        srefresh_tx=None,
        srefresh_rx=None,
        bundle_tx=None,
        bundle_rx=None,
        path_reevaluation_request_tx=None,
        path_reoptimizations=None,
    ):
        # type: (str,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int) -> RsvpMetricIter
        """Factory method that creates an instance of the RsvpMetric class

        RSVP-TE per router statistics information.

        Returns: RsvpMetricIter
        """
        item = RsvpMetric(
            parent=self._parent,
            name=name,
            ingress_p2p_lsps_configured=ingress_p2p_lsps_configured,
            ingress_p2p_lsps_up=ingress_p2p_lsps_up,
            egress_p2p_lsps_up=egress_p2p_lsps_up,
            lsp_flap_count=lsp_flap_count,
            paths_tx=paths_tx,
            paths_rx=paths_rx,
            resvs_tx=resvs_tx,
            resvs_rx=resvs_rx,
            path_tears_tx=path_tears_tx,
            path_tears_rx=path_tears_rx,
            resv_tears_tx=resv_tears_tx,
            resv_tears_rx=resv_tears_rx,
            path_errors_tx=path_errors_tx,
            path_errors_rx=path_errors_rx,
            resv_errors_tx=resv_errors_tx,
            resv_errors_rx=resv_errors_rx,
            resv_conf_tx=resv_conf_tx,
            resv_conf_rx=resv_conf_rx,
            hellos_tx=hellos_tx,
            hellos_rx=hellos_rx,
            acks_tx=acks_tx,
            acks_rx=acks_rx,
            nacks_tx=nacks_tx,
            nacks_rx=nacks_rx,
            srefresh_tx=srefresh_tx,
            srefresh_rx=srefresh_rx,
            bundle_tx=bundle_tx,
            bundle_rx=bundle_rx,
            path_reevaluation_request_tx=path_reevaluation_request_tx,
            path_reoptimizations=path_reoptimizations,
        )
        self._add(item)
        return self

    def add(
        self,
        name=None,
        ingress_p2p_lsps_configured=None,
        ingress_p2p_lsps_up=None,
        egress_p2p_lsps_up=None,
        lsp_flap_count=None,
        paths_tx=None,
        paths_rx=None,
        resvs_tx=None,
        resvs_rx=None,
        path_tears_tx=None,
        path_tears_rx=None,
        resv_tears_tx=None,
        resv_tears_rx=None,
        path_errors_tx=None,
        path_errors_rx=None,
        resv_errors_tx=None,
        resv_errors_rx=None,
        resv_conf_tx=None,
        resv_conf_rx=None,
        hellos_tx=None,
        hellos_rx=None,
        acks_tx=None,
        acks_rx=None,
        nacks_tx=None,
        nacks_rx=None,
        srefresh_tx=None,
        srefresh_rx=None,
        bundle_tx=None,
        bundle_rx=None,
        path_reevaluation_request_tx=None,
        path_reoptimizations=None,
    ):
        # type: (str,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int) -> RsvpMetric
        """Add method that creates and returns an instance of the RsvpMetric class

        RSVP-TE per router statistics information.

        Returns: RsvpMetric
        """
        item = RsvpMetric(
            parent=self._parent,
            name=name,
            ingress_p2p_lsps_configured=ingress_p2p_lsps_configured,
            ingress_p2p_lsps_up=ingress_p2p_lsps_up,
            egress_p2p_lsps_up=egress_p2p_lsps_up,
            lsp_flap_count=lsp_flap_count,
            paths_tx=paths_tx,
            paths_rx=paths_rx,
            resvs_tx=resvs_tx,
            resvs_rx=resvs_rx,
            path_tears_tx=path_tears_tx,
            path_tears_rx=path_tears_rx,
            resv_tears_tx=resv_tears_tx,
            resv_tears_rx=resv_tears_rx,
            path_errors_tx=path_errors_tx,
            path_errors_rx=path_errors_rx,
            resv_errors_tx=resv_errors_tx,
            resv_errors_rx=resv_errors_rx,
            resv_conf_tx=resv_conf_tx,
            resv_conf_rx=resv_conf_rx,
            hellos_tx=hellos_tx,
            hellos_rx=hellos_rx,
            acks_tx=acks_tx,
            acks_rx=acks_rx,
            nacks_tx=nacks_tx,
            nacks_rx=nacks_rx,
            srefresh_tx=srefresh_tx,
            srefresh_rx=srefresh_rx,
            bundle_tx=bundle_tx,
            bundle_rx=bundle_rx,
            path_reevaluation_request_tx=path_reevaluation_request_tx,
            path_reoptimizations=path_reoptimizations,
        )
        self._add(item)
        return item


class StatesRequest(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "ipv4_neighbors",
                "ipv6_neighbors",
                "bgp_prefixes",
                "isis_lsps",
                "lldp_neighbors",
                "rsvp_lsps",
            ],
        },
        "ipv4_neighbors": {"type": "Neighborsv4StatesRequest"},
        "ipv6_neighbors": {"type": "Neighborsv6StatesRequest"},
        "bgp_prefixes": {"type": "BgpPrefixStateRequest"},
        "isis_lsps": {"type": "IsisLspsStateRequest"},
        "lldp_neighbors": {"type": "LldpNeighborsStateRequest"},
        "rsvp_lsps": {"type": "RsvpLspsStateRequest"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "ipv4_neighbors",
    }  # type: Dict[str, Union(type)]

    IPV4_NEIGHBORS = "ipv4_neighbors"  # type: str
    IPV6_NEIGHBORS = "ipv6_neighbors"  # type: str
    BGP_PREFIXES = "bgp_prefixes"  # type: str
    ISIS_LSPS = "isis_lsps"  # type: str
    LLDP_NEIGHBORS = "lldp_neighbors"  # type: str
    RSVP_LSPS = "rsvp_lsps"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None):
        super(StatesRequest, self).__init__()
        self._parent = parent
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    @property
    def ipv4_neighbors(self):
        # type: () -> Neighborsv4StatesRequest
        """Factory property that returns an instance of the Neighborsv4StatesRequest class

        The request to retrieve IPv4 Neighbor state (ARP cache entries) of network interface(s).

        Returns: Neighborsv4StatesRequest
        """
        return self._get_property(
            "ipv4_neighbors", Neighborsv4StatesRequest, self, "ipv4_neighbors"
        )

    @property
    def ipv6_neighbors(self):
        # type: () -> Neighborsv6StatesRequest
        """Factory property that returns an instance of the Neighborsv6StatesRequest class

        The request to retrieve IPv6 Neighbor state (NDISC cache entries) of network interface(s).

        Returns: Neighborsv6StatesRequest
        """
        return self._get_property(
            "ipv6_neighbors", Neighborsv6StatesRequest, self, "ipv6_neighbors"
        )

    @property
    def bgp_prefixes(self):
        # type: () -> BgpPrefixStateRequest
        """Factory property that returns an instance of the BgpPrefixStateRequest class

        The request to retrieve BGP peer prefix information.

        Returns: BgpPrefixStateRequest
        """
        return self._get_property(
            "bgp_prefixes", BgpPrefixStateRequest, self, "bgp_prefixes"
        )

    @property
    def isis_lsps(self):
        # type: () -> IsisLspsStateRequest
        """Factory property that returns an instance of the IsisLspsStateRequest class

        The request to retrieve ISIS Link State PDU (LSP) information learned by the router.

        Returns: IsisLspsStateRequest
        """
        return self._get_property("isis_lsps", IsisLspsStateRequest, self, "isis_lsps")

    @property
    def lldp_neighbors(self):
        # type: () -> LldpNeighborsStateRequest
        """Factory property that returns an instance of the LldpNeighborsStateRequest class

        The request to retrieve LLDP neighbor information for given instance.

        Returns: LldpNeighborsStateRequest
        """
        return self._get_property(
            "lldp_neighbors", LldpNeighborsStateRequest, self, "lldp_neighbors"
        )

    @property
    def rsvp_lsps(self):
        # type: () -> RsvpLspsStateRequest
        """Factory property that returns an instance of the RsvpLspsStateRequest class

        The request to retrieve RSVP Label Switched Path (LSP) information learned by the router.

        Returns: RsvpLspsStateRequest
        """
        return self._get_property("rsvp_lsps", RsvpLspsStateRequest, self, "rsvp_lsps")

    @property
    def choice(self):
        # type: () -> Union[Literal["bgp_prefixes"], Literal["ipv4_neighbors"], Literal["ipv6_neighbors"], Literal["isis_lsps"], Literal["lldp_neighbors"], Literal["rsvp_lsps"]]
        """choice getter

        TBD

        Returns: Union[Literal["bgp_prefixes"], Literal["ipv4_neighbors"], Literal["ipv6_neighbors"], Literal["isis_lsps"], Literal["lldp_neighbors"], Literal["rsvp_lsps"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["bgp_prefixes"], Literal["ipv4_neighbors"], Literal["ipv6_neighbors"], Literal["isis_lsps"], Literal["lldp_neighbors"], Literal["rsvp_lsps"]]
        """
        self._set_property("choice", value)


class Neighborsv4StatesRequest(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "ethernet_names": {
            "type": list,
            "itemtype": str,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, ethernet_names=None):
        super(Neighborsv4StatesRequest, self).__init__()
        self._parent = parent
        self._set_property("ethernet_names", ethernet_names)

    def set(self, ethernet_names=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def ethernet_names(self):
        # type: () -> List[str]
        """ethernet_names getter

        The names of Ethernet interfaces for which Neighbor state (ARP cache entries) will be retrieved. If no names are specified then the results will contain Neighbor state (ARP cache entries) for all available Ethernet interfaces.. x-constraint:. /components/schemas/Device.Ethernet/properties/name. . x-constraint:. /components/schemas/Device.Ethernet/properties/name.

        Returns: List[str]
        """
        return self._get_property("ethernet_names")

    @ethernet_names.setter
    def ethernet_names(self, value):
        """ethernet_names setter

        The names of Ethernet interfaces for which Neighbor state (ARP cache entries) will be retrieved. If no names are specified then the results will contain Neighbor state (ARP cache entries) for all available Ethernet interfaces.. x-constraint:. /components/schemas/Device.Ethernet/properties/name. . x-constraint:. /components/schemas/Device.Ethernet/properties/name.

        value: List[str]
        """
        self._set_property("ethernet_names", value)


class Neighborsv6StatesRequest(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "ethernet_names": {
            "type": list,
            "itemtype": str,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, ethernet_names=None):
        super(Neighborsv6StatesRequest, self).__init__()
        self._parent = parent
        self._set_property("ethernet_names", ethernet_names)

    def set(self, ethernet_names=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def ethernet_names(self):
        # type: () -> List[str]
        """ethernet_names getter

        The names of Ethernet interfaces for which Neighbor state (NDISC cache entries) will be retrieved. If no names are specified then the results will contain Neighbor state (NDISC cache entries) for all available Ethernet interfaces.. x-constraint:. /components/schemas/Device.Ethernet/properties/name. . x-constraint:. /components/schemas/Device.Ethernet/properties/name.

        Returns: List[str]
        """
        return self._get_property("ethernet_names")

    @ethernet_names.setter
    def ethernet_names(self, value):
        """ethernet_names setter

        The names of Ethernet interfaces for which Neighbor state (NDISC cache entries) will be retrieved. If no names are specified then the results will contain Neighbor state (NDISC cache entries) for all available Ethernet interfaces.. x-constraint:. /components/schemas/Device.Ethernet/properties/name. . x-constraint:. /components/schemas/Device.Ethernet/properties/name.

        value: List[str]
        """
        self._set_property("ethernet_names", value)


class BgpPrefixStateRequest(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "bgp_peer_names": {
            "type": list,
            "itemtype": str,
        },
        "prefix_filters": {
            "type": list,
            "enum": [
                "ipv4_unicast",
                "ipv6_unicast",
            ],
            "itemtype": str,
        },
        "ipv4_unicast_filters": {"type": "BgpPrefixIpv4UnicastFilterIter"},
        "ipv6_unicast_filters": {"type": "BgpPrefixIpv6UnicastFilterIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    IPV4_UNICAST = "ipv4_unicast"  # type: str
    IPV6_UNICAST = "ipv6_unicast"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, bgp_peer_names=None, prefix_filters=None):
        super(BgpPrefixStateRequest, self).__init__()
        self._parent = parent
        self._set_property("bgp_peer_names", bgp_peer_names)
        self._set_property("prefix_filters", prefix_filters)

    def set(self, bgp_peer_names=None, prefix_filters=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def bgp_peer_names(self):
        # type: () -> List[str]
        """bgp_peer_names getter

        The names of BGP peers for which prefix information will be retrieved. If no names are specified then the results will contain prefix information for all configured BGP peers.. x-constraint:. /components/schemas/Bgp.V4Peer/properties/name. /components/schemas/Bgp.V6Peer/properties/name. . x-constraint:. /components/schemas/Bgp.V4Peer/properties/name. /components/schemas/Bgp.V6Peer/properties/name.

        Returns: List[str]
        """
        return self._get_property("bgp_peer_names")

    @bgp_peer_names.setter
    def bgp_peer_names(self, value):
        """bgp_peer_names setter

        The names of BGP peers for which prefix information will be retrieved. If no names are specified then the results will contain prefix information for all configured BGP peers.. x-constraint:. /components/schemas/Bgp.V4Peer/properties/name. /components/schemas/Bgp.V6Peer/properties/name. . x-constraint:. /components/schemas/Bgp.V4Peer/properties/name. /components/schemas/Bgp.V6Peer/properties/name.

        value: List[str]
        """
        self._set_property("bgp_peer_names", value)

    @property
    def prefix_filters(self):
        # type: () -> List[Union[Literal["ipv4_unicast"], Literal["ipv6_unicast"]]]
        """prefix_filters getter

        Specify which prefixes to return. If the list is empty or missing then all prefixes will be returned.

        Returns: List[Union[Literal["ipv4_unicast"], Literal["ipv6_unicast"]]]
        """
        return self._get_property("prefix_filters")

    @prefix_filters.setter
    def prefix_filters(self, value):
        """prefix_filters setter

        Specify which prefixes to return. If the list is empty or missing then all prefixes will be returned.

        value: List[Union[Literal["ipv4_unicast"], Literal["ipv6_unicast"]]]
        """
        self._set_property("prefix_filters", value)

    @property
    def ipv4_unicast_filters(self):
        # type: () -> BgpPrefixIpv4UnicastFilterIter
        """ipv4_unicast_filters getter

        The IPv4 unicast results can be filtered by specifying additional prefix search criteria. If the ipv4_unicast_filters property is missing or empty then all IPv4 prefixes will be returned.

        Returns: BgpPrefixIpv4UnicastFilterIter
        """
        return self._get_property(
            "ipv4_unicast_filters",
            BgpPrefixIpv4UnicastFilterIter,
            self._parent,
            self._choice,
        )

    @property
    def ipv6_unicast_filters(self):
        # type: () -> BgpPrefixIpv6UnicastFilterIter
        """ipv6_unicast_filters getter

        The IPv6 unicast results can be filtered by specifying additional prefix search criteria. If the ipv6_unicast_filters property is missing or empty then all IPv6 prefixes will be returned.

        Returns: BgpPrefixIpv6UnicastFilterIter
        """
        return self._get_property(
            "ipv6_unicast_filters",
            BgpPrefixIpv6UnicastFilterIter,
            self._parent,
            self._choice,
        )


class BgpPrefixIpv4UnicastFilter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "addresses": {
            "type": list,
            "itemtype": str,
            "itemformat": "ipv4",
        },
        "prefix_length": {
            "type": int,
            "format": "uint32",
            "maximum": 128,
        },
        "origin": {
            "type": str,
            "enum": [
                "igp",
                "egp",
                "incomplete",
            ],
        },
        "path_id": {
            "type": int,
            "format": "uint32",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    IGP = "igp"  # type: str
    EGP = "egp"  # type: str
    INCOMPLETE = "incomplete"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self, parent=None, addresses=None, prefix_length=None, origin=None, path_id=None
    ):
        super(BgpPrefixIpv4UnicastFilter, self).__init__()
        self._parent = parent
        self._set_property("addresses", addresses)
        self._set_property("prefix_length", prefix_length)
        self._set_property("origin", origin)
        self._set_property("path_id", path_id)

    def set(self, addresses=None, prefix_length=None, origin=None, path_id=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def addresses(self):
        # type: () -> List[str]
        """addresses getter

        The addresses to match. If the addresses property is missing or empty then all addresses will match.

        Returns: List[str]
        """
        return self._get_property("addresses")

    @addresses.setter
    def addresses(self, value):
        """addresses setter

        The addresses to match. If the addresses property is missing or empty then all addresses will match.

        value: List[str]
        """
        self._set_property("addresses", value)

    @property
    def prefix_length(self):
        # type: () -> int
        """prefix_length getter

        The prefix length to match. If the prefix length is missing then all prefix lengths will match.

        Returns: int
        """
        return self._get_property("prefix_length")

    @prefix_length.setter
    def prefix_length(self, value):
        """prefix_length setter

        The prefix length to match. If the prefix length is missing then all prefix lengths will match.

        value: int
        """
        self._set_property("prefix_length", value)

    @property
    def origin(self):
        # type: () -> Union[Literal["egp"], Literal["igp"], Literal["incomplete"]]
        """origin getter

        The origin to match. If the origin is missing then all origins will match.

        Returns: Union[Literal["egp"], Literal["igp"], Literal["incomplete"]]
        """
        return self._get_property("origin")

    @origin.setter
    def origin(self, value):
        """origin setter

        The origin to match. If the origin is missing then all origins will match.

        value: Union[Literal["egp"], Literal["igp"], Literal["incomplete"]]
        """
        self._set_property("origin", value)

    @property
    def path_id(self):
        # type: () -> int
        """path_id getter

        The path id to match. If the path id is missing then all path ids will match.

        Returns: int
        """
        return self._get_property("path_id")

    @path_id.setter
    def path_id(self, value):
        """path_id setter

        The path id to match. If the path id is missing then all path ids will match.

        value: int
        """
        self._set_property("path_id", value)


class BgpPrefixIpv4UnicastFilterIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(BgpPrefixIpv4UnicastFilterIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[BgpPrefixIpv4UnicastFilter]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> BgpPrefixIpv4UnicastFilterIter
        return self._iter()

    def __next__(self):
        # type: () -> BgpPrefixIpv4UnicastFilter
        return self._next()

    def next(self):
        # type: () -> BgpPrefixIpv4UnicastFilter
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, BgpPrefixIpv4UnicastFilter):
            raise Exception("Item is not an instance of BgpPrefixIpv4UnicastFilter")

    def filter(self, addresses=None, prefix_length=None, origin=None, path_id=None):
        # type: (List[str],int,Union[Literal["egp"], Literal["igp"], Literal["incomplete"]],int) -> BgpPrefixIpv4UnicastFilterIter
        """Factory method that creates an instance of the BgpPrefixIpv4UnicastFilter class

        TBD

        Returns: BgpPrefixIpv4UnicastFilterIter
        """
        item = BgpPrefixIpv4UnicastFilter(
            parent=self._parent,
            addresses=addresses,
            prefix_length=prefix_length,
            origin=origin,
            path_id=path_id,
        )
        self._add(item)
        return self

    def add(self, addresses=None, prefix_length=None, origin=None, path_id=None):
        # type: (List[str],int,Union[Literal["egp"], Literal["igp"], Literal["incomplete"]],int) -> BgpPrefixIpv4UnicastFilter
        """Add method that creates and returns an instance of the BgpPrefixIpv4UnicastFilter class

        TBD

        Returns: BgpPrefixIpv4UnicastFilter
        """
        item = BgpPrefixIpv4UnicastFilter(
            parent=self._parent,
            addresses=addresses,
            prefix_length=prefix_length,
            origin=origin,
            path_id=path_id,
        )
        self._add(item)
        return item


class BgpPrefixIpv6UnicastFilter(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "addresses": {
            "type": list,
            "itemtype": str,
            "itemformat": "ipv6",
        },
        "prefix_length": {
            "type": int,
            "format": "uint32",
            "maximum": 128,
        },
        "origin": {
            "type": str,
            "enum": [
                "igp",
                "egp",
                "incomplete",
            ],
        },
        "path_id": {
            "type": int,
            "format": "uint32",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    IGP = "igp"  # type: str
    EGP = "egp"  # type: str
    INCOMPLETE = "incomplete"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self, parent=None, addresses=None, prefix_length=None, origin=None, path_id=None
    ):
        super(BgpPrefixIpv6UnicastFilter, self).__init__()
        self._parent = parent
        self._set_property("addresses", addresses)
        self._set_property("prefix_length", prefix_length)
        self._set_property("origin", origin)
        self._set_property("path_id", path_id)

    def set(self, addresses=None, prefix_length=None, origin=None, path_id=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def addresses(self):
        # type: () -> List[str]
        """addresses getter

        The addresses to match. If the addresses property is missing or empty then all addresses will match.

        Returns: List[str]
        """
        return self._get_property("addresses")

    @addresses.setter
    def addresses(self, value):
        """addresses setter

        The addresses to match. If the addresses property is missing or empty then all addresses will match.

        value: List[str]
        """
        self._set_property("addresses", value)

    @property
    def prefix_length(self):
        # type: () -> int
        """prefix_length getter

        The prefix length to match. If the prefix length is missing then all prefix lengths will match.

        Returns: int
        """
        return self._get_property("prefix_length")

    @prefix_length.setter
    def prefix_length(self, value):
        """prefix_length setter

        The prefix length to match. If the prefix length is missing then all prefix lengths will match.

        value: int
        """
        self._set_property("prefix_length", value)

    @property
    def origin(self):
        # type: () -> Union[Literal["egp"], Literal["igp"], Literal["incomplete"]]
        """origin getter

        The origin to match. If the origin is missing then all origins will match.

        Returns: Union[Literal["egp"], Literal["igp"], Literal["incomplete"]]
        """
        return self._get_property("origin")

    @origin.setter
    def origin(self, value):
        """origin setter

        The origin to match. If the origin is missing then all origins will match.

        value: Union[Literal["egp"], Literal["igp"], Literal["incomplete"]]
        """
        self._set_property("origin", value)

    @property
    def path_id(self):
        # type: () -> int
        """path_id getter

        The path id to match. If the path id is missing then all path ids will match.

        Returns: int
        """
        return self._get_property("path_id")

    @path_id.setter
    def path_id(self, value):
        """path_id setter

        The path id to match. If the path id is missing then all path ids will match.

        value: int
        """
        self._set_property("path_id", value)


class BgpPrefixIpv6UnicastFilterIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(BgpPrefixIpv6UnicastFilterIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[BgpPrefixIpv6UnicastFilter]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> BgpPrefixIpv6UnicastFilterIter
        return self._iter()

    def __next__(self):
        # type: () -> BgpPrefixIpv6UnicastFilter
        return self._next()

    def next(self):
        # type: () -> BgpPrefixIpv6UnicastFilter
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, BgpPrefixIpv6UnicastFilter):
            raise Exception("Item is not an instance of BgpPrefixIpv6UnicastFilter")

    def filter(self, addresses=None, prefix_length=None, origin=None, path_id=None):
        # type: (List[str],int,Union[Literal["egp"], Literal["igp"], Literal["incomplete"]],int) -> BgpPrefixIpv6UnicastFilterIter
        """Factory method that creates an instance of the BgpPrefixIpv6UnicastFilter class

        TBD

        Returns: BgpPrefixIpv6UnicastFilterIter
        """
        item = BgpPrefixIpv6UnicastFilter(
            parent=self._parent,
            addresses=addresses,
            prefix_length=prefix_length,
            origin=origin,
            path_id=path_id,
        )
        self._add(item)
        return self

    def add(self, addresses=None, prefix_length=None, origin=None, path_id=None):
        # type: (List[str],int,Union[Literal["egp"], Literal["igp"], Literal["incomplete"]],int) -> BgpPrefixIpv6UnicastFilter
        """Add method that creates and returns an instance of the BgpPrefixIpv6UnicastFilter class

        TBD

        Returns: BgpPrefixIpv6UnicastFilter
        """
        item = BgpPrefixIpv6UnicastFilter(
            parent=self._parent,
            addresses=addresses,
            prefix_length=prefix_length,
            origin=origin,
            path_id=path_id,
        )
        self._add(item)
        return item


class IsisLspsStateRequest(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "isis_router_names": {
            "type": list,
            "itemtype": str,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, isis_router_names=None):
        super(IsisLspsStateRequest, self).__init__()
        self._parent = parent
        self._set_property("isis_router_names", isis_router_names)

    def set(self, isis_router_names=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def isis_router_names(self):
        # type: () -> List[str]
        """isis_router_names getter

        The names of ISIS routers for which learned information is requested. An empty list will return results for all ISIS routers.. x-constraint:. /components/schemas/Device.IsisRouter/properties/name. . x-constraint:. /components/schemas/Device.IsisRouter/properties/name.

        Returns: List[str]
        """
        return self._get_property("isis_router_names")

    @isis_router_names.setter
    def isis_router_names(self, value):
        """isis_router_names setter

        The names of ISIS routers for which learned information is requested. An empty list will return results for all ISIS routers.. x-constraint:. /components/schemas/Device.IsisRouter/properties/name. . x-constraint:. /components/schemas/Device.IsisRouter/properties/name.

        value: List[str]
        """
        self._set_property("isis_router_names", value)


class LldpNeighborsStateRequest(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "lldp_names": {
            "type": list,
            "itemtype": str,
        },
        "neighbor_id_filters": {
            "type": list,
            "itemtype": str,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, lldp_names=None, neighbor_id_filters=None):
        super(LldpNeighborsStateRequest, self).__init__()
        self._parent = parent
        self._set_property("lldp_names", lldp_names)
        self._set_property("neighbor_id_filters", neighbor_id_filters)

    def set(self, lldp_names=None, neighbor_id_filters=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def lldp_names(self):
        # type: () -> List[str]
        """lldp_names getter

        The names of LLDP instances for which neighbor information will be retrieved. If no names are specified then the results will contain neighbor information for all configured LLDP instances.. x-constraint:. /components/schemas/Lldp/properties/name. . x-constraint:. /components/schemas/Lldp/properties/name.

        Returns: List[str]
        """
        return self._get_property("lldp_names")

    @lldp_names.setter
    def lldp_names(self, value):
        """lldp_names setter

        The names of LLDP instances for which neighbor information will be retrieved. If no names are specified then the results will contain neighbor information for all configured LLDP instances.. x-constraint:. /components/schemas/Lldp/properties/name. . x-constraint:. /components/schemas/Lldp/properties/name.

        value: List[str]
        """
        self._set_property("lldp_names", value)

    @property
    def neighbor_id_filters(self):
        # type: () -> List[str]
        """neighbor_id_filters getter

        Specify the neighbors for which information will be returned. If empty or missing then information for all neighbors will be returned.

        Returns: List[str]
        """
        return self._get_property("neighbor_id_filters")

    @neighbor_id_filters.setter
    def neighbor_id_filters(self, value):
        """neighbor_id_filters setter

        Specify the neighbors for which information will be returned. If empty or missing then information for all neighbors will be returned.

        value: List[str]
        """
        self._set_property("neighbor_id_filters", value)


class RsvpLspsStateRequest(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "rsvp_router_names": {
            "type": list,
            "itemtype": str,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, rsvp_router_names=None):
        super(RsvpLspsStateRequest, self).__init__()
        self._parent = parent
        self._set_property("rsvp_router_names", rsvp_router_names)

    def set(self, rsvp_router_names=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def rsvp_router_names(self):
        # type: () -> List[str]
        """rsvp_router_names getter

        The names of RSVP-TE routers for which learned information is requested. An empty list will return results for all RSVP=TE routers.. x-constraint:. /components/schemas/Device.Rsvp/properties/name. . x-constraint:. /components/schemas/Device.Rsvp/properties/name.

        Returns: List[str]
        """
        return self._get_property("rsvp_router_names")

    @rsvp_router_names.setter
    def rsvp_router_names(self, value):
        """rsvp_router_names setter

        The names of RSVP-TE routers for which learned information is requested. An empty list will return results for all RSVP=TE routers.. x-constraint:. /components/schemas/Device.Rsvp/properties/name. . x-constraint:. /components/schemas/Device.Rsvp/properties/name.

        value: List[str]
        """
        self._set_property("rsvp_router_names", value)


class StatesResponse(OpenApiObject):
    __slots__ = ("_parent", "_choice")

    _TYPES = {
        "choice": {
            "type": str,
            "enum": [
                "ipv4_neighbors",
                "ipv6_neighbors",
                "bgp_prefixes",
                "isis_lsps",
                "lldp_neighbors",
                "rsvp_lsps",
            ],
        },
        "ipv4_neighbors": {"type": "Neighborsv4StateIter"},
        "ipv6_neighbors": {"type": "Neighborsv6StateIter"},
        "bgp_prefixes": {"type": "BgpPrefixesStateIter"},
        "isis_lsps": {"type": "IsisLspsStateIter"},
        "lldp_neighbors": {"type": "LldpNeighborsStateIter"},
        "rsvp_lsps": {"type": "RsvpLspsStateIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "choice": "ipv4_neighbors",
    }  # type: Dict[str, Union(type)]

    IPV4_NEIGHBORS = "ipv4_neighbors"  # type: str
    IPV6_NEIGHBORS = "ipv6_neighbors"  # type: str
    BGP_PREFIXES = "bgp_prefixes"  # type: str
    ISIS_LSPS = "isis_lsps"  # type: str
    LLDP_NEIGHBORS = "lldp_neighbors"  # type: str
    RSVP_LSPS = "rsvp_lsps"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, choice=None):
        super(StatesResponse, self).__init__()
        self._parent = parent
        if (
            "choice" in self._DEFAULTS
            and choice is None
            and self._DEFAULTS["choice"] in self._TYPES
        ):
            getattr(self, self._DEFAULTS["choice"])
        else:
            self._set_property("choice", choice)

    @property
    def choice(self):
        # type: () -> Union[Literal["bgp_prefixes"], Literal["ipv4_neighbors"], Literal["ipv6_neighbors"], Literal["isis_lsps"], Literal["lldp_neighbors"], Literal["rsvp_lsps"]]
        """choice getter

        TBD

        Returns: Union[Literal["bgp_prefixes"], Literal["ipv4_neighbors"], Literal["ipv6_neighbors"], Literal["isis_lsps"], Literal["lldp_neighbors"], Literal["rsvp_lsps"]]
        """
        return self._get_property("choice")

    @choice.setter
    def choice(self, value):
        """choice setter

        TBD

        value: Union[Literal["bgp_prefixes"], Literal["ipv4_neighbors"], Literal["ipv6_neighbors"], Literal["isis_lsps"], Literal["lldp_neighbors"], Literal["rsvp_lsps"]]
        """
        self._set_property("choice", value)

    @property
    def ipv4_neighbors(self):
        # type: () -> Neighborsv4StateIter
        """ipv4_neighbors getter

        TBD

        Returns: Neighborsv4StateIter
        """
        return self._get_property(
            "ipv4_neighbors", Neighborsv4StateIter, self._parent, self._choice
        )

    @property
    def ipv6_neighbors(self):
        # type: () -> Neighborsv6StateIter
        """ipv6_neighbors getter

        TBD

        Returns: Neighborsv6StateIter
        """
        return self._get_property(
            "ipv6_neighbors", Neighborsv6StateIter, self._parent, self._choice
        )

    @property
    def bgp_prefixes(self):
        # type: () -> BgpPrefixesStateIter
        """bgp_prefixes getter

        TBD

        Returns: BgpPrefixesStateIter
        """
        return self._get_property(
            "bgp_prefixes", BgpPrefixesStateIter, self._parent, self._choice
        )

    @property
    def isis_lsps(self):
        # type: () -> IsisLspsStateIter
        """isis_lsps getter

        TBD

        Returns: IsisLspsStateIter
        """
        return self._get_property(
            "isis_lsps", IsisLspsStateIter, self._parent, self._choice
        )

    @property
    def lldp_neighbors(self):
        # type: () -> LldpNeighborsStateIter
        """lldp_neighbors getter

        TBD

        Returns: LldpNeighborsStateIter
        """
        return self._get_property(
            "lldp_neighbors", LldpNeighborsStateIter, self._parent, self._choice
        )

    @property
    def rsvp_lsps(self):
        # type: () -> RsvpLspsStateIter
        """rsvp_lsps getter

        TBD

        Returns: RsvpLspsStateIter
        """
        return self._get_property(
            "rsvp_lsps", RsvpLspsStateIter, self._parent, self._choice
        )


class Neighborsv4State(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "ethernet_name": {"type": str},
        "ipv4_address": {
            "type": str,
            "format": "ipv4",
        },
        "link_layer_address": {
            "type": str,
            "format": "mac",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("ethernet_name", "ipv4_address")  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        ethernet_name=None,
        ipv4_address=None,
        link_layer_address=None,
    ):
        super(Neighborsv4State, self).__init__()
        self._parent = parent
        self._set_property("ethernet_name", ethernet_name)
        self._set_property("ipv4_address", ipv4_address)
        self._set_property("link_layer_address", link_layer_address)

    def set(self, ethernet_name=None, ipv4_address=None, link_layer_address=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def ethernet_name(self):
        # type: () -> str
        """ethernet_name getter

        The name of the Ethernet interface associated with the Neighbor state (ARP cache entry).

        Returns: str
        """
        return self._get_property("ethernet_name")

    @ethernet_name.setter
    def ethernet_name(self, value):
        """ethernet_name setter

        The name of the Ethernet interface associated with the Neighbor state (ARP cache entry).

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property ethernet_name as None")
        self._set_property("ethernet_name", value)

    @property
    def ipv4_address(self):
        # type: () -> str
        """ipv4_address getter

        The IPv4 address of the neighbor.

        Returns: str
        """
        return self._get_property("ipv4_address")

    @ipv4_address.setter
    def ipv4_address(self, value):
        """ipv4_address setter

        The IPv4 address of the neighbor.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property ipv4_address as None")
        self._set_property("ipv4_address", value)

    @property
    def link_layer_address(self):
        # type: () -> str
        """link_layer_address getter

        The link-layer address (MAC) of the neighbor.

        Returns: str
        """
        return self._get_property("link_layer_address")

    @link_layer_address.setter
    def link_layer_address(self, value):
        """link_layer_address setter

        The link-layer address (MAC) of the neighbor.

        value: str
        """
        self._set_property("link_layer_address", value)


class Neighborsv4StateIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(Neighborsv4StateIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[Neighborsv4State]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> Neighborsv4StateIter
        return self._iter()

    def __next__(self):
        # type: () -> Neighborsv4State
        return self._next()

    def next(self):
        # type: () -> Neighborsv4State
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, Neighborsv4State):
            raise Exception("Item is not an instance of Neighborsv4State")

    def state(self, ethernet_name=None, ipv4_address=None, link_layer_address=None):
        # type: (str,str,str) -> Neighborsv4StateIter
        """Factory method that creates an instance of the Neighborsv4State class

        IPv4 Neighbor state (ARP cache entry).

        Returns: Neighborsv4StateIter
        """
        item = Neighborsv4State(
            parent=self._parent,
            ethernet_name=ethernet_name,
            ipv4_address=ipv4_address,
            link_layer_address=link_layer_address,
        )
        self._add(item)
        return self

    def add(self, ethernet_name=None, ipv4_address=None, link_layer_address=None):
        # type: (str,str,str) -> Neighborsv4State
        """Add method that creates and returns an instance of the Neighborsv4State class

        IPv4 Neighbor state (ARP cache entry).

        Returns: Neighborsv4State
        """
        item = Neighborsv4State(
            parent=self._parent,
            ethernet_name=ethernet_name,
            ipv4_address=ipv4_address,
            link_layer_address=link_layer_address,
        )
        self._add(item)
        return item


class Neighborsv6State(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "ethernet_name": {"type": str},
        "ipv6_address": {
            "type": str,
            "format": "ipv6",
        },
        "link_layer_address": {
            "type": str,
            "format": "mac",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ("ethernet_name", "ipv6_address")  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        ethernet_name=None,
        ipv6_address=None,
        link_layer_address=None,
    ):
        super(Neighborsv6State, self).__init__()
        self._parent = parent
        self._set_property("ethernet_name", ethernet_name)
        self._set_property("ipv6_address", ipv6_address)
        self._set_property("link_layer_address", link_layer_address)

    def set(self, ethernet_name=None, ipv6_address=None, link_layer_address=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def ethernet_name(self):
        # type: () -> str
        """ethernet_name getter

        The name of the Ethernet interface associated with the Neighbor state (NDISC cache entry).

        Returns: str
        """
        return self._get_property("ethernet_name")

    @ethernet_name.setter
    def ethernet_name(self, value):
        """ethernet_name setter

        The name of the Ethernet interface associated with the Neighbor state (NDISC cache entry).

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property ethernet_name as None")
        self._set_property("ethernet_name", value)

    @property
    def ipv6_address(self):
        # type: () -> str
        """ipv6_address getter

        The IPv6 address of the neighbor.

        Returns: str
        """
        return self._get_property("ipv6_address")

    @ipv6_address.setter
    def ipv6_address(self, value):
        """ipv6_address setter

        The IPv6 address of the neighbor.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property ipv6_address as None")
        self._set_property("ipv6_address", value)

    @property
    def link_layer_address(self):
        # type: () -> str
        """link_layer_address getter

        The link-layer address (MAC) of the neighbor.

        Returns: str
        """
        return self._get_property("link_layer_address")

    @link_layer_address.setter
    def link_layer_address(self, value):
        """link_layer_address setter

        The link-layer address (MAC) of the neighbor.

        value: str
        """
        self._set_property("link_layer_address", value)


class Neighborsv6StateIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(Neighborsv6StateIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[Neighborsv6State]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> Neighborsv6StateIter
        return self._iter()

    def __next__(self):
        # type: () -> Neighborsv6State
        return self._next()

    def next(self):
        # type: () -> Neighborsv6State
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, Neighborsv6State):
            raise Exception("Item is not an instance of Neighborsv6State")

    def state(self, ethernet_name=None, ipv6_address=None, link_layer_address=None):
        # type: (str,str,str) -> Neighborsv6StateIter
        """Factory method that creates an instance of the Neighborsv6State class

        IPv6 Neighbor state (NDISC cache entry).

        Returns: Neighborsv6StateIter
        """
        item = Neighborsv6State(
            parent=self._parent,
            ethernet_name=ethernet_name,
            ipv6_address=ipv6_address,
            link_layer_address=link_layer_address,
        )
        self._add(item)
        return self

    def add(self, ethernet_name=None, ipv6_address=None, link_layer_address=None):
        # type: (str,str,str) -> Neighborsv6State
        """Add method that creates and returns an instance of the Neighborsv6State class

        IPv6 Neighbor state (NDISC cache entry).

        Returns: Neighborsv6State
        """
        item = Neighborsv6State(
            parent=self._parent,
            ethernet_name=ethernet_name,
            ipv6_address=ipv6_address,
            link_layer_address=link_layer_address,
        )
        self._add(item)
        return item


class BgpPrefixesState(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "bgp_peer_name": {"type": str},
        "ipv4_unicast_prefixes": {"type": "BgpPrefixIpv4UnicastStateIter"},
        "ipv6_unicast_prefixes": {"type": "BgpPrefixIpv6UnicastStateIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, bgp_peer_name=None):
        super(BgpPrefixesState, self).__init__()
        self._parent = parent
        self._set_property("bgp_peer_name", bgp_peer_name)

    def set(self, bgp_peer_name=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def bgp_peer_name(self):
        # type: () -> str
        """bgp_peer_name getter

        The name of BGP peer.

        Returns: str
        """
        return self._get_property("bgp_peer_name")

    @bgp_peer_name.setter
    def bgp_peer_name(self, value):
        """bgp_peer_name setter

        The name of BGP peer.

        value: str
        """
        self._set_property("bgp_peer_name", value)

    @property
    def ipv4_unicast_prefixes(self):
        # type: () -> BgpPrefixIpv4UnicastStateIter
        """ipv4_unicast_prefixes getter

        TBD

        Returns: BgpPrefixIpv4UnicastStateIter
        """
        return self._get_property(
            "ipv4_unicast_prefixes",
            BgpPrefixIpv4UnicastStateIter,
            self._parent,
            self._choice,
        )

    @property
    def ipv6_unicast_prefixes(self):
        # type: () -> BgpPrefixIpv6UnicastStateIter
        """ipv6_unicast_prefixes getter

        TBD

        Returns: BgpPrefixIpv6UnicastStateIter
        """
        return self._get_property(
            "ipv6_unicast_prefixes",
            BgpPrefixIpv6UnicastStateIter,
            self._parent,
            self._choice,
        )


class BgpPrefixIpv4UnicastState(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "ipv4_address": {"type": str},
        "prefix_length": {
            "type": int,
            "format": "uint32",
            "maximum": 128,
        },
        "origin": {
            "type": str,
            "enum": [
                "igp",
                "egp",
                "incomplete",
            ],
        },
        "path_id": {
            "type": int,
            "format": "uint32",
        },
        "ipv4_next_hop": {
            "type": str,
            "format": "ipv4",
        },
        "ipv6_next_hop": {
            "type": str,
            "format": "ipv6",
        },
        "communities": {"type": "ResultBgpCommunityIter"},
        "as_path": {"type": "ResultBgpAsPath"},
        "local_preference": {
            "type": int,
            "format": "uint32",
        },
        "multi_exit_discriminator": {
            "type": int,
            "format": "uint32",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    IGP = "igp"  # type: str
    EGP = "egp"  # type: str
    INCOMPLETE = "incomplete"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        ipv4_address=None,
        prefix_length=None,
        origin=None,
        path_id=None,
        ipv4_next_hop=None,
        ipv6_next_hop=None,
        local_preference=None,
        multi_exit_discriminator=None,
    ):
        super(BgpPrefixIpv4UnicastState, self).__init__()
        self._parent = parent
        self._set_property("ipv4_address", ipv4_address)
        self._set_property("prefix_length", prefix_length)
        self._set_property("origin", origin)
        self._set_property("path_id", path_id)
        self._set_property("ipv4_next_hop", ipv4_next_hop)
        self._set_property("ipv6_next_hop", ipv6_next_hop)
        self._set_property("local_preference", local_preference)
        self._set_property("multi_exit_discriminator", multi_exit_discriminator)

    def set(
        self,
        ipv4_address=None,
        prefix_length=None,
        origin=None,
        path_id=None,
        ipv4_next_hop=None,
        ipv6_next_hop=None,
        local_preference=None,
        multi_exit_discriminator=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def ipv4_address(self):
        # type: () -> str
        """ipv4_address getter

        An IPv4 unicast address

        Returns: str
        """
        return self._get_property("ipv4_address")

    @ipv4_address.setter
    def ipv4_address(self, value):
        """ipv4_address setter

        An IPv4 unicast address

        value: str
        """
        self._set_property("ipv4_address", value)

    @property
    def prefix_length(self):
        # type: () -> int
        """prefix_length getter

        The length of the prefix.

        Returns: int
        """
        return self._get_property("prefix_length")

    @prefix_length.setter
    def prefix_length(self, value):
        """prefix_length setter

        The length of the prefix.

        value: int
        """
        self._set_property("prefix_length", value)

    @property
    def origin(self):
        # type: () -> Union[Literal["egp"], Literal["igp"], Literal["incomplete"]]
        """origin getter

        The origin of the prefix.

        Returns: Union[Literal["egp"], Literal["igp"], Literal["incomplete"]]
        """
        return self._get_property("origin")

    @origin.setter
    def origin(self, value):
        """origin setter

        The origin of the prefix.

        value: Union[Literal["egp"], Literal["igp"], Literal["incomplete"]]
        """
        self._set_property("origin", value)

    @property
    def path_id(self):
        # type: () -> int
        """path_id getter

        The path id.

        Returns: int
        """
        return self._get_property("path_id")

    @path_id.setter
    def path_id(self, value):
        """path_id setter

        The path id.

        value: int
        """
        self._set_property("path_id", value)

    @property
    def ipv4_next_hop(self):
        # type: () -> str
        """ipv4_next_hop getter

        The IPv4 address of the egress interface.

        Returns: str
        """
        return self._get_property("ipv4_next_hop")

    @ipv4_next_hop.setter
    def ipv4_next_hop(self, value):
        """ipv4_next_hop setter

        The IPv4 address of the egress interface.

        value: str
        """
        self._set_property("ipv4_next_hop", value)

    @property
    def ipv6_next_hop(self):
        # type: () -> str
        """ipv6_next_hop getter

        The IPv6 address of the egress interface.

        Returns: str
        """
        return self._get_property("ipv6_next_hop")

    @ipv6_next_hop.setter
    def ipv6_next_hop(self, value):
        """ipv6_next_hop setter

        The IPv6 address of the egress interface.

        value: str
        """
        self._set_property("ipv6_next_hop", value)

    @property
    def communities(self):
        # type: () -> ResultBgpCommunityIter
        """communities getter

        Optional community attributes.

        Returns: ResultBgpCommunityIter
        """
        return self._get_property(
            "communities", ResultBgpCommunityIter, self._parent, self._choice
        )

    @property
    def as_path(self):
        # type: () -> ResultBgpAsPath
        """as_path getter

        This attribute identifies the autonomous systems through which routing information carried in this UPDATE message has passed.This attribute identifies the autonomous systems through which routing information carried in this UPDATE message has passed.This attribute identifies the autonomous systems through which routing information carried in this UPDATE message has passed.

        Returns: ResultBgpAsPath
        """
        return self._get_property("as_path", ResultBgpAsPath)

    @property
    def local_preference(self):
        # type: () -> int
        """local_preference getter

        The local preference is well-known attribute and the value is used for route selection. The route with the highest local preference value is preferred.

        Returns: int
        """
        return self._get_property("local_preference")

    @local_preference.setter
    def local_preference(self, value):
        """local_preference setter

        The local preference is well-known attribute and the value is used for route selection. The route with the highest local preference value is preferred.

        value: int
        """
        self._set_property("local_preference", value)

    @property
    def multi_exit_discriminator(self):
        # type: () -> int
        """multi_exit_discriminator getter

        The multi exit discriminator (MED) is an optional non-transitive attribute and the value is used for route selection. The route with the lowest MED value is preferred.

        Returns: int
        """
        return self._get_property("multi_exit_discriminator")

    @multi_exit_discriminator.setter
    def multi_exit_discriminator(self, value):
        """multi_exit_discriminator setter

        The multi exit discriminator (MED) is an optional non-transitive attribute and the value is used for route selection. The route with the lowest MED value is preferred.

        value: int
        """
        self._set_property("multi_exit_discriminator", value)


class ResultBgpCommunity(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "type": {
            "type": str,
            "enum": [
                "manual_as_number",
                "no_export",
                "no_advertised",
                "no_export_subconfed",
                "llgr_stale",
                "no_llgr",
            ],
        },
        "as_number": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "as_custom": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    MANUAL_AS_NUMBER = "manual_as_number"  # type: str
    NO_EXPORT = "no_export"  # type: str
    NO_ADVERTISED = "no_advertised"  # type: str
    NO_EXPORT_SUBCONFED = "no_export_subconfed"  # type: str
    LLGR_STALE = "llgr_stale"  # type: str
    NO_LLGR = "no_llgr"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, type=None, as_number=None, as_custom=None):
        super(ResultBgpCommunity, self).__init__()
        self._parent = parent
        self._set_property("type", type)
        self._set_property("as_number", as_number)
        self._set_property("as_custom", as_custom)

    def set(self, type=None, as_number=None, as_custom=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def type(self):
        # type: () -> Union[Literal["llgr_stale"], Literal["manual_as_number"], Literal["no_advertised"], Literal["no_export"], Literal["no_export_subconfed"], Literal["no_llgr"]]
        """type getter

        The type of community AS number. If community type is manual_as_number then as_number and as_custom will be available.

        Returns: Union[Literal["llgr_stale"], Literal["manual_as_number"], Literal["no_advertised"], Literal["no_export"], Literal["no_export_subconfed"], Literal["no_llgr"]]
        """
        return self._get_property("type")

    @type.setter
    def type(self, value):
        """type setter

        The type of community AS number. If community type is manual_as_number then as_number and as_custom will be available.

        value: Union[Literal["llgr_stale"], Literal["manual_as_number"], Literal["no_advertised"], Literal["no_export"], Literal["no_export_subconfed"], Literal["no_llgr"]]
        """
        self._set_property("type", value)

    @property
    def as_number(self):
        # type: () -> int
        """as_number getter

        First two octets of 32 bit community AS number.

        Returns: int
        """
        return self._get_property("as_number")

    @as_number.setter
    def as_number(self, value):
        """as_number setter

        First two octets of 32 bit community AS number.

        value: int
        """
        self._set_property("as_number", value)

    @property
    def as_custom(self):
        # type: () -> int
        """as_custom getter

        Last two octets of the community value.

        Returns: int
        """
        return self._get_property("as_custom")

    @as_custom.setter
    def as_custom(self, value):
        """as_custom setter

        Last two octets of the community value.

        value: int
        """
        self._set_property("as_custom", value)


class ResultBgpCommunityIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(ResultBgpCommunityIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[ResultBgpCommunity]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> ResultBgpCommunityIter
        return self._iter()

    def __next__(self):
        # type: () -> ResultBgpCommunity
        return self._next()

    def next(self):
        # type: () -> ResultBgpCommunity
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, ResultBgpCommunity):
            raise Exception("Item is not an instance of ResultBgpCommunity")

    def bgpcommunity(self, type=None, as_number=None, as_custom=None):
        # type: (Union[Literal["llgr_stale"], Literal["manual_as_number"], Literal["no_advertised"], Literal["no_export"], Literal["no_export_subconfed"], Literal["no_llgr"]],int,int) -> ResultBgpCommunityIter
        """Factory method that creates an instance of the ResultBgpCommunity class

        BGP communities provide additional capability for tagging routes and for modifying BGP routing policy on upstream and downstream routers. BGP community is 32-bit number which is broken into 16-bit AS number and 16-bit custom value.

        Returns: ResultBgpCommunityIter
        """
        item = ResultBgpCommunity(
            parent=self._parent, type=type, as_number=as_number, as_custom=as_custom
        )
        self._add(item)
        return self

    def add(self, type=None, as_number=None, as_custom=None):
        # type: (Union[Literal["llgr_stale"], Literal["manual_as_number"], Literal["no_advertised"], Literal["no_export"], Literal["no_export_subconfed"], Literal["no_llgr"]],int,int) -> ResultBgpCommunity
        """Add method that creates and returns an instance of the ResultBgpCommunity class

        BGP communities provide additional capability for tagging routes and for modifying BGP routing policy on upstream and downstream routers. BGP community is 32-bit number which is broken into 16-bit AS number and 16-bit custom value.

        Returns: ResultBgpCommunity
        """
        item = ResultBgpCommunity(
            parent=self._parent, type=type, as_number=as_number, as_custom=as_custom
        )
        self._add(item)
        return item


class ResultBgpAsPath(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "segments": {"type": "ResultBgpAsPathSegmentIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None):
        super(ResultBgpAsPath, self).__init__()
        self._parent = parent

    @property
    def segments(self):
        # type: () -> ResultBgpAsPathSegmentIter
        """segments getter

        AS Path segments present in the received AS Path attribute.

        Returns: ResultBgpAsPathSegmentIter
        """
        return self._get_property(
            "segments", ResultBgpAsPathSegmentIter, self._parent, self._choice
        )


class ResultBgpAsPathSegment(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "type": {
            "type": str,
            "enum": [
                "as_seq",
                "as_set",
                "as_confed_seq",
                "as_confed_set",
            ],
        },
        "as_numbers": {
            "type": list,
            "itemtype": int,
            "itemformat": "uint32",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    AS_SEQ = "as_seq"  # type: str
    AS_SET = "as_set"  # type: str
    AS_CONFED_SEQ = "as_confed_seq"  # type: str
    AS_CONFED_SET = "as_confed_set"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, type=None, as_numbers=None):
        super(ResultBgpAsPathSegment, self).__init__()
        self._parent = parent
        self._set_property("type", type)
        self._set_property("as_numbers", as_numbers)

    def set(self, type=None, as_numbers=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def type(self):
        # type: () -> Union[Literal["as_confed_seq"], Literal["as_confed_set"], Literal["as_seq"], Literal["as_set"]]
        """type getter

        AS sequence is the most common type of AS_PATH, it contains the list of ASNs starting with the most recent ASN being added read from left to right.. The other three AS_PATH types are used for Confederations AS_SET is the type of AS_PATH attribute that summarizes routes using using the aggregate-address command, allowing AS_PATHs to be summarized in the update as well. AS_CONFED_SEQ gives the list of ASNs in the path starting with the most recent ASN to be added reading left to right AS_CONFED_SET will allow summarization of multiple AS PATHs to be sent in BGP Updates.

        Returns: Union[Literal["as_confed_seq"], Literal["as_confed_set"], Literal["as_seq"], Literal["as_set"]]
        """
        return self._get_property("type")

    @type.setter
    def type(self, value):
        """type setter

        AS sequence is the most common type of AS_PATH, it contains the list of ASNs starting with the most recent ASN being added read from left to right.. The other three AS_PATH types are used for Confederations AS_SET is the type of AS_PATH attribute that summarizes routes using using the aggregate-address command, allowing AS_PATHs to be summarized in the update as well. AS_CONFED_SEQ gives the list of ASNs in the path starting with the most recent ASN to be added reading left to right AS_CONFED_SET will allow summarization of multiple AS PATHs to be sent in BGP Updates.

        value: Union[Literal["as_confed_seq"], Literal["as_confed_set"], Literal["as_seq"], Literal["as_set"]]
        """
        self._set_property("type", value)

    @property
    def as_numbers(self):
        # type: () -> List[int]
        """as_numbers getter

        The AS numbers in this AS path segment.

        Returns: List[int]
        """
        return self._get_property("as_numbers")

    @as_numbers.setter
    def as_numbers(self, value):
        """as_numbers setter

        The AS numbers in this AS path segment.

        value: List[int]
        """
        self._set_property("as_numbers", value)


class ResultBgpAsPathSegmentIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(ResultBgpAsPathSegmentIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[ResultBgpAsPathSegment]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> ResultBgpAsPathSegmentIter
        return self._iter()

    def __next__(self):
        # type: () -> ResultBgpAsPathSegment
        return self._next()

    def next(self):
        # type: () -> ResultBgpAsPathSegment
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, ResultBgpAsPathSegment):
            raise Exception("Item is not an instance of ResultBgpAsPathSegment")

    def bgpaspathsegment(self, type=None, as_numbers=None):
        # type: (Union[Literal["as_confed_seq"], Literal["as_confed_set"], Literal["as_seq"], Literal["as_set"]],List[int]) -> ResultBgpAsPathSegmentIter
        """Factory method that creates an instance of the ResultBgpAsPathSegment class

        Configuration for single BGP AS path segment

        Returns: ResultBgpAsPathSegmentIter
        """
        item = ResultBgpAsPathSegment(
            parent=self._parent, type=type, as_numbers=as_numbers
        )
        self._add(item)
        return self

    def add(self, type=None, as_numbers=None):
        # type: (Union[Literal["as_confed_seq"], Literal["as_confed_set"], Literal["as_seq"], Literal["as_set"]],List[int]) -> ResultBgpAsPathSegment
        """Add method that creates and returns an instance of the ResultBgpAsPathSegment class

        Configuration for single BGP AS path segment

        Returns: ResultBgpAsPathSegment
        """
        item = ResultBgpAsPathSegment(
            parent=self._parent, type=type, as_numbers=as_numbers
        )
        self._add(item)
        return item


class BgpPrefixIpv4UnicastStateIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(BgpPrefixIpv4UnicastStateIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[BgpPrefixIpv4UnicastState]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> BgpPrefixIpv4UnicastStateIter
        return self._iter()

    def __next__(self):
        # type: () -> BgpPrefixIpv4UnicastState
        return self._next()

    def next(self):
        # type: () -> BgpPrefixIpv4UnicastState
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, BgpPrefixIpv4UnicastState):
            raise Exception("Item is not an instance of BgpPrefixIpv4UnicastState")

    def state(
        self,
        ipv4_address=None,
        prefix_length=None,
        origin=None,
        path_id=None,
        ipv4_next_hop=None,
        ipv6_next_hop=None,
        local_preference=None,
        multi_exit_discriminator=None,
    ):
        # type: (str,int,Union[Literal["egp"], Literal["igp"], Literal["incomplete"]],int,str,str,int,int) -> BgpPrefixIpv4UnicastStateIter
        """Factory method that creates an instance of the BgpPrefixIpv4UnicastState class

        IPv4 unicast prefix.

        Returns: BgpPrefixIpv4UnicastStateIter
        """
        item = BgpPrefixIpv4UnicastState(
            parent=self._parent,
            ipv4_address=ipv4_address,
            prefix_length=prefix_length,
            origin=origin,
            path_id=path_id,
            ipv4_next_hop=ipv4_next_hop,
            ipv6_next_hop=ipv6_next_hop,
            local_preference=local_preference,
            multi_exit_discriminator=multi_exit_discriminator,
        )
        self._add(item)
        return self

    def add(
        self,
        ipv4_address=None,
        prefix_length=None,
        origin=None,
        path_id=None,
        ipv4_next_hop=None,
        ipv6_next_hop=None,
        local_preference=None,
        multi_exit_discriminator=None,
    ):
        # type: (str,int,Union[Literal["egp"], Literal["igp"], Literal["incomplete"]],int,str,str,int,int) -> BgpPrefixIpv4UnicastState
        """Add method that creates and returns an instance of the BgpPrefixIpv4UnicastState class

        IPv4 unicast prefix.

        Returns: BgpPrefixIpv4UnicastState
        """
        item = BgpPrefixIpv4UnicastState(
            parent=self._parent,
            ipv4_address=ipv4_address,
            prefix_length=prefix_length,
            origin=origin,
            path_id=path_id,
            ipv4_next_hop=ipv4_next_hop,
            ipv6_next_hop=ipv6_next_hop,
            local_preference=local_preference,
            multi_exit_discriminator=multi_exit_discriminator,
        )
        self._add(item)
        return item


class BgpPrefixIpv6UnicastState(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "ipv6_address": {"type": str},
        "prefix_length": {
            "type": int,
            "format": "uint32",
            "maximum": 128,
        },
        "origin": {
            "type": str,
            "enum": [
                "igp",
                "egp",
                "incomplete",
            ],
        },
        "path_id": {
            "type": int,
            "format": "uint32",
        },
        "ipv4_next_hop": {
            "type": str,
            "format": "ipv4",
        },
        "ipv6_next_hop": {
            "type": str,
            "format": "ipv6",
        },
        "communities": {"type": "ResultBgpCommunityIter"},
        "as_path": {"type": "ResultBgpAsPath"},
        "local_preference": {
            "type": int,
            "format": "uint32",
        },
        "multi_exit_discriminator": {
            "type": int,
            "format": "uint32",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    IGP = "igp"  # type: str
    EGP = "egp"  # type: str
    INCOMPLETE = "incomplete"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        ipv6_address=None,
        prefix_length=None,
        origin=None,
        path_id=None,
        ipv4_next_hop=None,
        ipv6_next_hop=None,
        local_preference=None,
        multi_exit_discriminator=None,
    ):
        super(BgpPrefixIpv6UnicastState, self).__init__()
        self._parent = parent
        self._set_property("ipv6_address", ipv6_address)
        self._set_property("prefix_length", prefix_length)
        self._set_property("origin", origin)
        self._set_property("path_id", path_id)
        self._set_property("ipv4_next_hop", ipv4_next_hop)
        self._set_property("ipv6_next_hop", ipv6_next_hop)
        self._set_property("local_preference", local_preference)
        self._set_property("multi_exit_discriminator", multi_exit_discriminator)

    def set(
        self,
        ipv6_address=None,
        prefix_length=None,
        origin=None,
        path_id=None,
        ipv4_next_hop=None,
        ipv6_next_hop=None,
        local_preference=None,
        multi_exit_discriminator=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def ipv6_address(self):
        # type: () -> str
        """ipv6_address getter

        An IPv6 unicast address

        Returns: str
        """
        return self._get_property("ipv6_address")

    @ipv6_address.setter
    def ipv6_address(self, value):
        """ipv6_address setter

        An IPv6 unicast address

        value: str
        """
        self._set_property("ipv6_address", value)

    @property
    def prefix_length(self):
        # type: () -> int
        """prefix_length getter

        The length of the prefix.

        Returns: int
        """
        return self._get_property("prefix_length")

    @prefix_length.setter
    def prefix_length(self, value):
        """prefix_length setter

        The length of the prefix.

        value: int
        """
        self._set_property("prefix_length", value)

    @property
    def origin(self):
        # type: () -> Union[Literal["egp"], Literal["igp"], Literal["incomplete"]]
        """origin getter

        The origin of the prefix.

        Returns: Union[Literal["egp"], Literal["igp"], Literal["incomplete"]]
        """
        return self._get_property("origin")

    @origin.setter
    def origin(self, value):
        """origin setter

        The origin of the prefix.

        value: Union[Literal["egp"], Literal["igp"], Literal["incomplete"]]
        """
        self._set_property("origin", value)

    @property
    def path_id(self):
        # type: () -> int
        """path_id getter

        The path id.

        Returns: int
        """
        return self._get_property("path_id")

    @path_id.setter
    def path_id(self, value):
        """path_id setter

        The path id.

        value: int
        """
        self._set_property("path_id", value)

    @property
    def ipv4_next_hop(self):
        # type: () -> str
        """ipv4_next_hop getter

        The IPv4 address of the egress interface.

        Returns: str
        """
        return self._get_property("ipv4_next_hop")

    @ipv4_next_hop.setter
    def ipv4_next_hop(self, value):
        """ipv4_next_hop setter

        The IPv4 address of the egress interface.

        value: str
        """
        self._set_property("ipv4_next_hop", value)

    @property
    def ipv6_next_hop(self):
        # type: () -> str
        """ipv6_next_hop getter

        The IPv6 address of the egress interface.

        Returns: str
        """
        return self._get_property("ipv6_next_hop")

    @ipv6_next_hop.setter
    def ipv6_next_hop(self, value):
        """ipv6_next_hop setter

        The IPv6 address of the egress interface.

        value: str
        """
        self._set_property("ipv6_next_hop", value)

    @property
    def communities(self):
        # type: () -> ResultBgpCommunityIter
        """communities getter

        Optional community attributes.

        Returns: ResultBgpCommunityIter
        """
        return self._get_property(
            "communities", ResultBgpCommunityIter, self._parent, self._choice
        )

    @property
    def as_path(self):
        # type: () -> ResultBgpAsPath
        """as_path getter

        This attribute identifies the autonomous systems through which routing information carried in this UPDATE message has passed.This attribute identifies the autonomous systems through which routing information carried in this UPDATE message has passed.This attribute identifies the autonomous systems through which routing information carried in this UPDATE message has passed.

        Returns: ResultBgpAsPath
        """
        return self._get_property("as_path", ResultBgpAsPath)

    @property
    def local_preference(self):
        # type: () -> int
        """local_preference getter

        The local preference is well-known attribute and the value is used for route selection. The route with the highest local preference value is preferred.

        Returns: int
        """
        return self._get_property("local_preference")

    @local_preference.setter
    def local_preference(self, value):
        """local_preference setter

        The local preference is well-known attribute and the value is used for route selection. The route with the highest local preference value is preferred.

        value: int
        """
        self._set_property("local_preference", value)

    @property
    def multi_exit_discriminator(self):
        # type: () -> int
        """multi_exit_discriminator getter

        The multi exit discriminator (MED) is an optional non-transitive attribute and the value is used for route selection. The route with the lowest MED value is preferred.

        Returns: int
        """
        return self._get_property("multi_exit_discriminator")

    @multi_exit_discriminator.setter
    def multi_exit_discriminator(self, value):
        """multi_exit_discriminator setter

        The multi exit discriminator (MED) is an optional non-transitive attribute and the value is used for route selection. The route with the lowest MED value is preferred.

        value: int
        """
        self._set_property("multi_exit_discriminator", value)


class BgpPrefixIpv6UnicastStateIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(BgpPrefixIpv6UnicastStateIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[BgpPrefixIpv6UnicastState]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> BgpPrefixIpv6UnicastStateIter
        return self._iter()

    def __next__(self):
        # type: () -> BgpPrefixIpv6UnicastState
        return self._next()

    def next(self):
        # type: () -> BgpPrefixIpv6UnicastState
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, BgpPrefixIpv6UnicastState):
            raise Exception("Item is not an instance of BgpPrefixIpv6UnicastState")

    def state(
        self,
        ipv6_address=None,
        prefix_length=None,
        origin=None,
        path_id=None,
        ipv4_next_hop=None,
        ipv6_next_hop=None,
        local_preference=None,
        multi_exit_discriminator=None,
    ):
        # type: (str,int,Union[Literal["egp"], Literal["igp"], Literal["incomplete"]],int,str,str,int,int) -> BgpPrefixIpv6UnicastStateIter
        """Factory method that creates an instance of the BgpPrefixIpv6UnicastState class

        IPv6 unicast prefix.

        Returns: BgpPrefixIpv6UnicastStateIter
        """
        item = BgpPrefixIpv6UnicastState(
            parent=self._parent,
            ipv6_address=ipv6_address,
            prefix_length=prefix_length,
            origin=origin,
            path_id=path_id,
            ipv4_next_hop=ipv4_next_hop,
            ipv6_next_hop=ipv6_next_hop,
            local_preference=local_preference,
            multi_exit_discriminator=multi_exit_discriminator,
        )
        self._add(item)
        return self

    def add(
        self,
        ipv6_address=None,
        prefix_length=None,
        origin=None,
        path_id=None,
        ipv4_next_hop=None,
        ipv6_next_hop=None,
        local_preference=None,
        multi_exit_discriminator=None,
    ):
        # type: (str,int,Union[Literal["egp"], Literal["igp"], Literal["incomplete"]],int,str,str,int,int) -> BgpPrefixIpv6UnicastState
        """Add method that creates and returns an instance of the BgpPrefixIpv6UnicastState class

        IPv6 unicast prefix.

        Returns: BgpPrefixIpv6UnicastState
        """
        item = BgpPrefixIpv6UnicastState(
            parent=self._parent,
            ipv6_address=ipv6_address,
            prefix_length=prefix_length,
            origin=origin,
            path_id=path_id,
            ipv4_next_hop=ipv4_next_hop,
            ipv6_next_hop=ipv6_next_hop,
            local_preference=local_preference,
            multi_exit_discriminator=multi_exit_discriminator,
        )
        self._add(item)
        return item


class BgpPrefixesStateIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(BgpPrefixesStateIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[BgpPrefixesState]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> BgpPrefixesStateIter
        return self._iter()

    def __next__(self):
        # type: () -> BgpPrefixesState
        return self._next()

    def next(self):
        # type: () -> BgpPrefixesState
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, BgpPrefixesState):
            raise Exception("Item is not an instance of BgpPrefixesState")

    def state(self, bgp_peer_name=None):
        # type: (str) -> BgpPrefixesStateIter
        """Factory method that creates an instance of the BgpPrefixesState class

        BGP peer prefixes.

        Returns: BgpPrefixesStateIter
        """
        item = BgpPrefixesState(parent=self._parent, bgp_peer_name=bgp_peer_name)
        self._add(item)
        return self

    def add(self, bgp_peer_name=None):
        # type: (str) -> BgpPrefixesState
        """Add method that creates and returns an instance of the BgpPrefixesState class

        BGP peer prefixes.

        Returns: BgpPrefixesState
        """
        item = BgpPrefixesState(parent=self._parent, bgp_peer_name=bgp_peer_name)
        self._add(item)
        return item


class IsisLspsState(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "isis_router_name": {"type": str},
        "lsps": {"type": "IsisLspStateIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, isis_router_name=None):
        super(IsisLspsState, self).__init__()
        self._parent = parent
        self._set_property("isis_router_name", isis_router_name)

    def set(self, isis_router_name=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def isis_router_name(self):
        # type: () -> str
        """isis_router_name getter

        The name of the ISIS Router.

        Returns: str
        """
        return self._get_property("isis_router_name")

    @isis_router_name.setter
    def isis_router_name(self, value):
        """isis_router_name setter

        The name of the ISIS Router.

        value: str
        """
        self._set_property("isis_router_name", value)

    @property
    def lsps(self):
        # type: () -> IsisLspStateIter
        """lsps getter

        One or more LSPs that are learned by this ISIS router.

        Returns: IsisLspStateIter
        """
        return self._get_property("lsps", IsisLspStateIter, self._parent, self._choice)


class IsisLspState(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "lsp_id": {"type": str},
        "pdu_type": {
            "type": str,
            "enum": [
                "level_1",
                "level_2",
            ],
        },
        "remaining_lifetime": {
            "type": int,
            "format": "uint32",
        },
        "sequence_number": {
            "type": int,
            "format": "uint64",
        },
        "pdu_length": {
            "type": int,
            "format": "uint32",
            "maximum": 65535,
        },
        "flags": {"type": "IsisLspFlags"},
        "is_type": {
            "type": int,
            "format": "uint32",
            "maximum": 3,
        },
        "tlvs": {"type": "IsisLspTlvs"},
    }  # type: Dict[str, str]

    _REQUIRED = ("lsp_id",)  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    LEVEL_1 = "level_1"  # type: str
    LEVEL_2 = "level_2"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        lsp_id=None,
        pdu_type=None,
        remaining_lifetime=None,
        sequence_number=None,
        pdu_length=None,
        is_type=None,
    ):
        super(IsisLspState, self).__init__()
        self._parent = parent
        self._set_property("lsp_id", lsp_id)
        self._set_property("pdu_type", pdu_type)
        self._set_property("remaining_lifetime", remaining_lifetime)
        self._set_property("sequence_number", sequence_number)
        self._set_property("pdu_length", pdu_length)
        self._set_property("is_type", is_type)

    def set(
        self,
        lsp_id=None,
        pdu_type=None,
        remaining_lifetime=None,
        sequence_number=None,
        pdu_length=None,
        is_type=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def lsp_id(self):
        # type: () -> str
        """lsp_id getter

        LSP ID in the format, e.g. '640000000001-00-00'. LSP ID consists of the System ID of neighbor, the Pseudonode ID, and the LSP number. The last two bytes represent Pseudonode ID and LSP number respectively. pseudonode is logical representation of the LAN which is generated by Designated Intermediate System (DIS) on LAN segment. If one LSP exceeds the maximum LSP size then it is sent in another LSP with the LSP number incremented by one. router's learned LSP gets refreshed by 'remaining_lifetime'. Then the sequence number is incremented by 1.

        Returns: str
        """
        return self._get_property("lsp_id")

    @lsp_id.setter
    def lsp_id(self, value):
        """lsp_id setter

        LSP ID in the format, e.g. '640000000001-00-00'. LSP ID consists of the System ID of neighbor, the Pseudonode ID, and the LSP number. The last two bytes represent Pseudonode ID and LSP number respectively. pseudonode is logical representation of the LAN which is generated by Designated Intermediate System (DIS) on LAN segment. If one LSP exceeds the maximum LSP size then it is sent in another LSP with the LSP number incremented by one. router's learned LSP gets refreshed by 'remaining_lifetime'. Then the sequence number is incremented by 1.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property lsp_id as None")
        self._set_property("lsp_id", value)

    @property
    def pdu_type(self):
        # type: () -> Union[Literal["level_1"], Literal["level_2"]]
        """pdu_type getter

        Link State PDU type.

        Returns: Union[Literal["level_1"], Literal["level_2"]]
        """
        return self._get_property("pdu_type")

    @pdu_type.setter
    def pdu_type(self, value):
        """pdu_type setter

        Link State PDU type.

        value: Union[Literal["level_1"], Literal["level_2"]]
        """
        self._set_property("pdu_type", value)

    @property
    def remaining_lifetime(self):
        # type: () -> int
        """remaining_lifetime getter

        Remaining lifetime in seconds before LSP expires.

        Returns: int
        """
        return self._get_property("remaining_lifetime")

    @remaining_lifetime.setter
    def remaining_lifetime(self, value):
        """remaining_lifetime setter

        Remaining lifetime in seconds before LSP expires.

        value: int
        """
        self._set_property("remaining_lifetime", value)

    @property
    def sequence_number(self):
        # type: () -> int
        """sequence_number getter

        Sequence number of the LSP.

        Returns: int
        """
        return self._get_property("sequence_number")

    @sequence_number.setter
    def sequence_number(self, value):
        """sequence_number setter

        Sequence number of the LSP.

        value: int
        """
        self._set_property("sequence_number", value)

    @property
    def pdu_length(self):
        # type: () -> int
        """pdu_length getter

        Total length of the LSP.

        Returns: int
        """
        return self._get_property("pdu_length")

    @pdu_length.setter
    def pdu_length(self, value):
        """pdu_length setter

        Total length of the LSP.

        value: int
        """
        self._set_property("pdu_length", value)

    @property
    def flags(self):
        # type: () -> IsisLspFlags
        """flags getter

        LSP Type flags.LSP Type flags.LSP Type flags.LSP Type-Block flags.

        Returns: IsisLspFlags
        """
        return self._get_property("flags", IsisLspFlags)

    @property
    def is_type(self):
        # type: () -> int
        """is_type getter

        IS Type bits and indicate the type of Intermediate System.. - i.e. bit set) Level Intermediate system.. - Unused value.. - (i.e. bits and set) Level Intermediate system.

        Returns: int
        """
        return self._get_property("is_type")

    @is_type.setter
    def is_type(self, value):
        """is_type setter

        IS Type bits and indicate the type of Intermediate System.. - i.e. bit set) Level Intermediate system.. - Unused value.. - (i.e. bits and set) Level Intermediate system.

        value: int
        """
        self._set_property("is_type", value)

    @property
    def tlvs(self):
        # type: () -> IsisLspTlvs
        """tlvs getter

        This contains the list of TLVs present in one LSP.This contains the list of TLVs present in one LSP.This contains the list of TLVs present in one LSP.It refers to Link State PDU State TLVs container.

        Returns: IsisLspTlvs
        """
        return self._get_property("tlvs", IsisLspTlvs)


class IsisLspFlags(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "partition_repair": {"type": bool},
        "attached_error": {"type": bool},
        "attached_expense": {"type": bool},
        "attached_delay": {"type": bool},
        "attached_default": {"type": bool},
        "overload": {"type": bool},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        partition_repair=None,
        attached_error=None,
        attached_expense=None,
        attached_delay=None,
        attached_default=None,
        overload=None,
    ):
        super(IsisLspFlags, self).__init__()
        self._parent = parent
        self._set_property("partition_repair", partition_repair)
        self._set_property("attached_error", attached_error)
        self._set_property("attached_expense", attached_expense)
        self._set_property("attached_delay", attached_delay)
        self._set_property("attached_default", attached_default)
        self._set_property("overload", overload)

    def set(
        self,
        partition_repair=None,
        attached_error=None,
        attached_expense=None,
        attached_delay=None,
        attached_default=None,
        overload=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def partition_repair(self):
        # type: () -> bool
        """partition_repair getter

        When set, the originator supports partition repair.

        Returns: bool
        """
        return self._get_property("partition_repair")

    @partition_repair.setter
    def partition_repair(self, value):
        """partition_repair setter

        When set, the originator supports partition repair.

        value: bool
        """
        self._set_property("partition_repair", value)

    @property
    def attached_error(self):
        # type: () -> bool
        """attached_error getter

        When set, the originator is attached to another area using the referred metric.

        Returns: bool
        """
        return self._get_property("attached_error")

    @attached_error.setter
    def attached_error(self, value):
        """attached_error setter

        When set, the originator is attached to another area using the referred metric.

        value: bool
        """
        self._set_property("attached_error", value)

    @property
    def attached_expense(self):
        # type: () -> bool
        """attached_expense getter

        When set, the originator is attached to another. area using the referred metric.

        Returns: bool
        """
        return self._get_property("attached_expense")

    @attached_expense.setter
    def attached_expense(self, value):
        """attached_expense setter

        When set, the originator is attached to another. area using the referred metric.

        value: bool
        """
        self._set_property("attached_expense", value)

    @property
    def attached_delay(self):
        # type: () -> bool
        """attached_delay getter

        Delay Metric when set, the originator is attached to another. area using the referred metric.

        Returns: bool
        """
        return self._get_property("attached_delay")

    @attached_delay.setter
    def attached_delay(self, value):
        """attached_delay setter

        Delay Metric when set, the originator is attached to another. area using the referred metric.

        value: bool
        """
        self._set_property("attached_delay", value)

    @property
    def attached_default(self):
        # type: () -> bool
        """attached_default getter

        Default Metric when set, the originator is attached to another. area using the referred metric.

        Returns: bool
        """
        return self._get_property("attached_default")

    @attached_default.setter
    def attached_default(self, value):
        """attached_default setter

        Default Metric when set, the originator is attached to another. area using the referred metric.

        value: bool
        """
        self._set_property("attached_default", value)

    @property
    def overload(self):
        # type: () -> bool
        """overload getter

        Overload bit when set, the originator is overloaded, and must. be avoided in path calculation.

        Returns: bool
        """
        return self._get_property("overload")

    @overload.setter
    def overload(self, value):
        """overload setter

        Overload bit when set, the originator is overloaded, and must. be avoided in path calculation.

        value: bool
        """
        self._set_property("overload", value)


class IsisLspTlvs(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "hostname_tlvs": {"type": "IsisLspHostnameIter"},
        "is_reachability_tlvs": {"type": "IsisLspIsReachabilityTlvIter"},
        "extended_is_reachability_tlvs": {
            "type": "IsisLspExtendedIsReachabilityTlvIter"
        },
        "ipv4_internal_reachability_tlvs": {
            "type": "IsisLspIpv4InternalReachabilityTlvIter"
        },
        "ipv4_external_reachability_tlvs": {
            "type": "IsisLspIpv4ExternalReachabilityTlvIter"
        },
        "extended_ipv4_reachability_tlvs": {
            "type": "IsisLspExtendedIpv4ReachabilityTlvIter"
        },
        "ipv6_reachability_tlvs": {"type": "IsisLspIpv6ReachabilityTlvIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None):
        super(IsisLspTlvs, self).__init__()
        self._parent = parent

    @property
    def hostname_tlvs(self):
        # type: () -> IsisLspHostnameIter
        """hostname_tlvs getter

        Array of Hostname TLVs type 137) present in this LSP.

        Returns: IsisLspHostnameIter
        """
        return self._get_property(
            "hostname_tlvs", IsisLspHostnameIter, self._parent, self._choice
        )

    @property
    def is_reachability_tlvs(self):
        # type: () -> IsisLspIsReachabilityTlvIter
        """is_reachability_tlvs getter

        Array of IS-Reachability TLVs (type 2) present in this LSP.

        Returns: IsisLspIsReachabilityTlvIter
        """
        return self._get_property(
            "is_reachability_tlvs",
            IsisLspIsReachabilityTlvIter,
            self._parent,
            self._choice,
        )

    @property
    def extended_is_reachability_tlvs(self):
        # type: () -> IsisLspExtendedIsReachabilityTlvIter
        """extended_is_reachability_tlvs getter

        Array of Extended IS-Reachability TLVs (type 22) present in this LSP.

        Returns: IsisLspExtendedIsReachabilityTlvIter
        """
        return self._get_property(
            "extended_is_reachability_tlvs",
            IsisLspExtendedIsReachabilityTlvIter,
            self._parent,
            self._choice,
        )

    @property
    def ipv4_internal_reachability_tlvs(self):
        # type: () -> IsisLspIpv4InternalReachabilityTlvIter
        """ipv4_internal_reachability_tlvs getter

        Array of IPv4 Internal Reachability TLVs (type 128) present in this LSP.

        Returns: IsisLspIpv4InternalReachabilityTlvIter
        """
        return self._get_property(
            "ipv4_internal_reachability_tlvs",
            IsisLspIpv4InternalReachabilityTlvIter,
            self._parent,
            self._choice,
        )

    @property
    def ipv4_external_reachability_tlvs(self):
        # type: () -> IsisLspIpv4ExternalReachabilityTlvIter
        """ipv4_external_reachability_tlvs getter

        Array of IPv4 External Reachability TLVs (type 130) present in this LSP.

        Returns: IsisLspIpv4ExternalReachabilityTlvIter
        """
        return self._get_property(
            "ipv4_external_reachability_tlvs",
            IsisLspIpv4ExternalReachabilityTlvIter,
            self._parent,
            self._choice,
        )

    @property
    def extended_ipv4_reachability_tlvs(self):
        # type: () -> IsisLspExtendedIpv4ReachabilityTlvIter
        """extended_ipv4_reachability_tlvs getter

        Array of IPv4 Extended Reachability TLVs (type 135) present in this LSP.

        Returns: IsisLspExtendedIpv4ReachabilityTlvIter
        """
        return self._get_property(
            "extended_ipv4_reachability_tlvs",
            IsisLspExtendedIpv4ReachabilityTlvIter,
            self._parent,
            self._choice,
        )

    @property
    def ipv6_reachability_tlvs(self):
        # type: () -> IsisLspIpv6ReachabilityTlvIter
        """ipv6_reachability_tlvs getter

        Array of IPv6 Reachability TLVs (type 236) present in this LSP.

        Returns: IsisLspIpv6ReachabilityTlvIter
        """
        return self._get_property(
            "ipv6_reachability_tlvs",
            IsisLspIpv6ReachabilityTlvIter,
            self._parent,
            self._choice,
        )


class IsisLspHostname(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "hostname": {"type": str},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, hostname=None):
        super(IsisLspHostname, self).__init__()
        self._parent = parent
        self._set_property("hostname", hostname)

    def set(self, hostname=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def hostname(self):
        # type: () -> str
        """hostname getter

        Hostname for an ISIS router.

        Returns: str
        """
        return self._get_property("hostname")

    @hostname.setter
    def hostname(self, value):
        """hostname setter

        Hostname for an ISIS router.

        value: str
        """
        self._set_property("hostname", value)


class IsisLspHostnameIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(IsisLspHostnameIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[IsisLspHostname]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> IsisLspHostnameIter
        return self._iter()

    def __next__(self):
        # type: () -> IsisLspHostname
        return self._next()

    def next(self):
        # type: () -> IsisLspHostname
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, IsisLspHostname):
            raise Exception("Item is not an instance of IsisLspHostname")

    def hostname(self, hostname=None):
        # type: (str) -> IsisLspHostnameIter
        """Factory method that creates an instance of the IsisLspHostname class

        It contains Hostname for the TLV 137.

        Returns: IsisLspHostnameIter
        """
        item = IsisLspHostname(parent=self._parent, hostname=hostname)
        self._add(item)
        return self

    def add(self, hostname=None):
        # type: (str) -> IsisLspHostname
        """Add method that creates and returns an instance of the IsisLspHostname class

        It contains Hostname for the TLV 137.

        Returns: IsisLspHostname
        """
        item = IsisLspHostname(parent=self._parent, hostname=hostname)
        self._add(item)
        return item


class IsisLspIsReachabilityTlv(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "neighbors": {"type": "IsisLspneighborIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None):
        super(IsisLspIsReachabilityTlv, self).__init__()
        self._parent = parent

    @property
    def neighbors(self):
        # type: () -> IsisLspneighborIter
        """neighbors getter

        This container describes Intermediate System (IS) neighbors.

        Returns: IsisLspneighborIter
        """
        return self._get_property(
            "neighbors", IsisLspneighborIter, self._parent, self._choice
        )


class IsisLspneighbor(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "system_id": {
            "type": str,
            "format": "hex",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, system_id=None):
        super(IsisLspneighbor, self).__init__()
        self._parent = parent
        self._set_property("system_id", system_id)

    def set(self, system_id=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def system_id(self):
        # type: () -> str
        """system_id getter

        The System ID for this emulated ISIS router, e.g. "640100010000".

        Returns: str
        """
        return self._get_property("system_id")

    @system_id.setter
    def system_id(self, value):
        """system_id setter

        The System ID for this emulated ISIS router, e.g. "640100010000".

        value: str
        """
        self._set_property("system_id", value)


class IsisLspneighborIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(IsisLspneighborIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[IsisLspneighbor]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> IsisLspneighborIter
        return self._iter()

    def __next__(self):
        # type: () -> IsisLspneighbor
        return self._next()

    def next(self):
        # type: () -> IsisLspneighbor
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, IsisLspneighbor):
            raise Exception("Item is not an instance of IsisLspneighbor")

    def neighbor(self, system_id=None):
        # type: (str) -> IsisLspneighborIter
        """Factory method that creates an instance of the IsisLspneighbor class

        This contains IS neighbors.

        Returns: IsisLspneighborIter
        """
        item = IsisLspneighbor(parent=self._parent, system_id=system_id)
        self._add(item)
        return self

    def add(self, system_id=None):
        # type: (str) -> IsisLspneighbor
        """Add method that creates and returns an instance of the IsisLspneighbor class

        This contains IS neighbors.

        Returns: IsisLspneighbor
        """
        item = IsisLspneighbor(parent=self._parent, system_id=system_id)
        self._add(item)
        return item


class IsisLspIsReachabilityTlvIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(IsisLspIsReachabilityTlvIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[IsisLspIsReachabilityTlv]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> IsisLspIsReachabilityTlvIter
        return self._iter()

    def __next__(self):
        # type: () -> IsisLspIsReachabilityTlv
        return self._next()

    def next(self):
        # type: () -> IsisLspIsReachabilityTlv
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, IsisLspIsReachabilityTlv):
            raise Exception("Item is not an instance of IsisLspIsReachabilityTlv")

    def isreachabilitytlv(self):
        # type: () -> IsisLspIsReachabilityTlvIter
        """Factory method that creates an instance of the IsisLspIsReachabilityTlv class

        This container describes list of ISIS neighbors and attributes in IS-Reachability TLV (type 2).

        Returns: IsisLspIsReachabilityTlvIter
        """
        item = IsisLspIsReachabilityTlv(parent=self._parent)
        self._add(item)
        return self

    def add(self):
        # type: () -> IsisLspIsReachabilityTlv
        """Add method that creates and returns an instance of the IsisLspIsReachabilityTlv class

        This container describes list of ISIS neighbors and attributes in IS-Reachability TLV (type 2).

        Returns: IsisLspIsReachabilityTlv
        """
        item = IsisLspIsReachabilityTlv(parent=self._parent)
        self._add(item)
        return item


class IsisLspExtendedIsReachabilityTlv(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "neighbors": {"type": "IsisLspneighborIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None):
        super(IsisLspExtendedIsReachabilityTlv, self).__init__()
        self._parent = parent

    @property
    def neighbors(self):
        # type: () -> IsisLspneighborIter
        """neighbors getter

        This container describes IS neighbors.

        Returns: IsisLspneighborIter
        """
        return self._get_property(
            "neighbors", IsisLspneighborIter, self._parent, self._choice
        )


class IsisLspExtendedIsReachabilityTlvIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(IsisLspExtendedIsReachabilityTlvIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[IsisLspExtendedIsReachabilityTlv]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> IsisLspExtendedIsReachabilityTlvIter
        return self._iter()

    def __next__(self):
        # type: () -> IsisLspExtendedIsReachabilityTlv
        return self._next()

    def next(self):
        # type: () -> IsisLspExtendedIsReachabilityTlv
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, IsisLspExtendedIsReachabilityTlv):
            raise Exception(
                "Item is not an instance of IsisLspExtendedIsReachabilityTlv"
            )

    def extendedisreachabilitytlv(self):
        # type: () -> IsisLspExtendedIsReachabilityTlvIter
        """Factory method that creates an instance of the IsisLspExtendedIsReachabilityTlv class

        This is list of ISIS neighbors and attributes in Extended-IS-Reachability TLV (type 22).

        Returns: IsisLspExtendedIsReachabilityTlvIter
        """
        item = IsisLspExtendedIsReachabilityTlv(parent=self._parent)
        self._add(item)
        return self

    def add(self):
        # type: () -> IsisLspExtendedIsReachabilityTlv
        """Add method that creates and returns an instance of the IsisLspExtendedIsReachabilityTlv class

        This is list of ISIS neighbors and attributes in Extended-IS-Reachability TLV (type 22).

        Returns: IsisLspExtendedIsReachabilityTlv
        """
        item = IsisLspExtendedIsReachabilityTlv(parent=self._parent)
        self._add(item)
        return item


class IsisLspIpv4InternalReachabilityTlv(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "prefixes": {"type": "IsisLspV4PrefixIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None):
        super(IsisLspIpv4InternalReachabilityTlv, self).__init__()
        self._parent = parent

    @property
    def prefixes(self):
        # type: () -> IsisLspV4PrefixIter
        """prefixes getter

        Describes list of IPv4 prefixes in this TLV.

        Returns: IsisLspV4PrefixIter
        """
        return self._get_property(
            "prefixes", IsisLspV4PrefixIter, self._parent, self._choice
        )


class IsisLspV4Prefix(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "ipv4_address": {"type": str},
        "prefix_length": {
            "type": int,
            "format": "uint32",
            "maximum": 32,
        },
        "redistribution_type": {
            "type": str,
            "enum": [
                "up",
                "down",
            ],
        },
        "default_metric": {
            "type": int,
            "format": "uint32",
        },
        "origin_type": {
            "type": str,
            "enum": [
                "internal",
                "external",
            ],
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    UP = "up"  # type: str
    DOWN = "down"  # type: str

    INTERNAL = "internal"  # type: str
    EXTERNAL = "external"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        ipv4_address=None,
        prefix_length=None,
        redistribution_type=None,
        default_metric=None,
        origin_type=None,
    ):
        super(IsisLspV4Prefix, self).__init__()
        self._parent = parent
        self._set_property("ipv4_address", ipv4_address)
        self._set_property("prefix_length", prefix_length)
        self._set_property("redistribution_type", redistribution_type)
        self._set_property("default_metric", default_metric)
        self._set_property("origin_type", origin_type)

    def set(
        self,
        ipv4_address=None,
        prefix_length=None,
        redistribution_type=None,
        default_metric=None,
        origin_type=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def ipv4_address(self):
        # type: () -> str
        """ipv4_address getter

        An IPv4 unicast prefix reachable via the originator of this LSP.

        Returns: str
        """
        return self._get_property("ipv4_address")

    @ipv4_address.setter
    def ipv4_address(self, value):
        """ipv4_address setter

        An IPv4 unicast prefix reachable via the originator of this LSP.

        value: str
        """
        self._set_property("ipv4_address", value)

    @property
    def prefix_length(self):
        # type: () -> int
        """prefix_length getter

        The length of the IPv4 prefix.

        Returns: int
        """
        return self._get_property("prefix_length")

    @prefix_length.setter
    def prefix_length(self, value):
        """prefix_length setter

        The length of the IPv4 prefix.

        value: int
        """
        self._set_property("prefix_length", value)

    @property
    def redistribution_type(self):
        # type: () -> Union[Literal["down"], Literal["up"]]
        """redistribution_type getter

        Up (0)-used when prefix is initially advertised within the ISIS L3 hierarchy, and for all other prefixes in L1 and L2 LSPs. (default) Down (1)-used when an L1/L2 router advertises L2 prefixes in L1 LSPs. The prefixes are being advertised from higher level (L2) down to lower level (L1).

        Returns: Union[Literal["down"], Literal["up"]]
        """
        return self._get_property("redistribution_type")

    @redistribution_type.setter
    def redistribution_type(self, value):
        """redistribution_type setter

        Up (0)-used when prefix is initially advertised within the ISIS L3 hierarchy, and for all other prefixes in L1 and L2 LSPs. (default) Down (1)-used when an L1/L2 router advertises L2 prefixes in L1 LSPs. The prefixes are being advertised from higher level (L2) down to lower level (L1).

        value: Union[Literal["down"], Literal["up"]]
        """
        self._set_property("redistribution_type", value)

    @property
    def default_metric(self):
        # type: () -> int
        """default_metric getter

        ISIS default metric value.

        Returns: int
        """
        return self._get_property("default_metric")

    @default_metric.setter
    def default_metric(self, value):
        """default_metric setter

        ISIS default metric value.

        value: int
        """
        self._set_property("default_metric", value)

    @property
    def origin_type(self):
        # type: () -> Union[Literal["external"], Literal["internal"]]
        """origin_type getter

        The origin of the advertised route-internal or external to the ISIS area. Options include the following: Internal-for intra-area routes, through Level LSPs. External-for inter-area routes redistributed within L1, through Level. LSPs.

        Returns: Union[Literal["external"], Literal["internal"]]
        """
        return self._get_property("origin_type")

    @origin_type.setter
    def origin_type(self, value):
        """origin_type setter

        The origin of the advertised route-internal or external to the ISIS area. Options include the following: Internal-for intra-area routes, through Level LSPs. External-for inter-area routes redistributed within L1, through Level. LSPs.

        value: Union[Literal["external"], Literal["internal"]]
        """
        self._set_property("origin_type", value)


class IsisLspV4PrefixIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(IsisLspV4PrefixIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[IsisLspV4Prefix]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> IsisLspV4PrefixIter
        return self._iter()

    def __next__(self):
        # type: () -> IsisLspV4Prefix
        return self._next()

    def next(self):
        # type: () -> IsisLspV4Prefix
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, IsisLspV4Prefix):
            raise Exception("Item is not an instance of IsisLspV4Prefix")

    def v4prefix(
        self,
        ipv4_address=None,
        prefix_length=None,
        redistribution_type=None,
        default_metric=None,
        origin_type=None,
    ):
        # type: (str,int,Union[Literal["down"], Literal["up"]],int,Union[Literal["external"], Literal["internal"]]) -> IsisLspV4PrefixIter
        """Factory method that creates an instance of the IsisLspV4Prefix class

        This group defines attributes of an IPv4 standard prefix.

        Returns: IsisLspV4PrefixIter
        """
        item = IsisLspV4Prefix(
            parent=self._parent,
            ipv4_address=ipv4_address,
            prefix_length=prefix_length,
            redistribution_type=redistribution_type,
            default_metric=default_metric,
            origin_type=origin_type,
        )
        self._add(item)
        return self

    def add(
        self,
        ipv4_address=None,
        prefix_length=None,
        redistribution_type=None,
        default_metric=None,
        origin_type=None,
    ):
        # type: (str,int,Union[Literal["down"], Literal["up"]],int,Union[Literal["external"], Literal["internal"]]) -> IsisLspV4Prefix
        """Add method that creates and returns an instance of the IsisLspV4Prefix class

        This group defines attributes of an IPv4 standard prefix.

        Returns: IsisLspV4Prefix
        """
        item = IsisLspV4Prefix(
            parent=self._parent,
            ipv4_address=ipv4_address,
            prefix_length=prefix_length,
            redistribution_type=redistribution_type,
            default_metric=default_metric,
            origin_type=origin_type,
        )
        self._add(item)
        return item


class IsisLspIpv4InternalReachabilityTlvIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(IsisLspIpv4InternalReachabilityTlvIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[IsisLspIpv4InternalReachabilityTlv]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> IsisLspIpv4InternalReachabilityTlvIter
        return self._iter()

    def __next__(self):
        # type: () -> IsisLspIpv4InternalReachabilityTlv
        return self._next()

    def next(self):
        # type: () -> IsisLspIpv4InternalReachabilityTlv
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, IsisLspIpv4InternalReachabilityTlv):
            raise Exception(
                "Item is not an instance of IsisLspIpv4InternalReachabilityTlv"
            )

    def ipv4internalreachabilitytlv(self):
        # type: () -> IsisLspIpv4InternalReachabilityTlvIter
        """Factory method that creates an instance of the IsisLspIpv4InternalReachabilityTlv class

        This container defines list of IPv4 internal reachability information in one IPv4 internal reachability TLV.. This is advertised when the origin-type is set 'internal' in route range configurations.

        Returns: IsisLspIpv4InternalReachabilityTlvIter
        """
        item = IsisLspIpv4InternalReachabilityTlv(parent=self._parent)
        self._add(item)
        return self

    def add(self):
        # type: () -> IsisLspIpv4InternalReachabilityTlv
        """Add method that creates and returns an instance of the IsisLspIpv4InternalReachabilityTlv class

        This container defines list of IPv4 internal reachability information in one IPv4 internal reachability TLV.. This is advertised when the origin-type is set 'internal' in route range configurations.

        Returns: IsisLspIpv4InternalReachabilityTlv
        """
        item = IsisLspIpv4InternalReachabilityTlv(parent=self._parent)
        self._add(item)
        return item


class IsisLspIpv4ExternalReachabilityTlv(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "prefixes": {"type": "IsisLspV4PrefixIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None):
        super(IsisLspIpv4ExternalReachabilityTlv, self).__init__()
        self._parent = parent

    @property
    def prefixes(self):
        # type: () -> IsisLspV4PrefixIter
        """prefixes getter

        Describes list of IPv4 prefixes in this TLV..

        Returns: IsisLspV4PrefixIter
        """
        return self._get_property(
            "prefixes", IsisLspV4PrefixIter, self._parent, self._choice
        )


class IsisLspIpv4ExternalReachabilityTlvIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(IsisLspIpv4ExternalReachabilityTlvIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[IsisLspIpv4ExternalReachabilityTlv]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> IsisLspIpv4ExternalReachabilityTlvIter
        return self._iter()

    def __next__(self):
        # type: () -> IsisLspIpv4ExternalReachabilityTlv
        return self._next()

    def next(self):
        # type: () -> IsisLspIpv4ExternalReachabilityTlv
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, IsisLspIpv4ExternalReachabilityTlv):
            raise Exception(
                "Item is not an instance of IsisLspIpv4ExternalReachabilityTlv"
            )

    def ipv4externalreachabilitytlv(self):
        # type: () -> IsisLspIpv4ExternalReachabilityTlvIter
        """Factory method that creates an instance of the IsisLspIpv4ExternalReachabilityTlv class

        This container defines list of IPv4 external reachability information in one IPv4 external reachability TLV.. This is advertised when the origin-type is set 'external' in route range configurations.

        Returns: IsisLspIpv4ExternalReachabilityTlvIter
        """
        item = IsisLspIpv4ExternalReachabilityTlv(parent=self._parent)
        self._add(item)
        return self

    def add(self):
        # type: () -> IsisLspIpv4ExternalReachabilityTlv
        """Add method that creates and returns an instance of the IsisLspIpv4ExternalReachabilityTlv class

        This container defines list of IPv4 external reachability information in one IPv4 external reachability TLV.. This is advertised when the origin-type is set 'external' in route range configurations.

        Returns: IsisLspIpv4ExternalReachabilityTlv
        """
        item = IsisLspIpv4ExternalReachabilityTlv(parent=self._parent)
        self._add(item)
        return item


class IsisLspExtendedIpv4ReachabilityTlv(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "prefixes": {"type": "IsisLspExtendedV4PrefixIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None):
        super(IsisLspExtendedIpv4ReachabilityTlv, self).__init__()
        self._parent = parent

    @property
    def prefixes(self):
        # type: () -> IsisLspExtendedV4PrefixIter
        """prefixes getter

        IPv4 prefix contained within extended reachability TLVs.

        Returns: IsisLspExtendedV4PrefixIter
        """
        return self._get_property(
            "prefixes", IsisLspExtendedV4PrefixIter, self._parent, self._choice
        )


class IsisLspExtendedV4Prefix(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "ipv4_address": {
            "type": str,
            "format": "ipv4",
        },
        "prefix_length": {
            "type": int,
            "format": "uint32",
            "maximum": 32,
        },
        "metric": {
            "type": int,
            "format": "uint32",
        },
        "redistribution_type": {
            "type": str,
            "enum": [
                "up",
                "down",
            ],
        },
        "prefix_attributes": {"type": "IsisLspPrefixAttributes"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    UP = "up"  # type: str
    DOWN = "down"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        ipv4_address=None,
        prefix_length=None,
        metric=None,
        redistribution_type=None,
    ):
        super(IsisLspExtendedV4Prefix, self).__init__()
        self._parent = parent
        self._set_property("ipv4_address", ipv4_address)
        self._set_property("prefix_length", prefix_length)
        self._set_property("metric", metric)
        self._set_property("redistribution_type", redistribution_type)

    def set(
        self,
        ipv4_address=None,
        prefix_length=None,
        metric=None,
        redistribution_type=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def ipv4_address(self):
        # type: () -> str
        """ipv4_address getter

        An IPv4 unicast prefix reachable via the originator of this LSP.

        Returns: str
        """
        return self._get_property("ipv4_address")

    @ipv4_address.setter
    def ipv4_address(self, value):
        """ipv4_address setter

        An IPv4 unicast prefix reachable via the originator of this LSP.

        value: str
        """
        self._set_property("ipv4_address", value)

    @property
    def prefix_length(self):
        # type: () -> int
        """prefix_length getter

        The length of the IPv4 prefix.

        Returns: int
        """
        return self._get_property("prefix_length")

    @prefix_length.setter
    def prefix_length(self, value):
        """prefix_length setter

        The length of the IPv4 prefix.

        value: int
        """
        self._set_property("prefix_length", value)

    @property
    def metric(self):
        # type: () -> int
        """metric getter

        ISIS wide metric.

        Returns: int
        """
        return self._get_property("metric")

    @metric.setter
    def metric(self, value):
        """metric setter

        ISIS wide metric.

        value: int
        """
        self._set_property("metric", value)

    @property
    def redistribution_type(self):
        # type: () -> Union[Literal["down"], Literal["up"]]
        """redistribution_type getter

        Up (0)-used when prefix is initially advertised within the ISIS L3 hierarchy, and for all other prefixes in L1 and L2 LSPs. (default) Down (1)-used when an L1/L2 router advertises L2 prefixes in L1 LSPs. The prefixes are being advertised from higher level (L2) down to lower level (L1).

        Returns: Union[Literal["down"], Literal["up"]]
        """
        return self._get_property("redistribution_type")

    @redistribution_type.setter
    def redistribution_type(self, value):
        """redistribution_type setter

        Up (0)-used when prefix is initially advertised within the ISIS L3 hierarchy, and for all other prefixes in L1 and L2 LSPs. (default) Down (1)-used when an L1/L2 router advertises L2 prefixes in L1 LSPs. The prefixes are being advertised from higher level (L2) down to lower level (L1).

        value: Union[Literal["down"], Literal["up"]]
        """
        self._set_property("redistribution_type", value)

    @property
    def prefix_attributes(self):
        # type: () -> IsisLspPrefixAttributes
        """prefix_attributes getter

        This contains the properties of ISIS Prefix attributes for the extended IPv4 and IPv6 reachability. https://www.rfc-editor.org/rfc/rfc7794.htmlThis contains the properties of ISIS Prefix attributes for the extended IPv4 and IPv6 reachability. https://www.rfc-editor.org/rfc/rfc7794.htmlThis contains the properties of ISIS Prefix attributes for the extended IPv4 and IPv6 reachability. https://www.rfc-editor.org/rfc/rfc7794.html

        Returns: IsisLspPrefixAttributes
        """
        return self._get_property("prefix_attributes", IsisLspPrefixAttributes)


class IsisLspPrefixAttributes(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "x_flag": {"type": bool},
        "r_flag": {"type": bool},
        "n_flag": {"type": bool},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, x_flag=None, r_flag=None, n_flag=None):
        super(IsisLspPrefixAttributes, self).__init__()
        self._parent = parent
        self._set_property("x_flag", x_flag)
        self._set_property("r_flag", r_flag)
        self._set_property("n_flag", n_flag)

    def set(self, x_flag=None, r_flag=None, n_flag=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def x_flag(self):
        # type: () -> bool
        """x_flag getter

        External Prefix Flag (Bit 0)

        Returns: bool
        """
        return self._get_property("x_flag")

    @x_flag.setter
    def x_flag(self, value):
        """x_flag setter

        External Prefix Flag (Bit 0)

        value: bool
        """
        self._set_property("x_flag", value)

    @property
    def r_flag(self):
        # type: () -> bool
        """r_flag getter

        Re-advertisement Flag (Bit 1)

        Returns: bool
        """
        return self._get_property("r_flag")

    @r_flag.setter
    def r_flag(self, value):
        """r_flag setter

        Re-advertisement Flag (Bit 1)

        value: bool
        """
        self._set_property("r_flag", value)

    @property
    def n_flag(self):
        # type: () -> bool
        """n_flag getter

        Node Flag (Bit 2)

        Returns: bool
        """
        return self._get_property("n_flag")

    @n_flag.setter
    def n_flag(self, value):
        """n_flag setter

        Node Flag (Bit 2)

        value: bool
        """
        self._set_property("n_flag", value)


class IsisLspExtendedV4PrefixIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(IsisLspExtendedV4PrefixIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[IsisLspExtendedV4Prefix]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> IsisLspExtendedV4PrefixIter
        return self._iter()

    def __next__(self):
        # type: () -> IsisLspExtendedV4Prefix
        return self._next()

    def next(self):
        # type: () -> IsisLspExtendedV4Prefix
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, IsisLspExtendedV4Prefix):
            raise Exception("Item is not an instance of IsisLspExtendedV4Prefix")

    def extendedv4prefix(
        self,
        ipv4_address=None,
        prefix_length=None,
        metric=None,
        redistribution_type=None,
    ):
        # type: (str,int,int,Union[Literal["down"], Literal["up"]]) -> IsisLspExtendedV4PrefixIter
        """Factory method that creates an instance of the IsisLspExtendedV4Prefix class

        This group defines attributes of an IPv4 standard prefix.

        Returns: IsisLspExtendedV4PrefixIter
        """
        item = IsisLspExtendedV4Prefix(
            parent=self._parent,
            ipv4_address=ipv4_address,
            prefix_length=prefix_length,
            metric=metric,
            redistribution_type=redistribution_type,
        )
        self._add(item)
        return self

    def add(
        self,
        ipv4_address=None,
        prefix_length=None,
        metric=None,
        redistribution_type=None,
    ):
        # type: (str,int,int,Union[Literal["down"], Literal["up"]]) -> IsisLspExtendedV4Prefix
        """Add method that creates and returns an instance of the IsisLspExtendedV4Prefix class

        This group defines attributes of an IPv4 standard prefix.

        Returns: IsisLspExtendedV4Prefix
        """
        item = IsisLspExtendedV4Prefix(
            parent=self._parent,
            ipv4_address=ipv4_address,
            prefix_length=prefix_length,
            metric=metric,
            redistribution_type=redistribution_type,
        )
        self._add(item)
        return item


class IsisLspExtendedIpv4ReachabilityTlvIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(IsisLspExtendedIpv4ReachabilityTlvIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[IsisLspExtendedIpv4ReachabilityTlv]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> IsisLspExtendedIpv4ReachabilityTlvIter
        return self._iter()

    def __next__(self):
        # type: () -> IsisLspExtendedIpv4ReachabilityTlv
        return self._next()

    def next(self):
        # type: () -> IsisLspExtendedIpv4ReachabilityTlv
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, IsisLspExtendedIpv4ReachabilityTlv):
            raise Exception(
                "Item is not an instance of IsisLspExtendedIpv4ReachabilityTlv"
            )

    def extendedipv4reachabilitytlv(self):
        # type: () -> IsisLspExtendedIpv4ReachabilityTlvIter
        """Factory method that creates an instance of the IsisLspExtendedIpv4ReachabilityTlv class

        This container defines list of IPv4 extended reachability information in one Extended IPv4 External Reachability TLV.. It is advertised when the 'wide metric' is enabled.

        Returns: IsisLspExtendedIpv4ReachabilityTlvIter
        """
        item = IsisLspExtendedIpv4ReachabilityTlv(parent=self._parent)
        self._add(item)
        return self

    def add(self):
        # type: () -> IsisLspExtendedIpv4ReachabilityTlv
        """Add method that creates and returns an instance of the IsisLspExtendedIpv4ReachabilityTlv class

        This container defines list of IPv4 extended reachability information in one Extended IPv4 External Reachability TLV.. It is advertised when the 'wide metric' is enabled.

        Returns: IsisLspExtendedIpv4ReachabilityTlv
        """
        item = IsisLspExtendedIpv4ReachabilityTlv(parent=self._parent)
        self._add(item)
        return item


class IsisLspIpv6ReachabilityTlv(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "prefixes": {"type": "IsisLspV6PrefixIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None):
        super(IsisLspIpv6ReachabilityTlv, self).__init__()
        self._parent = parent

    @property
    def prefixes(self):
        # type: () -> IsisLspV6PrefixIter
        """prefixes getter

        IPv6 prefix contained within reachability TLVs.

        Returns: IsisLspV6PrefixIter
        """
        return self._get_property(
            "prefixes", IsisLspV6PrefixIter, self._parent, self._choice
        )


class IsisLspV6Prefix(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "ipv6_address": {
            "type": str,
            "format": "ipv6",
        },
        "prefix_length": {
            "type": int,
            "format": "uint32",
            "maximum": 128,
        },
        "metric": {
            "type": int,
            "format": "uint32",
        },
        "redistribution_type": {
            "type": str,
            "enum": [
                "up",
                "down",
            ],
        },
        "origin_type": {
            "type": str,
            "enum": [
                "internal",
                "external",
            ],
        },
        "prefix_attributes": {"type": "IsisLspPrefixAttributes"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    UP = "up"  # type: str
    DOWN = "down"  # type: str

    INTERNAL = "internal"  # type: str
    EXTERNAL = "external"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        ipv6_address=None,
        prefix_length=None,
        metric=None,
        redistribution_type=None,
        origin_type=None,
    ):
        super(IsisLspV6Prefix, self).__init__()
        self._parent = parent
        self._set_property("ipv6_address", ipv6_address)
        self._set_property("prefix_length", prefix_length)
        self._set_property("metric", metric)
        self._set_property("redistribution_type", redistribution_type)
        self._set_property("origin_type", origin_type)

    def set(
        self,
        ipv6_address=None,
        prefix_length=None,
        metric=None,
        redistribution_type=None,
        origin_type=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def ipv6_address(self):
        # type: () -> str
        """ipv6_address getter

        An IPv6 unicast prefix reachable via the originator of this LSP.

        Returns: str
        """
        return self._get_property("ipv6_address")

    @ipv6_address.setter
    def ipv6_address(self, value):
        """ipv6_address setter

        An IPv6 unicast prefix reachable via the originator of this LSP.

        value: str
        """
        self._set_property("ipv6_address", value)

    @property
    def prefix_length(self):
        # type: () -> int
        """prefix_length getter

        The length of the IPv6 prefix.

        Returns: int
        """
        return self._get_property("prefix_length")

    @prefix_length.setter
    def prefix_length(self, value):
        """prefix_length setter

        The length of the IPv6 prefix.

        value: int
        """
        self._set_property("prefix_length", value)

    @property
    def metric(self):
        # type: () -> int
        """metric getter

        ISIS wide metric.

        Returns: int
        """
        return self._get_property("metric")

    @metric.setter
    def metric(self, value):
        """metric setter

        ISIS wide metric.

        value: int
        """
        self._set_property("metric", value)

    @property
    def redistribution_type(self):
        # type: () -> Union[Literal["down"], Literal["up"]]
        """redistribution_type getter

        Up (0)-used when prefix is initially advertised within the ISIS L3 hierarchy, and for all other prefixes in L1 and L2 LSPs. (default) Down (1)-used when an L1/L2 router advertises L2 prefixes in L1 LSPs. The prefixes are being advertised from higher level (L2) down to lower level (L1).

        Returns: Union[Literal["down"], Literal["up"]]
        """
        return self._get_property("redistribution_type")

    @redistribution_type.setter
    def redistribution_type(self, value):
        """redistribution_type setter

        Up (0)-used when prefix is initially advertised within the ISIS L3 hierarchy, and for all other prefixes in L1 and L2 LSPs. (default) Down (1)-used when an L1/L2 router advertises L2 prefixes in L1 LSPs. The prefixes are being advertised from higher level (L2) down to lower level (L1).

        value: Union[Literal["down"], Literal["up"]]
        """
        self._set_property("redistribution_type", value)

    @property
    def origin_type(self):
        # type: () -> Union[Literal["external"], Literal["internal"]]
        """origin_type getter

        The origin of the advertised route-internal or external to the ISIS area. Options include the following: Internal-for intra-area routes, through Level LSPs. External-for inter-area routes redistributed within L1, through Level. LSPs.

        Returns: Union[Literal["external"], Literal["internal"]]
        """
        return self._get_property("origin_type")

    @origin_type.setter
    def origin_type(self, value):
        """origin_type setter

        The origin of the advertised route-internal or external to the ISIS area. Options include the following: Internal-for intra-area routes, through Level LSPs. External-for inter-area routes redistributed within L1, through Level. LSPs.

        value: Union[Literal["external"], Literal["internal"]]
        """
        self._set_property("origin_type", value)

    @property
    def prefix_attributes(self):
        # type: () -> IsisLspPrefixAttributes
        """prefix_attributes getter

        This contains the properties of ISIS Prefix attributes for the extended IPv4 and IPv6 reachability. https://www.rfc-editor.org/rfc/rfc7794.htmlThis contains the properties of ISIS Prefix attributes for the extended IPv4 and IPv6 reachability. https://www.rfc-editor.org/rfc/rfc7794.htmlThis contains the properties of ISIS Prefix attributes for the extended IPv4 and IPv6 reachability. https://www.rfc-editor.org/rfc/rfc7794.html

        Returns: IsisLspPrefixAttributes
        """
        return self._get_property("prefix_attributes", IsisLspPrefixAttributes)


class IsisLspV6PrefixIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(IsisLspV6PrefixIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[IsisLspV6Prefix]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> IsisLspV6PrefixIter
        return self._iter()

    def __next__(self):
        # type: () -> IsisLspV6Prefix
        return self._next()

    def next(self):
        # type: () -> IsisLspV6Prefix
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, IsisLspV6Prefix):
            raise Exception("Item is not an instance of IsisLspV6Prefix")

    def v6prefix(
        self,
        ipv6_address=None,
        prefix_length=None,
        metric=None,
        redistribution_type=None,
        origin_type=None,
    ):
        # type: (str,int,int,Union[Literal["down"], Literal["up"]],Union[Literal["external"], Literal["internal"]]) -> IsisLspV6PrefixIter
        """Factory method that creates an instance of the IsisLspV6Prefix class

        It defines attributes of an IPv6 standard prefix.

        Returns: IsisLspV6PrefixIter
        """
        item = IsisLspV6Prefix(
            parent=self._parent,
            ipv6_address=ipv6_address,
            prefix_length=prefix_length,
            metric=metric,
            redistribution_type=redistribution_type,
            origin_type=origin_type,
        )
        self._add(item)
        return self

    def add(
        self,
        ipv6_address=None,
        prefix_length=None,
        metric=None,
        redistribution_type=None,
        origin_type=None,
    ):
        # type: (str,int,int,Union[Literal["down"], Literal["up"]],Union[Literal["external"], Literal["internal"]]) -> IsisLspV6Prefix
        """Add method that creates and returns an instance of the IsisLspV6Prefix class

        It defines attributes of an IPv6 standard prefix.

        Returns: IsisLspV6Prefix
        """
        item = IsisLspV6Prefix(
            parent=self._parent,
            ipv6_address=ipv6_address,
            prefix_length=prefix_length,
            metric=metric,
            redistribution_type=redistribution_type,
            origin_type=origin_type,
        )
        self._add(item)
        return item


class IsisLspIpv6ReachabilityTlvIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(IsisLspIpv6ReachabilityTlvIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[IsisLspIpv6ReachabilityTlv]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> IsisLspIpv6ReachabilityTlvIter
        return self._iter()

    def __next__(self):
        # type: () -> IsisLspIpv6ReachabilityTlv
        return self._next()

    def next(self):
        # type: () -> IsisLspIpv6ReachabilityTlv
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, IsisLspIpv6ReachabilityTlv):
            raise Exception("Item is not an instance of IsisLspIpv6ReachabilityTlv")

    def ipv6reachabilitytlv(self):
        # type: () -> IsisLspIpv6ReachabilityTlvIter
        """Factory method that creates an instance of the IsisLspIpv6ReachabilityTlv class

        It defines list of IPv6 extended reachability information in one IPv6 Reachability TLV.

        Returns: IsisLspIpv6ReachabilityTlvIter
        """
        item = IsisLspIpv6ReachabilityTlv(parent=self._parent)
        self._add(item)
        return self

    def add(self):
        # type: () -> IsisLspIpv6ReachabilityTlv
        """Add method that creates and returns an instance of the IsisLspIpv6ReachabilityTlv class

        It defines list of IPv6 extended reachability information in one IPv6 Reachability TLV.

        Returns: IsisLspIpv6ReachabilityTlv
        """
        item = IsisLspIpv6ReachabilityTlv(parent=self._parent)
        self._add(item)
        return item


class IsisLspStateIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(IsisLspStateIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[IsisLspState]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> IsisLspStateIter
        return self._iter()

    def __next__(self):
        # type: () -> IsisLspState
        return self._next()

    def next(self):
        # type: () -> IsisLspState
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, IsisLspState):
            raise Exception("Item is not an instance of IsisLspState")

    def state(
        self,
        lsp_id=None,
        pdu_type=None,
        remaining_lifetime=None,
        sequence_number=None,
        pdu_length=None,
        is_type=None,
    ):
        # type: (str,Union[Literal["level_1"], Literal["level_2"]],int,int,int,int) -> IsisLspStateIter
        """Factory method that creates an instance of the IsisLspState class

        ISIS LSP.

        Returns: IsisLspStateIter
        """
        item = IsisLspState(
            parent=self._parent,
            lsp_id=lsp_id,
            pdu_type=pdu_type,
            remaining_lifetime=remaining_lifetime,
            sequence_number=sequence_number,
            pdu_length=pdu_length,
            is_type=is_type,
        )
        self._add(item)
        return self

    def add(
        self,
        lsp_id=None,
        pdu_type=None,
        remaining_lifetime=None,
        sequence_number=None,
        pdu_length=None,
        is_type=None,
    ):
        # type: (str,Union[Literal["level_1"], Literal["level_2"]],int,int,int,int) -> IsisLspState
        """Add method that creates and returns an instance of the IsisLspState class

        ISIS LSP.

        Returns: IsisLspState
        """
        item = IsisLspState(
            parent=self._parent,
            lsp_id=lsp_id,
            pdu_type=pdu_type,
            remaining_lifetime=remaining_lifetime,
            sequence_number=sequence_number,
            pdu_length=pdu_length,
            is_type=is_type,
        )
        self._add(item)
        return item


class IsisLspsStateIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(IsisLspsStateIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[IsisLspsState]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> IsisLspsStateIter
        return self._iter()

    def __next__(self):
        # type: () -> IsisLspsState
        return self._next()

    def next(self):
        # type: () -> IsisLspsState
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, IsisLspsState):
            raise Exception("Item is not an instance of IsisLspsState")

    def state(self, isis_router_name=None):
        # type: (str) -> IsisLspsStateIter
        """Factory method that creates an instance of the IsisLspsState class

        The result of ISIS LSP information that are retrieved.

        Returns: IsisLspsStateIter
        """
        item = IsisLspsState(parent=self._parent, isis_router_name=isis_router_name)
        self._add(item)
        return self

    def add(self, isis_router_name=None):
        # type: (str) -> IsisLspsState
        """Add method that creates and returns an instance of the IsisLspsState class

        The result of ISIS LSP information that are retrieved.

        Returns: IsisLspsState
        """
        item = IsisLspsState(parent=self._parent, isis_router_name=isis_router_name)
        self._add(item)
        return item


class LldpNeighborsState(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "lldp_name": {"type": str},
        "system_name": {"type": str},
        "system_description": {"type": str},
        "chassis_id": {"type": str},
        "chassis_id_type": {
            "type": str,
            "enum": [
                "port_component",
                "network_address",
                "chassis_component",
                "mac_address",
                "interface_name",
                "local",
                "interface_alias",
            ],
        },
        "neighbor_id": {"type": str},
        "age": {
            "type": int,
            "format": "uint32",
        },
        "last_update": {
            "type": int,
            "format": "uint32",
        },
        "ttl": {
            "type": int,
            "format": "uint32",
        },
        "port_id": {"type": str},
        "port_id_type": {
            "type": str,
            "enum": [
                "port_component",
                "network_address",
                "agent_circuit_id",
                "mac_address",
                "interface_name",
                "local",
                "interface_alias",
            ],
        },
        "port_description": {"type": str},
        "management_address": {"type": str},
        "management_address_type": {"type": str},
        "custom_tlvs": {"type": "LldpCustomTLVStateIter"},
        "capabilities": {"type": "LldpCapabilityStateIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    PORT_COMPONENT = "port_component"  # type: str
    NETWORK_ADDRESS = "network_address"  # type: str
    CHASSIS_COMPONENT = "chassis_component"  # type: str
    MAC_ADDRESS = "mac_address"  # type: str
    INTERFACE_NAME = "interface_name"  # type: str
    LOCAL = "local"  # type: str
    INTERFACE_ALIAS = "interface_alias"  # type: str

    PORT_COMPONENT = "port_component"  # type: str
    NETWORK_ADDRESS = "network_address"  # type: str
    AGENT_CIRCUIT_ID = "agent_circuit_id"  # type: str
    MAC_ADDRESS = "mac_address"  # type: str
    INTERFACE_NAME = "interface_name"  # type: str
    LOCAL = "local"  # type: str
    INTERFACE_ALIAS = "interface_alias"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        lldp_name=None,
        system_name=None,
        system_description=None,
        chassis_id=None,
        chassis_id_type=None,
        neighbor_id=None,
        age=None,
        last_update=None,
        ttl=None,
        port_id=None,
        port_id_type=None,
        port_description=None,
        management_address=None,
        management_address_type=None,
    ):
        super(LldpNeighborsState, self).__init__()
        self._parent = parent
        self._set_property("lldp_name", lldp_name)
        self._set_property("system_name", system_name)
        self._set_property("system_description", system_description)
        self._set_property("chassis_id", chassis_id)
        self._set_property("chassis_id_type", chassis_id_type)
        self._set_property("neighbor_id", neighbor_id)
        self._set_property("age", age)
        self._set_property("last_update", last_update)
        self._set_property("ttl", ttl)
        self._set_property("port_id", port_id)
        self._set_property("port_id_type", port_id_type)
        self._set_property("port_description", port_description)
        self._set_property("management_address", management_address)
        self._set_property("management_address_type", management_address_type)

    def set(
        self,
        lldp_name=None,
        system_name=None,
        system_description=None,
        chassis_id=None,
        chassis_id_type=None,
        neighbor_id=None,
        age=None,
        last_update=None,
        ttl=None,
        port_id=None,
        port_id_type=None,
        port_description=None,
        management_address=None,
        management_address_type=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def lldp_name(self):
        # type: () -> str
        """lldp_name getter

        The name of the LLDP instance.

        Returns: str
        """
        return self._get_property("lldp_name")

    @lldp_name.setter
    def lldp_name(self, value):
        """lldp_name setter

        The name of the LLDP instance.

        value: str
        """
        self._set_property("lldp_name", value)

    @property
    def system_name(self):
        # type: () -> str
        """system_name getter

        The system name field shall contain an alpha-numeric string that indicates the system's administratively assigned name. The system name should be the system's fully qualified domain name. If implementations support IETF RFC 3418, the sysName object should be used for this field.

        Returns: str
        """
        return self._get_property("system_name")

    @system_name.setter
    def system_name(self, value):
        """system_name setter

        The system name field shall contain an alpha-numeric string that indicates the system's administratively assigned name. The system name should be the system's fully qualified domain name. If implementations support IETF RFC 3418, the sysName object should be used for this field.

        value: str
        """
        self._set_property("system_name", value)

    @property
    def system_description(self):
        # type: () -> str
        """system_description getter

        The system description field shall contain an alpha-numeric string that is the textual description of the network entity. The system description should include the full name and version identification of the system's hardware type, software operating system, and networking software. If implementations support IETF RFC 3418, the sysDescr object should be used for this field.

        Returns: str
        """
        return self._get_property("system_description")

    @system_description.setter
    def system_description(self, value):
        """system_description setter

        The system description field shall contain an alpha-numeric string that is the textual description of the network entity. The system description should include the full name and version identification of the system's hardware type, software operating system, and networking software. If implementations support IETF RFC 3418, the sysDescr object should be used for this field.

        value: str
        """
        self._set_property("system_description", value)

    @property
    def chassis_id(self):
        # type: () -> str
        """chassis_id getter

        The Chassis ID is mandatory TLV which identifies the chassis component of the endpoint identifier associated with the transmitting LLDP agent.

        Returns: str
        """
        return self._get_property("chassis_id")

    @chassis_id.setter
    def chassis_id(self, value):
        """chassis_id setter

        The Chassis ID is mandatory TLV which identifies the chassis component of the endpoint identifier associated with the transmitting LLDP agent.

        value: str
        """
        self._set_property("chassis_id", value)

    @property
    def chassis_id_type(self):
        # type: () -> Union[Literal["chassis_component"], Literal["interface_alias"], Literal["interface_name"], Literal["local"], Literal["mac_address"], Literal["network_address"], Literal["port_component"]]
        """chassis_id_type getter

        This field identifies the format and source of the chassis identifier string. It is an enumerator defined by the LldpChassisIdSubtype object from IEEE 802.1AB MIB.

        Returns: Union[Literal["chassis_component"], Literal["interface_alias"], Literal["interface_name"], Literal["local"], Literal["mac_address"], Literal["network_address"], Literal["port_component"]]
        """
        return self._get_property("chassis_id_type")

    @chassis_id_type.setter
    def chassis_id_type(self, value):
        """chassis_id_type setter

        This field identifies the format and source of the chassis identifier string. It is an enumerator defined by the LldpChassisIdSubtype object from IEEE 802.1AB MIB.

        value: Union[Literal["chassis_component"], Literal["interface_alias"], Literal["interface_name"], Literal["local"], Literal["mac_address"], Literal["network_address"], Literal["port_component"]]
        """
        self._set_property("chassis_id_type", value)

    @property
    def neighbor_id(self):
        # type: () -> str
        """neighbor_id getter

        System generated identifier for the neighbor on the LLDP instance.

        Returns: str
        """
        return self._get_property("neighbor_id")

    @neighbor_id.setter
    def neighbor_id(self, value):
        """neighbor_id setter

        System generated identifier for the neighbor on the LLDP instance.

        value: str
        """
        self._set_property("neighbor_id", value)

    @property
    def age(self):
        # type: () -> int
        """age getter

        Age since discovery in seconds.

        Returns: int
        """
        return self._get_property("age")

    @age.setter
    def age(self, value):
        """age setter

        Age since discovery in seconds.

        value: int
        """
        self._set_property("age", value)

    @property
    def last_update(self):
        # type: () -> int
        """last_update getter

        Seconds since last update received.

        Returns: int
        """
        return self._get_property("last_update")

    @last_update.setter
    def last_update(self, value):
        """last_update setter

        Seconds since last update received.

        value: int
        """
        self._set_property("last_update", value)

    @property
    def ttl(self):
        # type: () -> int
        """ttl getter

        The time-to-live (TTL) in seconds is mandatory TLV which indicates how long information from the neighbor should be considered valid.

        Returns: int
        """
        return self._get_property("ttl")

    @ttl.setter
    def ttl(self, value):
        """ttl setter

        The time-to-live (TTL) in seconds is mandatory TLV which indicates how long information from the neighbor should be considered valid.

        value: int
        """
        self._set_property("ttl", value)

    @property
    def port_id(self):
        # type: () -> str
        """port_id getter

        The Port ID is mandatory TLV which identifies the port component of the endpoint identifier associated with the transmitting LLDP agent. If the specified port is an IEEE 802.3 Repeater port, then this TLV is optional.

        Returns: str
        """
        return self._get_property("port_id")

    @port_id.setter
    def port_id(self, value):
        """port_id setter

        The Port ID is mandatory TLV which identifies the port component of the endpoint identifier associated with the transmitting LLDP agent. If the specified port is an IEEE 802.3 Repeater port, then this TLV is optional.

        value: str
        """
        self._set_property("port_id", value)

    @property
    def port_id_type(self):
        # type: () -> Union[Literal["agent_circuit_id"], Literal["interface_alias"], Literal["interface_name"], Literal["local"], Literal["mac_address"], Literal["network_address"], Literal["port_component"]]
        """port_id_type getter

        This field identifies the format and source of the port identifier string. It is an enumerator defined by the PtopoPortIdType object from RFC2922.

        Returns: Union[Literal["agent_circuit_id"], Literal["interface_alias"], Literal["interface_name"], Literal["local"], Literal["mac_address"], Literal["network_address"], Literal["port_component"]]
        """
        return self._get_property("port_id_type")

    @port_id_type.setter
    def port_id_type(self, value):
        """port_id_type setter

        This field identifies the format and source of the port identifier string. It is an enumerator defined by the PtopoPortIdType object from RFC2922.

        value: Union[Literal["agent_circuit_id"], Literal["interface_alias"], Literal["interface_name"], Literal["local"], Literal["mac_address"], Literal["network_address"], Literal["port_component"]]
        """
        self._set_property("port_id_type", value)

    @property
    def port_description(self):
        # type: () -> str
        """port_description getter

        The binary string containing the actual port identifier for the port which this LLDP PDU was transmitted. The source and format of this field is defined by PtopoPortId from RFC2922.

        Returns: str
        """
        return self._get_property("port_description")

    @port_description.setter
    def port_description(self, value):
        """port_description setter

        The binary string containing the actual port identifier for the port which this LLDP PDU was transmitted. The source and format of this field is defined by PtopoPortId from RFC2922.

        value: str
        """
        self._set_property("port_description", value)

    @property
    def management_address(self):
        # type: () -> str
        """management_address getter

        The Management Address is mandatory TLV which identifies network address associated with the local LLDP agent, which can be used to reach the agent on the port identified in the Port ID TLV.

        Returns: str
        """
        return self._get_property("management_address")

    @management_address.setter
    def management_address(self, value):
        """management_address setter

        The Management Address is mandatory TLV which identifies network address associated with the local LLDP agent, which can be used to reach the agent on the port identified in the Port ID TLV.

        value: str
        """
        self._set_property("management_address", value)

    @property
    def management_address_type(self):
        # type: () -> str
        """management_address_type getter

        The enumerated value for the network address type identified in this TLV. This enumeration is defined in the 'Assigned Numbers' RFC [RFC3232] and the ianaAddressFamilyNumbers object.

        Returns: str
        """
        return self._get_property("management_address_type")

    @management_address_type.setter
    def management_address_type(self, value):
        """management_address_type setter

        The enumerated value for the network address type identified in this TLV. This enumeration is defined in the 'Assigned Numbers' RFC [RFC3232] and the ianaAddressFamilyNumbers object.

        value: str
        """
        self._set_property("management_address_type", value)

    @property
    def custom_tlvs(self):
        # type: () -> LldpCustomTLVStateIter
        """custom_tlvs getter

        TBD

        Returns: LldpCustomTLVStateIter
        """
        return self._get_property(
            "custom_tlvs", LldpCustomTLVStateIter, self._parent, self._choice
        )

    @property
    def capabilities(self):
        # type: () -> LldpCapabilityStateIter
        """capabilities getter

        TBD

        Returns: LldpCapabilityStateIter
        """
        return self._get_property(
            "capabilities", LldpCapabilityStateIter, self._parent, self._choice
        )


class LldpCustomTLVState(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "custom_type": {
            "type": int,
            "format": "uint32",
        },
        "oui": {"type": str},
        "oui_subtype": {"type": str},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, custom_type=None, oui=None, oui_subtype=None):
        super(LldpCustomTLVState, self).__init__()
        self._parent = parent
        self._set_property("custom_type", custom_type)
        self._set_property("oui", oui)
        self._set_property("oui_subtype", oui_subtype)

    def set(self, custom_type=None, oui=None, oui_subtype=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def custom_type(self):
        # type: () -> int
        """custom_type getter

        The integer value identifying the type of information contained in the value field.

        Returns: int
        """
        return self._get_property("custom_type")

    @custom_type.setter
    def custom_type(self, value):
        """custom_type setter

        The integer value identifying the type of information contained in the value field.

        value: int
        """
        self._set_property("custom_type", value)

    @property
    def oui(self):
        # type: () -> str
        """oui getter

        The organizationally unique identifier field shall contain the organization's OUI as defined in Clause of IEEE Std 802. The high-order octet is and the low-order octets are the SMI Network Management Private Enterprise Code of the Vendor in network byte order, as defined in the 'Assigned Numbers' RFC [RFC3232].

        Returns: str
        """
        return self._get_property("oui")

    @oui.setter
    def oui(self, value):
        """oui setter

        The organizationally unique identifier field shall contain the organization's OUI as defined in Clause of IEEE Std 802. The high-order octet is and the low-order octets are the SMI Network Management Private Enterprise Code of the Vendor in network byte order, as defined in the 'Assigned Numbers' RFC [RFC3232].

        value: str
        """
        self._set_property("oui", value)

    @property
    def oui_subtype(self):
        # type: () -> str
        """oui_subtype getter

        The organizationally defined subtype field shall contain unique subtype value assigned by the defining organization.

        Returns: str
        """
        return self._get_property("oui_subtype")

    @oui_subtype.setter
    def oui_subtype(self, value):
        """oui_subtype setter

        The organizationally defined subtype field shall contain unique subtype value assigned by the defining organization.

        value: str
        """
        self._set_property("oui_subtype", value)


class LldpCustomTLVStateIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(LldpCustomTLVStateIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[LldpCustomTLVState]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> LldpCustomTLVStateIter
        return self._iter()

    def __next__(self):
        # type: () -> LldpCustomTLVState
        return self._next()

    def next(self):
        # type: () -> LldpCustomTLVState
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, LldpCustomTLVState):
            raise Exception("Item is not an instance of LldpCustomTLVState")

    def state(self, custom_type=None, oui=None, oui_subtype=None):
        # type: (int,str,str) -> LldpCustomTLVStateIter
        """Factory method that creates an instance of the LldpCustomTLVState class

        Custom TLV received from neighbor.Custom TLVs are organization specific TLVs advertised with TLV type 127.

        Returns: LldpCustomTLVStateIter
        """
        item = LldpCustomTLVState(
            parent=self._parent,
            custom_type=custom_type,
            oui=oui,
            oui_subtype=oui_subtype,
        )
        self._add(item)
        return self

    def add(self, custom_type=None, oui=None, oui_subtype=None):
        # type: (int,str,str) -> LldpCustomTLVState
        """Add method that creates and returns an instance of the LldpCustomTLVState class

        Custom TLV received from neighbor.Custom TLVs are organization specific TLVs advertised with TLV type 127.

        Returns: LldpCustomTLVState
        """
        item = LldpCustomTLVState(
            parent=self._parent,
            custom_type=custom_type,
            oui=oui,
            oui_subtype=oui_subtype,
        )
        self._add(item)
        return item


class LldpCapabilityState(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "capability_name": {
            "type": str,
            "enum": [
                "mac_bridge",
                "two_port_mac_relay",
                "repeater",
                "docsis_cable_device",
                "s_vlan",
                "telephone",
                "other",
                "router",
                "c_vlan",
                "station_only",
                "wlan_access_point",
            ],
        },
        "capability_enabled": {"type": bool},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    MAC_BRIDGE = "mac_bridge"  # type: str
    TWO_PORT_MAC_RELAY = "two_port_mac_relay"  # type: str
    REPEATER = "repeater"  # type: str
    DOCSIS_CABLE_DEVICE = "docsis_cable_device"  # type: str
    S_VLAN = "s_vlan"  # type: str
    TELEPHONE = "telephone"  # type: str
    OTHER = "other"  # type: str
    ROUTER = "router"  # type: str
    C_VLAN = "c_vlan"  # type: str
    STATION_ONLY = "station_only"  # type: str
    WLAN_ACCESS_POINT = "wlan_access_point"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, capability_name=None, capability_enabled=None):
        super(LldpCapabilityState, self).__init__()
        self._parent = parent
        self._set_property("capability_name", capability_name)
        self._set_property("capability_enabled", capability_enabled)

    def set(self, capability_name=None, capability_enabled=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def capability_name(self):
        # type: () -> Union[Literal["c_vlan"], Literal["docsis_cable_device"], Literal["mac_bridge"], Literal["other"], Literal["repeater"], Literal["router"], Literal["s_vlan"], Literal["station_only"], Literal["telephone"], Literal["two_port_mac_relay"], Literal["wlan_access_point"]]
        """capability_name getter

        Name of the system capability advertised by the neighbor. Capabilities are represented in bitmap that defines the primary functions of the system. The capabilities are defined in IEEE 802.1AB.

        Returns: Union[Literal["c_vlan"], Literal["docsis_cable_device"], Literal["mac_bridge"], Literal["other"], Literal["repeater"], Literal["router"], Literal["s_vlan"], Literal["station_only"], Literal["telephone"], Literal["two_port_mac_relay"], Literal["wlan_access_point"]]
        """
        return self._get_property("capability_name")

    @capability_name.setter
    def capability_name(self, value):
        """capability_name setter

        Name of the system capability advertised by the neighbor. Capabilities are represented in bitmap that defines the primary functions of the system. The capabilities are defined in IEEE 802.1AB.

        value: Union[Literal["c_vlan"], Literal["docsis_cable_device"], Literal["mac_bridge"], Literal["other"], Literal["repeater"], Literal["router"], Literal["s_vlan"], Literal["station_only"], Literal["telephone"], Literal["two_port_mac_relay"], Literal["wlan_access_point"]]
        """
        self._set_property("capability_name", value)

    @property
    def capability_enabled(self):
        # type: () -> bool
        """capability_enabled getter

        Indicates whether the corresponding system capability is enabled on the neighbor.

        Returns: bool
        """
        return self._get_property("capability_enabled")

    @capability_enabled.setter
    def capability_enabled(self, value):
        """capability_enabled setter

        Indicates whether the corresponding system capability is enabled on the neighbor.

        value: bool
        """
        self._set_property("capability_enabled", value)


class LldpCapabilityStateIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(LldpCapabilityStateIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[LldpCapabilityState]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> LldpCapabilityStateIter
        return self._iter()

    def __next__(self):
        # type: () -> LldpCapabilityState
        return self._next()

    def next(self):
        # type: () -> LldpCapabilityState
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, LldpCapabilityState):
            raise Exception("Item is not an instance of LldpCapabilityState")

    def state(self, capability_name=None, capability_enabled=None):
        # type: (Union[Literal["c_vlan"], Literal["docsis_cable_device"], Literal["mac_bridge"], Literal["other"], Literal["repeater"], Literal["router"], Literal["s_vlan"], Literal["station_only"], Literal["telephone"], Literal["two_port_mac_relay"], Literal["wlan_access_point"]],bool) -> LldpCapabilityStateIter
        """Factory method that creates an instance of the LldpCapabilityState class

        LLDP system capability advertised by the neighbor

        Returns: LldpCapabilityStateIter
        """
        item = LldpCapabilityState(
            parent=self._parent,
            capability_name=capability_name,
            capability_enabled=capability_enabled,
        )
        self._add(item)
        return self

    def add(self, capability_name=None, capability_enabled=None):
        # type: (Union[Literal["c_vlan"], Literal["docsis_cable_device"], Literal["mac_bridge"], Literal["other"], Literal["repeater"], Literal["router"], Literal["s_vlan"], Literal["station_only"], Literal["telephone"], Literal["two_port_mac_relay"], Literal["wlan_access_point"]],bool) -> LldpCapabilityState
        """Add method that creates and returns an instance of the LldpCapabilityState class

        LLDP system capability advertised by the neighbor

        Returns: LldpCapabilityState
        """
        item = LldpCapabilityState(
            parent=self._parent,
            capability_name=capability_name,
            capability_enabled=capability_enabled,
        )
        self._add(item)
        return item


class LldpNeighborsStateIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(LldpNeighborsStateIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[LldpNeighborsState]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> LldpNeighborsStateIter
        return self._iter()

    def __next__(self):
        # type: () -> LldpNeighborsState
        return self._next()

    def next(self):
        # type: () -> LldpNeighborsState
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, LldpNeighborsState):
            raise Exception("Item is not an instance of LldpNeighborsState")

    def state(
        self,
        lldp_name=None,
        system_name=None,
        system_description=None,
        chassis_id=None,
        chassis_id_type=None,
        neighbor_id=None,
        age=None,
        last_update=None,
        ttl=None,
        port_id=None,
        port_id_type=None,
        port_description=None,
        management_address=None,
        management_address_type=None,
    ):
        # type: (str,str,str,str,Union[Literal["chassis_component"], Literal["interface_alias"], Literal["interface_name"], Literal["local"], Literal["mac_address"], Literal["network_address"], Literal["port_component"]],str,int,int,int,str,Union[Literal["agent_circuit_id"], Literal["interface_alias"], Literal["interface_name"], Literal["local"], Literal["mac_address"], Literal["network_address"], Literal["port_component"]],str,str,str) -> LldpNeighborsStateIter
        """Factory method that creates an instance of the LldpNeighborsState class

        LLDP neighbor information.

        Returns: LldpNeighborsStateIter
        """
        item = LldpNeighborsState(
            parent=self._parent,
            lldp_name=lldp_name,
            system_name=system_name,
            system_description=system_description,
            chassis_id=chassis_id,
            chassis_id_type=chassis_id_type,
            neighbor_id=neighbor_id,
            age=age,
            last_update=last_update,
            ttl=ttl,
            port_id=port_id,
            port_id_type=port_id_type,
            port_description=port_description,
            management_address=management_address,
            management_address_type=management_address_type,
        )
        self._add(item)
        return self

    def add(
        self,
        lldp_name=None,
        system_name=None,
        system_description=None,
        chassis_id=None,
        chassis_id_type=None,
        neighbor_id=None,
        age=None,
        last_update=None,
        ttl=None,
        port_id=None,
        port_id_type=None,
        port_description=None,
        management_address=None,
        management_address_type=None,
    ):
        # type: (str,str,str,str,Union[Literal["chassis_component"], Literal["interface_alias"], Literal["interface_name"], Literal["local"], Literal["mac_address"], Literal["network_address"], Literal["port_component"]],str,int,int,int,str,Union[Literal["agent_circuit_id"], Literal["interface_alias"], Literal["interface_name"], Literal["local"], Literal["mac_address"], Literal["network_address"], Literal["port_component"]],str,str,str) -> LldpNeighborsState
        """Add method that creates and returns an instance of the LldpNeighborsState class

        LLDP neighbor information.

        Returns: LldpNeighborsState
        """
        item = LldpNeighborsState(
            parent=self._parent,
            lldp_name=lldp_name,
            system_name=system_name,
            system_description=system_description,
            chassis_id=chassis_id,
            chassis_id_type=chassis_id_type,
            neighbor_id=neighbor_id,
            age=age,
            last_update=last_update,
            ttl=ttl,
            port_id=port_id,
            port_id_type=port_id_type,
            port_description=port_description,
            management_address=management_address,
            management_address_type=management_address_type,
        )
        self._add(item)
        return item


class RsvpLspsState(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "rsvp_router_name": {"type": str},
        "ipv4_lsps": {"type": "RsvpIPv4LspStateIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, rsvp_router_name=None):
        super(RsvpLspsState, self).__init__()
        self._parent = parent
        self._set_property("rsvp_router_name", rsvp_router_name)

    def set(self, rsvp_router_name=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def rsvp_router_name(self):
        # type: () -> str
        """rsvp_router_name getter

        The name of the RSVP-TE Router.

        Returns: str
        """
        return self._get_property("rsvp_router_name")

    @rsvp_router_name.setter
    def rsvp_router_name(self, value):
        """rsvp_router_name setter

        The name of the RSVP-TE Router.

        value: str
        """
        self._set_property("rsvp_router_name", value)

    @property
    def ipv4_lsps(self):
        # type: () -> RsvpIPv4LspStateIter
        """ipv4_lsps getter

        IPv4 Point-to-Point RSVP-TE Discovered LSPs.

        Returns: RsvpIPv4LspStateIter
        """
        return self._get_property(
            "ipv4_lsps", RsvpIPv4LspStateIter, self._parent, self._choice
        )


class RsvpIPv4LspState(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "source_address": {
            "type": str,
            "format": "ipv4",
        },
        "destination_address": {
            "type": str,
            "format": "ipv4",
        },
        "lsp": {"type": "RsvpLspState"},
        "rros": {"type": "RsvpLspIpv4RroIter"},
        "eros": {"type": "RsvpLspIpv4EroIter"},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, source_address=None, destination_address=None):
        super(RsvpIPv4LspState, self).__init__()
        self._parent = parent
        self._set_property("source_address", source_address)
        self._set_property("destination_address", destination_address)

    def set(self, source_address=None, destination_address=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def source_address(self):
        # type: () -> str
        """source_address getter

        The origin IPv4 address of RSVP session.

        Returns: str
        """
        return self._get_property("source_address")

    @source_address.setter
    def source_address(self, value):
        """source_address setter

        The origin IPv4 address of RSVP session.

        value: str
        """
        self._set_property("source_address", value)

    @property
    def destination_address(self):
        # type: () -> str
        """destination_address getter

        The IPv4 destination address of RSVP session.

        Returns: str
        """
        return self._get_property("destination_address")

    @destination_address.setter
    def destination_address(self, value):
        """destination_address setter

        The IPv4 destination address of RSVP session.

        value: str
        """
        self._set_property("destination_address", value)

    @property
    def lsp(self):
        # type: () -> RsvpLspState
        """lsp getter

        IPv4 RSVP-TE Discovered LSPs.IPv4 RSVP-TE Discovered LSPs.IPv4 RSVP-TE Discovered LSPs.It refers to the RSVP LSP properties.

        Returns: RsvpLspState
        """
        return self._get_property("lsp", RsvpLspState)

    @property
    def rros(self):
        # type: () -> RsvpLspIpv4RroIter
        """rros getter

        It refers to RSVP RRO objects container.

        Returns: RsvpLspIpv4RroIter
        """
        return self._get_property(
            "rros", RsvpLspIpv4RroIter, self._parent, self._choice
        )

    @property
    def eros(self):
        # type: () -> RsvpLspIpv4EroIter
        """eros getter

        It refers to RSVP ERO objects container.

        Returns: RsvpLspIpv4EroIter
        """
        return self._get_property(
            "eros", RsvpLspIpv4EroIter, self._parent, self._choice
        )


class RsvpLspState(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "tunnel_id": {
            "type": int,
            "format": "uint32",
        },
        "lsp_id": {
            "type": int,
            "format": "uint32",
        },
        "session_name": {"type": str},
        "label_in": {
            "type": int,
            "format": "uint32",
        },
        "label_out": {
            "type": int,
            "format": "uint32",
        },
        "session_status": {
            "type": str,
            "enum": [
                "up",
                "down",
            ],
        },
        "last_flap_reason": {
            "type": str,
            "enum": [
                "resv_tear",
                "path_tear",
                "path_timeout",
            ],
        },
        "up_time": {
            "type": int,
            "format": "uint64",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    UP = "up"  # type: str
    DOWN = "down"  # type: str

    RESV_TEAR = "resv_tear"  # type: str
    PATH_TEAR = "path_tear"  # type: str
    PATH_TIMEOUT = "path_timeout"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self,
        parent=None,
        tunnel_id=None,
        lsp_id=None,
        session_name=None,
        label_in=None,
        label_out=None,
        session_status=None,
        last_flap_reason=None,
        up_time=None,
    ):
        super(RsvpLspState, self).__init__()
        self._parent = parent
        self._set_property("tunnel_id", tunnel_id)
        self._set_property("lsp_id", lsp_id)
        self._set_property("session_name", session_name)
        self._set_property("label_in", label_in)
        self._set_property("label_out", label_out)
        self._set_property("session_status", session_status)
        self._set_property("last_flap_reason", last_flap_reason)
        self._set_property("up_time", up_time)

    def set(
        self,
        tunnel_id=None,
        lsp_id=None,
        session_name=None,
        label_in=None,
        label_out=None,
        session_status=None,
        last_flap_reason=None,
        up_time=None,
    ):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def tunnel_id(self):
        # type: () -> int
        """tunnel_id getter

        The tunnel id of RSVP session which acts as an identifier that remains constant over the life of the tunnel.

        Returns: int
        """
        return self._get_property("tunnel_id")

    @tunnel_id.setter
    def tunnel_id(self, value):
        """tunnel_id setter

        The tunnel id of RSVP session which acts as an identifier that remains constant over the life of the tunnel.

        value: int
        """
        self._set_property("tunnel_id", value)

    @property
    def lsp_id(self):
        # type: () -> int
        """lsp_id getter

        The lsp-id of RSVP session which acts as differentiator for two lsps originating from the same headend, commonly used to distinguish RSVP sessions during make before break operations.

        Returns: int
        """
        return self._get_property("lsp_id")

    @lsp_id.setter
    def lsp_id(self, value):
        """lsp_id setter

        The lsp-id of RSVP session which acts as differentiator for two lsps originating from the same headend, commonly used to distinguish RSVP sessions during make before break operations.

        value: int
        """
        self._set_property("lsp_id", value)

    @property
    def session_name(self):
        # type: () -> str
        """session_name getter

        The value of RSVP-TE Session Name field of the Session Attribute object.

        Returns: str
        """
        return self._get_property("session_name")

    @session_name.setter
    def session_name(self, value):
        """session_name setter

        The value of RSVP-TE Session Name field of the Session Attribute object.

        value: str
        """
        self._set_property("session_name", value)

    @property
    def label_in(self):
        # type: () -> int
        """label_in getter

        The label received by RSVP-TE ingress.

        Returns: int
        """
        return self._get_property("label_in")

    @label_in.setter
    def label_in(self, value):
        """label_in setter

        The label received by RSVP-TE ingress.

        value: int
        """
        self._set_property("label_in", value)

    @property
    def label_out(self):
        # type: () -> int
        """label_out getter

        The label assigned by RSVP-TE egress.

        Returns: int
        """
        return self._get_property("label_out")

    @label_out.setter
    def label_out(self, value):
        """label_out setter

        The label assigned by RSVP-TE egress.

        value: int
        """
        self._set_property("label_out", value)

    @property
    def session_status(self):
        # type: () -> Union[Literal["down"], Literal["up"]]
        """session_status getter

        Operational state of the RSVP LSP.

        Returns: Union[Literal["down"], Literal["up"]]
        """
        return self._get_property("session_status")

    @session_status.setter
    def session_status(self, value):
        """session_status setter

        Operational state of the RSVP LSP.

        value: Union[Literal["down"], Literal["up"]]
        """
        self._set_property("session_status", value)

    @property
    def last_flap_reason(self):
        # type: () -> Union[Literal["path_tear"], Literal["path_timeout"], Literal["resv_tear"]]
        """last_flap_reason getter

        The reason for the last flap of this RSVP session.

        Returns: Union[Literal["path_tear"], Literal["path_timeout"], Literal["resv_tear"]]
        """
        return self._get_property("last_flap_reason")

    @last_flap_reason.setter
    def last_flap_reason(self, value):
        """last_flap_reason setter

        The reason for the last flap of this RSVP session.

        value: Union[Literal["path_tear"], Literal["path_timeout"], Literal["resv_tear"]]
        """
        self._set_property("last_flap_reason", value)

    @property
    def up_time(self):
        # type: () -> int
        """up_time getter

        The tunnel UP time in milli seconds. If the tunnel is DOWN the UP time will be zero.

        Returns: int
        """
        return self._get_property("up_time")

    @up_time.setter
    def up_time(self, value):
        """up_time setter

        The tunnel UP time in milli seconds. If the tunnel is DOWN the UP time will be zero.

        value: int
        """
        self._set_property("up_time", value)


class RsvpLspIpv4Rro(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "address": {
            "type": str,
            "format": "ipv4",
        },
        "reported_label": {
            "type": int,
            "format": "uint32",
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, address=None, reported_label=None):
        super(RsvpLspIpv4Rro, self).__init__()
        self._parent = parent
        self._set_property("address", address)
        self._set_property("reported_label", reported_label)

    def set(self, address=None, reported_label=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def address(self):
        # type: () -> str
        """address getter

        The IPv4 addresses of the routers that the traffic engineering tunnel traversed.

        Returns: str
        """
        return self._get_property("address")

    @address.setter
    def address(self, value):
        """address setter

        The IPv4 addresses of the routers that the traffic engineering tunnel traversed.

        value: str
        """
        self._set_property("address", value)

    @property
    def reported_label(self):
        # type: () -> int
        """reported_label getter

        Label reported for RRO hop. When the Label_Recording flag is set in the Session Attribute object, nodes doing route recording should include the Label Record subobject containing the reported label.

        Returns: int
        """
        return self._get_property("reported_label")

    @reported_label.setter
    def reported_label(self, value):
        """reported_label setter

        Label reported for RRO hop. When the Label_Recording flag is set in the Session Attribute object, nodes doing route recording should include the Label Record subobject containing the reported label.

        value: int
        """
        self._set_property("reported_label", value)


class RsvpLspIpv4RroIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(RsvpLspIpv4RroIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[RsvpLspIpv4Rro]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> RsvpLspIpv4RroIter
        return self._iter()

    def __next__(self):
        # type: () -> RsvpLspIpv4Rro
        return self._next()

    def next(self):
        # type: () -> RsvpLspIpv4Rro
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, RsvpLspIpv4Rro):
            raise Exception("Item is not an instance of RsvpLspIpv4Rro")

    def ipv4rro(self, address=None, reported_label=None):
        # type: (str,int) -> RsvpLspIpv4RroIter
        """Factory method that creates an instance of the RsvpLspIpv4Rro class

        This contains the list of Record Route Object(RRO) objects associated with the traffic engineering tunnel. The Record Route Object(RRO) is used in RSVP-TE to record the route traversed by the LSP. The RRO might be present in both Path message and Resv message, the RRO stores the IP addresses of the routers that the traffic engineering tunnel traversed and also the label generated and distributed by the routers. The RROs in the Resv message mirrors that of the Path message, the only difference is that the RRO in Resv message records the path information in the reverse direction.

        Returns: RsvpLspIpv4RroIter
        """
        item = RsvpLspIpv4Rro(
            parent=self._parent, address=address, reported_label=reported_label
        )
        self._add(item)
        return self

    def add(self, address=None, reported_label=None):
        # type: (str,int) -> RsvpLspIpv4Rro
        """Add method that creates and returns an instance of the RsvpLspIpv4Rro class

        This contains the list of Record Route Object(RRO) objects associated with the traffic engineering tunnel. The Record Route Object(RRO) is used in RSVP-TE to record the route traversed by the LSP. The RRO might be present in both Path message and Resv message, the RRO stores the IP addresses of the routers that the traffic engineering tunnel traversed and also the label generated and distributed by the routers. The RROs in the Resv message mirrors that of the Path message, the only difference is that the RRO in Resv message records the path information in the reverse direction.

        Returns: RsvpLspIpv4Rro
        """
        item = RsvpLspIpv4Rro(
            parent=self._parent, address=address, reported_label=reported_label
        )
        self._add(item)
        return item


class RsvpLspIpv4Ero(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "prefix": {
            "type": str,
            "format": "ipv4",
        },
        "asn": {
            "type": int,
            "format": "uint32",
        },
        "type": {
            "type": str,
            "enum": [
                "ipv4",
                "ipv6",
                "asn",
                "asn4",
                "label",
                "unnumbered_interface",
            ],
        },
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    IPV4 = "ipv4"  # type: str
    IPV6 = "ipv6"  # type: str
    ASN = "asn"  # type: str
    ASN4 = "asn4"  # type: str
    LABEL = "label"  # type: str
    UNNUMBERED_INTERFACE = "unnumbered_interface"  # type: str

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, prefix=None, asn=None, type=None):
        super(RsvpLspIpv4Ero, self).__init__()
        self._parent = parent
        self._set_property("prefix", prefix)
        self._set_property("asn", asn)
        self._set_property("type", type)

    def set(self, prefix=None, asn=None, type=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def prefix(self):
        # type: () -> str
        """prefix getter

        The IPv4 prefix indicated by the ERO. Specified only when the ERO hop is an IPv4 prefix.

        Returns: str
        """
        return self._get_property("prefix")

    @prefix.setter
    def prefix(self, value):
        """prefix setter

        The IPv4 prefix indicated by the ERO. Specified only when the ERO hop is an IPv4 prefix.

        value: str
        """
        self._set_property("prefix", value)

    @property
    def asn(self):
        # type: () -> int
        """asn getter

        The autonomous system number indicated by the ERO. Specified only when the ERO hop is an or 4-byte AS number.

        Returns: int
        """
        return self._get_property("asn")

    @asn.setter
    def asn(self, value):
        """asn setter

        The autonomous system number indicated by the ERO. Specified only when the ERO hop is an or 4-byte AS number.

        value: int
        """
        self._set_property("asn", value)

    @property
    def type(self):
        # type: () -> Union[Literal["asn"], Literal["asn4"], Literal["ipv4"], Literal["ipv6"], Literal["label"], Literal["unnumbered_interface"]]
        """type getter

        The type indicated by the ERO.

        Returns: Union[Literal["asn"], Literal["asn4"], Literal["ipv4"], Literal["ipv6"], Literal["label"], Literal["unnumbered_interface"]]
        """
        return self._get_property("type")

    @type.setter
    def type(self, value):
        """type setter

        The type indicated by the ERO.

        value: Union[Literal["asn"], Literal["asn4"], Literal["ipv4"], Literal["ipv6"], Literal["label"], Literal["unnumbered_interface"]]
        """
        self._set_property("type", value)


class RsvpLspIpv4EroIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(RsvpLspIpv4EroIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[RsvpLspIpv4Ero]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> RsvpLspIpv4EroIter
        return self._iter()

    def __next__(self):
        # type: () -> RsvpLspIpv4Ero
        return self._next()

    def next(self):
        # type: () -> RsvpLspIpv4Ero
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, RsvpLspIpv4Ero):
            raise Exception("Item is not an instance of RsvpLspIpv4Ero")

    def ipv4ero(self, prefix=None, asn=None, type=None):
        # type: (str,int,Union[Literal["asn"], Literal["asn4"], Literal["ipv4"], Literal["ipv6"], Literal["label"], Literal["unnumbered_interface"]]) -> RsvpLspIpv4EroIter
        """Factory method that creates an instance of the RsvpLspIpv4Ero class

        This contains the list of sub-objects included in the Explicit Route Object(ERO) object send in the PATH message from the ingress. These sub-objects contain the intermediate hops to be traversed by the LSP while being forwarded towards the egress endpoint.

        Returns: RsvpLspIpv4EroIter
        """
        item = RsvpLspIpv4Ero(parent=self._parent, prefix=prefix, asn=asn, type=type)
        self._add(item)
        return self

    def add(self, prefix=None, asn=None, type=None):
        # type: (str,int,Union[Literal["asn"], Literal["asn4"], Literal["ipv4"], Literal["ipv6"], Literal["label"], Literal["unnumbered_interface"]]) -> RsvpLspIpv4Ero
        """Add method that creates and returns an instance of the RsvpLspIpv4Ero class

        This contains the list of sub-objects included in the Explicit Route Object(ERO) object send in the PATH message from the ingress. These sub-objects contain the intermediate hops to be traversed by the LSP while being forwarded towards the egress endpoint.

        Returns: RsvpLspIpv4Ero
        """
        item = RsvpLspIpv4Ero(parent=self._parent, prefix=prefix, asn=asn, type=type)
        self._add(item)
        return item


class RsvpIPv4LspStateIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(RsvpIPv4LspStateIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[RsvpIPv4LspState]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> RsvpIPv4LspStateIter
        return self._iter()

    def __next__(self):
        # type: () -> RsvpIPv4LspState
        return self._next()

    def next(self):
        # type: () -> RsvpIPv4LspState
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, RsvpIPv4LspState):
            raise Exception("Item is not an instance of RsvpIPv4LspState")

    def state(self, source_address=None, destination_address=None):
        # type: (str,str) -> RsvpIPv4LspStateIter
        """Factory method that creates an instance of the RsvpIPv4LspState class

        IPv4 RSVP-TE Discovered LSPs.

        Returns: RsvpIPv4LspStateIter
        """
        item = RsvpIPv4LspState(
            parent=self._parent,
            source_address=source_address,
            destination_address=destination_address,
        )
        self._add(item)
        return self

    def add(self, source_address=None, destination_address=None):
        # type: (str,str) -> RsvpIPv4LspState
        """Add method that creates and returns an instance of the RsvpIPv4LspState class

        IPv4 RSVP-TE Discovered LSPs.

        Returns: RsvpIPv4LspState
        """
        item = RsvpIPv4LspState(
            parent=self._parent,
            source_address=source_address,
            destination_address=destination_address,
        )
        self._add(item)
        return item


class RsvpLspsStateIter(OpenApiIter):
    __slots__ = ("_parent", "_choice")

    _GETITEM_RETURNS_CHOICE_OBJECT = False

    def __init__(self, parent=None, choice=None):
        super(RsvpLspsStateIter, self).__init__()
        self._parent = parent
        self._choice = choice

    def __getitem__(self, key):
        # type: (str) -> Union[RsvpLspsState]
        return self._getitem(key)

    def __iter__(self):
        # type: () -> RsvpLspsStateIter
        return self._iter()

    def __next__(self):
        # type: () -> RsvpLspsState
        return self._next()

    def next(self):
        # type: () -> RsvpLspsState
        return self._next()

    def _instanceOf(self, item):
        if not isinstance(item, RsvpLspsState):
            raise Exception("Item is not an instance of RsvpLspsState")

    def state(self, rsvp_router_name=None):
        # type: (str) -> RsvpLspsStateIter
        """Factory method that creates an instance of the RsvpLspsState class

        Discovered IPv4 Point-to-Point LSPs of RSVP-TE router.

        Returns: RsvpLspsStateIter
        """
        item = RsvpLspsState(parent=self._parent, rsvp_router_name=rsvp_router_name)
        self._add(item)
        return self

    def add(self, rsvp_router_name=None):
        # type: (str) -> RsvpLspsState
        """Add method that creates and returns an instance of the RsvpLspsState class

        Discovered IPv4 Point-to-Point LSPs of RSVP-TE router.

        Returns: RsvpLspsState
        """
        item = RsvpLspsState(parent=self._parent, rsvp_router_name=rsvp_router_name)
        self._add(item)
        return item


class CaptureRequest(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "port_name": {"type": str},
    }  # type: Dict[str, str]

    _REQUIRED = ("port_name",)  # type: tuple(str)

    _DEFAULTS = {}  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(self, parent=None, port_name=None):
        super(CaptureRequest, self).__init__()
        self._parent = parent
        self._set_property("port_name", port_name)

    def set(self, port_name=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def port_name(self):
        # type: () -> str
        """port_name getter

        The name of port capture is started on.. x-constraint:. /components/schemas/Port/properties/name. . x-constraint:. /components/schemas/Port/properties/name.

        Returns: str
        """
        return self._get_property("port_name")

    @port_name.setter
    def port_name(self, value):
        """port_name setter

        The name of port capture is started on.. x-constraint:. /components/schemas/Port/properties/name. . x-constraint:. /components/schemas/Port/properties/name.

        value: str
        """
        if value is None:
            raise TypeError("Cannot set required property port_name as None")
        self._set_property("port_name", value)


class Version(OpenApiObject):
    __slots__ = "_parent"

    _TYPES = {
        "api_spec_version": {"type": str},
        "sdk_version": {"type": str},
        "app_version": {"type": str},
    }  # type: Dict[str, str]

    _REQUIRED = ()  # type: tuple(str)

    _DEFAULTS = {
        "api_spec_version": "",
        "sdk_version": "",
        "app_version": "",
    }  # type: Dict[str, Union(type)]

    _STATUS = {}  # type: Dict[str, Union(type)]

    def __init__(
        self, parent=None, api_spec_version="", sdk_version="", app_version=""
    ):
        super(Version, self).__init__()
        self._parent = parent
        self._set_property("api_spec_version", api_spec_version)
        self._set_property("sdk_version", sdk_version)
        self._set_property("app_version", app_version)

    def set(self, api_spec_version=None, sdk_version=None, app_version=None):
        for property_name, property_value in locals().items():
            if property_name != "self" and property_value is not None:
                self._set_property(property_name, property_value)

    @property
    def api_spec_version(self):
        # type: () -> str
        """api_spec_version getter

        Version of API specification

        Returns: str
        """
        return self._get_property("api_spec_version")

    @api_spec_version.setter
    def api_spec_version(self, value):
        """api_spec_version setter

        Version of API specification

        value: str
        """
        self._set_property("api_spec_version", value)

    @property
    def sdk_version(self):
        # type: () -> str
        """sdk_version getter

        Version of SDK generated from API specification

        Returns: str
        """
        return self._get_property("sdk_version")

    @sdk_version.setter
    def sdk_version(self, value):
        """sdk_version setter

        Version of SDK generated from API specification

        value: str
        """
        self._set_property("sdk_version", value)

    @property
    def app_version(self):
        # type: () -> str
        """app_version getter

        Version of application consuming or serving the API

        Returns: str
        """
        return self._get_property("app_version")

    @app_version.setter
    def app_version(self, value):
        """app_version setter

        Version of application consuming or serving the API

        value: str
        """
        self._set_property("app_version", value)


class Api(object):
    """OpenApi Abstract API"""

    __warnings__ = []

    def __init__(self, **kwargs):
        self._version_meta = self.version()
        self._version_meta.api_spec_version = "0.13.0"
        self._version_meta.sdk_version = "0.13.0"
        self._version_check = kwargs.get("version_check")
        if self._version_check is None:
            self._version_check = False
        self._version_check_err = None

    def add_warnings(self, msg):
        print("[WARNING]: %s" % msg)
        self.__warnings__.append(msg)

    def _deserialize_error(self, err_string):
        # type: (str) -> Union[Error, None]
        err = self.error()
        try:
            err.deserialize(err_string)
        except Exception:
            err = None
        return err

    def from_exception(self, error):
        # type: (Exception) -> Union[Error, None]
        if isinstance(error, Error):
            return error
        elif isinstance(error, grpc.RpcError):
            err = self._deserialize_error(error.details())
            if err is not None:
                return err
            err = self.error()
            err.code = error.code().value[0]
            err.errors = [error.details()]
            return err
        elif isinstance(error, Exception):
            if len(error.args) != 1:
                return None
            if isinstance(error.args[0], Error):
                return error.args[0]
            elif isinstance(error.args[0], str):
                return self._deserialize_error(error.args[0])

    def set_config(self, payload):
        """POST /config

        Sets configuration resources on the traffic generator.

        Return: warning
        """
        raise NotImplementedError("set_config")

    def get_config(self):
        """GET /config

        TBD

        Return: config
        """
        raise NotImplementedError("get_config")

    def update_config(self, payload):
        """PATCH /config

        Updates specific attributes of resources configured on the traffic generator. The fetched configuration shall reflect the updates applied successfully.. The Response.Warnings in the Success response is available for implementers to disclose additional information about state change including any implicit changes that are outside the scope of the state change.

        Return: warning
        """
        raise NotImplementedError("update_config")

    def set_control_state(self, payload):
        """POST /control/state

        Sets the operational state of configured resources.

        Return: warning
        """
        raise NotImplementedError("set_control_state")

    def set_control_action(self, payload):
        """POST /control/action

        Triggers actions against configured resources.

        Return: control_action_response
        """
        raise NotImplementedError("set_control_action")

    def get_metrics(self, payload):
        """POST /monitor/metrics

        TBD

        Return: metrics_response
        """
        raise NotImplementedError("get_metrics")

    def get_states(self, payload):
        """POST /monitor/states

        TBD

        Return: states_response
        """
        raise NotImplementedError("get_states")

    def get_capture(self, payload):
        """POST /monitor/capture

        TBD

        Return: None
        """
        raise NotImplementedError("get_capture")

    def get_version(self):
        """GET /capabilities/version

        TBD

        Return: version
        """
        raise NotImplementedError("get_version")

    def config(self):
        """Factory method that creates an instance of Config

        Return: Config
        """
        return Config()

    def warning(self):
        """Factory method that creates an instance of Warning

        Return: Warning
        """
        return Warning()

    def error(self):
        """Factory method that creates an instance of Error

        Return: Error
        """
        return Error()

    def config_update(self):
        """Factory method that creates an instance of ConfigUpdate

        Return: ConfigUpdate
        """
        return ConfigUpdate()

    def control_state(self):
        """Factory method that creates an instance of ControlState

        Return: ControlState
        """
        return ControlState()

    def control_action(self):
        """Factory method that creates an instance of ControlAction

        Return: ControlAction
        """
        return ControlAction()

    def control_action_response(self):
        """Factory method that creates an instance of ControlActionResponse

        Return: ControlActionResponse
        """
        return ControlActionResponse()

    def metrics_request(self):
        """Factory method that creates an instance of MetricsRequest

        Return: MetricsRequest
        """
        return MetricsRequest()

    def metrics_response(self):
        """Factory method that creates an instance of MetricsResponse

        Return: MetricsResponse
        """
        return MetricsResponse()

    def states_request(self):
        """Factory method that creates an instance of StatesRequest

        Return: StatesRequest
        """
        return StatesRequest()

    def states_response(self):
        """Factory method that creates an instance of StatesResponse

        Return: StatesResponse
        """
        return StatesResponse()

    def capture_request(self):
        """Factory method that creates an instance of CaptureRequest

        Return: CaptureRequest
        """
        return CaptureRequest()

    def version(self):
        """Factory method that creates an instance of Version

        Return: Version
        """
        return Version()

    def close(self):
        pass

    def _check_client_server_version_compatibility(
        self, client_ver, server_ver, component_name
    ):
        try:
            c = semantic_version.Version(client_ver)
        except Exception as e:
            raise AssertionError(
                "Client {} version '{}' is not a valid semver: {}".format(
                    component_name, client_ver, e
                )
            )

        try:
            s = semantic_version.SimpleSpec(server_ver)
        except Exception as e:
            raise AssertionError(
                "Server {} version '{}' is not a valid semver: {}".format(
                    component_name, server_ver, e
                )
            )

        err = "Client {} version '{}' is not semver compatible with Server {} version '{}'".format(
            component_name, client_ver, component_name, server_ver
        )

        if not s.match(c):
            raise Exception(err)

    def get_local_version(self):
        return self._version_meta

    def get_remote_version(self):
        return self.get_version()

    def check_version_compatibility(self):
        comp_err, api_err = self._do_version_check()
        if comp_err is not None:
            raise comp_err
        if api_err is not None:
            raise api_err

    def _do_version_check(self):
        local = self.get_local_version()
        try:
            remote = self.get_remote_version()
        except Exception as e:
            return None, e

        try:
            self._check_client_server_version_compatibility(
                local.api_spec_version, remote.api_spec_version, "API spec"
            )
        except Exception as e:
            msg = "client SDK version '{}' is not compatible with server SDK version '{}'".format(
                local.sdk_version, remote.sdk_version
            )
            return Exception("{}: {}".format(msg, str(e))), None

        return None, None

    def _do_version_check_once(self):
        if not self._version_check:
            return

        if self._version_check_err is not None:
            raise self._version_check_err

        comp_err, api_err = self._do_version_check()
        if comp_err is not None:
            self._version_check_err = comp_err
            raise comp_err
        if api_err is not None:
            self._version_check_err = None
            raise api_err

        self._version_check = False
        self._version_check_err = None


class HttpApi(Api):
    """OpenAPI HTTP Api"""

    def __init__(self, **kwargs):
        super(HttpApi, self).__init__(**kwargs)
        self._transport = HttpTransport(**kwargs)

    @property
    def verify(self):
        return self._transport.verify

    @verify.setter
    def verify(self, value):
        self._transport.set_verify(value)

    def set_config(self, payload):
        """POST /config

        Sets configuration resources on the traffic generator.

        Return: warning
        """
        self._do_version_check_once()
        return self._transport.send_recv(
            "post",
            "/config",
            payload=payload,
            return_object=self.warning(),
            request_class=Config,
        )

    def get_config(self):
        """GET /config

        TBD

        Return: config
        """
        self._do_version_check_once()
        return self._transport.send_recv(
            "get",
            "/config",
            payload=None,
            return_object=self.config(),
        )

    def update_config(self, payload):
        """PATCH /config

        Updates specific attributes of resources configured on the traffic generator. The fetched configuration shall reflect the updates applied successfully.. The Response.Warnings in the Success response is available for implementers to disclose additional information about state change including any implicit changes that are outside the scope of the state change.

        Return: warning
        """
        self._do_version_check_once()
        return self._transport.send_recv(
            "patch",
            "/config",
            payload=payload,
            return_object=self.warning(),
            request_class=ConfigUpdate,
        )

    def set_control_state(self, payload):
        """POST /control/state

        Sets the operational state of configured resources.

        Return: warning
        """
        self._do_version_check_once()
        return self._transport.send_recv(
            "post",
            "/control/state",
            payload=payload,
            return_object=self.warning(),
            request_class=ControlState,
        )

    def set_control_action(self, payload):
        """POST /control/action

        Triggers actions against configured resources.

        Return: control_action_response
        """
        self._do_version_check_once()
        return self._transport.send_recv(
            "post",
            "/control/action",
            payload=payload,
            return_object=self.control_action_response(),
            request_class=ControlAction,
        )

    def get_metrics(self, payload):
        """POST /monitor/metrics

        TBD

        Return: metrics_response
        """
        self._do_version_check_once()
        return self._transport.send_recv(
            "post",
            "/monitor/metrics",
            payload=payload,
            return_object=self.metrics_response(),
            request_class=MetricsRequest,
        )

    def get_states(self, payload):
        """POST /monitor/states

        TBD

        Return: states_response
        """
        self._do_version_check_once()
        return self._transport.send_recv(
            "post",
            "/monitor/states",
            payload=payload,
            return_object=self.states_response(),
            request_class=StatesRequest,
        )

    def get_capture(self, payload):
        """POST /monitor/capture

        TBD

        Return: None
        """
        self._do_version_check_once()
        return self._transport.send_recv(
            "post",
            "/monitor/capture",
            payload=payload,
            return_object=None,
            request_class=CaptureRequest,
        )

    def get_version(self):
        """GET /capabilities/version

        TBD

        Return: version
        """
        return self._transport.send_recv(
            "get",
            "/capabilities/version",
            payload=None,
            return_object=self.version(),
        )


class GrpcApi(Api):
    # OpenAPI gRPC Api
    def __init__(self, **kwargs):
        super(GrpcApi, self).__init__(**kwargs)
        self._stub = None
        self._channel = None
        self._cert = None
        self._cert_domain = None
        self._request_timeout = 10
        self._keep_alive_timeout = 10 * 1000
        self._location = (
            kwargs["location"]
            if "location" in kwargs and kwargs["location"] is not None
            else "localhost:50051"
        )
        self._transport = kwargs["transport"] if "transport" in kwargs else None
        self._logger = kwargs["logger"] if "logger" in kwargs else None
        self._loglevel = kwargs["loglevel"] if "loglevel" in kwargs else logging.DEBUG
        if self._logger is None:
            stdout_handler = logging.StreamHandler(sys.stdout)
            formatter = logging.Formatter(
                fmt="%(asctime)s [%(name)s] [%(levelname)s] %(message)s",
                datefmt="%Y-%m-%d %H:%M:%S",
            )
            formatter.converter = time.gmtime
            stdout_handler.setFormatter(formatter)
            self._logger = logging.Logger(self.__module__, level=self._loglevel)
            self._logger.addHandler(stdout_handler)
        self._logger.debug(
            "gRPCTransport args: {}".format(
                ", ".join(["{}={!r}".format(k, v) for k, v in kwargs.items()])
            )
        )

    def _use_secure_connection(self, cert_path, cert_domain=None):
        """Accepts certificate and host_name for SSL Connection."""
        if cert_path is None:
            raise Exception("path to certificate cannot be None")
        self._cert = cert_path
        self._cert_domain = cert_domain

    def _get_stub(self):
        if self._stub is None:
            CHANNEL_OPTIONS = [
                ("grpc.enable_retries", 0),
                ("grpc.keepalive_timeout_ms", self._keep_alive_timeout),
            ]
            if self._cert is None:
                self._channel = grpc.insecure_channel(
                    self._location, options=CHANNEL_OPTIONS
                )
            else:
                crt = open(self._cert, "rb").read()
                creds = grpc.ssl_channel_credentials(crt)
                if self._cert_domain is not None:
                    CHANNEL_OPTIONS.append(
                        ("grpc.ssl_target_name_override", self._cert_domain)
                    )
                self._channel = grpc.secure_channel(
                    self._location, credentials=creds, options=CHANNEL_OPTIONS
                )
            self._stub = pb2_grpc.OpenapiStub(self._channel)
        return self._stub

    def _serialize_payload(self, payload):
        if not isinstance(payload, (str, dict, OpenApiBase)):
            raise Exception("We are supporting [str, dict, OpenApiBase] object")
        if isinstance(payload, OpenApiBase):
            payload = payload.serialize()
        if isinstance(payload, dict):
            payload = json.dumps(payload)
        elif isinstance(payload, (str, unicode)):
            payload = json.dumps(yaml.safe_load(payload))
        return payload

    def _raise_exception(self, grpc_error):
        err = self.error()
        try:
            err.deserialize(grpc_error.details())
        except Exception as _:
            err.code = grpc_error.code().value[0]
            err.errors = [grpc_error.details()]
        raise Exception(err)

    @property
    def request_timeout(self):
        """duration of time in seconds to allow for the RPC."""
        return self._request_timeout

    @request_timeout.setter
    def request_timeout(self, timeout):
        self._request_timeout = timeout

    @property
    def keep_alive_timeout(self):
        return self._keep_alive_timeout

    @keep_alive_timeout.setter
    def keep_alive_timeout(self, timeout):
        self._keep_alive_timeout = timeout * 1000

    def close(self):
        if self._channel is not None:
            self._channel.close()
            self._channel = None
            self._stub = None

    def set_config(self, payload):
        pb_obj = json_format.Parse(self._serialize_payload(payload), pb2.Config())
        self._do_version_check_once()
        req_obj = pb2.SetConfigRequest(config=pb_obj)
        stub = self._get_stub()
        try:
            res_obj = stub.SetConfig(req_obj, timeout=self._request_timeout)
        except grpc.RpcError as grpc_error:
            self._raise_exception(grpc_error)
        response = json_format.MessageToDict(res_obj, preserving_proto_field_name=True)
        result = response.get("warning")
        if result is not None:
            if len(result) == 0:
                result = json_format.MessageToDict(
                    res_obj.warning,
                    preserving_proto_field_name=True,
                    including_default_value_fields=True,
                )
            return self.warning().deserialize(result)

    def get_config(self):
        stub = self._get_stub()
        empty = pb2_grpc.google_dot_protobuf_dot_empty__pb2.Empty()
        res_obj = stub.GetConfig(empty, timeout=self._request_timeout)
        response = json_format.MessageToDict(res_obj, preserving_proto_field_name=True)
        result = response.get("config")
        if result is not None:
            return self.config().deserialize(result)

    def update_config(self, payload):
        pb_obj = json_format.Parse(self._serialize_payload(payload), pb2.ConfigUpdate())
        self._do_version_check_once()
        req_obj = pb2.UpdateConfigRequest(config_update=pb_obj)
        stub = self._get_stub()
        try:
            res_obj = stub.UpdateConfig(req_obj, timeout=self._request_timeout)
        except grpc.RpcError as grpc_error:
            self._raise_exception(grpc_error)
        response = json_format.MessageToDict(res_obj, preserving_proto_field_name=True)
        result = response.get("warning")
        if result is not None:
            if len(result) == 0:
                result = json_format.MessageToDict(
                    res_obj.warning,
                    preserving_proto_field_name=True,
                    including_default_value_fields=True,
                )
            return self.warning().deserialize(result)

    def set_control_state(self, payload):
        pb_obj = json_format.Parse(self._serialize_payload(payload), pb2.ControlState())
        self._do_version_check_once()
        req_obj = pb2.SetControlStateRequest(control_state=pb_obj)
        stub = self._get_stub()
        try:
            res_obj = stub.SetControlState(req_obj, timeout=self._request_timeout)
        except grpc.RpcError as grpc_error:
            self._raise_exception(grpc_error)
        response = json_format.MessageToDict(res_obj, preserving_proto_field_name=True)
        result = response.get("warning")
        if result is not None:
            if len(result) == 0:
                result = json_format.MessageToDict(
                    res_obj.warning,
                    preserving_proto_field_name=True,
                    including_default_value_fields=True,
                )
            return self.warning().deserialize(result)

    def set_control_action(self, payload):
        pb_obj = json_format.Parse(
            self._serialize_payload(payload), pb2.ControlAction()
        )
        self._do_version_check_once()
        req_obj = pb2.SetControlActionRequest(control_action=pb_obj)
        stub = self._get_stub()
        try:
            res_obj = stub.SetControlAction(req_obj, timeout=self._request_timeout)
        except grpc.RpcError as grpc_error:
            self._raise_exception(grpc_error)
        response = json_format.MessageToDict(res_obj, preserving_proto_field_name=True)
        result = response.get("control_action_response")
        if result is not None:
            if len(result) == 0:
                result = json_format.MessageToDict(
                    res_obj.control_action_response,
                    preserving_proto_field_name=True,
                    including_default_value_fields=True,
                )
            return self.control_action_response().deserialize(result)

    def get_metrics(self, payload):
        pb_obj = json_format.Parse(
            self._serialize_payload(payload), pb2.MetricsRequest()
        )
        self._do_version_check_once()
        req_obj = pb2.GetMetricsRequest(metrics_request=pb_obj)
        stub = self._get_stub()
        try:
            res_obj = stub.GetMetrics(req_obj, timeout=self._request_timeout)
        except grpc.RpcError as grpc_error:
            self._raise_exception(grpc_error)
        response = json_format.MessageToDict(res_obj, preserving_proto_field_name=True)
        result = response.get("metrics_response")
        if result is not None:
            return self.metrics_response().deserialize(result)

    def get_states(self, payload):
        pb_obj = json_format.Parse(
            self._serialize_payload(payload), pb2.StatesRequest()
        )
        self._do_version_check_once()
        req_obj = pb2.GetStatesRequest(states_request=pb_obj)
        stub = self._get_stub()
        try:
            res_obj = stub.GetStates(req_obj, timeout=self._request_timeout)
        except grpc.RpcError as grpc_error:
            self._raise_exception(grpc_error)
        response = json_format.MessageToDict(res_obj, preserving_proto_field_name=True)
        result = response.get("states_response")
        if result is not None:
            return self.states_response().deserialize(result)

    def get_capture(self, payload):
        pb_obj = json_format.Parse(
            self._serialize_payload(payload), pb2.CaptureRequest()
        )
        self._do_version_check_once()
        req_obj = pb2.GetCaptureRequest(capture_request=pb_obj)
        stub = self._get_stub()
        try:
            res_obj = stub.GetCapture(req_obj, timeout=self._request_timeout)
        except grpc.RpcError as grpc_error:
            self._raise_exception(grpc_error)
        response = json_format.MessageToDict(res_obj, preserving_proto_field_name=True)
        bytes = response.get("response_bytes")
        if bytes is not None:
            return io.BytesIO(res_obj.response_bytes)

    def get_version(self):
        stub = self._get_stub()
        empty = pb2_grpc.google_dot_protobuf_dot_empty__pb2.Empty()
        res_obj = stub.GetVersion(empty, timeout=self._request_timeout)
        response = json_format.MessageToDict(res_obj, preserving_proto_field_name=True)
        result = response.get("version")
        if result is not None:
            return self.version().deserialize(result)
