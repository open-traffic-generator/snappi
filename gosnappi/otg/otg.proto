/* Open Traffic Generator API 0.11.10
 * Open Traffic Generator API defines a model-driven, vendor-neutral and standard
 * interface for emulating layer 2-7 network devices and generating test traffic.
 * 
 * Contributions can be made in the following ways:
 * - [open an issue](https://github.com/open-traffic-generator/models/issues) in the
 * models repository
 * - [fork the models repository](https://github.com/open-traffic-generator/models)
 * and submit a PR
 * License: MIT */

syntax = "proto3";

package otg;

option go_package = "./otg;otg";

import "google/protobuf/descriptor.proto";
import "google/protobuf/empty.proto";

// A container for all models that are part of the configuration.
message Config {

  // The ports that will be configured on the traffic generator.
  repeated Port ports = 1;

  // The LAGs that will be configured on the traffic generator.
  repeated Lag lags = 2;

  // The layer1 settings that will be configured on the traffic generator.
  repeated Layer1 layer1 = 3;

  // The capture settings that will be configured on the traffic generator.
  repeated Capture captures = 4;

  // The emulated devices that will be configured on the traffic generator.
  // Each device contains configurations for network interfaces and
  // protocols running on top of those interfaces.
  repeated Device devices = 5;

  // The flows that will be configured on the traffic generator.
  repeated Flow flows = 6;

  // Description missing in models
  optional Event events = 7;

  // Description missing in models
  optional ConfigOptions options = 8;

  // LLDP protocol that will be configured on traffic generator.
  repeated Lldp lldp = 9;
}

// Global configuration options.
message ConfigOptions {

  // Description missing in models
  optional PortOptions port_options = 1;

  // Description missing in models
  optional ProtocolOptions protocol_options = 2;
}

// An abstract test port.
message Port {

  // The location of a test port.  It is the endpoint where packets will emit from.
  // Test port locations can be the following:
  // - physical appliance with multiple ports
  // - physical chassis with multiple cards and ports
  // - local interface
  // - virtual machine, docker container, kubernetes cluster
  // 
  // The test port location format is implementation specific. Use the /results/capabilities
  // API to determine what formats an  implementation supports for the location property.
  // Get the configured location state by using the /results/port API.
  optional string location = 1;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  string name = 2;
}

// Common port options that apply to all configured Port objects.
message PortOptions {

  // Preempt all the test port locations as defined by the  Port.Port.properties.location.
  // If the test ports defined by their location values are in use and  this value is
  // true, the test ports will be preempted.
  // default = False
  optional bool location_preemption = 1;
}

// The container for LAG (ports group) - aggregation of multiple LAG members (ports)
message Lag {

  // Description missing in models
  repeated LagPort ports = 1;

  // Description missing in models
  optional LagProtocol protocol = 2;

  // Specifies the mininum number of member interfaces that must be active for the aggregate
  // interface to be available.
  // If the aggregate interface is not available due to min-links criterion not being
  // met, LACPDUs continue to be transmitted and received by the member interfaces if
  // LACP is enabled, but other PDUs are not transmitted or received.
  // default = 1
  optional uint32 min_links = 3;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  string name = 4;
}

// The container for a port's ethernet interface and LAG protocol settings
message LagPort {

  // The name of a port object that will be part of the LAG.
  // 
  // x-constraint:
  // - /components/schemas/Port/properties/name
  // 
  // required = true
  string port_name = 1;

  // Description missing in models
  optional LagPortLacp lacp = 2;

  // Description missing in models
  // required = true
  DeviceEthernetBase ethernet = 3;
}

// Description missing in models
message LagProtocol {

  message Choice {
    enum Enum {
      unspecified = 0;
      lacp = 1;
      static = 2;
    }
  }
  // The type of controlling protocol for the LAG (ports group).
  // default = Choice.Enum.lacp
  optional Choice.Enum choice = 1;

  // Description missing in models
  optional LagProtocolLacp lacp = 2;

  // Description missing in models
  optional LagProtocolStatic static = 3;
}

// The container for static link aggregation protocol settings.
message LagProtocolStatic {

  // The static lag id
  // default = 0
  optional uint32 lag_id = 1;
}

// The container for link aggregation control protocol settings of a LAG (ports group).
message LagProtocolLacp {

  // The actor system id
  // default = 00:00:00:00:00:00
  optional string actor_system_id = 1;

  // The actor system priority
  // default = 0
  optional uint32 actor_system_priority = 2;

  // The actor key
  // default = 0
  optional uint32 actor_key = 3;
}

// The container for link aggregation control protocol settings of a LAG member (port).
message LagPortLacp {

  // The actor port number
  // default = 0
  optional uint32 actor_port_number = 1;

  // The actor port priority
  // default = 1
  optional uint32 actor_port_priority = 2;

  message ActorActivity {
    enum Enum {
      unspecified = 0;
      passive = 1;
      active = 2;
    }
  }
  // Sets the value of LACP actor activity as either passive or active.
  // Passive indicates the port's preference for not transmitting  LACPDUs unless its
  // partner's control is Active.
  // Active indicates the port's preference to participate in the  protocol regardless
  // of the partner's control value.
  // default = ActorActivity.Enum.active
  optional ActorActivity.Enum actor_activity = 3;

  // This field defines how frequently LACPDUs are sent to the link partner
  // default = 0
  optional uint32 lacpdu_periodic_time_interval = 4;

  // This timer is used to detect whether received protocol information has expired
  // default = 0
  optional uint32 lacpdu_timeout = 5;
}

// Base Ethernet interface.
message DeviceEthernetBase {

  // Media Access Control address.
  // required = true
  string mac = 1;

  // Maximum Transmission Unit.
  // default = 1500
  optional uint32 mtu = 2;

  // List of VLANs
  repeated DeviceVlan vlans = 3;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  string name = 4;
}

// An Ethernet interface with IPv4 and IPv6 addresses.
message DeviceEthernet {

  // Deprecated: This property is deprecated in favor of property connection.port_name
  // 
  // The unique name of a Port or a LAG that will emulate this interface.
  // port_name is deprecated and will be removed in future release.port_name and connection
  // can't be used together, use either port_name or connection.
  // 
  // x-constraint:
  // - /components/schemas/Port/properties/name
  // - /components/schemas/Lag/properties/name
  // 
  optional string port_name = 1;

  // Device connection to physical, LAG or another device.
  optional EthernetConnection connection = 2;

  // List of IPv4 addresses and their gateways.
  repeated DeviceIpv4 ipv4_addresses = 3;

  // List of global IPv6 addresses and their gateways.
  // The Link Local IPv6 address will be automatically generated.
  repeated DeviceIpv6 ipv6_addresses = 4;

  // Media Access Control address.
  // required = true
  string mac = 5;

  // Maximum Transmission Unit.
  // default = 1500
  optional uint32 mtu = 6;

  // List of VLANs
  repeated DeviceVlan vlans = 7;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  string name = 8;
}

// Ethernet interface connection to a port, LAG or VXLAN tunnel.
message EthernetConnection {

  message Choice {
    enum Enum {
      unspecified = 0;
      port_name = 1;
      lag_name = 2;
      vxlan_name = 3;
    }
  }
  // port_name, lag_name or vxlan_name
  optional Choice.Enum choice = 1;

  // Name of the port that the Ethernet interface is configured on.
  // 
  // x-constraint:
  // - /components/schemas/Port/properties/name
  // 
  optional string port_name = 2;

  // Name of the LAG that the Ethernet interface is configured on.
  // 
  // x-constraint:
  // - /components/schemas/Lag/properties/name
  // 
  optional string lag_name = 3;

  // Name of the VXLAN instance (or VXLAN tunnel) that this Ethernet interface is connected
  // to.
  // 
  // x-constraint:
  // - #/components/schemas/Vxlan.V4Tunnel/properties/name
  // - #/components/schemas/Vxlan.V6Tunnel/properties/name
  // 
  optional string vxlan_name = 4;
}

// Emulated VLAN protocol.
message DeviceVlan {

  message Tpid {
    enum Enum {
      unspecified = 0;
      x8100 = 1;
      x88a8 = 2;
      x9100 = 3;
      x9200 = 4;
      x9300 = 5;
    }
  }
  // Tag protocol identifier
  // default = Tpid.Enum.x8100
  optional Tpid.Enum tpid = 1;

  // Priority code point
  // default = 0
  optional uint32 priority = 2;

  // VLAN identifier
  // default = 1
  optional uint32 id = 3;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  string name = 4;
}

// An IPv4 interface with gateway
message DeviceIpv4 {

  // The IPv4 address of the gateway
  // required = true
  string gateway = 1;

  // Description missing in models
  optional DeviceIpv4GatewayMAC gateway_mac = 2;

  // The IPv4 address
  // required = true
  string address = 3;

  // The prefix of the IPv4 address.
  // default = 24
  optional uint32 prefix = 4;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  string name = 5;
}

// An IPv4 Loopback interface.
message DeviceIpv4Loopback {

  // The unique name of the Ethernet interface behind which this Loopback  interface will
  // be created.
  // 
  // x-constraint:
  // - /components/schemas/Device.Ethernet/properties/name
  // 
  // required = true
  string eth_name = 1;

  // The IPv4 Loopback address with prefix length of 32.
  // default = 0.0.0.0
  optional string address = 2;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  string name = 3;
}

// By default auto(resolved gateway mac) is set.  Setting a value would mean that ARP
// will not be used for learning MAC of connected device. The user-configured MAC address
// will be used for auto-filling the destination
// MAC address in the control and data packets sent from this IPv4 endpoint
// whenever applicable.
message DeviceIpv4GatewayMAC {

  message Choice {
    enum Enum {
      unspecified = 0;
      auto = 1;
      value = 2;
    }
  }
  // auto or configured value.
  // default = Choice.Enum.auto
  optional Choice.Enum choice = 1;

  // The OTG implementation can provide a system generated value for this property. If
  // the OTG is unable to generate a value the default value must be used.
  // default = 00:00:00:00:00:00
  optional string auto = 2;

  // Description missing in models
  // default = 00:00:00:00:00:00
  optional string value = 3;
}

// An IPv6 interface with gateway.
message DeviceIpv6 {

  // The IPv6 gateway address.
  // required = true
  string gateway = 1;

  // Description missing in models
  optional DeviceIpv6GatewayMAC gateway_mac = 2;

  // The IPv6 address.
  // required = true
  string address = 3;

  // The network prefix.
  // default = 64
  optional uint32 prefix = 4;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  string name = 5;
}

// An IPv6 Loopback interface
message DeviceIpv6Loopback {

  // The unique name of the Ethernet interface behind which this Loopback
  // interface will be created.
  // 
  // x-constraint:
  // - /components/schemas/Device.Ethernet/properties/name
  // 
  // required = true
  string eth_name = 1;

  // The IPv6 Loopback address with prefix length of 128.
  // default = ::0
  optional string address = 2;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  string name = 3;
}

// By default auto(resolved gateway mac) is set. Setting a value would mean that ND
// will not be used for learning MAC of connected device. The user-configured MAC address
// will be used for auto-filling the destination
// MAC address in the control and data packets sent from this IPv6 endpoint
// whenever applicable.
message DeviceIpv6GatewayMAC {

  message Choice {
    enum Enum {
      unspecified = 0;
      auto = 1;
      value = 2;
    }
  }
  // auto or configured value.
  // default = Choice.Enum.auto
  optional Choice.Enum choice = 1;

  // The OTG implementation can provide a system generated value for this property. If
  // the OTG is unable to generate a value the default value must be used.
  // default = 00:00:00:00:00:00
  optional string auto = 2;

  // Description missing in models
  // default = 00:00:00:00:00:00
  optional string value = 3;
}

// A container for layer1 settings.
message Layer1 {

  // A list of unique names of port objects that will share the
  // choice settings.
  // 
  // x-constraint:
  // - /components/schemas/Port/properties/name
  // 
  repeated string port_names = 1;

  message Speed {
    enum Enum {
      unspecified = 0;
      speed_10_fd_mbps = 1;
      speed_10_hd_mbps = 2;
      speed_100_fd_mbps = 3;
      speed_100_hd_mbps = 4;
      speed_1_gbps = 5;
      speed_10_gbps = 6;
      speed_25_gbps = 7;
      speed_40_gbps = 8;
      speed_50_gbps = 9;
      speed_100_gbps = 10;
      speed_200_gbps = 11;
      speed_400_gbps = 12;
    }
  }
  // Set the speed if supported.
  // default = Speed.Enum.speed_10_gbps
  optional Speed.Enum speed = 2;

  message Media {
    enum Enum {
      unspecified = 0;
      copper = 1;
      fiber = 2;
      sgmii = 3;
    }
  }
  // Set the type of media interface if supported.
  optional Media.Enum media = 3;

  // Enable promiscuous mode if supported.
  // default = True
  optional bool promiscuous = 4;

  // Set the maximum transmission unit size if supported.
  // default = 1500
  optional uint32 mtu = 5;

  // Set to true to override the auto_negotiate, link_training
  // and rs_fec settings for gigabit ethernet interfaces.
  optional bool ieee_media_defaults = 6;

  // Enable/disable auto negotiation.
  optional bool auto_negotiate = 7;

  // Description missing in models
  optional Layer1AutoNegotiation auto_negotiation = 8;

  // Description missing in models
  optional Layer1FlowControl flow_control = 9;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  string name = 10;
}

// Configuration for auto negotiation settings
message Layer1AutoNegotiation {

  // If auto_negotiate is true and the interface supports this option
  // then this speed will be advertised.
  // default = True
  optional bool advertise_1000_mbps = 1;

  // If auto_negotiate is true and the interface supports this option
  // then this speed will be advertised.
  // default = True
  optional bool advertise_100_fd_mbps = 2;

  // If auto_negotiate is true and the interface supports this option
  // then this speed will be advertised.
  // default = True
  optional bool advertise_100_hd_mbps = 3;

  // If auto_negotiate is true and the interface supports this option
  // then this speed will be advertised.
  // default = True
  optional bool advertise_10_fd_mbps = 4;

  // If auto_negotiate is true and the interface supports this option
  // then this speed will be advertised.
  // default = True
  optional bool advertise_10_hd_mbps = 5;

  // Enable/disable gigabit ethernet link training.
  // default = False
  optional bool link_training = 6;

  // Enable/disable gigabit ethernet reed solomon forward error correction (RS FEC).
  // default = False
  optional bool rs_fec = 7;
}

// A container for layer1 receive flow control settings.
// To enable flow control settings on ports this object must be a valid
// object not a null value.
message Layer1FlowControl {

  // The 48bit mac address that the layer1 port names will listen on
  // for a directed pause.
  // default = 01:80:C2:00:00:01
  optional string directed_address = 1;

  message Choice {
    enum Enum {
      unspecified = 0;
      ieee_802_1qbb = 1;
      ieee_802_3x = 2;
    }
  }
  // The type of priority flow control.
  // default = Choice.Enum.ieee_802_1qbb
  optional Choice.Enum choice = 2;

  // Description missing in models
  optional Layer1Ieee8021qbb ieee_802_1qbb = 3;

  // Description missing in models
  optional Layer1Ieee8023x ieee_802_3x = 4;
}

// A container for ieee 802.3x rx pause settings
message Layer1Ieee8023x {
}

// These settings enhance the existing 802.3x pause priority capabilities
// to enable flow control based on 802.1p priorities (classes of service).
message Layer1Ieee8021qbb {

  // The upper limit on the transmit time of a queue after receiving a
  // message to pause a specified priority.
  // A value of 0 or null indicates that pfc delay will not be enabled.
  // default = 0
  optional uint32 pfc_delay = 1;

  // The valid values are null, 0 - 7.
  // A null value indicates there is no setting for this pfc class.
  // default = 0
  optional uint32 pfc_class_0 = 2;

  // The valid values are null, 0 - 7.
  // A null value indicates there is no setting for this pfc class.
  // default = 1
  optional uint32 pfc_class_1 = 3;

  // The valid values are null, 0 - 7.
  // A null value indicates there is no setting for this pfc class.
  // default = 2
  optional uint32 pfc_class_2 = 4;

  // The valid values are null, 0 - 7.
  // A null value indicates there is no setting for this pfc class.
  // default = 3
  optional uint32 pfc_class_3 = 5;

  // The valid values are null, 0 - 7.
  // A null value indicates there is no setting for this pfc class.
  // default = 4
  optional uint32 pfc_class_4 = 6;

  // The valid values are null, 0 - 7.
  // A null value indicates there is no setting for this pfc class.
  // default = 5
  optional uint32 pfc_class_5 = 7;

  // The valid values are null, 0 - 7.
  // A null value indicates there is no setting for this pfc class.
  // default = 6
  optional uint32 pfc_class_6 = 8;

  // The valid values are null, 0 - 7.
  // A null value indicates there is no setting for this pfc class.
  // default = 7
  optional uint32 pfc_class_7 = 9;
}

// Under Review: Information TBD
// 
// Configuration for capture settings.
message Capture {

  // The unique names of ports that the capture settings will apply to. Port_names cannot
  // be duplicated between capture objects.
  // 
  // x-constraint:
  // - /components/schemas/Port/properties/name
  // 
  repeated string port_names = 1;

  // A list of filters to apply to the capturing ports. If no filters are specified then
  // all packets will be captured. A capture can have multiple filters. The number of
  // filters supported is determined by the implementation which can be retrieved using
  // the capabilities API.
  // When multiple filters are specified the capture implementation  must && (and) all
  // the filters.
  repeated CaptureFilter filters = 2;

  // Overwrite the capture buffer.
  // default = True
  optional bool overwrite = 3;

  // The maximum size of each captured packet. If no value is specified or it is null
  // then the entire packet will be captured.
  optional uint32 packet_size = 4;

  message Format {
    enum Enum {
      unspecified = 0;
      pcap = 1;
      pcapng = 2;
    }
  }
  // The format of the capture file.
  // default = Format.Enum.pcap
  optional Format.Enum format = 5;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  string name = 6;
}

// Configuration for capture filters
message CaptureFilter {

  message Choice {
    enum Enum {
      unspecified = 0;
      custom = 1;
      ethernet = 2;
      vlan = 3;
      ipv4 = 4;
      ipv6 = 5;
    }
  }
  // The type of capture filter.
  // default = Choice.Enum.custom
  optional Choice.Enum choice = 1;

  // Offset from last filter in the list. If no filters are present it is offset from
  // position 0. Multiple custom filters can be present, the length of each custom filter
  // is the length of the value being filtered.
  optional CaptureCustom custom = 2;

  // Description missing in models
  optional CaptureEthernet ethernet = 3;

  // Description missing in models
  optional CaptureVlan vlan = 4;

  // Description missing in models
  optional CaptureIpv4 ipv4 = 5;

  // Description missing in models
  optional CaptureIpv6 ipv6 = 6;
}

// Description missing in models
message CaptureCustom {

  // The bit offset of field to filter on
  optional uint32 offset = 1;

  // The bit length of field to filter on
  // default = 8
  optional uint32 bit_length = 2;

  // Description missing in models
  // default = 00
  optional string value = 3;

  // Description missing in models
  // default = 00
  optional string mask = 4;

  // Description missing in models
  // default = False
  optional bool negate = 5;
}

// Description missing in models
message CaptureField {

  // Description missing in models
  // default = 00
  optional string value = 1;

  // Description missing in models
  // default = 00
  optional string mask = 2;

  // Description missing in models
  // default = False
  optional bool negate = 3;
}

// Description missing in models
message CaptureEthernet {

  // Description missing in models
  optional CaptureField src = 1;

  // Description missing in models
  optional CaptureField dst = 2;

  // Description missing in models
  optional CaptureField ether_type = 3;

  // Description missing in models
  optional CaptureField pfc_queue = 4;
}

// Description missing in models
message CaptureVlan {

  // Description missing in models
  optional CaptureField priority = 1;

  // Description missing in models
  optional CaptureField cfi = 2;

  // Description missing in models
  optional CaptureField id = 3;

  // Description missing in models
  optional CaptureField protocol = 4;
}

// Description missing in models
message CaptureIpv4 {

  // Description missing in models
  optional CaptureField version = 1;

  // Description missing in models
  optional CaptureField header_length = 2;

  // Description missing in models
  optional CaptureField priority = 3;

  // Description missing in models
  optional CaptureField total_length = 4;

  // Description missing in models
  optional CaptureField identification = 5;

  // Description missing in models
  optional CaptureField reserved = 6;

  // Description missing in models
  optional CaptureField dont_fragment = 7;

  // Description missing in models
  optional CaptureField more_fragments = 8;

  // Description missing in models
  optional CaptureField fragment_offset = 9;

  // Description missing in models
  optional CaptureField time_to_live = 10;

  // Description missing in models
  optional CaptureField protocol = 11;

  // Description missing in models
  optional CaptureField header_checksum = 12;

  // Description missing in models
  optional CaptureField src = 13;

  // Description missing in models
  optional CaptureField dst = 14;
}

// Description missing in models
message CaptureIpv6 {

  // Description missing in models
  optional CaptureField version = 1;

  // Description missing in models
  optional CaptureField traffic_class = 2;

  // Description missing in models
  optional CaptureField flow_label = 3;

  // Description missing in models
  optional CaptureField payload_length = 4;

  // Description missing in models
  optional CaptureField next_header = 5;

  // Description missing in models
  optional CaptureField hop_limit = 6;

  // Description missing in models
  optional CaptureField src = 7;

  // Description missing in models
  optional CaptureField dst = 8;
}

// A container for emulated interfaces, loopback interfaces and protocol configurations.
message Device {

  // Ethernet configuration for one or more emulated network interfaces.
  repeated DeviceEthernet ethernets = 1;

  // IPv4 Loopback interface that can be attached to an Ethernet in the same device  or
  // to an Ethernet in another device.
  repeated DeviceIpv4Loopback ipv4_loopbacks = 2;

  // IPv6 Loopback interface that can be attached to an Ethernet in the same device  or
  // to an Ethernet in another device.
  repeated DeviceIpv6Loopback ipv6_loopbacks = 3;

  // The properties of an IS-IS router and its children,  such as IS-IS interfaces and
  // route ranges.
  optional DeviceIsisRouter isis = 4;

  // The properties of BGP router and its children,  such as BGPv4, BGPv6 peers and their
  // route ranges.
  optional DeviceBgpRouter bgp = 5;

  // Configuration of VXLAN tunnel interfaces RFC Ref: https://datatracker.ietf.org/doc/html/rfc7348
  optional DeviceVxlan vxlan = 6;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  string name = 7;

  // The properties of an RSVP router and its children.
  optional DeviceRsvp rsvp = 8;
}

// Common options that apply to all configured protocols and interfaces.
message ProtocolOptions {

  // When set to true, all underlying resources for configured protocols   and interfaces
  // shall be created and corresponding protocol session negotiation shall be initiated.
  // Otherwise, when set to false,  corresponding protocol session negotiation will need
  // to be initiated  using a separate set_protocol_state API call.
  // default = True
  optional bool auto_start_all = 1;
}

// A container of properties for an ISIS router and its interfaces.
message DeviceIsisRouter {

  // This contains the properties of a Multi-Instance-capable routers or MI-RTR. Each
  // router can emulate one ISIS instance at a time.
  optional DeviceIsisMultiInstance instance = 1;

  // The System ID for this emulated ISIS router, e.g. 640100010000.
  // required = true
  string system_id = 2;

  // List of ISIS interfaces for this router.
  repeated IsisInterface interfaces = 3;

  // Contains basic properties of an ISIS Router.
  optional IsisBasic basic = 4;

  // Contains advance properties of an ISIS Router..
  optional IsisAdvanced advanced = 5;

  // ISIS Router authentication properties.
  optional IsisAuthentication router_auth = 6;

  // Emulated ISIS IPv4 routes.
  repeated IsisV4RouteRange v4_routes = 7;

  // Emulated ISIS IPv6 routes.
  repeated IsisV6RouteRange v6_routes = 8;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  string name = 9;
}

// This container properties of an Multi-Instance-capable router (MI-RTR).
message DeviceIsisMultiInstance {

  // Instance Identifier (IID) TLV will associate a PDU with an ISIS instance  by using
  // a unique 16-bit number and including one or more  Instance-Specific Topology Identifiers
  // (ITIDs).
  // default = 1
  optional uint32 iid = 1;

  // This contains one or more ITIDs that will be advertised in IID TLV.
  repeated uint32 itids = 2;
}

// Configuration for single ISIS interface.
message IsisInterface {

  // The unique name of the Ethernet interface on which ISIS is running. Two ISIS interfaces
  // cannot share the same Ethernet.
  // 
  // x-constraint:
  // - /components/schemas/Device.Ethernet/properties/name
  // 
  // required = true
  string eth_name = 1;

  // The default metric cost for the interface.
  // default = 10
  optional uint32 metric = 2;

  message NetworkType {
    enum Enum {
      unspecified = 0;
      broadcast = 1;
      point_to_point = 2;
    }
  }
  // The type of network link.
  // default = NetworkType.Enum.broadcast
  optional NetworkType.Enum network_type = 3;

  message LevelType {
    enum Enum {
      unspecified = 0;
      level_1 = 1;
      level_2 = 2;
      level_1_2 = 3;
    }
  }
  // This indicates whether this router is participating in Level-1 (L1),
  // Level-2 (L2) or both L1 and L2 domains on this interface.
  // default = LevelType.Enum.level_2
  optional LevelType.Enum level_type = 4;

  // Settings of Level 1 Hello.
  optional IsisInterfaceLevel l1_settings = 5;

  // Settings of Level 2 Hello.
  optional IsisInterfaceLevel l2_settings = 6;

  // Contains the properties of multiple topologies.
  repeated IsisMT multi_topology_ids = 7;

  // Contains a list of Traffic Engineering attributes.
  repeated LinkStateTE traffic_engineering = 8;

  // The Circuit authentication method used for the interfaces on this emulated ISIS v4/v6
  // router.
  optional IsisInterfaceAuthentication authentication = 9;

  // Optional container for advanced interface properties.
  optional IsisInterfaceAdvanced advanced = 10;

  // Link protection on the ISIS link between two interfaces.
  optional IsisInterfaceLinkProtection link_protection = 11;

  // This contains list of SRLG values for the link between two interfaces.
  repeated uint32 srlg_values = 12;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  string name = 13;
}

// Configuration for the properties of Level 1 Hello.
message IsisInterfaceLevel {

  // The Priority setting in Level 1 LAN Hellos for Designated Router election.
  // default = 0
  optional uint32 priority = 1;

  // The Hello interval for Level 1 Hello messages, in seconds.
  // default = 10
  optional uint32 hello_interval = 2;

  // The Dead (Holding Time) interval for Level 1 Hello messages, in seconds.
  // default = 30
  optional uint32 dead_interval = 3;
}

// Configuration of properties per interface per topology when multiple topologies are
// configured in an ISIS router.
// in a ISIS router.
message IsisMT {

  // The Multi Topology ID for one of the topologies supported on the ISIS interface.
  // default = 0
  optional uint32 mt_id = 1;

  // Specifies the link metric for this topology on the ISIS interface.
  // default = 10
  optional uint32 link_metric = 2;
}

// A container for Traffic Engineering properties on a interface.
message LinkStateTE {

  // The Administrative group sub-TLV (sub-TLV 3). It is a 4-octet
  // user-defined bit mask used to assign administrative group numbers
  // to the interface, for use in assigning colors and resource classes.
  // Each set bit corresponds to a single administrative group for this
  // interface. The settings translate into Group numbers, which range
  // from 0 to 31 (integers).
  // default = 00000000
  optional string administrative_group = 1;

  // The user-assigned link metric for Traffic Engineering.
  // default = 0
  optional uint32 metric_level = 2;

  // The maximum link bandwidth (sub-TLV 9) in bytes/sec allowed for this
  // link for a direction.
  // default = 125000000
  optional uint32 max_bandwith = 3;

  // The maximum link bandwidth (sub-TLV 10) in bytes/sec allowed for this
  // link in a direction.
  // default = 125000000
  optional uint32 max_reservable_bandwidth = 4;

  // Configuration of bandwidths of priority 0 through priority 7.
  optional LinkStatepriorityBandwidths priority_bandwidths = 5;
}

// Specifies the amount of bandwidth that can be reserved with a setup priority of 0
// 
// through 7, arranged in increasing order with priority 0 having highest priority.
// 
// In ISIS, this is sent in sub-TLV (11) of Extended IS Reachability TLV.
message LinkStatepriorityBandwidths {

  // Specifies the amount of bandwidth that can be reserved for the Priority 0.
  // default = 125000000
  optional uint32 pb0 = 1;

  // Specifies the amount of bandwidth that can be reserved for the Priority 1.
  // default = 125000000
  optional uint32 pb1 = 2;

  // Specify the amount of bandwidth that can be reserved for the Priority 2.
  // default = 125000000
  optional uint32 pb2 = 3;

  // Specifies the amount of bandwidth that can be reserved for the Priority 3.
  // default = 125000000
  optional uint32 pb3 = 4;

  // Specifies the amount of bandwidth that can be reserved for the Priority 4.
  // default = 125000000
  optional uint32 pb4 = 5;

  // Specifies the amount of bandwidth that can be reserved for the Priority 5.
  // default = 125000000
  optional uint32 pb5 = 6;

  // Specifies the amount of bandwidth that can be reserved for the Priority 6.
  // default = 125000000
  optional uint32 pb6 = 7;

  // Specifies the amount of bandwidth that can be reserved for the Priority 7.
  // default = 125000000
  optional uint32 pb7 = 8;
}

// Optional container for circuit authentication properties.
message IsisInterfaceAuthentication {

  message AuthType {
    enum Enum {
      unspecified = 0;
      md5 = 1;
      password = 2;
    }
  }
  // The circuit authentication method.
  // required = true
  AuthType.Enum auth_type = 1;

  // MD5 key to be used for authentication.
  optional string md5 = 2;

  // The password, in clear text, to be used for Authentication.
  optional string password = 3;
}

// Optional container for advanced interface properties.
message IsisInterfaceAdvanced {

  // If a padded Hello message is received on the interface, the length of
  // the Hello packets sent out on that interface is adjusted to match.
  // default = True
  optional bool auto_adjust_mtu = 1;

  // If a Level 1 Hello is received on this emulated router for an area
  // not currently in its area list, an area from the received Hello is
  // added to that list. This ensures an area match for all future
  // Level 1 Hellos from the source L1 router.
  // default = True
  optional bool auto_adjust_area = 2;

  // If a Hello message listing supported protocols is received on this
  // emulated router, the supported protocols advertised by this router
  // are changed to match exactly.
  // default = False
  optional bool auto_adjust_supported_protocols = 3;

  // If it is true, the Point-to-Point circuit will include 3-way TLV in its Point-to-Point
  // IIH  and attempt to establish the adjacency as specified in RFC 5303. This field
  // is not applicable if network_type is set to 'broadcast' type in ISIS interface.
  // default = True
  optional bool enable_3way_handshake = 4;

  // If it is true, the Point-to-Point Hello messages will be sent to the unicast MAC
  // address.
  // default = False
  optional bool p2p_hellos_to_unicast_mac = 5;
}

// Optional container for the link protection sub TLV (type 20).
message IsisInterfaceLinkProtection {

  // Enable this to protect other link or links. LSPs on a link of this type are lost
  // if any of the links fail.
  // default = False
  optional bool extra_traffic = 1;

  // Enabling this signifies that there is no other link protecting this
  // link. LSPs on a link of this type are lost if the link fails.
  // default = False
  optional bool unprotected = 2;

  // Enable this to share the Extra Traffic links between one or more
  // links of type Shared.There are one or more disjoint links of type
  // Extra Traffic that are protecting this link.
  // default = False
  optional bool shared = 3;

  // Enabling this signifies that there is one dedicated disjoint link
  // of type Extra Traffic that is protecting this link.
  // default = False
  optional bool dedicated_1_to_1 = 4;

  // Enabling this signifies that a dedicated disjoint link is protecting
  // this link. However, the protecting link is not advertised in the
  // link state database and is therefore not available for the routing
  // of LSPs.
  // default = False
  optional bool dedicated_1_plus_1 = 5;

  // Enabling this signifies that a protection scheme that is more
  // reliable than Dedicated 1+1.
  // default = False
  optional bool enhanced = 6;

  // This is a Protection Scheme with value 0x40.
  // default = False
  optional bool reserved_40 = 7;

  // This is a Protection Scheme with value 0x80.
  // default = False
  optional bool reserved_80 = 8;
}

// This contains ISIS router basic properties.
message IsisBasic {

  // IPv4 Traffic Engineering(TE) router id. This address should be configured as an IPv4
  // Loopback address in 'ipv4_loopbacks' in the Device.
  optional string ipv4_te_router_id = 1;

  // Host name for the router. The host name is transmitted in all the packets sent from
  // the router.
  optional string hostname = 2;

  // When set to true, it allows sending of more detailed metric information  for the
  // routes using 32-bit wide values using TLV 135 IP reachability and  more detailed
  // reachability information for IS reachability by using TLV 22.  The detailed usage
  // is described in RFC3784.
  // default = True
  optional bool enable_wide_metric = 3;

  // Configuration for controlling storage of ISIS learned LSPs are received from the
  // neighbors.
  // default = False
  optional bool learned_lsp_filter = 4;
}

// Contains ISIS router advanced properties.
message IsisAdvanced {

  // It enables padding of Hello message to MTU size.
  // default = True
  optional bool enable_hello_padding = 1;

  // The Number of Area Addresses permitted, with a valid range from 0 to 254.  A zero
  // indicates a maximum of 3 addresses.
  // default = 3
  optional uint32 max_area_addresses = 2;

  // Its combination of the ISP and HO-DSP.Usually all nodes within an area have  the
  // same area address. If no area addresses are configured, a default area of 490001
  // will be advertised.
  repeated string area_addresses = 3;

  // The rate at which LSPs are re-sent in seconds.
  // default = 600
  optional uint32 lsp_refresh_rate = 4;

  // The MaxAge for retaining a learned LSP on this router in seconds.
  // default = 1200
  optional uint32 lsp_lifetime = 5;

  // The number of milliseconds between transmissions of Partial Sequence Number PDU.
  // default = 2000
  optional uint32 psnp_interval = 6;

  // The number of milliseconds between transmissions of Partial Sequence Number PDU.
  // default = 10000
  optional uint32 csnp_interval = 7;

  // The maximum size in bytes of any LSP that can be transmitted over a link of equal
  // or less  than maximum MTU size.
  // default = 1492
  optional uint32 max_lsp_size = 8;

  // The number of seconds between transmissions of LSPs/MGROUP-PDUs.
  // default = 5000
  optional uint32 lsp_mgroup_min_trans_interval = 9;

  // If the Attached bit is enabled, it indicates that the ISIS router is attached to
  // another area  or the Level 2 backbone. The purpose of an Attached-Bit is to accomplish
  // Inter-Area Routing.  When an L1/L2 router is connected to more than one area, it
  // sets the Attached-bit on its L1 LSP. This can cause a default route ( 0.0.0.0/0 )
  // to be installed by the receiving router.
  // default = True
  optional bool enable_attached_bit = 10;
}

// This contains ISIS Area/Domain authentication properties.
message IsisAuthentication {

  // Do not verify MD5 checksum in received LSPs.
  // default = True
  optional bool ignore_receive_md5 = 1;

  // The Area authentication method used for the emulated ISIS router.
  // This is used for L1 LSPs.
  optional IsisAuthenticationBase area_auth = 2;

  // The Domain authentication method used for the emulated ISIS router.
  // This is used for L2 LSPs.
  optional IsisAuthenticationBase domain_auth = 3;
}

// Optional container for ISIS authentication properties.
message IsisAuthenticationBase {

  message AuthType {
    enum Enum {
      unspecified = 0;
      md5 = 1;
      password = 2;
    }
  }
  // The authentication method.
  // required = true
  AuthType.Enum auth_type = 1;

  // Authentication as an MD5 key.
  optional string md5 = 2;

  // Authentication as a clear text password.
  optional string password = 3;
}

// Emulated ISIS IPv4 routes.
message IsisV4RouteRange {

  // A list of group of IPv4 route addresses.
  repeated V4RouteAddress addresses = 1;

  // The user-defined metric associated with this route range.
  // default = 0
  optional uint32 link_metric = 2;

  message OriginType {
    enum Enum {
      unspecified = 0;
      internal = 1;
      external = 2;
    }
  }
  // The origin of the advertised route-internal or external to the ISIS area. Options
  // include the following:
  // Internal-for intra-area routes, through Level 1 LSPs.
  // External-for inter-area routes redistributed within L1, through Level
  // 1 LSPs.
  // default = OriginType.Enum.internal
  optional OriginType.Enum origin_type = 3;

  message RedistributionType {
    enum Enum {
      unspecified = 0;
      up = 1;
      down = 2;
    }
  }
  // Defines the Up/Down (Redistribution) bit defined for TLVs 128 and 130 by RFC 2966.
  // It is used for domain-wide advertisement of prefix information.
  // 
  // Up (0)-used when a prefix is initially advertised within the ISIS L3
  // hierarchy,
  // and for all other prefixes in L1 and L2 LSPs. (default)
  // Down (1)-used when an L1/L2 router advertises L2 prefixes in L1 LSPs.
  // 
  // The prefixes are being advertised from a higher level (L2) down to a lower level
  // (L1).
  // default = RedistributionType.Enum.up
  optional RedistributionType.Enum redistribution_type = 4;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  string name = 5;

  // Specifies whether the sub-TLV for IPv4/IPv6 Extended Reachability Attribute Flags
  // will be advertised or not.
  // default = False
  optional bool prefix_attr_enabled = 6;

  // External Prefix Flag (Bit 0)
  // default = False
  optional bool x_flag = 7;

  // Re-advertisement Flag (Bit 1)
  // default = False
  optional bool r_flag = 8;

  // Node Flag (Bit 2)
  // default = False
  optional bool n_flag = 9;
}

// A container for IPv4 route addresses.
message V4RouteAddress {

  // The starting address of the network.
  // required = true
  string address = 1;

  // The IPv4 network prefix length to be applied to the address.
  // default = 24
  optional uint32 prefix = 2;

  // The total number of addresses in the range.
  // default = 1
  optional uint32 count = 3;

  // Increments the network address prefixes within a route range  where multiple routes
  // are present.  The value is incremented according to the Prefix Length and Step.
  // default = 1
  optional uint32 step = 4;
}

// A container for IPv6 route addresses.
message V6RouteAddress {

  // The starting address of the network.
  // required = true
  string address = 1;

  // The IPv6 network prefix length to be applied to the address.
  // default = 64
  optional uint32 prefix = 2;

  // The total number of addresses in the range.
  // default = 1
  optional uint32 count = 3;

  // Increments the network address prefixes within a route range  where multiple routes
  // are present.  The value is incremented according to the Prefix Length and Step.
  // default = 1
  optional uint32 step = 4;
}

// A container for MAC route addresses.
message MACRouteAddress {

  // The starting address of the MAC Range.
  // required = true
  string address = 1;

  // The MAC prefix length to be applied to the address.
  // default = 48
  optional uint32 prefix = 2;

  // The total number of mac addresses in the range.
  // default = 1
  optional uint32 count = 3;

  // Increments the mac address prefixes within a mac range  where multiple routes are
  // present.  The value is incremented according to the mac prefix Length and Step.
  // default = 1
  optional uint32 step = 4;
}

// Emulated ISIS IPv6 routes.
message IsisV6RouteRange {

  // A list of group of IPv6 route addresses.
  repeated V6RouteAddress addresses = 1;

  // The user-defined metric associated with this route range.
  // default = 0
  optional uint32 link_metric = 2;

  message OriginType {
    enum Enum {
      unspecified = 0;
      internal = 1;
      external = 2;
    }
  }
  // The origin of the advertised route-internal or external to the ISIS area. Options
  // include the following:
  // Internal-for intra-area routes, through Level 1 LSPs.
  // External-for inter-area routes redistributed within L1, through Level
  // 1 LSPs.
  // default = OriginType.Enum.internal
  optional OriginType.Enum origin_type = 3;

  message RedistributionType {
    enum Enum {
      unspecified = 0;
      up = 1;
      down = 2;
    }
  }
  // Defines the Up/Down (Redistribution) bit defined for TLVs 128 and 130 by RFC 2966.
  // It is used for domain-wide advertisement of prefix information.
  // 
  // Up (0)-used when a prefix is initially advertised within the ISIS L3
  // hierarchy,
  // and for all other prefixes in L1 and L2 LSPs. (default)
  // Down (1)-used when an L1/L2 router advertises L2 prefixes in L1 LSPs.
  // 
  // The prefixes are being advertised from a higher level (L2) down to a lower level
  // (L1).
  // default = RedistributionType.Enum.up
  optional RedistributionType.Enum redistribution_type = 4;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  string name = 5;

  // Specifies whether the sub-TLV for IPv4/IPv6 Extended Reachability Attribute Flags
  // will be advertised or not.
  // default = False
  optional bool prefix_attr_enabled = 6;

  // External Prefix Flag (Bit 0)
  // default = False
  optional bool x_flag = 7;

  // Re-advertisement Flag (Bit 1)
  // default = False
  optional bool r_flag = 8;

  // Node Flag (Bit 2)
  // default = False
  optional bool n_flag = 9;
}

// Configuration for one or more IPv4 or IPv6 BGP peers.
message DeviceBgpRouter {

  // The BGP router ID is a unique identifier used by BGP. It is a 32-bit value that is
  // often represented by an IPv4 address.
  // required = true
  string router_id = 1;

  // This contains an array of references to IPv4 interfaces,  each of which will have
  // list of peers to different destinations.
  repeated BgpV4Interface ipv4_interfaces = 2;

  // This contains an array of references to IPv6 interfaces,  each of which will have
  // list of peers to different destinations.
  repeated BgpV6Interface ipv6_interfaces = 3;
}

// All errors detected while processing the Message Header are indicated by sending
// the NOTIFICATION message  with the Error Code-Message Header Error. The Error Subcode
// elaborates on the specific nature of the error.
message DeviceBgpMessageHeaderError {

  message Subcode {
    enum Enum {
      unspecified = 0;
      connection_not_synchronized_code1_subcode1 = 1;
      bad_message_length_code1_subcode2 = 2;
      bad_message_type_code1_subcode3 = 3;
    }
  }
  // The Error Subcode indicates the specific type of error encountered during Message
  // Header processing.
  // default = Subcode.Enum.connection_not_synchronized_code1_subcode1
  optional Subcode.Enum subcode = 1;
}

// All errors detected while processing the OPEN message are indicated by sending the
// NOTIFICATION message  with the Error Code-Open Message Error. The Error Subcode elaborates
// on the specific nature of the error.
message DeviceBgpOpenMessageError {

  message Subcode {
    enum Enum {
      unspecified = 0;
      unsupported_version_number_code2_subcode1 = 1;
      error_peer_as_code2_subcode2 = 2;
      error_bgp_id_code2_subcode3 = 3;
      unsupported_optional_parameter_code2_subcode4 = 4;
      auth_failed_code2_subcode5 = 5;
      unsupported_hold_time_code2_subcode6 = 6;
      unsupported_capability_code2_subcode7 = 7;
    }
  }
  // The Error Subcode indicates the specific type of error encountered during OPEN message
  // processing.
  // default = Subcode.Enum.unsupported_version_number_code2_subcode1
  optional Subcode.Enum subcode = 1;
}

// All errors detected while processing the UPDATE message are indicated by sending
// the NOTIFICATION message  with the Error Code-Update Message Error. The Error Subcode
// elaborates on the specific nature of the error.
message DeviceBgpUpdateMessageError {

  message Subcode {
    enum Enum {
      unspecified = 0;
      malformed_attrib_list_code3_subcode1 = 1;
      unrecognized_wellknown_attrib_code3_subcode2 = 2;
      wellknown_attrib_missing_code3_subcode3 = 3;
      attrib_flags_error_code3_subcode4 = 4;
      attrib_length_error_code3_subcode5 = 5;
      invalid_origin_attrib_code3_subcode6 = 6;
      as_routing_loop_code3_subcode7 = 7;
      invalid_nhop_attrib_code3_subcode8 = 8;
      error_optional_attrib_code3_subcode9 = 9;
      invalid_network_field_code3_subcode10 = 10;
      abnormal_aspath_code3_subcode11 = 11;
    }
  }
  // The Error Subcode, the specific type of error encountered during UPDATE processing.
  // default = Subcode.Enum.malformed_attrib_list_code3_subcode1
  optional Subcode.Enum subcode = 1;
}

// If a system does not receive successive KEEPALIVE, UPDATE, and/or NOTIFICATION messages
// within the period specified  in the Hold Time field of the OPEN message, then the
// NOTIFICATION message with the Hold Timer Expired Error Code(Error Code 4) is  sent
// and the BGP connection is closed. The Sub Code used is 0. If a user wants to use
// non zero Sub Code then CustomError can be used.
message DeviceBgpHoldTimerExpired {
}

// Any error detected by the BGP Finite State Machine (e.g., receipt of an unexpected
// event) is indicated by  sending the NOTIFICATION message with the Error Code-Finite
// State Machine Error(Error Code 5). The Sub Code used is 0.  If a user wants to use
// non zero Sub Code then CustomError can be used.
message DeviceBgpFiniteStateMachineError {
}

// In the absence of any fatal errors, a BGP peer can close its BGP connection by sending
// the NOTIFICATION message with the  Error Code Cease.
message DeviceBgpCeaseError {

  message Subcode {
    enum Enum {
      unspecified = 0;
      max_number_prefix_reached_code6_subcode1 = 1;
      admin_shutdown_code6_subcode2 = 2;
      peer_deleted_code6_subcode3 = 3;
      admin_reset_code6_subcode4 = 4;
      connection_reject_code6_subcode5 = 5;
      other_config_changes_code6_subcode6 = 6;
      connection_collision_resolution_code6_subcode7 = 7;
      out_of_resources_code6_subcode8 = 8;
      bfd_session_down_code6_subcode9 = 9;
    }
  }
  // The Error Subcode to be sent to the peer in the Cease NOTIFICATION.
  // default = Subcode.Enum.admin_shutdown_code6_subcode2
  optional Subcode.Enum subcode = 1;
}

// A BGP peer can send NOTIFICATION message with user defined Error Code and Error Subcode.
message DeviceBgpCustomError {

  // The Error code to be sent in the NOTIFICATION message to peer.
  optional uint32 code = 1;

  // The Error Subcode to be sent in the NOTIFICATION message to peer.
  optional uint32 subcode = 2;
}

// Configuration for emulated BGPv4 peers and routes.
message BgpV4Peer {

  // IPv4 address of the BGP peer for the session.
  // required = true
  string peer_address = 1;

  // This contains the list of Ethernet Virtual Private Network (EVPN) Ethernet Segments
  // (ES) Per BGP Peer for IPv4 Address Family Identifier (AFI).
  // 
  // Each Ethernet Segment contains a list of EVPN Instances (EVIs) .
  // Each EVI contains a list of Broadcast Domains.
  // Each Broadcast Domain contains a list of MAC/IP Ranges.
  // 
  // <Ethernet Segment, EVI, Broadcast Domain> is responsible for advertising Ethernet
  // Auto-discovery Route Per EVI (Type 1).
  // 
  // <Ethernet Segment, EVI> is responsible for advertising Ethernet Auto-discovery Route
  // Per Ethernet Segment (Type 1).
  // 
  // <Ethernet Segment, EVI, Broadcast Domain, MAC/IP> is responsible for advertising
  // MAC/IP Advertisement Route (Type 2).
  // 
  // <Ethernet Segment, EVI, Broadcast Domain> is responsible for advertising Inclusive
  // Multicast Ethernet Tag Route (Type 3).
  // 
  // Ethernet Segment is responsible for advertising Ethernet Segment Route (Type 4).
  repeated BgpV4EthernetSegment evpn_ethernet_segments = 2;

  message AsType {
    enum Enum {
      unspecified = 0;
      ibgp = 1;
      ebgp = 2;
    }
  }
  // The type of BGP autonomous system. External BGP is used for BGP links between two
  // or more autonomous systems (ebgp). Internal BGP is used within a single autonomous
  // system (ibgp). BGP property defaults are aligned with this object defined as an internal
  // BGP peer. If the as_type is specified as 'ebgp' then other properties will need to
  // be specified as per an external BGP peer. Specifically, for 'ebgp',  'as_set_mode'
  // attribute in 'as_path' field  in any Route Range should be changed from default value
  // 'do_not_include_local_as' to any other value.
  // required = true
  AsType.Enum as_type = 3;

  // Autonomous System Number (AS number or ASN)
  // required = true
  uint32 as_number = 4;

  message AsNumberWidth {
    enum Enum {
      unspecified = 0;
      two = 1;
      four = 2;
    }
  }
  // The width in bytes of the as_number values. Any as_number values that exceeds the
  // width MUST result in an error.
  // default = AsNumberWidth.Enum.four
  optional AsNumberWidth.Enum as_number_width = 5;

  // Description missing in models
  optional BgpAdvanced advanced = 6;

  // Description missing in models
  optional BgpCapability capability = 7;

  // Description missing in models
  optional BgpLearnedInformationFilter learned_information_filter = 8;

  // Emulated BGPv4 route ranges.
  repeated BgpV4RouteRange v4_routes = 9;

  // Emulated BGPv6 route ranges.
  repeated BgpV6RouteRange v6_routes = 10;

  // Segment Routing Traffic Engineering (SR TE) Policies for IPv4 Address Family Identifier
  // (AFI).
  repeated BgpSrteV4Policy v4_srte_policies = 11;

  // Segment Routing Traffic Engineering (SR TE) Policies for IPv6 Address Family Identifier
  // (AFI).
  repeated BgpSrteV6Policy v6_srte_policies = 12;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  string name = 13;

  // Description missing in models
  optional BgpGracefulRestart graceful_restart = 14;
}

// Configuration for emulated BGPv4 peers and routes on a single IPv4 interface.
message BgpV4Interface {

  // The unique name of the IPv4 or Loopback IPv4 interface used as the source IP for
  // this list of BGP peers.
  // 
  // x-constraint:
  // - /components/schemas/Device.Ipv4/properties/name
  // - /components/schemas/Device.Ipv4Loopback/properties/name
  // 
  // required = true
  string ipv4_name = 1;

  // This contains the list of BGPv4 peers configured on this interface.
  repeated BgpV4Peer peers = 2;
}

// Configuration for BGP Ethernet Segment ranges. Advertises following routes -
// 
// Type 4 - Ethernet Segment Route
message BgpV4EthernetSegment {

  // Designated Forwarder (DF) election configuration.
  optional BgpEthernetSegmentDfElection df_election = 1;

  // This contains the list of EVIs.
  repeated BgpV4EvpnEvis evis = 2;

  // 10-octet Ethernet Segment Identifier (ESI) Example - For multi-home scenario nonZero
  // ESI is '10000000000000000000' .
  // default = 00000000000000000000
  optional string esi = 3;

  message ActiveMode {
    enum Enum {
      unspecified = 0;
      single_active = 1;
      all_active = 2;
    }
  }
  // Single Active or All Active mode Redundancy mode selection for Multi-home.
  // default = ActiveMode.Enum.all_active
  optional ActiveMode.Enum active_mode = 4;

  // The label value to be advertised as ESI Label in ESI Label Extended Community. This
  // is included in Ethernet Auto-discovery per ES Routes advertised by a router.
  // default = 0
  optional uint32 esi_label = 5;

  // Description missing in models
  optional BgpRouteAdvanced advanced = 6;

  // Optional community settings.
  repeated BgpCommunity communities = 7;

  // Optional Extended Community settings. The Extended Communities Attribute is a transitive
  // optional BGP attribute, with the Type Code 16. Community and Extended Communities
  // attributes are utilized to trigger routing decisions, such as acceptance, rejection,
  // preference, or redistribution. An extended community is an 8-Bytes value. It is
  // divided into two main parts. The first 2 Bytes of the community encode a type and
  // sub-type fields and the last 6 Bytes carry a unique set of data in a format defined
  // by the type and sub-type field. Extended communities provide a larger  range for
  // grouping or categorizing communities. When type is administrator_as_2octet or administrator_as_4octet,
  // the valid sub types are route target and origin. The valid value for  administrator_as_2octet
  // and administrator_as_4octet type is either two byte AS followed by four byte local
  // administrator id or four byte AS followed by two  byte local administrator id.  When
  // type is administrator_ipv4_address the valid sub types are route target and origin.
  // The valid value for  administrator_ipv4_address is a four byte IPv4 address followed
  // by a two byte local administrator id.  When type is opaque, valid sub types are color
  // and encapsulation. When sub type is color, first two bytes of the value field contain
  // flags and last four bytes  contains the value of the color. When sub type is encapsulation
  // the first four bytes of value field are reserved and last two bytes carries the tunnel
  // type from  IANA's ETHER TYPES registry e.g IPv4 (protocol type = 0x0800), IPv6 (protocol
  // type = 0x86dd), and MPLS (protocol type = 0x8847). When type is administrator_as_2octet_link_bandwidth
  // the valid sub type is extended_bandwidth. The first two bytes of the value field
  // contains the AS number and the last four bytes contains the bandwidth in IEEE floating
  // point format.  When type is evpn the valid subtype is mac_address. In the value field
  // the low-order bit of the first byte(Flags) is defined as the Sticky/static flag and
  // may be set to 1, indicating the MAC address is static and cannot move. The second
  // byte is reserved and the  last four bytes contain the sequence number which is used
  // to ensure that PEs retain the correct MAC/IP Advertisement route when multiple updates
  // occur for the same MAC address.
  repeated BgpExtCommunity ext_communities = 8;

  // Optional AS PATH settings.
  optional BgpAsPath as_path = 9;
}

// Configuration for Designated Forwarder (DF) election among the Provider Edge (PE)
// routers on the same Ethernet Segment.
message BgpEthernetSegmentDfElection {

  // The DF election timer in seconds.
  // default = 3
  optional uint32 election_timer = 1;
}

// Configuration for advanced BGP route range settings.
message BgpRouteAdvanced {

  // BGP Multi Exit Discriminator attribute sent to the peer to help in the route selection
  // process.  If set to true, the Multi Exit Discriminator attribute will be included
  // in the route advertisement.
  // default = True
  optional bool include_multi_exit_discriminator = 3;

  // The multi exit discriminator (MED) value used for route selection sent to the peer.
  optional uint32 multi_exit_discriminator = 1;

  // If set to true, the Origin attribute will be included in the route advertisement.
  // default = True
  optional bool include_origin = 4;

  message Origin {
    enum Enum {
      unspecified = 0;
      igp = 1;
      egp = 2;
      incomplete = 3;
    }
  }
  // The origin attribute of a prefix can take three values: the prefix originates from
  // an interior routing protocol 'igp',  it originates from 'egp' or the origin is 'incomplete',
  // if the prefix is learned through other means.
  // default = Origin.Enum.igp
  optional Origin.Enum origin = 2;

  // BGP Local Preference attribute sent to the peer to indicate the degree of preference
  // for externally learned routes. If set to true, the Local Preference attribute will
  // be included  in the route advertisement. This should be included only for internal
  // peers.
  // default = True
  optional bool include_local_preference = 5;

  // Value to be set in Local Preference attribute if include_local_preference is set
  // to true. It is  used for the selection of the path for the traffic leaving the AS.
  // The route with the  highest local preference value is preferred.
  // default = 100
  optional uint32 local_preference = 6;
}

// BGP communities provide additional capability for tagging routes and  for modifying
// BGP routing policy on upstream and downstream routers. BGP community is a 32-bit
// number which is broken into 16-bit AS number and  a 16-bit custom value.
message BgpCommunity {

  message Type {
    enum Enum {
      unspecified = 0;
      manual_as_number = 1;
      no_export = 2;
      no_advertised = 3;
      no_export_subconfed = 4;
      llgr_stale = 5;
      no_llgr = 6;
    }
  }
  // The type of community AS number.
  optional Type.Enum type = 1;

  // First two octets of 32 bit community AS number.
  // default = 0
  optional uint32 as_number = 2;

  // Last two octets of the community value.
  // default = 0
  optional uint32 as_custom = 3;
}

// The Extended Communities Attribute is a transitive optional BGP attribute, with the
// Type Code 16. Community and Extended Communities  attributes are utilized to trigger
// routing decisions, such as acceptance, rejection,  preference, or redistribution.
// An extended community is an 8-Bytes value. It is divided into two main parts. The
// first 2 Bytes of the community encode a type and sub-type fields and the last 6 Bytes
// carry a unique set of data in a  format defined by the type and sub-type field. Extended
// communities provide a larger  range for grouping or categorizing communities.
message BgpExtCommunity {

  message Type {
    enum Enum {
      unspecified = 0;
      administrator_as_2octet = 1;
      administrator_ipv4_address = 2;
      administrator_as_4octet = 3;
      opaque = 4;
      evpn = 5;
      administrator_as_2octet_link_bandwidth = 6;
    }
  }
  // Extended Community Type field of 1 Byte.
  // - administrator_as_2octet: Two-Octet AS Specific Extended Community (RFC 4360).
  // - administrator_ipv4_address: IPv4 Address Specific Extended Community (RFC 4360).
  // - administrator_as_4octet:  4-Octet AS Specific Extended Community (RFC 5668).
  // - opaque: Opaque Extended Community (RFC 7432).
  // - evpn: EVPN Extended Community (RFC 7153).
  // - administrator_as_2octet_link_bandwidth : Link Bandwidth Extended Community (RFC
  // 7153).
  optional Type.Enum type = 1;

  message Subtype {
    enum Enum {
      unspecified = 0;
      route_target = 1;
      origin = 2;
      extended_bandwidth = 3;
      color = 4;
      encapsulation = 5;
      mac_address = 6;
    }
  }
  // Extended Community Sub Type field of 1 Byte.
  // - route_target: Route Target.
  // - origin: Origin.
  // - extended_bandwidth: Specifies the link bandwidth.
  // - color: Specifies the color value.
  // - encapsulation: Specifies the Encapsulation Extended Community.
  // - mac_address: Specifies the Extended community MAC address.
  optional Subtype.Enum subtype = 2;

  // Extended Community value of 6 Bytes. Example - for the Opaque type and Color subtype
  // value can be '0000000000c8'  for the color value 200.
  optional string value = 3;
}

// This attribute identifies the autonomous systems through  which routing information
// carried in this UPDATE message has passed. This contains the configuration of how
// to include the Local AS in the AS path attribute of the MP REACH NLRI. It also contains
// optional configuration of additional AS Path Segments that can be included in the
// AS Path attribute. The AS Path consists of a Set or Sequence of Autonomous Systems
// (AS) numbers  that a routing information passes through to reach the destination.
message BgpAsPath {

  message AsSetMode {
    enum Enum {
      unspecified = 0;
      do_not_include_local_as = 1;
      include_as_seq = 2;
      include_as_set = 3;
      include_as_confed_seq = 4;
      include_as_confed_set = 5;
      prepend_to_first_segment = 6;
    }
  }
  // Defines how the Local AS should be included in the MP REACH NLRI. For iBGP sessions,
  // Do Not Include Local AS must be chosen. For eBGP sessions, any choice other than
  // Do Not Include Local AS can be chosen.
  // default = AsSetMode.Enum.do_not_include_local_as
  optional AsSetMode.Enum as_set_mode = 1;

  // The additional AS path segments to be added in the NLRI.  By default, an empty AS
  // path is always included and  the local AS is added to it as per the value of 'as_set_mode'
  // attribute.
  repeated BgpAsPathSegment segments = 2;
}

// Configuration for a single BGP AS path segment
message BgpAsPathSegment {

  message Type {
    enum Enum {
      unspecified = 0;
      as_seq = 1;
      as_set = 2;
      as_confed_seq = 3;
      as_confed_set = 4;
    }
  }
  // AS sequence is the most common type of AS_PATH, it contains the  list of ASNs starting
  // with the most recent ASN being added read  from left to right.
  // The other three AS_PATH types are used for Confederations - AS_SET is the type of
  // AS_PATH attribute that summarizes routes using using the aggregate-address command,
  // allowing AS_PATHs to be  summarized in the update as well. - AS_CONFED_SEQ gives
  // the list of ASNs in the path starting with the  most recent ASN to be added reading
  // left to right - AS_CONFED_SET will allow summarization of multiple AS PATHs to be
  // sent in BGP Updates.
  // default = Type.Enum.as_seq
  optional Type.Enum type = 1;

  // The AS numbers in this AS path segment.
  repeated uint32 as_numbers = 2;
}

// This contains a list of different flavors of EVPN.
// For example EVPN over VXLAN or EVPN over MPLS etc to be configured per Ethernet segment.
// 
// Need to instantiate correct type of EVPN instance as per requirement.
message BgpV4EvpnEvis {

  message Choice {
    enum Enum {
      unspecified = 0;
      evi_vxlan = 1;
    }
  }
  // Description missing in models
  // default = Choice.Enum.evi_vxlan
  optional Choice.Enum choice = 1;

  // EVPN VXLAN instance to be configured per Ethernet Segment.
  optional BgpV4EviVxlan evi_vxlan = 2;
}

// Configuration for BGP EVPN EVI. Advertises following routes -
// 
// Type 3 - Inclusive Multicast Ethernet Tag Route
// 
// Type 1 -  Ethernet Auto-discovery Route (Per EVI)
// 
// Type 1 -  Ethernet Auto-discovery Route (Per ES)
message BgpV4EviVxlan {

  // This contains the list of Broadcast Domains to be configured per EVI.
  repeated BgpV4EviVxlanBroadcastDomain broadcast_domains = 1;

  message ReplicationType {
    enum Enum {
      unspecified = 0;
      ingress_replication = 1;
    }
  }
  // This model only supports Ingress Replication
  // default = ReplicationType.Enum.ingress_replication
  optional ReplicationType.Enum replication_type = 2;

  // Downstream assigned VNI to be carried as Part of P-Multicast Service Interface Tunnel
  // attribute (PMSI Tunnel Attribute) in Type 3 Inclusive Multicast Ethernet Tag Route.
  // default = 16
  optional uint32 pmsi_label = 3;

  // The Auto-discovery Route label (AD label) value, which gets advertised in the Ethernet
  // Auto-discovery Route per <EVI, ESI>
  // default = 0
  optional uint32 ad_label = 4;

  // Colon separated Extended Community value of 6 Bytes - AS number: Value identifying
  // an EVI.            Example - for the as_2octet 60005:100.
  optional BgpRouteDistinguisher route_distinguisher = 5;

  // List of Layer 2 Virtual Network Identifier (L2VNI) export targets associated with
  // this EVI.
  repeated BgpRouteTarget route_target_export = 6;

  // List of L2VNI import targets associated with this EVI.
  repeated BgpRouteTarget route_target_import = 7;

  // List of Layer 3 Virtual Network Identifier (L3VNI) Export Route Targets.
  repeated BgpRouteTarget l3_route_target_export = 8;

  // List of L3VNI Import Route Targets.
  repeated BgpRouteTarget l3_route_target_import = 9;

  // Description missing in models
  optional BgpRouteAdvanced advanced = 10;

  // Optional community settings.
  repeated BgpCommunity communities = 11;

  // Optional Extended Community settings. The Extended Communities Attribute is a transitive
  // optional BGP attribute, with the Type Code 16. Community and Extended Communities
  // attributes are utilized to trigger routing decisions, such as acceptance, rejection,
  // preference, or redistribution. An extended community is an 8-Bytes value. It is
  // divided into two main parts. The first 2 Bytes of the community encode a type and
  // sub-type fields and the last 6 Bytes carry a unique set of data in a format defined
  // by the type and sub-type field. Extended communities provide a larger  range for
  // grouping or categorizing communities. When type is administrator_as_2octet or administrator_as_4octet,
  // the valid sub types are route target and origin. The valid value for  administrator_as_2octet
  // and administrator_as_4octet type is either two byte AS followed by four byte local
  // administrator id or four byte AS followed by two  byte local administrator id.  When
  // type is administrator_ipv4_address the valid sub types are route target and origin.
  // The valid value for  administrator_ipv4_address is a four byte IPv4 address followed
  // by a two byte local administrator id.  When type is opaque, valid sub types are color
  // and encapsulation. When sub type is color, first two bytes of the value field contain
  // flags and last four bytes  contains the value of the color. When sub type is encapsulation
  // the first four bytes of value field are reserved and last two bytes carries the tunnel
  // type from  IANA's ETHER TYPES registry e.g IPv4 (protocol type = 0x0800), IPv6 (protocol
  // type = 0x86dd), and MPLS (protocol type = 0x8847). When type is administrator_as_2octet_link_bandwidth
  // the valid sub type is extended_bandwidth. The first two bytes of the value field
  // contains the AS number and the last four bytes contains the bandwidth in IEEE floating
  // point format.  When type is evpn the valid subtype is mac_address. In the value field
  // the low-order bit of the first byte(Flags) is defined as the Sticky/static flag and
  // may be set to 1, indicating the MAC address is static and cannot move. The second
  // byte is reserved and the  last four bytes contain the sequence number which is used
  // to ensure that PEs retain the correct MAC/IP Advertisement route when multiple updates
  // occur for the same MAC address.
  repeated BgpExtCommunity ext_communities = 12;

  // Optional AS PATH settings.
  optional BgpAsPath as_path = 13;
}

// Configuration for Broadcast Domains per EVI.
message BgpV4EviVxlanBroadcastDomain {

  // This contains the list of Customer MAC/IP Ranges to be configured per Broadcast Domain.
  // 
  // 
  // Advertises following route -
  // Type 2 - MAC/IP Advertisement Route.
  repeated BgpCMacIpRange cmac_ip_range = 1;

  // The Ethernet Tag ID of the Broadcast Domain.
  // default = 0
  optional uint32 ethernet_tag_id = 2;

  // VLAN-Aware service to be enabled or disabled.
  // default = False
  optional bool vlan_aware_service = 3;
}

// Configuration for MAC/IP Ranges per Broadcast Domain.
// 
// Advertises following route -
// 
// Type 2 - MAC/IP Advertisement Route.
message BgpCMacIpRange {

  // Host MAC address range per Broadcast Domain.
  optional MACRouteAddress mac_addresses = 1;

  // Layer 2 Virtual Network Identifier (L2VNI) to be advertised with MAC/IP Advertisement
  // Route (Type 2)
  // default = 0
  optional uint32 l2vni = 2;

  // Host IPv4 address range per Broadcast Domain.
  optional V4RouteAddress ipv4_addresses = 3;

  // Host IPv6 address range per Broadcast Domain.
  optional V6RouteAddress ipv6_addresses = 4;

  // Layer 3 Virtual Network Identifier (L3VNI) to be advertised with MAC/IP Advertisement
  // Route (Type 2).
  // default = 0
  optional uint32 l3vni = 5;

  // Include default Gateway Extended Community in MAC/IP Advertisement Route (Type 2).
  // default = False
  optional bool include_default_gateway = 6;

  // Description missing in models
  optional BgpRouteAdvanced advanced = 7;

  // Optional community settings.
  repeated BgpCommunity communities = 8;

  // Optional Extended Community settings. The Extended Communities Attribute is a transitive
  // optional BGP attribute, with the Type Code 16. Community and Extended Communities
  // attributes are utilized to trigger routing decisions, such as acceptance, rejection,
  // preference, or redistribution. An extended community is an 8-Bytes value. It is
  // divided into two main parts. The first 2 Bytes of the community encode a type and
  // sub-type fields and the last 6 Bytes carry a unique set of data in a format defined
  // by the type and sub-type field. Extended communities provide a larger  range for
  // grouping or categorizing communities. When type is administrator_as_2octet or administrator_as_4octet,
  // the valid sub types are route target and origin. The valid value for  administrator_as_2octet
  // and administrator_as_4octet type is either two byte AS followed by four byte local
  // administrator id or four byte AS followed by two  byte local administrator id.  When
  // type is administrator_ipv4_address the valid sub types are route target and origin.
  // The valid value for  administrator_ipv4_address is a four byte IPv4 address followed
  // by a two byte local administrator id.  When type is opaque, valid sub types are color
  // and encapsulation. When sub type is color, first two bytes of the value field contain
  // flags and last four bytes  contains the value of the color. When sub type is encapsulation
  // the first four bytes of value field are reserved and last two bytes carries the tunnel
  // type from  IANA's ETHER TYPES registry e.g IPv4 (protocol type = 0x0800), IPv6 (protocol
  // type = 0x86dd), and MPLS (protocol type = 0x8847). When type is administrator_as_2octet_link_bandwidth
  // the valid sub type is extended_bandwidth. The first two bytes of the value field
  // contains the AS number and the last four bytes contains the bandwidth in IEEE floating
  // point format.  When type is evpn the valid subtype is mac_address. In the value field
  // the low-order bit of the first byte(Flags) is defined as the Sticky/static flag and
  // may be set to 1, indicating the MAC address is static and cannot move. The second
  // byte is reserved and the  last four bytes contain the sequence number which is used
  // to ensure that PEs retain the correct MAC/IP Advertisement route when multiple updates
  // occur for the same MAC address.
  repeated BgpExtCommunity ext_communities = 9;

  // Optional AS PATH settings.
  optional BgpAsPath as_path = 10;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  string name = 11;
}

// BGP Route Distinguisher.
message BgpRouteDistinguisher {

  message RdType {
    enum Enum {
      unspecified = 0;
      as_2octet = 1;
      ipv4_address = 2;
      as_4octet = 3;
    }
  }
  // Route Distinguisher Type field of 2 Byte.
  // - as_2octet: Two-Octet AS Specific Extended Community (RFC 4360).
  // - ipv4_address: IPv4 Address Specific Extended Community (RFC 4360).
  // - as_4octet:  4-Octet AS Specific Extended Community (RFC 5668).
  // default = RdType.Enum.as_2octet
  optional RdType.Enum rd_type = 1;

  // Allow to automatically configure RD IP address  from local ip.
  // default = False
  optional bool auto_config_rd_ip_addr = 2;

  // Colon separated Extended Community value of 6 Bytes - AS number: Value.  Example
  // - for the as_2octet or as_4octet 60005:100,  for ipv4_address 1.1.1.1:100
  optional string rd_value = 3;
}

// BGP Route Target.
message BgpRouteTarget {

  message RtType {
    enum Enum {
      unspecified = 0;
      as_2octet = 1;
      ipv4_address = 2;
      as_4octet = 3;
    }
  }
  // Extended Community Type field of 2 Byte.
  // - as_2octet: Two-Octet AS Specific Extended Community (RFC 4360).
  // - ipv4_address: IPv4 Address Specific Extended Community (RFC 4360).
  // - as_4octet:  4-Octet AS Specific Extended Community (RFC 5668).
  optional RtType.Enum rt_type = 1;

  // Colon separated Extended Community value of 6 Bytes - AS number: Assigned Number.
  // Example - for the as_2octet or as_4octet 60005:100,  for ipv4_address 1.1.1.1:100
  optional string rt_value = 2;
}

// Configuration for BGP advanced settings.
message BgpAdvanced {

  // Number of seconds the sender proposes for the value of the Hold Timer.
  // default = 90
  optional uint32 hold_time_interval = 1;

  // Number of seconds between transmissions of Keepalive messages by this peer.
  // default = 30
  optional uint32 keep_alive_interval = 2;

  // The time interval at which Update messages are sent to the DUT, expressed as the
  // number of milliseconds between Update messages. The update interval 0 implies to
  // send all the updates as fast as possible.
  // default = 0
  optional uint32 update_interval = 3;

  // The limited number of iterations that a unit of data can experience before the data
  // is discarded. This is placed in the TTL field in the IP header of the  transmitted
  // packets.
  // default = 64
  optional uint32 time_to_live = 4;

  // The value to be used as a secret MD5 key for authentication. If not configured, MD5
  // authentication will not be enabled.
  optional string md5_key = 5;
}

// Configuration for BGP capability settings.
message BgpCapability {

  // Support for the IPv4 Unicast address family.
  // default = True
  optional bool ipv4_unicast = 1;

  // Support for the IPv4 Multicast address family.
  // default = False
  optional bool ipv4_multicast = 2;

  // Support for the IPv4 Unicast address family.
  // default = True
  optional bool ipv6_unicast = 3;

  // Support for the IPv6 Multicast address family.
  // default = False
  optional bool ipv6_multicast = 4;

  // Support for VPLS as below.
  // RFC4761 - Virtual Private LAN Service (VPLS) using BGP for Auto-Discovery
  // and Signaling.
  // RFC6624 - Layer 2 Virtual Private Networks using BGP for Auto-Discovery
  // and Signaling.
  // default = False
  optional bool vpls = 5;

  // Support for the route refresh capabilities. Route Refresh allows the dynamic exchange
  // of route refresh requests  and routing information between BGP peers and the subsequent
  // re-advertisement  of the outbound or inbound routing table.
  // default = True
  optional bool route_refresh = 6;

  // Supports for the route constraint capabilities. Route Constraint allows the advertisement
  // of Route Target Membership  information. The BGP peers exchange Route Target Reachability
  // Information,  which is used to build a route distribution graph.  This limits the
  // propagation of VPN Network Layer Reachability Information (NLRI) between different
  // autonomous systems  or distinct clusters of the same autonomous system. This is supported
  // for Layer 3 Virtual Private Network scenario.
  // default = False
  optional bool route_constraint = 7;

  // Support for BGP Link State for ISIS and OSPF.
  // default = False
  optional bool link_state_non_vpn = 8;

  // Capability advertisement of BGP Link State for VPNs.
  // default = False
  optional bool link_state_vpn = 9;

  // Support for the EVPN address family.
  // default = False
  optional bool evpn = 10;

  // Support for extended Next Hop Encoding for Nexthop field in  IPv4 routes advertisement.
  // This allows IPv4 routes being advertised by IPv6 peers to  include an IPv6 Nexthop.
  // default = False
  optional bool extended_next_hop_encoding = 11;

  // Support for the IPv4 Multicast VPN address family.
  // default = False
  optional bool ipv4_multicast_vpn = 12;

  // Support for the IPv4 MPLS L3VPN address family.
  // default = False
  optional bool ipv4_mpls_vpn = 13;

  // Supports for IPv4 MDT address family messages.
  // default = False
  optional bool ipv4_mdt = 14;

  // Support for the IPv4 Multicast VPN address family.
  // default = False
  optional bool ipv4_multicast_mpls_vpn = 15;

  // Support for propagation of IPv4 unicast flow specification rules.
  // default = False
  optional bool ipv4_unicast_flow_spec = 16;

  // Support for IPv4 SRTE policy.
  // default = False
  optional bool ipv4_sr_te_policy = 17;

  // Support for IPv4 Unicast Add Path Capability.
  // default = False
  optional bool ipv4_unicast_add_path = 18;

  // Support for the IPv6 Multicast VPN address family.
  // default = False
  optional bool ipv6_multicast_vpn = 19;

  // Support for the IPv6 MPLS L3VPN address family.
  // default = False
  optional bool ipv6_mpls_vpn = 20;

  // Support for IPv6 MDT address family messages.
  // default = False
  optional bool ipv6_mdt = 21;

  // Support for the IPv6 Multicast VPN address family.
  // default = False
  optional bool ipv6_multicast_mpls_vpn = 22;

  // Support for propagation of IPv6 unicast flow specification rules.
  // default = False
  optional bool ipv6_unicast_flow_spec = 23;

  // Support for IPv6 SRTE policy.
  // default = False
  optional bool ipv6_sr_te_policy = 24;

  // Support for IPv6 Unicast Add Path Capability.
  // default = False
  optional bool ipv6_unicast_add_path = 25;
}

// Configuration for controlling storage of BGP learned information recieved from the
// peer.
message BgpLearnedInformationFilter {

  // If enabled, will store the information related to Unicast IPv4 Prefixes recieved
  // from the peer.
  // default = False
  optional bool unicast_ipv4_prefix = 1;

  // If enabled, will store the information related to Unicast IPv6 Prefixes recieved
  // from the peer.
  // default = False
  optional bool unicast_ipv6_prefix = 2;
}

// Emulated BGPv4 route range.
message BgpV4RouteRange {

  // A list of group of IPv4 route addresses.
  repeated V4RouteAddress addresses = 1;

  message NextHopMode {
    enum Enum {
      unspecified = 0;
      local_ip = 1;
      manual = 2;
    }
  }
  // Specify the NextHop in MP REACH NLRI. The mode for setting the IP address  of the
  // NextHop in the MP REACH NLRI can be one of the following:
  // Local IP: Automatically fills the Nexthop with the Local IP of the BGP
  // peer.
  // If BGP peer is of type IPv6, Nexthop Encoding capability should be enabled.
  // Manual: Override the Nexthop with any arbitrary IPv4/IPv6 address.
  // default = NextHopMode.Enum.local_ip
  optional NextHopMode.Enum next_hop_mode = 2;

  message NextHopAddressType {
    enum Enum {
      unspecified = 0;
      ipv4 = 1;
      ipv6 = 2;
    }
  }
  // If the Nexthop Mode is Manual, it sets the type of the NextHop IP address.
  // default = NextHopAddressType.Enum.ipv4
  optional NextHopAddressType.Enum next_hop_address_type = 3;

  // The IPv4 address of the next hop if the Nexthop Mode is manual and the Nexthop type
  // is IPv4. If BGP peer is of type IPv6, Nexthop Encoding capability should be enabled.
  // default = 0.0.0.0
  optional string next_hop_ipv4_address = 4;

  // The IPv6 address of the next hop if the Nexthop Mode is manual and the Nexthop type
  // is IPv6.
  // default = ::0
  optional string next_hop_ipv6_address = 5;

  // Description missing in models
  optional BgpRouteAdvanced advanced = 6;

  // Optional community settings.
  repeated BgpCommunity communities = 7;

  // Description missing in models
  optional BgpAsPath as_path = 8;

  // Description missing in models
  optional BgpAddPath add_path = 9;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  string name = 10;

  // Optional Extended Community settings. The Extended Communities Attribute is a transitive
  // optional BGP attribute, with the Type Code 16. Community and Extended Communities
  // attributes are utilized to trigger routing decisions, such as acceptance, rejection,
  // preference, or redistribution. An extended community is an 8-Bytes value. It is
  // divided into two main parts. The first 2 Bytes of the community encode a type and
  // sub-type fields and the last 6 Bytes carry a unique set of data in a format defined
  // by the type and sub-type field. Extended communities provide a larger  range for
  // grouping or categorizing communities. When type is administrator_as_2octet or administrator_as_4octet,
  // the valid sub types are route target and origin. The valid value for  administrator_as_2octet
  // and administrator_as_4octet type is either two byte AS followed by four byte local
  // administrator id or four byte AS followed by two  byte local administrator id.  When
  // type is administrator_ipv4_address the valid sub types are route target and origin.
  // The valid value for  administrator_ipv4_address is a four byte IPv4 address followed
  // by a two byte local administrator id.  When type is opaque, valid sub types are color
  // and encapsulation. When sub type is color, first two bytes of the value field contain
  // flags and last four bytes  contains the value of the color. When sub type is encapsulation
  // the first four bytes of value field are reserved and last two bytes carries the tunnel
  // type from  IANA's ETHER TYPES registry e.g IPv4 (protocol type = 0x0800), IPv6 (protocol
  // type = 0x86dd), and MPLS (protocol type = 0x8847). When type is administrator_as_2octet_link_bandwidth
  // the valid sub type is extended_bandwidth. The first two bytes of the value field
  // contains the AS number and the last four bytes contains the bandwidth in IEEE floating
  // point format.  When type is evpn the valid subtype is mac_address. In the value field
  // the low-order bit of the first byte(Flags) is defined as the Sticky/static flag and
  // may be set to 1, indicating the MAC address is static and cannot move. The second
  // byte is reserved and the  last four bytes contain the sequence number which is used
  // to ensure that PEs retain the correct MAC/IP Advertisement route when multiple updates
  // occur for the same MAC address.  Note evpn type is defined mainly for use with evpn
  // route updates and not for IPv4 and IPv6 route updates.
  repeated BgpExtCommunity ext_communities = 11;
}

// The BGP Additional Paths feature is a BGP extension that allows the  advertisement
// of multiple paths for the same prefix without the new  paths implicitly replacing
// any previous paths.
message BgpAddPath {

  // The id of the additional path.
  // default = 1
  optional uint32 path_id = 1;
}

// Emulated BGPv6 route range.
message BgpV6RouteRange {

  // A list of group of IPv6 route addresses.
  repeated V6RouteAddress addresses = 1;

  message NextHopMode {
    enum Enum {
      unspecified = 0;
      local_ip = 1;
      manual = 2;
    }
  }
  // Specify the NextHop in MP REACH NLRI. The mode for setting the IP address  of the
  // NextHop in the MP REACH NLRI can be one of the following:
  // Local IP: Automatically fills the Nexthop with the Local IP of the BGP
  // peer.
  // If BGP peer is of type IPv6, Nexthop Encoding capability should be enabled.
  // Manual: Override the Nexthop with any arbitrary IPv4/IPv6 address.
  // default = NextHopMode.Enum.local_ip
  optional NextHopMode.Enum next_hop_mode = 2;

  message NextHopAddressType {
    enum Enum {
      unspecified = 0;
      ipv4 = 1;
      ipv6 = 2;
    }
  }
  // If the Nexthop Mode is Manual, it sets the type of the NextHop IP address.
  // default = NextHopAddressType.Enum.ipv6
  optional NextHopAddressType.Enum next_hop_address_type = 3;

  // The IPv4 address of the next hop if the Nexthop Mode is manual and the Nexthop type
  // is IPv4. If BGP peer is of type IPv6, Nexthop Encoding capability should be enabled.
  // default = 0.0.0.0
  optional string next_hop_ipv4_address = 4;

  // The IPv6 address of the next hop if the Nexthop Mode is manual and the Nexthop type
  // is IPv6.
  // default = ::0
  optional string next_hop_ipv6_address = 5;

  // Description missing in models
  optional BgpRouteAdvanced advanced = 6;

  // Optional community settings.
  repeated BgpCommunity communities = 7;

  // Description missing in models
  optional BgpAsPath as_path = 8;

  // Description missing in models
  optional BgpAddPath add_path = 9;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  string name = 10;

  // Optional Extended Community settings. The Extended Communities Attribute is a transitive
  // optional BGP attribute, with the Type Code 16. Community and Extended Communities
  // attributes are utilized to trigger routing decisions, such as acceptance, rejection,
  // preference, or redistribution. An extended community is an 8-Bytes value. It is
  // divided into two main parts. The first 2 Bytes of the community encode a type and
  // sub-type fields and the last 6 Bytes carry a unique set of data in a format defined
  // by the type and sub-type field. Extended communities provide a larger  range for
  // grouping or categorizing communities. When type is administrator_as_2octet or administrator_as_4octet,
  // the valid sub types are route target and origin. The valid value for  administrator_as_2octet
  // and administrator_as_4octet type is either two byte AS followed by four byte local
  // administrator id or four byte AS followed by two  byte local administrator id.  When
  // type is administrator_ipv4_address the valid sub types are route target and origin.
  // The valid value for  administrator_ipv4_address is a four byte IPv4 address followed
  // by a two byte local administrator id.  When type is opaque, valid sub types are color
  // and encapsulation. When sub type is color, first two bytes of the value field contain
  // flags and last four bytes  contains the value of the color. When sub type is encapsulation
  // the first four bytes of value field are reserved and last two bytes carries the tunnel
  // type from  IANA's ETHER TYPES registry e.g IPv4 (protocol type = 0x0800), IPv6 (protocol
  // type = 0x86dd), and MPLS (protocol type = 0x8847). When type is administrator_as_2octet_link_bandwidth
  // the valid sub type is extended_bandwidth. The first two bytes of the value field
  // contains the AS number and the last four bytes contains the bandwidth in IEEE floating
  // point format.  When type is evpn the valid subtype is mac_address. In the value field
  // the low-order bit of the first byte(Flags) is defined as the Sticky/static flag and
  // may be set to 1, indicating the MAC address is static and cannot move. The second
  // byte is reserved and the  last four bytes contain the sequence number which is used
  // to ensure that PEs retain the correct MAC/IP Advertisement route when multiple updates
  // occur for the same MAC address.  Note evpn type is defined mainly for use with evpn
  // route updates and not for IPv4 and IPv6 route updates.
  repeated BgpExtCommunity ext_communities = 11;
}

// Configuration for BGP Segment Routing Traffic Engineering(SRTE)
// policy.
// 
message BgpSrteV4Policy {

  // 4-octet value uniquely identifying the policy in the context of (color, endpoint)
  // tuple. It is used by the SR Policy originator to make unique (from an NLRI perspective)
  // both for multiple candidate  paths of the same SR Policy as well as candidate paths
  // of different SR Policies (i.e. with different segment list) with the same Color
  // and Endpoint but meant for different head-ends.
  // default = 1
  optional uint32 distinguisher = 1;

  // Policy color is used to match the color of the destination prefixes to steer traffic
  // into the SR Policy.
  // default = 100
  optional uint32 color = 2;

  // Specifies a single node or a set of nodes (e.g. an anycast address). It is selected
  // on the basis of the SR Policy type (AFI).
  // required = true
  string ipv4_endpoint = 3;

  message NextHopMode {
    enum Enum {
      unspecified = 0;
      local_ip = 1;
      manual = 2;
    }
  }
  // Mode for choosing the NextHop in MP REACH NLRI. Available modes are : Local IP: Automatically
  // fills the Nexthop with the Local IP of the BGP peer. For IPv6 BGP peer the Nexthop
  // Encoding capability should be enabled. Manual: Override the Nexthop with any arbitrary
  // IPv4/IPv6 address.
  // default = NextHopMode.Enum.local_ip
  optional NextHopMode.Enum next_hop_mode = 4;

  message NextHopAddressType {
    enum Enum {
      unspecified = 0;
      ipv4 = 1;
      ipv6 = 2;
    }
  }
  // Type of next hop IP address to be used when 'next_hop_mode' is set to 'manual'.
  // default = NextHopAddressType.Enum.ipv4
  optional NextHopAddressType.Enum next_hop_address_type = 5;

  // The IPv4 address of the next hop if the Nexthop type 'next_hop_mode' is 'manual'
  // and the Nexthop type 'next_hop_address_type' is IPv4. If BGP peer is of type IPv6,
  // Nexthop Encoding capability extended_next_hop_encoding should be enabled.
  optional string next_hop_ipv4_address = 6;

  // The IPv6 address of the next hop if the Nexthop Mode 'next_hop_address_type' is 'manual'
  // and the Nexthop type 'next_hop_address_type' is IPv6.
  optional string next_hop_ipv6_address = 7;

  // Description missing in models
  optional BgpRouteAdvanced advanced = 8;

  // Description missing in models
  optional BgpAddPath add_path = 9;

  // Description missing in models
  optional BgpAsPath as_path = 10;

  // Optional Community settings.
  repeated BgpCommunity communities = 11;

  // Optional Extended Community settings. The Extended Communities Attribute is a transitive
  // optional BGP attribute, with the Type Code 16. Community and Extended Communities
  // attributes are utilized to trigger routing decisions, such as acceptance, rejection,
  // preference, or redistribution. An extended community is an 8-Bytes value. It is
  // divided into two main parts. The first 2 Bytes of the community encode a type and
  // sub-type fields and the last 6 Bytes carry a unique set of data in a format defined
  // by the type and sub-type field. Extended communities provide a larger  range for
  // grouping or categorizing communities. When type is administrator_as_2octet or administrator_as_4octet,
  // the valid sub types are route target and origin. The valid value for  administrator_as_2octet
  // and administrator_as_4octet type is either two byte AS followed by four byte local
  // administrator id or four byte AS followed by two  byte local administrator id.  When
  // type is administrator_ipv4_address the valid sub types are route target and origin.
  // The valid value for  administrator_ipv4_address is a four byte IPv4 address followed
  // by a two byte local administrator id.  When type is opaque, valid sub types are color
  // and encapsulation. When sub type is color, first two bytes of the value field contain
  // flags and last four bytes  contains the value of the color. When sub type is encapsulation
  // the first four bytes of value field are reserved and last two bytes carries the tunnel
  // type from  IANA's ETHER TYPES registry e.g IPv4 (protocol type = 0x0800), IPv6 (protocol
  // type = 0x86dd), and MPLS (protocol type = 0x8847). When type is administrator_as_2octet_link_bandwidth
  // the valid sub type is extended_bandwidth. The first two bytes of the value field
  // contains the AS number and the last four bytes contains the bandwidth in IEEE floating
  // point format.  When type is evpn the valid subtype is mac_address. In the value field
  // the low-order bit of the first byte(Flags) is defined as the Sticky/static flag and
  // may be set to 1, indicating the MAC address is static and cannot move. The second
  // byte is reserved and the  last four bytes contain the sequence number which is used
  // to ensure that PEs retain the correct MAC/IP Advertisement route when multiple updates
  // occur for the same MAC address.
  repeated BgpExtCommunity ext_communities = 12;

  // List Tunnel Encapsulation Attributes.
  repeated BgpSrteV4TunnelTlv tunnel_tlvs = 13;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  string name = 14;

  // If enabled means that this part of the configuration including any active 'children'
  // nodes will be advertised to peer.  If disabled, this means that though config is
  // present, it is not taking any part of the test but can be activated at run-time to
  // advertise just this part of the configuration to the peer.
  // default = True
  optional bool active = 15;
}

// Configuration for BGP SRTE Tunnel TLV.
message BgpSrteV4TunnelTlv {

  // Description missing in models
  optional BgpSrteRemoteEndpointSubTlv remote_endpoint_sub_tlv = 1;

  // Description missing in models
  optional BgpSrteColorSubTlv color_sub_tlv = 2;

  // Description missing in models
  optional BgpSrteBindingSubTlv binding_sub_tlv = 3;

  // Description missing in models
  optional BgpSrtePreferenceSubTlv preference_sub_tlv = 4;

  // Description missing in models
  optional BgpSrtePolicyPrioritySubTlv policy_priority_sub_tlv = 5;

  // Description missing in models
  optional BgpSrtePolicyNameSubTlv policy_name_sub_tlv = 6;

  // Description missing in models
  optional BgpSrteExplicitNullLabelPolicySubTlv explicit_null_label_policy_sub_tlv = 7;

  // Description missing in models
  repeated BgpSrteSegmentList segment_lists = 8;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  string name = 9;

  // If enabled means that this part of the configuration including any active 'children'
  // nodes will be advertised to peer.  If disabled, this means that though config is
  // present, it is not taking any part of the test but can be activated at run-time to
  // advertise just this part of the configuration to the peer.
  // default = True
  optional bool active = 10;
}

// Configuration for the BGP remote endpoint sub TLV.
message BgpSrteRemoteEndpointSubTlv {

  // Autonomous system (AS) number
  // default = 0
  optional uint32 as_number = 1;

  message AddressFamily {
    enum Enum {
      unspecified = 0;
      ipv4 = 1;
      ipv6 = 2;
    }
  }
  // Determines the address type
  // default = AddressFamily.Enum.ipv4
  optional AddressFamily.Enum address_family = 2;

  // The IPv4 address of the Remote Endpoint.
  // default = 0.0.0.0
  optional string ipv4_address = 3;

  // The IPv6 address of the Remote Endpoint.
  // default = ::0
  optional string ipv6_address = 4;
}

// Configuration for the Policy Color attribute sub-TLV. The Color sub-TLV MAY be used
// as a way to color the corresponding Tunnel TLV. The Value field of the sub-TLV is
// eight octets long and consists of a Color Extended Community. First two octets of
// its Value field are 0x030b as type and subtype of extended  community. Remaining
// six octets are are exposed to configure.
message BgpSrteColorSubTlv {

  // Six octet values. Example: 000000000064 for color value 100.
  optional string color = 1;
}

// Configuration for the binding SID sub-TLV.  This is used to signal the binding SID
// related information  of the SR Policy candidate path.
message BgpSrteBindingSubTlv {

  message BindingSidType {
    enum Enum {
      unspecified = 0;
      no_binding = 1;
      four_octet_sid = 2;
      ipv6_sid = 3;
    }
  }
  // Type of the binding SID.  Supported types are No Binding SID or Four Octets Sid or
  // IPv6 SID.
  // default = BindingSidType.Enum.no_binding
  optional BindingSidType.Enum binding_sid_type = 1;

  // Binding SID is encoded in 4 octets.
  optional uint32 four_octet_sid = 2;

  // IPv6 SID value.
  optional string ipv6_sid = 3;

  // S-Flag encodes the Specified-BSID-only behavior.
  // default = False
  optional bool s_flag = 4;

  // I-Flag encodes the Drop Upon Invalid behavior.
  // default = False
  optional bool i_flag = 5;
}

// Configuration for BGP preference sub TLV of the SR Policy candidate path.
message BgpSrtePreferenceSubTlv {

  // The preference value of the SR Policy candidate path.
  // default = 0
  optional uint32 preference = 1;
}

// Configuration for the Policy Priority sub-TLV. The Policy Priority to indicate the
// order in which the SR policies  are re-computed upon topological change.
message BgpSrtePolicyPrioritySubTlv {

  // One-octet Priority value.
  optional uint32 policy_priority = 1;
}

// Configuration for the Policy Name sub-TLV. The Policy Name sub-TLV is used to attach
// a symbolic name to the SR Policy candidate path.
message BgpSrtePolicyNameSubTlv {

  // Symbolic name for the policy that should be a string of printable ASCII characters,
  // without a NULL terminator.
  optional string policy_name = 1;
}

// Configuration for BGP explicit null label policy sub TLV settings.
message BgpSrteExplicitNullLabelPolicySubTlv {

  message ExplicitNullLabelPolicy {
    enum Enum {
      unspecified = 0;
      reserved_enlp = 1;
      push_ipv4_enlp = 2;
      push_ipv6_enlp = 3;
      push_ipv4_ipv6_enlp = 4;
      do_not_push_enlp = 5;
    }
  }
  // The value of the explicit null label policy
  // default = ExplicitNullLabelPolicy.Enum.do_not_push_enlp
  optional ExplicitNullLabelPolicy.Enum explicit_null_label_policy = 1;
}

// Optional configuration for BGP SR TE Policy segment list. The Segment List sub-TLV
// encodes a single explicit path towards the Endpoint.
message BgpSrteSegmentList {

  // The Weight associated with a given path and the sub-TLV is optional.
  // default = 0
  optional uint32 weight = 1;

  // Description missing in models
  repeated BgpSrteSegment segments = 2;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  string name = 3;

  // If enabled means that this part of the configuration including any active 'children'
  // nodes will be advertised to peer.  If disabled, this means that though config is
  // present, it is not taking any part of the test but can be activated at run-time to
  // advertise just this part of the configuration to the peer.
  // default = True
  optional bool active = 4;
}

// A Segment sub-TLV describes a single segment in a segment list  i.e., a single element
// of the explicit path. The Segment sub-TLVs are optional.
message BgpSrteSegment {

  message SegmentType {
    enum Enum {
      unspecified = 0;
      type_a = 1;
      type_b = 2;
      type_c = 3;
      type_d = 4;
      type_e = 5;
      type_f = 6;
      type_g = 7;
      type_h = 8;
      type_i = 9;
      type_j = 10;
      type_k = 11;
    }
  }
  // Specify one of the segment type.
  // https://datatracker.ietf.org/doc/html/draft-ietf-idr-segment-routing-te-policy-13
  // Type  A: SID only, in the form of MPLS Label.
  // Type  B: SID only, in the form of IPv6 Address.
  // Type  C: IPv4 Node Address with optional SID.
  // Type  D: IPv6 Node Address with optional SID for SR MPLS.
  // Type  E: IPv4 Address and index with optional SID.
  // Type  F: IPv4 Local and Remote addresses with optional SID.
  // Type  G: IPv6 Address and index for local and remote pair with optional
  // SID for SR MPLS.
  // Type  H: IPv6 Local and Remote addresses with optional SID for SR MPLS.
  // Type  I: IPv6 Node Address with optional SID for SRv6.
  // Type  J: IPv6 Address and index for local and remote pair with optional
  // SID for SRv6.
  // Type  K: IPv6 Local and Remote addresses for SRv6.
  // required = true
  SegmentType.Enum segment_type = 1;

  // Description missing in models
  optional BgpSrteSegmentATypeSubTlv type_a = 2;

  // Description missing in models
  optional BgpSrteSegmentBTypeSubTlv type_b = 3;

  // Description missing in models
  optional BgpSrteSegmentCTypeSubTlv type_c = 4;

  // Description missing in models
  optional BgpSrteSegmentDTypeSubTlv type_d = 5;

  // Description missing in models
  optional BgpSrteSegmentETypeSubTlv type_e = 6;

  // Description missing in models
  optional BgpSrteSegmentFTypeSubTlv type_f = 7;

  // Description missing in models
  optional BgpSrteSegmentGTypeSubTlv type_g = 8;

  // Description missing in models
  optional BgpSrteSegmentHTypeSubTlv type_h = 9;

  // Description missing in models
  optional BgpSrteSegmentITypeSubTlv type_i = 10;

  // Description missing in models
  optional BgpSrteSegmentJTypeSubTlv type_j = 11;

  // Description missing in models
  optional BgpSrteSegmentKTypeSubTlv type_k = 12;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  string name = 13;

  // If enabled means that this part of the configuration including any active 'children'
  // nodes will be advertised to peer.  If disabled, this means that though config is
  // present, it is not taking any part of the test but can be activated at run-time to
  // advertise just this part of the configuration to the peer.
  // default = True
  optional bool active = 14;
}

// Configuration for SR-MPLS with Label, TC, Bottom-of-Stack and TTL.
message BgpSrteSrMplsSid {

  // Label value in [0, 2^20 -1].
  optional uint32 label = 1;

  // Traffic class in bits.
  optional uint32 tc = 2;

  // Bottom-of-Stack bit.
  optional bool s_bit = 3;

  // Time To Live.
  optional uint32 ttl = 4;
}

// Configuration for SRv6 Endpoint Behavior and SID Structure.  Its optional. Summation
// of lengths for Locator Block, Locator Node,  Function, and Argument MUST be less
// than or equal to 128.
message BgpSrteSRv6SIDEndpointBehaviorAndStructure {

  // SRv6 SID Locator Block length in bits.
  // default = 0
  optional uint32 lb_length = 1;

  // SRv6 SID Locator Node length in bits.
  // default = 0
  optional uint32 ln_length = 2;

  // SRv6 SID Function length in bits.
  // default = 0
  optional uint32 func_length = 3;

  // SRv6 SID Arguments length in bits.
  // default = 0
  optional uint32 arg_length = 4;
}

// Type  A: SID only, in the form of MPLS Label.
message BgpSrteSegmentATypeSubTlv {

  // One octet bitmap for flags including V-Flag, A-Flag, S-Flag, B-Flag etc. as defined
  // in https://datatracker.ietf.org/doc/html/draft-ietf-idr-segment-routing-te-policy-13#section-2.4.4.2.12
  optional string flags = 1;

  // Label value in [0, 2^20 -1].
  optional uint32 label = 2;

  // Traffic class in bits.
  optional uint32 tc = 3;

  // Bottom-of-Stack bit.
  optional bool s_bit = 4;

  // Time To Live.
  optional uint32 ttl = 5;
}

// Type  B: SID only, in the form of IPv6 address.
message BgpSrteSegmentBTypeSubTlv {

  // One octet bitmap for flags including V-Flag, A-Flag, S-Flag, B-Flag etc. as defined
  // in https://datatracker.ietf.org/doc/html/draft-ietf-idr-segment-routing-te-policy-13#section-2.4.4.2.12
  optional string flags = 1;

  // SRv6 SID.
  // required = true
  string srv6_sid = 2;

  // Optional SRv6 Endpoint Behavior and SID Structure.
  optional BgpSrteSRv6SIDEndpointBehaviorAndStructure srv6_sid_endpoint_behavior = 3;
}

// Type C: IPv4 Node Address with optional SID.
message BgpSrteSegmentCTypeSubTlv {

  // One octet bitmap for flags including V-Flag, A-Flag, S-Flag, B-Flag etc. as defined
  // in https://datatracker.ietf.org/doc/html/draft-ietf-idr-segment-routing-te-policy-13#section-2.4.4.2.12
  optional string flags = 1;

  // SR Algorithm identifier when A-Flag in on.
  // default = 0
  optional uint32 sr_algorithm = 2;

  // IPv4 address representing a node.
  // required = true
  string ipv4_node_address = 3;

  // Optional SR-MPLS SID.
  optional BgpSrteSrMplsSid sr_mpls_sid = 4;
}

// Type D: IPv6 Node Address with optional SID for SR MPLS.
message BgpSrteSegmentDTypeSubTlv {

  // One octet bitmap for flags including V-Flag, A-Flag, S-Flag, B-Flag etc. as defined
  // in https://datatracker.ietf.org/doc/html/draft-ietf-idr-segment-routing-te-policy-13#section-2.4.4.2.12
  optional string flags = 1;

  // specifying SR Algorithm when when A-Flag as defined in above flags.
  // default = 0
  optional uint32 sr_algorithm = 2;

  // IPv6 address representing a node.
  // required = true
  string ipv6_node_address = 3;

  // Optional SR-MPLS SID.
  optional BgpSrteSrMplsSid sr_mpls_sid = 4;
}

// Type E: IPv4 Address and Local Interface ID with optional SID
message BgpSrteSegmentETypeSubTlv {

  // One octet bitmap for flags including V-Flag, A-Flag, S-Flag, B-Flag etc. as defined
  // in https://datatracker.ietf.org/doc/html/draft-ietf-idr-segment-routing-te-policy-13#section-2.4.4.2.12
  optional string flags = 1;

  // Local Interface ID: The Interface Index as defined in [RFC8664].
  // default = 0
  optional uint32 local_interface_id = 2;

  // IPv4 address representing a node.
  // required = true
  string ipv4_node_address = 3;

  // Optional SR-MPLS SID.
  optional BgpSrteSrMplsSid sr_mpls_sid = 4;
}

// Type F: IPv4 Local and Remote addresses with optional SID.
message BgpSrteSegmentFTypeSubTlv {

  // One octet bitmap for flags including V-Flag, A-Flag, S-Flag, B-Flag etc. as defined
  // in https://datatracker.ietf.org/doc/html/draft-ietf-idr-segment-routing-te-policy-13#section-2.4.4.2.12
  optional string flags = 1;

  // Local IPv4 Address.
  // required = true
  string local_ipv4_address = 2;

  // Remote IPv4 Address.
  // required = true
  string remote_ipv4_address = 3;

  // Optional SR-MPLS SID.
  optional BgpSrteSrMplsSid sr_mpls_sid = 4;
}

// Type G: IPv6 Address, Interface ID for local and remote pair with optional SID for
// SR MPLS.
message BgpSrteSegmentGTypeSubTlv {

  // One octet bitmap for flags including V-Flag, A-Flag, S-Flag, B-Flag etc. as defined
  // in https://datatracker.ietf.org/doc/html/draft-ietf-idr-segment-routing-te-policy-13#section-2.4.4.2.12
  optional string flags = 1;

  // Local Interface ID: The Interface Index as defined in [RFC8664].
  // default = 0
  optional uint32 local_interface_id = 2;

  // IPv6 address representing a node.
  // required = true
  string local_ipv6_node_address = 3;

  // Local Interface ID: The Interface Index as defined in [RFC8664].
  // default = 0
  optional uint32 remote_interface_id = 4;

  // IPv6 address representing a node.
  // required = true
  string remote_ipv6_node_address = 5;

  // Optional SR-MPLS SID.
  optional BgpSrteSrMplsSid sr_mpls_sid = 6;
}

// Type H: IPv6 Local and Remote addresses with optional SID for SR MPLS.
message BgpSrteSegmentHTypeSubTlv {

  // One octet bitmap for flags including V-Flag, A-Flag, S-Flag, B-Flag etc. as defined
  // in https://datatracker.ietf.org/doc/html/draft-ietf-idr-segment-routing-te-policy-13#section-2.4.4.2.12
  optional string flags = 1;

  // Local IPv6 Address.
  // required = true
  string local_ipv6_address = 2;

  // Remote IPv6 Address.
  // required = true
  string remote_ipv6_address = 3;

  // Optional SR-MPLS SID.
  optional BgpSrteSrMplsSid sr_mpls_sid = 4;
}

// Type I: IPv6 Node Address with optional SRv6 SID.
message BgpSrteSegmentITypeSubTlv {

  // One octet bitmap for flags including V-Flag, A-Flag, S-Flag, B-Flag etc. as defined
  // in https://datatracker.ietf.org/doc/html/draft-ietf-idr-segment-routing-te-policy-13#section-2.4.4.2.12
  optional string flags = 1;

  // IPv6 address representing a node.
  // required = true
  string ipv6_node_address = 2;

  // Optional SRv6 SID.
  optional string srv6_sid = 3;

  // Optional SRv6 Endpoint Behavior and SID Structure.
  optional BgpSrteSRv6SIDEndpointBehaviorAndStructure srv6_sid_endpoint_behavior = 4;
}

// Type J: IPv6 Address, Interface ID for local and remote pair for SRv6 with optional
// SID.
message BgpSrteSegmentJTypeSubTlv {

  // One octet bitmap for flags including V-Flag, A-Flag, S-Flag, B-Flag etc. as defined
  // in https://datatracker.ietf.org/doc/html/draft-ietf-idr-segment-routing-te-policy-13#section-2.4.4.2.12
  optional string flags = 1;

  // SR Algorithm identifier when A-Flag in on.
  // default = 0
  optional uint32 sr_algorithm = 2;

  // Local Interface ID: The Interface Index as defined in [RFC8664].
  // default = 0
  optional uint32 local_interface_id = 3;

  // IPv6 address representing a node.
  // required = true
  string local_ipv6_node_address = 4;

  // Local Interface ID: The Interface Index as defined in [RFC8664].
  // default = 0
  optional uint32 remote_interface_id = 5;

  // IPv6 address representing a node.
  // required = true
  string remote_ipv6_node_address = 6;

  // Optional SRv6 SID.
  optional string srv6_sid = 7;

  // Optional SRv6 Endpoint Behavior and SID Structure.
  optional BgpSrteSRv6SIDEndpointBehaviorAndStructure srv6_sid_endpoint_behavior = 8;
}

// Type K: IPv6 Local and Remote addresses for SRv6 with optional SID.
message BgpSrteSegmentKTypeSubTlv {

  // One octet bitmap for flags including V-Flag, A-Flag, S-Flag, B-Flag etc. as defined
  // in https://datatracker.ietf.org/doc/html/draft-ietf-idr-segment-routing-te-policy-13#section-2.4.4.2.12
  optional string flags = 1;

  // SR Algorithm identifier when A-Flag in on.
  // default = 0
  optional uint32 sr_algorithm = 2;

  // IPv6 address representing a node.
  // required = true
  string local_ipv6_address = 3;

  // IPv6 address representing a node.
  // required = true
  string remote_ipv6_address = 4;

  // Optional SRv6 SID.
  optional string srv6_sid = 5;

  // Optional SRv6 Endpoint Behavior and SID Structure.
  optional BgpSrteSRv6SIDEndpointBehaviorAndStructure srv6_sid_endpoint_behavior = 6;
}

// Configuration for BGP Segment Routing Traffic Engineering policy.
// 
message BgpSrteV6Policy {

  // Identifies the policy in the context of (color and endpoint) tuple.  It is used by
  // the SR Policy originator to make unique multiple  occurrences of the same SR Policy.
  // default = 1
  optional uint32 distinguisher = 1;

  // Identifies the policy. It is used to match the color of the  destination prefixes
  // to steer traffic into the SR Policy.
  // default = 100
  optional uint32 color = 2;

  // Specifies a single node or a set of nodes (e.g., an anycast address). It is selected
  // on the basis of the SR Policy type (AFI).
  // required = true
  string ipv6_endpoint = 3;

  message NextHopMode {
    enum Enum {
      unspecified = 0;
      local_ip = 1;
      manual = 2;
    }
  }
  // Mode for choosing the NextHop in MP REACH NLRI. Available modes are : Local IP: Automatically
  // fills the Nexthop with the Local IP of the BGP peer. For IPv6 BGP peer the Nexthop
  // Encoding capability should be enabled. Manual: Override the Nexthop with any arbitrary
  // IPv4/IPv6 address.
  // default = NextHopMode.Enum.local_ip
  optional NextHopMode.Enum next_hop_mode = 4;

  message NextHopAddressType {
    enum Enum {
      unspecified = 0;
      ipv4 = 1;
      ipv6 = 2;
    }
  }
  // Type of next hop IP address to be used when 'next_hop_mode' is set to 'manual'.
  // default = NextHopAddressType.Enum.ipv6
  optional NextHopAddressType.Enum next_hop_address_type = 5;

  // The IPv4 address of the Nexthop if the 'next_hop_mode' is 'manual' and the Nexthop
  // type 'next_hop_address_type' is IPv4. If BGP peer is of type IPv6, Nexthop Encoding
  // capability extended_next_hop_encoding should be enabled.
  // default = 0.0.0.0
  optional string next_hop_ipv4_address = 6;

  // The IPv6 address of the next hop if the Nexthop Mode 'next_hop_address_type' is 'manual'
  // and the Nexthop type 'next_hop_address_type' is IPv6.
  // default = ::0
  optional string next_hop_ipv6_address = 7;

  // Description missing in models
  optional BgpRouteAdvanced advanced = 8;

  // Description missing in models
  optional BgpAddPath add_path = 9;

  // Description missing in models
  optional BgpAsPath as_path = 10;

  // Optional community settings.
  repeated BgpCommunity communities = 11;

  // Optional Extended Community settings. The Extended Communities Attribute is a transitive
  // optional BGP attribute, with the Type Code 16. Community and Extended Communities
  // attributes are utilized to trigger routing decisions, such as acceptance, rejection,
  // preference, or redistribution. An extended community is an 8-Bytes value. It is
  // divided into two main parts. The first 2 Bytes of the community encode a type and
  // sub-type fields and the last 6 Bytes carry a unique set of data in a format defined
  // by the type and sub-type field. Extended communities provide a larger  range for
  // grouping or categorizing communities. When type is administrator_as_2octet or administrator_as_4octet,
  // the valid sub types are route target and origin. The valid value for  administrator_as_2octet
  // and administrator_as_4octet type is either two byte AS followed by four byte local
  // administrator id or four byte AS followed by two  byte local administrator id.  When
  // type is administrator_ipv4_address the valid sub types are route target and origin.
  // The valid value for  administrator_ipv4_address is a four byte IPv4 address followed
  // by a two byte local administrator id.  When type is opaque, valid sub types are color
  // and encapsulation. When sub type is color, first two bytes of the value field contain
  // flags and last four bytes  contains the value of the color. When sub type is encapsulation
  // the first four bytes of value field are reserved and last two bytes carries the tunnel
  // type from  IANA's ETHER TYPES registry e.g IPv4 (protocol type = 0x0800), IPv6 (protocol
  // type = 0x86dd), and MPLS (protocol type = 0x8847). When type is administrator_as_2octet_link_bandwidth
  // the valid sub type is extended_bandwidth. The first two bytes of the value field
  // contains the AS number and the last four bytes contains the bandwidth in IEEE floating
  // point format.  When type is evpn the valid subtype is mac_address. In the value field
  // the low-order bit of the first byte(Flags) is defined as the Sticky/static flag and
  // may be set to 1, indicating the MAC address is static and cannot move. The second
  // byte is reserved and the  last four bytes contain the sequence number which is used
  // to ensure that PEs retain the correct MAC/IP Advertisement route when multiple updates
  // occur for the same MAC address.
  repeated BgpExtCommunity extcommunities = 12;

  // List of optional tunnel TLV settings.
  repeated BgpSrteV6TunnelTlv tunnel_tlvs = 13;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  string name = 14;

  // If enabled means that this part of the configuration including any active 'children'
  // nodes will be advertised to peer.  If disabled, this means that though config is
  // present, it is not taking any part of the test but can be activated at run-time to
  // advertise just this part of the configuration to the peer.
  // default = True
  optional bool active = 15;
}

// Configuration for BGP SRTE Tunnel TLV.
message BgpSrteV6TunnelTlv {

  // Description missing in models
  optional BgpSrteRemoteEndpointSubTlv remote_endpoint_sub_tlv = 1;

  // Description missing in models
  optional BgpSrteColorSubTlv color_sub_tlv = 2;

  // Description missing in models
  optional BgpSrteBindingSubTlv binding_sub_tlv = 3;

  // Description missing in models
  optional BgpSrtePreferenceSubTlv preference_sub_tlv = 4;

  // Description missing in models
  optional BgpSrtePolicyPrioritySubTlv policy_priority_sub_tlv = 5;

  // Description missing in models
  optional BgpSrtePolicyNameSubTlv policy_name_sub_tlv = 6;

  // Description missing in models
  optional BgpSrteExplicitNullLabelPolicySubTlv explicit_null_label_policy_sub_tlv = 7;

  // Description missing in models
  repeated BgpSrteSegmentList segment_lists = 8;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  string name = 9;

  // If enabled means that this part of the configuration including any active 'children'
  // nodes will be advertised to peer.  If disabled, this means that though config is
  // present, it is not taking any part of the test but can be activated at run-time to
  // advertise just this part of the configuration to the peer.
  // default = True
  optional bool active = 10;
}

// The Graceful Restart Capability (RFC 4724) is a BGP capability that can be used by
// a BGP speaker to indicate its ability to preserve its forwarding state during BGP
// restart. The Graceful Restart (GR) capability is advertised in OPEN messages sent
// between BGP peers. After a BGP session has been established, and the initial routing
// update has been completed,  an End-of-RIB (Routing Information Base) marker is sent
// in an UPDATE message to convey information  about routing convergence.
message BgpGracefulRestart {

  // If enabled, Graceful Restart capability is advertised in BGP OPEN messages.
  // default = False
  optional bool enable_gr = 1;

  // This is the estimated duration (in seconds) it will take for the BGP session to be
  // re-established after a restart.  This can be used to speed up routing convergence
  // by its peer in case the BGP speaker does not come back after a restart.
  // default = 45
  optional uint32 restart_time = 2;

  // If enabled, the Long-lived Graceful Restart Capability, or LLGR Capability
  // will be advertised.
  // This capability MUST be advertised in conjunction with the Graceful Restart
  // capability.
  // default = False
  optional bool enable_llgr = 3;

  // Duration (in seconds) specifying how long stale information (for the AFI/SAFI)
  // may be retained. This is a three byte field and is applicable
  // only if 'enable_llgr' is set to 'true'.
  // default = 10
  optional uint32 stale_time = 4;
}

// Configuration for BGPv6 peer settings and routes.
message BgpV6Peer {

  // IPv6 address of the BGP peer for the session
  // required = true
  string peer_address = 1;

  // Description missing in models
  optional BgpV6SegmentRouting segment_routing = 2;

  // This contains the list of Ethernet Virtual Private Network (EVPN) Ethernet Segments
  // (ES) Per BGP Peer for IPv6 Address Family Identifier (AFI).
  // 
  // Each Ethernet Segment contains a list of EVPN Instances (EVIs) .
  // Each EVI contains a list of Broadcast Domains.
  // Each Broadcast Domain contains a list of MAC/IP Ranges.
  // 
  // <Ethernet Segment, EVI, Broadcast Domain> is responsible for advertising Ethernet
  // Auto-discovery Route Per EVI (Type 1).
  // 
  // <Ethernet Segment, EVI> is responsible for advertising Ethernet Auto-discovery Route
  // Per Ethernet Segment (Type 1).
  // 
  // <Ethernet Segment, EVI, Broadcast Domain, MAC/IP> is responsible for advertising
  // MAC/IP Advertisement Route (Type 2).
  // 
  // <Ethernet Segment, EVI, Broadcast Domain> is responsible for advertising Inclusive
  // Multicast Ethernet Tag Route (Type 3).
  // 
  // Ethernet Segment is responsible for advertising Ethernet Segment Route (Type 4).
  repeated BgpV6EthernetSegment evpn_ethernet_segments = 3;

  message AsType {
    enum Enum {
      unspecified = 0;
      ibgp = 1;
      ebgp = 2;
    }
  }
  // The type of BGP autonomous system. External BGP is used for BGP links between two
  // or more autonomous systems (ebgp). Internal BGP is used within a single autonomous
  // system (ibgp). BGP property defaults are aligned with this object defined as an internal
  // BGP peer. If the as_type is specified as 'ebgp' then other properties will need to
  // be specified as per an external BGP peer. Specifically, for 'ebgp',  'as_set_mode'
  // attribute in 'as_path' field  in any Route Range should be changed from default value
  // 'do_not_include_local_as' to any other value.
  // required = true
  AsType.Enum as_type = 4;

  // Autonomous System Number (AS number or ASN)
  // required = true
  uint32 as_number = 5;

  message AsNumberWidth {
    enum Enum {
      unspecified = 0;
      two = 1;
      four = 2;
    }
  }
  // The width in bytes of the as_number values. Any as_number values that exceeds the
  // width MUST result in an error.
  // default = AsNumberWidth.Enum.four
  optional AsNumberWidth.Enum as_number_width = 6;

  // Description missing in models
  optional BgpAdvanced advanced = 7;

  // Description missing in models
  optional BgpCapability capability = 8;

  // Description missing in models
  optional BgpLearnedInformationFilter learned_information_filter = 9;

  // Emulated BGPv4 route ranges.
  repeated BgpV4RouteRange v4_routes = 10;

  // Emulated BGPv6 route ranges.
  repeated BgpV6RouteRange v6_routes = 11;

  // Segment Routing Traffic Engineering (SR TE) Policies for IPv4 Address Family Identifier
  // (AFI).
  repeated BgpSrteV4Policy v4_srte_policies = 12;

  // Segment Routing Traffic Engineering (SR TE) Policies for IPv6 Address Family Identifier
  // (AFI).
  repeated BgpSrteV6Policy v6_srte_policies = 13;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  string name = 14;

  // Description missing in models
  optional BgpGracefulRestart graceful_restart = 15;
}

// Configuration for emulated BGPv6 peers and routes on a single IPv6 interface.
message BgpV6Interface {

  // The unique name of IPv6 or Loopback IPv6 interface used as the source IP for this
  // list of BGP peers.
  // 
  // x-constraint:
  // - /components/schemas/Device.Ipv6/properties/name
  // - /components/schemas/Device.Ipv6Loopback/properties/name
  // 
  // required = true
  string ipv6_name = 1;

  // This contains the list of BGPv6 peers configured on this interface.
  repeated BgpV6Peer peers = 2;
}

// Configuration for BGPv6 segment routing settings.
message BgpV6SegmentRouting {

  // TBD
  // default = False
  optional bool ingress_supports_vpn = 1;

  // TBD
  // default = False
  optional bool reduced_encapsulation = 2;

  // TBD
  // default = False
  optional bool copy_time_to_live = 3;

  // TBD
  // default = 0
  optional uint32 time_to_live = 4;

  // TBD
  // default = 0
  optional uint32 max_sids_per_srh = 5;

  // TBD
  // default = False
  optional bool auto_generate_segment_left_value = 6;

  // TBD
  // default = 0
  optional uint32 segment_left_value = 7;

  // TBD
  // default = False
  optional bool advertise_sr_te_policy = 8;
}

// Configuration for BGP Ethernet Segment ranges. Advertises following routes -
// 
// Type 4 - Ethernet Segment Route
message BgpV6EthernetSegment {

  // Designated Forwarder (DF) election configuration.
  optional BgpEthernetSegmentDfElection df_election = 1;

  // This contains the list of EVIs.
  repeated BgpV6EvpnEvis evis = 2;

  // 10-octet Ethernet Segment Identifier (ESI) Example - For multi-home scenario nonZero
  // ESI is '10000000000000000000' .
  // default = 00000000000000000000
  optional string esi = 3;

  message ActiveMode {
    enum Enum {
      unspecified = 0;
      single_active = 1;
      all_active = 2;
    }
  }
  // Single Active or All Active mode Redundancy mode selection for Multi-home.
  // default = ActiveMode.Enum.all_active
  optional ActiveMode.Enum active_mode = 4;

  // The label value to be advertised as ESI Label in ESI Label Extended Community. This
  // is included in Ethernet Auto-discovery per ES Routes advertised by a router.
  // default = 0
  optional uint32 esi_label = 5;

  // Description missing in models
  optional BgpRouteAdvanced advanced = 6;

  // Optional community settings.
  repeated BgpCommunity communities = 7;

  // Optional Extended Community settings. The Extended Communities Attribute is a transitive
  // optional BGP attribute, with the Type Code 16. Community and Extended Communities
  // attributes are utilized to trigger routing decisions, such as acceptance, rejection,
  // preference, or redistribution. An extended community is an 8-Bytes value. It is
  // divided into two main parts. The first 2 Bytes of the community encode a type and
  // sub-type fields and the last 6 Bytes carry a unique set of data in a format defined
  // by the type and sub-type field. Extended communities provide a larger  range for
  // grouping or categorizing communities. When type is administrator_as_2octet or administrator_as_4octet,
  // the valid sub types are route target and origin. The valid value for  administrator_as_2octet
  // and administrator_as_4octet type is either two byte AS followed by four byte local
  // administrator id or four byte AS followed by two  byte local administrator id.  When
  // type is administrator_ipv4_address the valid sub types are route target and origin.
  // The valid value for  administrator_ipv4_address is a four byte IPv4 address followed
  // by a two byte local administrator id.  When type is opaque, valid sub types are color
  // and encapsulation. When sub type is color, first two bytes of the value field contain
  // flags and last four bytes  contains the value of the color. When sub type is encapsulation
  // the first four bytes of value field are reserved and last two bytes carries the tunnel
  // type from  IANA's ETHER TYPES registry e.g IPv4 (protocol type = 0x0800), IPv6 (protocol
  // type = 0x86dd), and MPLS (protocol type = 0x8847). When type is administrator_as_2octet_link_bandwidth
  // the valid sub type is extended_bandwidth. The first two bytes of the value field
  // contains the AS number and the last four bytes contains the bandwidth in IEEE floating
  // point format.  When type is evpn the valid subtype is mac_address. In the value field
  // the low-order bit of the first byte(Flags) is defined as the Sticky/static flag and
  // may be set to 1, indicating the MAC address is static and cannot move. The second
  // byte is reserved and the  last four bytes contain the sequence number which is used
  // to ensure that PEs retain the correct MAC/IP Advertisement route when multiple updates
  // occur for the same MAC address.
  repeated BgpExtCommunity ext_communities = 8;

  // Optional AS PATH settings.
  optional BgpAsPath as_path = 9;
}

// This contains a list of different flavors of EVPN.
// For example EVPN over VXLAN or EVPN over MPLS etc to be configured per Ethernet segment.
// 
// Need to instantiate correct type of EVPN instance as per requirement.
message BgpV6EvpnEvis {

  message Choice {
    enum Enum {
      unspecified = 0;
      evi_vxlan = 1;
    }
  }
  // Description missing in models
  // default = Choice.Enum.evi_vxlan
  optional Choice.Enum choice = 1;

  // EVPN VXLAN instance to be configured per Ethernet Segment.
  optional BgpV6EviVxlan evi_vxlan = 2;
}

// Configuration for BGP EVPN EVI. Advertises following routes -
// 
// Type 3 - Inclusive Multicast Ethernet Tag Route
// 
// Type 1 -  Ethernet Auto-discovery Route (Per EVI)
// 
// Type 1 -  Ethernet Auto-discovery Route (Per ES)
message BgpV6EviVxlan {

  // This contains the list of Broadcast Domains to be configured per EVI.
  repeated BgpV6EviVxlanBroadcastDomain broadcast_domains = 1;

  message ReplicationType {
    enum Enum {
      unspecified = 0;
      ingress_replication = 1;
    }
  }
  // This model only supports Ingress Replication
  // default = ReplicationType.Enum.ingress_replication
  optional ReplicationType.Enum replication_type = 2;

  // Downstream assigned VNI to be carried as Part of P-Multicast Service Interface Tunnel
  // attribute (PMSI Tunnel Attribute) in Type 3 Inclusive Multicast Ethernet Tag Route.
  // default = 16
  optional uint32 pmsi_label = 3;

  // The Auto-discovery Route label (AD label) value, which gets advertised in the Ethernet
  // Auto-discovery Route per <EVI, ESI>
  // default = 0
  optional uint32 ad_label = 4;

  // Colon separated Extended Community value of 6 Bytes - AS number: Value identifying
  // an EVI.            Example - for the as_2octet 60005:100.
  optional BgpRouteDistinguisher route_distinguisher = 5;

  // List of Layer 2 Virtual Network Identifier (L2VNI) export targets associated with
  // this EVI.
  repeated BgpRouteTarget route_target_export = 6;

  // List of L2VNI import targets associated with this EVI.
  repeated BgpRouteTarget route_target_import = 7;

  // List of Layer 3 Virtual Network Identifier (L3VNI) Export Route Targets.
  repeated BgpRouteTarget l3_route_target_export = 8;

  // List of L3VNI Import Route Targets.
  repeated BgpRouteTarget l3_route_target_import = 9;

  // Description missing in models
  optional BgpRouteAdvanced advanced = 10;

  // Optional community settings.
  repeated BgpCommunity communities = 11;

  // Optional Extended Community settings. The Extended Communities Attribute is a transitive
  // optional BGP attribute, with the Type Code 16. Community and Extended Communities
  // attributes are utilized to trigger routing decisions, such as acceptance, rejection,
  // preference, or redistribution. An extended community is an 8-Bytes value. It is
  // divided into two main parts. The first 2 Bytes of the community encode a type and
  // sub-type fields and the last 6 Bytes carry a unique set of data in a format defined
  // by the type and sub-type field. Extended communities provide a larger  range for
  // grouping or categorizing communities. When type is administrator_as_2octet or administrator_as_4octet,
  // the valid sub types are route target and origin. The valid value for  administrator_as_2octet
  // and administrator_as_4octet type is either two byte AS followed by four byte local
  // administrator id or four byte AS followed by two  byte local administrator id.  When
  // type is administrator_ipv4_address the valid sub types are route target and origin.
  // The valid value for  administrator_ipv4_address is a four byte IPv4 address followed
  // by a two byte local administrator id.  When type is opaque, valid sub types are color
  // and encapsulation. When sub type is color, first two bytes of the value field contain
  // flags and last four bytes  contains the value of the color. When sub type is encapsulation
  // the first four bytes of value field are reserved and last two bytes carries the tunnel
  // type from  IANA's ETHER TYPES registry e.g IPv4 (protocol type = 0x0800), IPv6 (protocol
  // type = 0x86dd), and MPLS (protocol type = 0x8847). When type is administrator_as_2octet_link_bandwidth
  // the valid sub type is extended_bandwidth. The first two bytes of the value field
  // contains the AS number and the last four bytes contains the bandwidth in IEEE floating
  // point format.  When type is evpn the valid subtype is mac_address. In the value field
  // the low-order bit of the first byte(Flags) is defined as the Sticky/static flag and
  // may be set to 1, indicating the MAC address is static and cannot move. The second
  // byte is reserved and the  last four bytes contain the sequence number which is used
  // to ensure that PEs retain the correct MAC/IP Advertisement route when multiple updates
  // occur for the same MAC address.
  repeated BgpExtCommunity ext_communities = 12;

  // Optional AS PATH settings.
  optional BgpAsPath as_path = 13;
}

// Configuration for Broadcast Domains per EVI.
message BgpV6EviVxlanBroadcastDomain {

  // This contains the list of Customer MAC/IP Ranges to be configured per Broadcast Domain.
  // 
  // 
  // Advertises following route -
  // Type 2 - MAC/IP Advertisement Route.
  repeated BgpCMacIpRange cmac_ip_range = 1;

  // The Ethernet Tag ID of the Broadcast Domain.
  // default = 0
  optional uint32 ethernet_tag_id = 2;

  // VLAN-Aware service to be enabled or disabled.
  // default = False
  optional bool vlan_aware_service = 3;
}

// Description missing in models
message DeviceVxlan {

  // IPv4 VXLAN Tunnels
  repeated VxlanV4Tunnel v4_tunnels = 1;

  // IPv6 VXLAN Tunnels
  repeated VxlanV6Tunnel v6_tunnels = 2;
}

// Configuration and operational state parameters relating to IPv4 VXLAN tunnel end-point
// interface.
message VxlanV4Tunnel {

  // Determines the source interface.
  // 
  // x-constraint:
  // - /components/schemas/Device.Ipv4/properties/name
  // - /components/schemas/Device.Ipv4Loopback/properties/name
  // 
  // required = true
  string source_interface = 1;

  // Description missing in models
  optional VxlanV4TunnelDestinationIPMode destination_ip_mode = 2;

  // VXLAN Network Identifier (VNI) to distinguish network instances on the wire
  // required = true
  uint32 vni = 3;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  string name = 4;
}

// Configuration and operational state parameters relating to IPv6 VXLAN tunnel end-point
// interface.
message VxlanV6Tunnel {

  // Determines the source interface.
  // 
  // x-constraint:
  // - /components/schemas/Device.Ipv6/properties/name
  // - /components/schemas/Device.Ipv6Loopback/properties/name
  // 
  // required = true
  string source_interface = 1;

  // Description missing in models
  optional VxlanV6TunnelDestinationIPMode destination_ip_mode = 2;

  // VXLAN Network Identifier (VNI) to distinguish network instances on the wire
  // required = true
  uint32 vni = 3;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  string name = 4;
}

// Communication mode between the VTEPs, either unicast or multicast.
message VxlanV4TunnelDestinationIPMode {

  message Choice {
    enum Enum {
      unspecified = 0;
      unicast = 1;
      multicast = 2;
    }
  }
  // unicast or multicast
  // default = Choice.Enum.multicast
  optional Choice.Enum choice = 1;

  // Description missing in models
  optional VxlanV4TunnelDestinationIPModeUnicast unicast = 2;

  // Description missing in models
  optional VxlanV4TunnelDestinationIPModeMulticast multicast = 3;
}

// Communication mode between the VTEPs, either unicast or multicast.
message VxlanV6TunnelDestinationIPMode {

  message Choice {
    enum Enum {
      unspecified = 0;
      unicast = 1;
      multicast = 2;
    }
  }
  // unicast or multicast
  // default = Choice.Enum.multicast
  optional Choice.Enum choice = 1;

  // Description missing in models
  optional VxlanV6TunnelDestinationIPModeUnicast unicast = 2;

  // Description missing in models
  optional VxlanV6TunnelDestinationIPModeMulticast multicast = 3;
}

// Description missing in models
message VxlanV4TunnelDestinationIPModeUnicast {

  // List of VTEPs for member VNI(VXLAN Network Identifier)
  repeated VxlanV4TunnelDestinationIPModeUnicastVtep vteps = 1;
}

// Description missing in models
message VxlanV6TunnelDestinationIPModeUnicast {

  // List of VTEPs for member VNI(VXLAN Network Identifier)
  repeated VxlanV6TunnelDestinationIPModeUnicastVtep vteps = 1;
}

// Each VTEP maintains an ARP suppression cache table for known IP hosts and their associated
// MAC addresses in the VNI segment.  When an end host in the VNI sends an ARP request
// for another end-host IP address,  its local VTEP intercepts the ARP request and checks
// for the ARP-resolved IP address in its ARP suppression cache table.  If it finds
// a match, the local VTEP sends an ARP response on behalf of the remote end host.
message VxlanTunnelDestinationIPModeUnicastArpSuppressionCache {

  // Remote VM MAC address bound to Remote VM IPv4 address
  optional string remote_vm_mac = 1;

  // Remote VM IPv4 address
  optional string remote_vm_ipv4 = 2;
}

// VTEP (VXLAN Tunnel End Point (VTEP)) parameters
message VxlanV4TunnelDestinationIPModeUnicastVtep {

  // Remote VXLAN Tunnel End Point address
  optional string remote_vtep_address = 1;

  // Each VTEP maintains an ARP suppression cache table for known IP hosts and their associated
  // MAC addresses in the VNI segment.  When an end host in the VNI sends an ARP request
  // for another end-host IP address,  its local VTEP intercepts the ARP request and checks
  // for the ARP-resolved IP address in its ARP suppression cache table.  If it finds
  // a match, the local VTEP sends an ARP response on behalf of the remote end host.
  repeated VxlanTunnelDestinationIPModeUnicastArpSuppressionCache arp_suppression_cache = 2;
}

// VTEP (VXLAN Tunnel End Point (VTEP)) parameters
message VxlanV6TunnelDestinationIPModeUnicastVtep {

  // Remote VXLAN Tunnel End Point address
  optional string remote_vtep_address = 1;

  // Each VTEP maintains an ARP suppression cache table for known IP hosts and their associated
  // MAC addresses in the VNI segment.  When an end host in the VNI sends an ARP request
  // for another end-host IP address,  its local VTEP intercepts the ARP request and checks
  // for the ARP-resolved IP address in its ARP suppression cache table.  If it finds
  // a match, the local VTEP sends an ARP response on behalf of the remote end host.
  repeated VxlanTunnelDestinationIPModeUnicastArpSuppressionCache arp_suppression_cache = 2;
}

// Multicast Group address for member VNI(VXLAN Network Identifier)
message VxlanV4TunnelDestinationIPModeMulticast {

  // IPv4 Multicast address
  optional string address = 1;
}

// Multicast Group address for member VNI(VXLAN Network Identifier)
message VxlanV6TunnelDestinationIPModeMulticast {

  // IPv6 Multicast address
  optional string address = 1;
}

// Configuration for one or more RSVP interfaces, ingress and egress LSPs. In this model,
// currently IPv4 RSVP and point-to-point LSPs are supported as per RFC3209 and related
// specifications.
message DeviceRsvp {

  // List of IPv4 RSVP connected interfaces. At least one interface should be present
  // for device connected to the DUT. For unconnected devices, this array must be empty.
  repeated RsvpIpv4Interface ipv4_interfaces = 1;

  // List of IPv4 Loopback or IPv4 connected interfaces acting as RSVP ingress and egress
  // endpoints.
  repeated RsvpLspIpv4Interface lsp_ipv4_interfaces = 2;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  optional string name = 3;
}

// Configuration for RSVP Interface.
message RsvpIpv4Interface {

  // The globally unique name of the IPv4 interface connected to the DUT. This name must
  // match the name field of the ipv4_addresses on top which this RSVP interface is configured.
  // 
  // 
  // x-constraint:
  // - /components/schemas/Device.Ipv4/properties/name
  // 
  // required = true
  string ipv4_name = 1;

  // IPv4 address of the RSVP neighbor on this interface.
  // required = true
  string neighbor_ip = 2;

  // The user-defined label space start value. The LSPs for which this router acts as
  // a egress are assigned labels from this label pool.Thelabel_space_start and label_space_end
  // together defines this label-pool.
  // default = 1000
  optional uint32 label_space_start = 3;

  // The user-defined label space end value.The last label value that can be assigned
  // to the LSPs for which this router acts as egress.
  // default = 100000
  optional uint32 label_space_end = 4;

  // Enables sending of Refresh Reduction as described in RFC2961.
  // default = False
  optional bool enable_refresh_reduction = 5;

  // The number of seconds between transmissions of successive Summary Refreshes. There
  // is no specification specified maximum value. For clarity, setting the maximum to
  // 1 hour.
  // default = 30
  optional uint32 summary_refresh_interval = 6;

  // Enables aggregration of different RSVP messages within a single PDU.
  // default = False
  optional bool send_bundle = 7;

  // The number of milliseconds to wait after which RSVP will bundle different RSVP messages
  // and transmit Bundle messages.
  // default = 50
  optional uint32 bundle_threshold = 8;

  // Enables sending of Hello Messages as per RFC3209.
  // default = False
  optional bool enable_hello = 9;

  // If enable_hello is set to 'true', this specifies the minimum hello interval in seconds
  // at which successive Hello Messages  are sent as per RFC3209. There is no specification
  // specified maximum value. For clarity, setting the maximum to 1 hour.
  // default = 9
  optional uint32 hello_interval = 10;

  // The number of missed hellos after which the node should consider RSVP Neighbor to
  // have timed out. There is no specification specified maximum value. Setting the maximum
  // allowed value to 10.
  // default = 3
  optional uint32 timeout_multiplier = 11;
}

// Configuration for RSVP LSP IPv4 Interface.
message RsvpLspIpv4Interface {

  // The globally unique name of the IPv4 or Loopback IPv4 interface acting as the RSVP
  // ingress and egress endpoint for  the LSPs configured on this interface. This must
  // match the name field of either ipv4_addresses or ipv4_loopbacks  on which this LSP
  // interface is configured.
  // 
  // x-constraint:
  // - /components/schemas/Device.Ipv4/properties/name
  // - /components/schemas/Device.Ipv4Loopback/properties/name
  // 
  // required = true
  string ipv4_name = 1;

  // Contains properties of Tail(Egress) LSPs.
  optional RsvpLspIpv4InterfaceP2PEgressIpv4Lsp p2p_egress_ipv4_lsps = 2;

  // Array of point-to-point RSVP-TE P2P LSPs originating from this interface.
  repeated RsvpLspIpv4InterfaceP2PIngressIpv4Lsp p2p_ingress_ipv4_lsps = 3;
}

// Configuration for RSVP Egress Point-to-Point(P2P) IPv4 LSPs.
message RsvpLspIpv4InterfaceP2PEgressIpv4Lsp {

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  string name = 1;

  // The time in seconds between successive transmissions of RESV Refreshes. The actual
  // refresh interval is jittered by upto 50%. There is no specification specified maximum
  // value. For clarity, setting the maximum to 1 hour.
  // default = 30
  optional uint32 refresh_interval = 2;

  // The number of missed PATH refreshes after which a recieving node should consider
  // the LSP state to have timed out. There is no specification specified maximum value.
  // Setting the maximum allowed value to 10.
  // default = 3
  optional uint32 timeout_multiplier = 3;

  message ReservationStyle {
    enum Enum {
      unspecified = 0;
      shared_explicit = 1;
      fixed_filter = 2;
      auto = 3;
    }
  }
  // It determines how RSVP-TE enabled network devices set up reservations along the path
  // between an end-to-end  QOS-enabled connection. If 'auto' is enabled, the style is
  // chosen based on whether the incoming Path has 'SE Desired' flag set. Otherwise, the
  // style is chosen based on the value selected for this attribute.
  // default = ReservationStyle.Enum.shared_explicit
  optional ReservationStyle.Enum reservation_style = 4;

  // If enabled, a specific fixed label will be advertised by the egress or tail end for
  // all Path messages received by this egress.  This can be leveraged to advertise Explicit
  // or Implicit null labels.
  // default = False
  optional bool enable_fixed_label = 5;

  // The fixed label value as advertised by egress in RESV message. Applicable only if
  // 'fixed_label' is set to 'true'. Special values are '0 - IPv4 Explicit NULL', '2 -
  // IPv6 Explicit NULL' and '3 - Implicit NULL'.   Outside of this, labels are expected
  // to have a minimum value of 16.
  // default = 0
  optional uint32 fixed_label_value = 6;
}

// Configuration for an RSVP Ingress point-to-point LSP.
message RsvpLspIpv4InterfaceP2PIngressIpv4Lsp {

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  string name = 1;

  // IPv4 address of the remote endpoint of the LSP.
  // required = true
  string remote_address = 2;

  // The Tunnel ID of the RSVP LSP. Carried in the SESSION object in Path Messages.
  // default = 1
  optional uint32 tunnel_id = 3;

  // The LSP ID of the RSVP LSP. Carried in the SENDER_TEMPLATE object in Path Messages.
  // default = 1
  optional uint32 lsp_id = 4;

  // The time in seconds between successive transmissions of PATH Refreshes.  The actual
  // refresh interval is jittered by upto 50%. There is no specification specified maximum
  // value. For clarity, setting the maximum to 1 hour.
  // default = 30
  optional uint32 refresh_interval = 5;

  // The number of missed RESV refreshes after which a recieving node should consider
  // the LSP state to have timed out. There is no specification specified maximum value.
  // Setting the maximum allowed value to 10.
  // default = 3
  optional uint32 timeout_multiplier = 6;

  // The LSP id that will be used when creating a Make-Before-Break LSP when the active
  // LSP is using lsp_id. If the active LSP on which Make-Before-Break is being done is
  // using the backup_lsp_id, the new LSP created will toggle to  use the lsp_id instead.
  // default = 2
  optional uint32 backup_lsp_id = 7;

  // The amount of delay in milliseconds that an implementation should wait for before
  // switching traffic to the new LSP created after  a Make-Before-Break is done on an
  // LSP. The default value is 0 which means to switch immediately. An implementation
  // should support a minimum delay value of at least 50ms . There is no specification
  // specified maximum value. Setting maximum allowed value to 1 minute.  If a delay value
  // is supplied which is lesser than the minimum delay value supported, a warning should
  // be provided indicating that the minimum value of LSP switchover delay is automatically
  // increased to the supported minimum value. This warning should be included in the
  // list of warnings in the 'Response.Warning' attribute sent in the SetConfig 'Success'
  // Response.
  // default = 0
  optional uint32 lsp_switchover_delay = 8;

  // This contains the values of the fields to be included in the SESSION_ATTRIBUTE object
  // in the Path Message sent for the LSP.
  optional RsvpSessionAttribute session_attribute = 9;

  // This contains the values of the fields to be included in the TSPEC object in the
  // Path Message sent for the LSP.
  optional RsvpTspec tspec = 10;

  // This contains the values of the fields to be included in the FAST_REROUTE object
  // in the Path Message sent for the LSP.
  // This is an optional object . If this attribute is not included , the FAST_REROUTE
  // object will not be included.
  optional RsvpFastReroute fast_reroute = 11;

  // This contains the values of the fields to be included in the ERO object in the Path
  // Message sent for the LSP.
  // This is an optional object . If this attribute is not included , the ERO object will
  // not be included.
  optional RsvpEro ero = 12;
}

// Configuration for RSVP-TE SESSION_ATTRIBUTE object included in Path Messages as defined
// in RFC3209. The bandwidth_protection_desired and node_protection_desired flags are
// defined in RFC4090 (Fast Reroute).
message RsvpSessionAttribute {

  // If this is enabled, an auto-generated Session Name is included in the SESSION_ATTRIBUTE
  // object in the Path Message for this LSP.
  // default = True
  optional bool auto_generate_session_name = 1;

  // If auto_generate_session_name is set to 'false', then the value of this field is
  // used to fill the Session Name field of the SESSION_ATTRIBUTE object in the Path Message
  // for this LSP. It is suggested to include the Local IP, Remote IP, Tunnel ID and LSP
  // ID in the auto-generated Session Name to ensure uniqueness of the name in the test.
  // The maximum length of session name is 254 bytes.
  optional string session_name = 2;

  // Specifies the value of the Setup Priority field. This controls whether the LSP should
  // pre-empt existing  LSP setup with certain Holding Priority if resource limitation
  // is encountered when setting up the LSP. (e.g. bandwidth availability). The value
  // 0 is the highest priority while 7 is the lowest.
  // default = 7
  optional uint32 setup_priority = 3;

  // Specifies the value of the Holding Priority field. This controls whether a new LSP
  // being created with certain Setup Priority should pre-empt this LSP if resource limitation
  // is encountered when setting up the LSP. (e.g. bandwidth availability). The value
  // 0 is the highest priority while 7 is the lowest.
  // default = 7
  optional uint32 holding_priority = 4;

  // This flag permits transit routers to use a local repair mechanism which may result
  // in violation of the explicit route object.  When a fault is detected on an adjacent
  // downstream link or node, a transit router can reroute traffic for fast service restoration.
  // default = False
  optional bool local_protection_desired = 5;

  // This flag indicates that label information should be included when doing a route
  // record.
  // default = False
  optional bool label_recording_desired = 6;

  // This flag indicates that the tunnel ingress node may choose to reroute this tunnel
  // without tearing it down. A tunnel egress node SHOULD use the Shared Explicit(SE)
  // Style when responding with a Resv message.
  // default = False
  optional bool se_style_desired = 7;

  // This flag in the SESSION_ATTRIBUTE object in the Path Message indicates to the PLRs
  // along the protected LSP path that a  backup path with a bandwidth guarantee is desired.
  // This bandwidth has to be guaranteed for the protected LSP, if no FAST_REROUTE object
  // is included in the PATH message. If a FAST_REROUTE object is present in the Path
  // message, then the bandwidth specified therein is to be guaranteed.
  // default = False
  optional bool bandwidth_protection_desired = 8;

  // This flag in the SESSION_ATTRIBUTE object in the Path Message indicates to the PLRs
  // along a protected LSP path that it is desired to have a backup path that bypasses
  // at least the next node of the protected LSP.
  // default = False
  optional bool node_protection_desired = 9;

  // This is an optional object. If included the extended SESSION_ATTRIBUTE object is
  // sent in the Path message containing
  // the additional fields included in this object. This contains a set of three bitmaps
  // using which further constraints can be
  // set on the path calculated for the LSP based on the Admin Group settings in the IGP
  // (e.g ISIS or OSPF interface).
  optional RsvpResourceAffinities resource_affinities = 10;
}

// This is an optional object. If included, the extended SESSION_ATTRIBUTE object is
// sent in the Path message containing
// the additional fields included in this object. This contains a set of three bitmaps
// using which further constraints can be
// set on the path calculated for the LSP based on the Admin Group settings in the IGP
// (e.g ISIS or OSPF interface).
message RsvpResourceAffinities {

  // A 32-bit vector representing a set of attribute filters associated with a tunnel
  // any of which renders a link unacceptable.  A null set (all bits set to zero) doesn't
  // render the link unacceptable.  The most significant byte in the hex-string is the
  // farthest  to the left in the byte sequence.  Leading zero bytes in the configured
  // value may be omitted for brevity.
  // default = 0
  optional string exclude_any = 1;

  // A 32-bit vector representing a set of attribute filters associated with a tunnel
  // any of which renders a link acceptable. A null set (all bits set to zero) automatically
  // passes. The most significant byte in the hex-string is the farthest  to the left
  // in the byte sequence.  Leading zero bytes in the configured value may be omitted
  // for brevity.
  // default = 0
  optional string include_any = 2;

  // A 32-bit vector representing a set of attribute filters associated with a tunnel
  // all of which must be present for a link to be acceptable. A null set (all bits set
  // to zero) automatically passes. The most significant byte in the hex-string is the
  // farthest  to the left in the byte sequence.  Leading zero bytes in the configured
  // value may be omitted for brevity.
  // default = 0
  optional string include_all = 3;
}

// Configuration for RSVP-TE TSPEC object included in Path Messages. The usage of these
// parameters is defined in RFC2215.
message RsvpTspec {

  // The rate of the traffic to be carried in this LSP in bytes per second. This is part
  // of the Token Bucket specification defined for a traffic flow defined in RFC2215.
  // default = 0
  optional float token_bucket_rate = 1;

  // The depth of the token bucket in bytes used to specify the Token Bucket characteristics
  // of the traffic to be carried in the LSP. This is part of the Token Bucket specification
  // defined for a traffic flow defined in RFC2215.
  // default = 0
  optional float token_bucket_size = 2;

  // The peak data rate of the traffic in bytes per second used to specify the Token Bucket
  // characteristics of the traffic  to be carried in the LSP. This is part of the Token
  // Bucket specification defined for a traffic flow defined in RFC2215.
  // default = 0
  optional float peak_data_rate = 3;

  // Specifies the minium length of packet frames that will be policed.
  // default = 0
  optional uint32 minimum_policed_unit = 4;

  // Specifies the maximum length of packet frames that will be policed.
  // default = 0
  optional uint32 maximum_policed_unit = 5;
}

// Configuration for the optional RSVP-TE FAST_REROUTE object included in Path Messages
// as defined in RFC4090.
message RsvpFastReroute {

  // Specifies the value of the Setup Priority field. This controls whether the backup
  // LSP should pre-empt existing LSP that is setup with certain Holding Priority. While
  // setting up a backup LSP, preemption of existing LSP can happen  if resource limitation
  // is encountered (e.g bandwidth availability).
  // default = 7
  optional uint32 setup_priority = 1;

  // Specifies the value of the Holding Priority field. This controls whether a new LSP
  // being created with certain Setup Priority should pre-empt this LSP set up with this
  // Holding Priority. While setting up a new LSP, preemption of existing LSP can happen
  // if resource limitation is encountered (e.g bandwidth availability).
  // default = 7
  optional uint32 holding_priority = 2;

  // Specifies the value of the Hop Limit field. This controls the maximum number of hops
  // the LSP should traverse to reach the  LSP end-point.
  // default = 3
  optional uint32 hop_limit = 3;

  // Specifies the value of the Bandwidth field as a 32-bit IEEE floating point integer,
  // in bytes per second, as desired for the LSP.
  // default = 0
  optional float bandwidth = 4;

  // A 32-bit vector representing a set of attribute filters associated with a tunnel
  // any of which renders a link unacceptable. A null set (all bits set to zero) doesn't
  // render the link unacceptable. The most significant byte in the hex-string is the
  // farthest  to the left in the byte sequence.  Leading zero bytes in the configured
  // value may be omitted for brevity.
  // default = 0
  optional string exclude_any = 5;

  // A 32-bit vector representing a set of attribute filters associated with a tunnel
  // any of which renders a link acceptable. A null set (all bits set to zero) automatically
  // passes. The most significant byte in the hex-string is the farthest  to the left
  // in the byte sequence.  Leading zero bytes in the configured value may be omitted
  // for brevity.
  // default = 0
  optional string include_any = 6;

  // A 32-bit vector representing a set of attribute filters associated with a tunnel
  // all of which must be present for a link to be acceptable. A null set (all bits set
  // to zero) automatically passes. The most significant byte in the hex-string is the
  // farthest  to the left in the byte sequence.  Leading zero bytes in the configured
  // value may be omitted for brevity.
  // default = 0
  optional string include_all = 7;

  // Requests protection via the one-to-one backup method.
  // default = False
  optional bool one_to_one_backup_desired = 8;

  // Requests protection via the facility backup method.
  // default = False
  optional bool facility_backup_desired = 9;
}

// Configuration for the optional RSVP-TE explicit route object(ERO) object included
// in Path Messages.
message RsvpEro {

  message PrependNeighborIp {
    enum Enum {
      unspecified = 0;
      dont_prepend = 1;
      prepend_loose = 2;
      prepend_strict = 3;
    }
  }
  // Determines whether the IP address of the RSVP neighbor should be added as an ERO
  // sub-object. If it is to be included, it can be included as a Loose hop or as a Strict
  // hop.
  // default = PrependNeighborIp.Enum.prepend_loose
  optional PrependNeighborIp.Enum prepend_neighbor_ip = 1;

  // If prepend_egress_ip is set to one of 'prepend_loose' or 'prepend_strict', then set
  // this value as the prefix length of the ERO sub-object containing egress IP address.
  // 
  // default = 32
  optional uint32 prefix_length = 2;

  // Array of sub-objects to be included in the ERO. These sub-objects contain the intermediate
  // hops to be traversed by the LSP while being forwarded towards the egress endpoint.
  // These sub-objects are included after the optional sub-object containing IP address
  // of egress endpoint of the LSP (when present).
  repeated RsvpEroSubobject subobjects = 3;
}

// Configuration for the ERO sub-object.
message RsvpEroSubobject {

  message Type {
    enum Enum {
      unspecified = 0;
      ipv4 = 1;
      as_number = 2;
    }
  }
  // The type of the ERO sub-object, one of IPv4 Address or AS Number.
  // default = Type.Enum.ipv4
  optional Type.Enum type = 1;

  // IPv4 address that this LSP should traverse through. This field is applicable only
  // if the value of 'type' is set to 'ipv4'.
  // default = 0.0.0.0
  optional string ipv4_address = 2;

  // Prefix length for the IPv4 address in the ERO sub-object. This field is applicable
  // only if the value of 'type' is set to 'ipv4'.
  // default = 32
  optional uint32 prefix_length = 3;

  // Autonomous System number to be set in the ERO sub-object that this LSP should traverse
  // through. This field is applicable only if the value of 'type' is set to 'as_number'.
  // Note that as per RFC3209, 4-byte AS encoding is not supported.
  // default = 0
  optional uint32 as_number = 4;

  message HopType {
    enum Enum {
      unspecified = 0;
      strict = 1;
      loose = 2;
    }
  }
  // The hop type of the ERO sub-object, one of Strict or Loose.
  // default = HopType.Enum.loose
  optional HopType.Enum hop_type = 5;
}

// A high level data plane traffic flow.
message Flow {

  // The transmit and receive endpoints.
  // required = true
  FlowTxRx tx_rx = 1;

  // The list of protocol headers defining the shape of all
  // intended packets in corresponding flow as it is transmitted
  // by traffic-generator port.
  // 
  // The order of protocol headers assigned to the list is the
  // order they will appear on the wire.
  // 
  // In the case of an empty list the keyword/value of minItems: 1
  // indicates that an implementation MUST provide at least one
  // Flow.Header object.
  // 
  // The default value for the Flow.Header choice property is ethernet
  // which will result in an implementation by default providing at least
  // one ethernet packet header.
  repeated FlowHeader packet = 2;

  // Under Review: The packet header schema for egress tracking currently exposes unwanted
  // fields. The query structure for tagged metrics inside flows metrics requires documenting
  // expected response format.
  // 
  // The list of protocol headers defining the shape of all
  // intended packets in corresponding flow as it is received
  // by traffic-generator port.
  // 
  // For all protocol headers, only the `metric_tags` property is configurable.
  repeated FlowHeader egress_packet = 9;

  // The size of the packets.
  optional FlowSize size = 3;

  // The transmit rate of the packets.
  optional FlowRate rate = 4;

  // The transmit duration of the packets.
  optional FlowDuration duration = 5;

  // Flow metrics.
  optional FlowMetrics metrics = 6;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  string name = 7;
}

// A container for different types of transmit and receive
// endpoint containers.
message FlowTxRx {

  message Choice {
    enum Enum {
      unspecified = 0;
      port = 1;
      device = 2;
    }
  }
  // The type of transmit and receive container used by the flow.
  // default = Choice.Enum.port
  optional Choice.Enum choice = 1;

  // Description missing in models
  optional FlowPort port = 2;

  // Description missing in models
  optional FlowRouter device = 3;
}

// A container for a transmit port and 0..n intended receive ports.
// When assigning this container to a flow the flows's
// packet headers will not be populated with any address resolution
// information such as source and/or destination addresses.
// For example Flow.Ethernet dst mac address values will be defaulted to 0.
// For full control over the Flow.properties.packet header contents use this
// container.
message FlowPort {

  // The unique name of a port that is the transmit port.
  // 
  // x-constraint:
  // - /components/schemas/Port/properties/name
  // - /components/schemas/Lag/properties/name
  // 
  // required = true
  string tx_name = 1;

  // Deprecated: This property is deprecated in favor of property rx_names
  // 
  // The unique name of a port that is the intended receive port.
  // 
  // x-constraint:
  // - /components/schemas/Port/properties/name
  // - /components/schemas/Lag/properties/name
  // 
  optional string rx_name = 2;

  // Unique name of ports or lags that are intended receive endpoints.
  // 
  // x-constraint:
  // - /components/schemas/Port/properties/name
  // - /components/schemas/Lag/properties/name
  // 
  repeated string rx_names = 3;
}

// A container for declaring a map of 1..n transmit devices to 1..n receive devices.
// This allows for a single flow to have  different tx to rx device flows such as a
// single one to one map or a  many to many map.
message FlowRouter {

  message Mode {
    enum Enum {
      unspecified = 0;
      mesh = 1;
      one_to_one = 2;
    }
  }
  // Determines the intent of creating traffic sub-flow(s) between the device
  // endpoints, from the entities of <b>tx_names</b> to the entities of <b>rx_names</b>
  // 
  // to derive how <b>auto</b> packet fields can be populated with
  // the actual value(s) by the implementation.
  // 
  // The <b>one_to_one</b> mode creates traffic sub-flow(s) between each device endpoint
  // pair in
  // tx_names to rx_names by index.
  // The length of tx_names and rx_names MUST be the same.
  // The same device name can be repeated multiple times in tx_names or rx_names, in any
  // order to create desired meshing between device(s).
  // For 2 values in tx_names and 2 values in rx_names, 2 device endpoint pairs would
  // be generated (each pair representing a traffic sub-flow).
  // 
  // The <b>mesh</b> mode creates traffic sub-flow(s) between each value in tx_names to
  // every value in rx_names, forming the device endpoint pair(s).
  // For 2 values in tx_names and 3 values in rx_names, generated device endpoint pairs
  // would be 2x3=6.
  // 
  // A generated device endpoint pair with same device endpoint name for both transmit
  // & receive device endpoint MUST raise an error.
  // 
  // Packet fields of type <b>auto</b> would be populated with one value for each device
  // endpoint pair (representing the traffic sub-flow).
  // The value would be determined considering transmit & receive device of the sub-flow.
  // And the sequence of the populated value(s)
  // would be in the order of generated device endpoint pair(s).
  // If 2 device endpoint pairs are generated (based on mode, tx_names and rx_names),
  // say (d1 to d3) and (d2 to d3), and ethernet.dst is set as <b>auto</b>, then
  // the auto field would be <b>replaced</b> by the implementation with a sequence of
  // 2 values, [v1,v2] where
  // v1 is determined using context (d1,d3) and v2 using context (d2,d3).
  // The final outcome is that packets generated on the wire will contain the values v1,v2,v1,...
  // for ethernet.dst field. Any non-auto packet fields
  // should be configured accordingly. For example, non-auto packet field ethernet.src
  // can be configured with values [u1, u2], where
  // u1 & u2 are source MAC of the connected interface of device d1 and d2 respectively.
  // Then packets on the wire will contain correct value pairs
  // (u1,v1),(u2,v2),(u1,v1),... for (ethernet.src,ethernet.dst) fields.
  // default = Mode.Enum.mesh
  optional Mode.Enum mode = 1;

  // TBD
  // 
  // x-constraint:
  // - /components/schemas/Device.Ethernet/properties/name
  // - /components/schemas/Device.Ipv4/properties/name
  // - /components/schemas/Device.Ipv6/properties/name
  // - /components/schemas/Bgp.V4RouteRange/properties/name
  // - /components/schemas/Bgp.V6RouteRange/properties/name
  // - /components/schemas/Bgp.CMacIpRange/properties/name
  // - /components/schemas/Rsvp.LspIpv4Interface.P2PIngressIpv4Lsp/properties/name
  // - /components/schemas/Isis.V4RouteRange/properties/name
  // - /components/schemas/Isis.V6RouteRange/properties/name
  // 
  repeated string tx_names = 2;

  // TBD
  // 
  // x-constraint:
  // - /components/schemas/Device.Ethernet/properties/name
  // - /components/schemas/Device.Ipv4/properties/name
  // - /components/schemas/Device.Ipv6/properties/name
  // - /components/schemas/Bgp.V4RouteRange/properties/name
  // - /components/schemas/Bgp.V6RouteRange/properties/name
  // - /components/schemas/Bgp.CMacIpRange/properties/name
  // - /components/schemas/Rsvp.LspIpv4Interface.P2PEgressIpv4Lsp/properties/name
  // - /components/schemas/Isis.V4RouteRange/properties/name
  // - /components/schemas/Isis.V6RouteRange/properties/name
  // 
  repeated string rx_names = 3;
}

// Configuration for all traffic packet headers
message FlowHeader {

  message Choice {
    enum Enum {
      unspecified = 0;
      custom = 1;
      ethernet = 2;
      vlan = 3;
      vxlan = 4;
      ipv4 = 5;
      ipv6 = 6;
      pfcpause = 7;
      ethernetpause = 8;
      tcp = 9;
      udp = 10;
      gre = 11;
      gtpv1 = 12;
      gtpv2 = 13;
      arp = 14;
      icmp = 15;
      icmpv6 = 16;
      ppp = 17;
      igmpv1 = 18;
      mpls = 19;
    }
  }
  // The available types of flow headers. If one is not provided the
  // default ethernet packet header MUST be provided.
  // default = Choice.Enum.ethernet
  optional Choice.Enum choice = 1;

  // Description missing in models
  optional FlowCustom custom = 2;

  // Description missing in models
  optional FlowEthernet ethernet = 3;

  // Description missing in models
  optional FlowVlan vlan = 4;

  // Description missing in models
  optional FlowVxlan vxlan = 5;

  // Description missing in models
  optional FlowIpv4 ipv4 = 6;

  // Description missing in models
  optional FlowIpv6 ipv6 = 7;

  // Description missing in models
  optional FlowPfcPause pfcpause = 8;

  // Description missing in models
  optional FlowEthernetPause ethernetpause = 9;

  // Description missing in models
  optional FlowTcp tcp = 10;

  // Description missing in models
  optional FlowUdp udp = 11;

  // Description missing in models
  optional FlowGre gre = 12;

  // Description missing in models
  optional FlowGtpv1 gtpv1 = 13;

  // Description missing in models
  optional FlowGtpv2 gtpv2 = 14;

  // Description missing in models
  optional FlowArp arp = 15;

  // Description missing in models
  optional FlowIcmp icmp = 16;

  // Description missing in models
  optional FlowIcmpv6 icmpv6 = 17;

  // Description missing in models
  optional FlowPpp ppp = 18;

  // Description missing in models
  optional FlowIgmpv1 igmpv1 = 19;

  // Description missing in models
  optional FlowMpls mpls = 20;
}

// Custom packet header
message FlowCustom {

  // A custom packet header defined as a string of hex bytes. The string MUST contain
  // sequence of valid hex bytes. Spaces or colons can be part of the bytes but will be
  // discarded. This packet header can be used in multiple places in the packet.
  // required = true
  string bytes = 1;

  // One or more metric tags can be used to enable tracking portion of or all bits
  // in a corresponding header field for metrics per each applicable value.
  // These would appear as tagged metrics in corresponding flow metrics.
  repeated FlowCustomMetricTag metric_tags = 2;
}

// Metric Tag can be used to enable tracking portion of or all bits
// in a corresponding header field for metrics per each applicable value.
// These would appear as tagged metrics in corresponding flow metrics.
message FlowCustomMetricTag {

  // Name used to identify the metrics associated with the values applicable
  // for configured offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset
  // of corresponding header field
  // default = 1
  optional uint32 length = 3;
}

// Ethernet packet header
message FlowEthernet {

  // Description missing in models
  optional PatternFlowEthernetDst dst = 1;

  // Description missing in models
  optional PatternFlowEthernetSrc src = 2;

  // Description missing in models
  optional PatternFlowEthernetEtherType ether_type = 3;

  // Description missing in models
  optional PatternFlowEthernetPfcQueue pfc_queue = 4;
}

// VLAN packet header
message FlowVlan {

  // Description missing in models
  optional PatternFlowVlanPriority priority = 1;

  // Description missing in models
  optional PatternFlowVlanCfi cfi = 2;

  // Description missing in models
  optional PatternFlowVlanId id = 3;

  // Description missing in models
  optional PatternFlowVlanTpid tpid = 4;
}

// VXLAN packet header
message FlowVxlan {

  // Description missing in models
  optional PatternFlowVxlanFlags flags = 1;

  // Description missing in models
  optional PatternFlowVxlanReserved0 reserved0 = 2;

  // Description missing in models
  optional PatternFlowVxlanVni vni = 3;

  // Description missing in models
  optional PatternFlowVxlanReserved1 reserved1 = 4;
}

// IPv4 packet header
message FlowIpv4 {

  // Description missing in models
  optional PatternFlowIpv4Version version = 1;

  // Description missing in models
  optional PatternFlowIpv4HeaderLength header_length = 2;

  // Description missing in models
  optional FlowIpv4Priority priority = 3;

  // Description missing in models
  optional PatternFlowIpv4TotalLength total_length = 4;

  // Description missing in models
  optional PatternFlowIpv4Identification identification = 5;

  // Description missing in models
  optional PatternFlowIpv4Reserved reserved = 6;

  // Description missing in models
  optional PatternFlowIpv4DontFragment dont_fragment = 7;

  // Description missing in models
  optional PatternFlowIpv4MoreFragments more_fragments = 8;

  // Description missing in models
  optional PatternFlowIpv4FragmentOffset fragment_offset = 9;

  // Description missing in models
  optional PatternFlowIpv4TimeToLive time_to_live = 10;

  // Description missing in models
  optional PatternFlowIpv4Protocol protocol = 11;

  // Description missing in models
  optional PatternFlowIpv4HeaderChecksum header_checksum = 12;

  // Description missing in models
  optional PatternFlowIpv4Src src = 13;

  // Description missing in models
  optional PatternFlowIpv4Dst dst = 14;
}

// A container for ipv4 raw, tos, dscp ip priorities.
message FlowIpv4Priority {

  message Choice {
    enum Enum {
      unspecified = 0;
      raw = 1;
      tos = 2;
      dscp = 3;
    }
  }
  // Description missing in models
  // default = Choice.Enum.dscp
  optional Choice.Enum choice = 1;

  // Description missing in models
  optional PatternFlowIpv4PriorityRaw raw = 2;

  // Description missing in models
  optional FlowIpv4Tos tos = 3;

  // Description missing in models
  optional FlowIpv4Dscp dscp = 4;
}

// Differentiated services code point (DSCP) packet field.
message FlowIpv4Dscp {

  // Description missing in models
  optional PatternFlowIpv4DscpPhb phb = 1;

  // Description missing in models
  optional PatternFlowIpv4DscpEcn ecn = 2;
}

// Type of service (TOS) packet field.
message FlowIpv4Tos {

  // Description missing in models
  optional PatternFlowIpv4TosPrecedence precedence = 1;

  // Description missing in models
  optional PatternFlowIpv4TosDelay delay = 2;

  // Description missing in models
  optional PatternFlowIpv4TosThroughput throughput = 3;

  // Description missing in models
  optional PatternFlowIpv4TosReliability reliability = 4;

  // Description missing in models
  optional PatternFlowIpv4TosMonetary monetary = 5;

  // Description missing in models
  optional PatternFlowIpv4TosUnused unused = 6;
}

// IPv6 packet header
message FlowIpv6 {

  // Description missing in models
  optional PatternFlowIpv6Version version = 1;

  // Description missing in models
  optional PatternFlowIpv6TrafficClass traffic_class = 2;

  // Description missing in models
  optional PatternFlowIpv6FlowLabel flow_label = 3;

  // Description missing in models
  optional PatternFlowIpv6PayloadLength payload_length = 4;

  // Description missing in models
  optional PatternFlowIpv6NextHeader next_header = 5;

  // Description missing in models
  optional PatternFlowIpv6HopLimit hop_limit = 6;

  // Description missing in models
  optional PatternFlowIpv6Src src = 7;

  // Description missing in models
  optional PatternFlowIpv6Dst dst = 8;
}

// IEEE 802.1Qbb PFC Pause packet header.
message FlowPfcPause {

  // Description missing in models
  optional PatternFlowPfcPauseDst dst = 1;

  // Description missing in models
  optional PatternFlowPfcPauseSrc src = 2;

  // Description missing in models
  optional PatternFlowPfcPauseEtherType ether_type = 3;

  // Description missing in models
  optional PatternFlowPfcPauseControlOpCode control_op_code = 4;

  // Description missing in models
  optional PatternFlowPfcPauseClassEnableVector class_enable_vector = 5;

  // Description missing in models
  optional PatternFlowPfcPausePauseClass0 pause_class_0 = 6;

  // Description missing in models
  optional PatternFlowPfcPausePauseClass1 pause_class_1 = 7;

  // Description missing in models
  optional PatternFlowPfcPausePauseClass2 pause_class_2 = 8;

  // Description missing in models
  optional PatternFlowPfcPausePauseClass3 pause_class_3 = 9;

  // Description missing in models
  optional PatternFlowPfcPausePauseClass4 pause_class_4 = 10;

  // Description missing in models
  optional PatternFlowPfcPausePauseClass5 pause_class_5 = 11;

  // Description missing in models
  optional PatternFlowPfcPausePauseClass6 pause_class_6 = 12;

  // Description missing in models
  optional PatternFlowPfcPausePauseClass7 pause_class_7 = 13;
}

// IEEE 802.3x global ethernet pause packet header
message FlowEthernetPause {

  // Description missing in models
  optional PatternFlowEthernetPauseDst dst = 1;

  // Description missing in models
  optional PatternFlowEthernetPauseSrc src = 2;

  // Description missing in models
  optional PatternFlowEthernetPauseEtherType ether_type = 3;

  // Description missing in models
  optional PatternFlowEthernetPauseControlOpCode control_op_code = 4;

  // Description missing in models
  optional PatternFlowEthernetPauseTime time = 5;
}

// TCP packet header
message FlowTcp {

  // Description missing in models
  optional PatternFlowTcpSrcPort src_port = 1;

  // Description missing in models
  optional PatternFlowTcpDstPort dst_port = 2;

  // Description missing in models
  optional PatternFlowTcpSeqNum seq_num = 3;

  // Description missing in models
  optional PatternFlowTcpAckNum ack_num = 4;

  // Description missing in models
  optional PatternFlowTcpDataOffset data_offset = 5;

  // Description missing in models
  optional PatternFlowTcpEcnNs ecn_ns = 6;

  // Description missing in models
  optional PatternFlowTcpEcnCwr ecn_cwr = 7;

  // Description missing in models
  optional PatternFlowTcpEcnEcho ecn_echo = 8;

  // Description missing in models
  optional PatternFlowTcpCtlUrg ctl_urg = 9;

  // Description missing in models
  optional PatternFlowTcpCtlAck ctl_ack = 10;

  // Description missing in models
  optional PatternFlowTcpCtlPsh ctl_psh = 11;

  // Description missing in models
  optional PatternFlowTcpCtlRst ctl_rst = 12;

  // Description missing in models
  optional PatternFlowTcpCtlSyn ctl_syn = 13;

  // Description missing in models
  optional PatternFlowTcpCtlFin ctl_fin = 14;

  // Description missing in models
  optional PatternFlowTcpWindow window = 15;
}

// UDP packet header
message FlowUdp {

  // Description missing in models
  optional PatternFlowUdpSrcPort src_port = 1;

  // Description missing in models
  optional PatternFlowUdpDstPort dst_port = 2;

  // Description missing in models
  optional PatternFlowUdpLength length = 3;

  // Description missing in models
  optional PatternFlowUdpChecksum checksum = 4;
}

// Standard GRE packet header (RFC2784)
message FlowGre {

  // Description missing in models
  optional PatternFlowGreChecksumPresent checksum_present = 1;

  // Description missing in models
  optional PatternFlowGreReserved0 reserved0 = 2;

  // Description missing in models
  optional PatternFlowGreVersion version = 3;

  // Description missing in models
  optional PatternFlowGreProtocol protocol = 4;

  // Description missing in models
  optional PatternFlowGreChecksum checksum = 5;

  // Description missing in models
  optional PatternFlowGreReserved1 reserved1 = 6;
}

// GTPv1 packet header
message FlowGtpv1 {

  // Description missing in models
  optional PatternFlowGtpv1Version version = 1;

  // Description missing in models
  optional PatternFlowGtpv1ProtocolType protocol_type = 2;

  // Description missing in models
  optional PatternFlowGtpv1Reserved reserved = 3;

  // Description missing in models
  optional PatternFlowGtpv1EFlag e_flag = 4;

  // Description missing in models
  optional PatternFlowGtpv1SFlag s_flag = 5;

  // Description missing in models
  optional PatternFlowGtpv1PnFlag pn_flag = 6;

  // Description missing in models
  optional PatternFlowGtpv1MessageType message_type = 7;

  // Description missing in models
  optional PatternFlowGtpv1MessageLength message_length = 8;

  // Description missing in models
  optional PatternFlowGtpv1Teid teid = 9;

  // Description missing in models
  optional PatternFlowGtpv1SquenceNumber squence_number = 10;

  // Description missing in models
  optional PatternFlowGtpv1NPduNumber n_pdu_number = 11;

  // Description missing in models
  optional PatternFlowGtpv1NextExtensionHeaderType next_extension_header_type = 12;

  // A list of optional extension headers.
  repeated FlowGtpExtension extension_headers = 13;
}

// Description missing in models
message FlowGtpExtension {

  // Description missing in models
  optional PatternFlowGtpExtensionExtensionLength extension_length = 1;

  // Description missing in models
  optional PatternFlowGtpExtensionContents contents = 2;

  // Description missing in models
  optional PatternFlowGtpExtensionNextExtensionHeader next_extension_header = 3;
}

// GTPv2 packet header
message FlowGtpv2 {

  // Description missing in models
  optional PatternFlowGtpv2Version version = 1;

  // Description missing in models
  optional PatternFlowGtpv2PiggybackingFlag piggybacking_flag = 2;

  // Description missing in models
  optional PatternFlowGtpv2TeidFlag teid_flag = 3;

  // Description missing in models
  optional PatternFlowGtpv2Spare1 spare1 = 4;

  // Description missing in models
  optional PatternFlowGtpv2MessageType message_type = 5;

  // Description missing in models
  optional PatternFlowGtpv2MessageLength message_length = 6;

  // Description missing in models
  optional PatternFlowGtpv2Teid teid = 7;

  // Description missing in models
  optional PatternFlowGtpv2SequenceNumber sequence_number = 8;

  // Description missing in models
  optional PatternFlowGtpv2Spare2 spare2 = 9;
}

// ARP packet header
message FlowArp {

  // Description missing in models
  optional PatternFlowArpHardwareType hardware_type = 1;

  // Description missing in models
  optional PatternFlowArpProtocolType protocol_type = 2;

  // Description missing in models
  optional PatternFlowArpHardwareLength hardware_length = 3;

  // Description missing in models
  optional PatternFlowArpProtocolLength protocol_length = 4;

  // Description missing in models
  optional PatternFlowArpOperation operation = 5;

  // Description missing in models
  optional PatternFlowArpSenderHardwareAddr sender_hardware_addr = 6;

  // Description missing in models
  optional PatternFlowArpSenderProtocolAddr sender_protocol_addr = 7;

  // Description missing in models
  optional PatternFlowArpTargetHardwareAddr target_hardware_addr = 8;

  // Description missing in models
  optional PatternFlowArpTargetProtocolAddr target_protocol_addr = 9;
}

// ICMP packet header
message FlowIcmp {

  message Choice {
    enum Enum {
      unspecified = 0;
      echo = 1;
    }
  }
  // Description missing in models
  // default = Choice.Enum.echo
  optional Choice.Enum choice = 1;

  // Description missing in models
  optional FlowIcmpEcho echo = 2;
}

// Packet Header for ICMP echo request
message FlowIcmpEcho {

  // Description missing in models
  optional PatternFlowIcmpEchoType type = 1;

  // Description missing in models
  optional PatternFlowIcmpEchoCode code = 2;

  // Description missing in models
  optional PatternFlowIcmpEchoChecksum checksum = 3;

  // Description missing in models
  optional PatternFlowIcmpEchoIdentifier identifier = 4;

  // Description missing in models
  optional PatternFlowIcmpEchoSequenceNumber sequence_number = 5;
}

// ICMPv6 packet header
message FlowIcmpv6 {

  message Choice {
    enum Enum {
      unspecified = 0;
      echo = 1;
    }
  }
  // Description missing in models
  // default = Choice.Enum.echo
  optional Choice.Enum choice = 1;

  // Description missing in models
  optional FlowIcmpv6Echo echo = 2;
}

// Packet Header for ICMPv6 Echo
message FlowIcmpv6Echo {

  // Description missing in models
  optional PatternFlowIcmpv6EchoType type = 1;

  // Description missing in models
  optional PatternFlowIcmpv6EchoCode code = 2;

  // Description missing in models
  optional PatternFlowIcmpv6EchoIdentifier identifier = 3;

  // Description missing in models
  optional PatternFlowIcmpv6EchoSequenceNumber sequence_number = 4;

  // Description missing in models
  optional PatternFlowIcmpv6EchoChecksum checksum = 5;
}

// PPP packet header
message FlowPpp {

  // Description missing in models
  optional PatternFlowPppAddress address = 1;

  // Description missing in models
  optional PatternFlowPppControl control = 2;

  // Description missing in models
  optional PatternFlowPppProtocolType protocol_type = 3;
}

// IGMPv1 packet header
message FlowIgmpv1 {

  // Description missing in models
  optional PatternFlowIgmpv1Version version = 1;

  // Description missing in models
  optional PatternFlowIgmpv1Type type = 2;

  // Description missing in models
  optional PatternFlowIgmpv1Unused unused = 3;

  // Description missing in models
  optional PatternFlowIgmpv1Checksum checksum = 4;

  // Description missing in models
  optional PatternFlowIgmpv1GroupAddress group_address = 5;
}

// MPLS packet header; When configuring multiple such headers, the count shall not exceed
// 20.
message FlowMpls {

  // Description missing in models
  optional PatternFlowMplsLabel label = 1;

  // Description missing in models
  optional PatternFlowMplsTrafficClass traffic_class = 2;

  // Description missing in models
  optional PatternFlowMplsBottomOfStack bottom_of_stack = 3;

  // Description missing in models
  optional PatternFlowMplsTimeToLive time_to_live = 4;
}

// The frame size which overrides the total length of the packet
message FlowSize {

  message Choice {
    enum Enum {
      unspecified = 0;
      fixed = 1;
      increment = 2;
      random = 3;
      weight_pairs = 4;
    }
  }
  // Description missing in models
  // default = Choice.Enum.fixed
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 64
  optional uint32 fixed = 2;

  // Description missing in models
  optional FlowSizeIncrement increment = 3;

  // Description missing in models
  optional FlowSizeRandom random = 4;

  // Description missing in models
  optional FlowSizeWeightPairs weight_pairs = 5;
}

// Frame size that increments from a starting size to
// an ending size incrementing by a step size.
message FlowSizeIncrement {

  // Starting frame size in bytes
  // default = 64
  optional uint32 start = 1;

  // Ending frame size in bytes
  // default = 1518
  optional uint32 end = 2;

  // Step frame size in bytes
  // default = 1
  optional uint32 step = 3;
}

// Random frame size from a min value to a max value.
message FlowSizeRandom {

  // Description missing in models
  // default = 64
  optional uint32 min = 1;

  // Description missing in models
  // default = 1518
  optional uint32 max = 2;
}

// Frame size distribution, defined as <size, weight> pairs (including IMIX distribution).
// Frames are randomly generated such that the proportion of each frame size out of
// the total number of frames
// are matching with the weight value of the <size, weight> pair. However, as with any
// other probability
// distribution, the sample distribution is close to theoretical value only if the size
// of the sample is reasonably large.
// When the number of frames is very low the transmitted frames may not come close to
// the ratio described in the weight.
message FlowSizeWeightPairs {

  message Choice {
    enum Enum {
      unspecified = 0;
      predefined = 1;
      custom = 2;
    }
  }
  // Description missing in models
  // default = Choice.Enum.predefined
  optional Choice.Enum choice = 1;

  message Predefined {
    enum Enum {
      unspecified = 0;
      imix = 1;
      ipsec_imix = 2;
      ipv6_imix = 3;
      standard_imix = 4;
      tcp_imix = 5;
    }
  }
  // Specify predefined frame size distribution <size, weight> pairs (including IMIX distribution).
  // 
  // The available predefined distribution pairs are:
  // - IMIX (64:7, 570:4, and 1518:1)
  // - IPSec IMIX (90:58.67, 92:2, 594:23.66 and 1418:15.67)
  // - IPv6 IMIX (60:58.67, 496:2, 594:23.66 and 1518:15.67)
  // - Standard IMIX (58:58.67, 62:2, 594:23.66 and 1518:15.67)
  // - TCP IMIX (90:58.67, 92:2, 594:23.66 and 1518:15.67)
  // default = Predefined.Enum.imix
  optional Predefined.Enum predefined = 2;

  // Description missing in models
  repeated FlowSizeWeightPairsCustom custom = 3;
}

// Custom frame size distribution <size, weight> pair.
message FlowSizeWeightPairsCustom {

  // The size of the frame (in bytes) for this weight pair.
  // default = 64
  optional uint32 size = 1;

  // Weight assigned to the corresponding frame size in this weight pair.
  // Higher weight means more packets.
  // default = 1
  optional float weight = 2;
}

// The rate of packet transmission
message FlowRate {

  message Choice {
    enum Enum {
      unspecified = 0;
      pps = 1;
      bps = 2;
      kbps = 3;
      mbps = 4;
      gbps = 5;
      percentage = 6;
    }
  }
  // The available types of flow rate.
  // default = Choice.Enum.pps
  optional Choice.Enum choice = 1;

  // Packets per second.
  // default = 1000
  optional uint64 pps = 2;

  // Bits per second.
  // default = 1000000000
  optional uint64 bps = 3;

  // Kilobits per second.
  // default = 1000000
  optional uint64 kbps = 4;

  // Megabits per second.
  // default = 1000
  optional uint64 mbps = 5;

  // Gigabits per second.
  // default = 1
  optional uint32 gbps = 6;

  // The percentage of a port location's available bandwidth.
  // default = 100
  optional float percentage = 7;
}

// A container for different transmit durations.
message FlowDuration {

  message Choice {
    enum Enum {
      unspecified = 0;
      fixed_packets = 1;
      fixed_seconds = 2;
      burst = 3;
      continuous = 4;
    }
  }
  // A choice used to determine the type of duration.
  // default = Choice.Enum.continuous
  optional Choice.Enum choice = 1;

  // Description missing in models
  optional FlowFixedPackets fixed_packets = 2;

  // Description missing in models
  optional FlowFixedSeconds fixed_seconds = 3;

  // Description missing in models
  optional FlowBurst burst = 4;

  // Description missing in models
  optional FlowContinuous continuous = 5;
}

// Transmit will be continuous and will not stop automatically.
message FlowContinuous {

  // The minimum gap between packets expressed as bytes.
  // default = 12
  optional uint32 gap = 1;

  // Description missing in models
  optional FlowDelay delay = 2;
}

// The optional container to specify the delay before starting
// transmission of packets.
message FlowDelay {

  message Choice {
    enum Enum {
      unspecified = 0;
      bytes = 1;
      nanoseconds = 2;
      microseconds = 3;
    }
  }
  // Description missing in models
  // default = Choice.Enum.bytes
  optional Choice.Enum choice = 1;

  // The delay before starting transmission of packets.
  // A value of 0 indicates no delay.
  // default = 0
  optional float bytes = 2;

  // The delay before starting transmission of packets.
  // A value of 0 indicates no delay.
  // default = 0
  optional float nanoseconds = 3;

  // The delay before starting transmission of packets.
  // A value of 0 indicates no delay.
  // default = 0
  optional float microseconds = 4;
}

// Transmit a fixed number of packets after which the flow will stop.
message FlowFixedPackets {

  // Stop transmit of the flow after this number of packets.
  // default = 1
  optional uint32 packets = 1;

  // The minimum gap between packets expressed as bytes.
  // default = 12
  optional uint32 gap = 2;

  // Description missing in models
  optional FlowDelay delay = 3;
}

// Transmit for a fixed number of seconds after which the flow will stop.
message FlowFixedSeconds {

  // Stop transmit of the flow after this number of seconds.
  // default = 1
  optional float seconds = 1;

  // The minimum gap between packets expressed as bytes.
  // default = 12
  optional uint32 gap = 2;

  // Description missing in models
  optional FlowDelay delay = 3;
}

// Transmits continuous or fixed burst of packets.
// For continuous burst of packets, it will not automatically stop.
// For fixed burst of packets, it will stop after transmitting fixed number of bursts.
// 
message FlowBurst {

  // The number of packet bursts transmitted per flow.
  // A value of 0 implies continuous burst of packets.
  // default = 0
  optional uint32 bursts = 1;

  // The number of packets transmitted per burst.
  // default = 1
  optional uint32 packets = 2;

  // The minimum gap between packets expressed as bytes.
  // default = 12
  optional uint32 gap = 3;

  // Description missing in models
  optional FlowDurationInterBurstGap inter_burst_gap = 4;
}

// The optional container for specifying a gap between bursts.
message FlowDurationInterBurstGap {

  message Choice {
    enum Enum {
      unspecified = 0;
      bytes = 1;
      nanoseconds = 2;
      microseconds = 3;
    }
  }
  // The type of inter burst gap units.
  // default = Choice.Enum.bytes
  optional Choice.Enum choice = 1;

  // The amount of time between bursts expressed in bytes.
  // A value of 0 indicates no gap between bursts.
  // default = 12
  optional double bytes = 2;

  // The amount of time between bursts expressed in nanoseconds.
  // A value of 0 indicates no gap between bursts.
  // default = 96
  optional double nanoseconds = 3;

  // The amount of time between bursts expressed in microseconds.
  // A value of 0 indicates no gap between bursts.
  // default = 0.096
  optional double microseconds = 4;
}

// The optional container for configuring flow metrics.
message FlowMetrics {

  // Enables flow metrics.
  // Enabling this option may affect the resultant packet payload due to
  // additional instrumentation data.
  // default = False
  optional bool enable = 1;

  // Enables additional flow metric loss calculation.
  // default = False
  optional bool loss = 2;

  // Rx Tx ratio.
  optional FlowRxTxRatio rx_tx_ratio = 6;

  // Enables additional flow metric first and last timestamps.
  // default = False
  optional bool timestamps = 3;

  // Latency metrics.
  optional FlowLatencyMetrics latency = 4;

  // Predefined metric tags
  optional FlowPredefinedTags predefined_metric_tags = 5;
}

// The optional container for per flow latency metric configuration.
message FlowLatencyMetrics {

  // True to enable latency metrics using timestamps.
  // 
  // Enabling this option may affect the resultant packet payload due to
  // additional instrumentation data.
  // default = False
  optional bool enable = 1;

  message Mode {
    enum Enum {
      unspecified = 0;
      store_forward = 1;
      cut_through = 2;
    }
  }
  // Select the type of latency measurement. The different types of
  // latency measurements are:
  // 
  // 
  // store_forward:
  // The time interval starting when the last bit of the frame leaves the
  // sending port and ending when the first bit of the frame is seen on
  // the receiving port (LIFO).  This is based on the RFC 1242 standard.
  // 
  // 
  // cut_through:
  // The time interval starting when the first bit of the frame leaves
  // the sending port and ending when the first bit of the frame is seen
  // on the receiving port (FIFO).  This is based on the RFC 1242
  // standard.
  // default = Mode.Enum.store_forward
  optional Mode.Enum mode = 2;
}

// List of predefined flow tracking options, outside packet fields, that can be enabled.
message FlowPredefinedTags {

  // Enables Rx port or lag level disaggregation with predefined metrics tag name set
  // as rx_name.
  // The Rx port / lag names can be found under tagged_metrics tag names in flow metrics
  // response.
  // default = False
  optional bool rx_name = 1;
}

// Rx Tx ratio is the ratio of expected number of Rx packets across all Rx ports to
// the Tx packets
// for the configured flow. It is a factor by which the Tx packet count is multiplied
// to calculate
// the sum of expected Rx packet count, across all Rx ports. This will be used to calculate
// loss
// percentage of flow at aggregate level.
message FlowRxTxRatio {

  message Choice {
    enum Enum {
      unspecified = 0;
      rx_count = 1;
      value = 2;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  optional FlowRxTxRatioRxCount rx_count = 2;

  // Should be a positive, non-zero value. The default value of 1, is when the Rx packet
  // count across
  // all ports is expected to match the Tx packet count. A custom integer value (>1) can
  // be specified for
  // loss calculation for cases when there are multiple destination addresses configured
  // within one flow,
  // but DUT is configured to replicate only to a subset of Rx ports. For cases when Tx
  // side generates two
  // packets from each source in 1:1 protection mode but only one of the two packets are
  // received by the
  // Rx port, we may need to specify a fractional value instead.
  // default = 1.0
  optional float value = 3;
}

// This is for cases where one copy of Tx packet is received on all Rx ports and so
// the sum total of Rx packets
// received across all Rx ports is a multiple of Rx port count and Tx packets.
message FlowRxTxRatioRxCount {
}

// The optional container for event configuration.
message Event {

  // True to enable all events.
  // Enabling this option may affect the resultant packet payload due to
  // additional instrumentation data.
  // default = False
  optional bool enable = 1;

  // Description missing in models
  optional EventLink link = 2;

  // Description missing in models
  optional EventRxRateThreshold rx_rate_threshold = 3;

  // Description missing in models
  optional EventRouteAdvertiseWithdraw route_advertise_withdraw = 4;
}

// The optional container for rx rate threshold event configuration.
message EventRxRateThreshold {

  // True to enable the rx_rate_threshold event.
  // Enabling this option may affect the resultant packet payload due to
  // additional instrumentation data.
  // default = False
  optional bool enable = 1;

  // True to enable notifications when the rx rate of a flow passes above
  // or below the threshold value.
  // default = 95
  optional float threshold = 2;
}

// The optional container for link up/down event configuration.
message EventLink {

  // True to enable notifications when a link up/down event occurs.
  // default = False
  optional bool enable = 1;
}

// The optional container for route advertise/withdraw event configuration.
message EventRouteAdvertiseWithdraw {

  // True to enable notifications when a route advertise/withdraw
  // event occurs.
  // default = False
  optional bool enable = 1;
}

// Description missing in models
message EventRequest {

  message Type {
    enum Enum {
      unspecified = 0;
      link_down = 1;
      link_up = 2;
      route_withdraw = 3;
      route_advertise = 4;
      flow_rx_rate_above_threshold = 5;
      flow_rx_rate_below_threshold = 6;
    }
  }
  // Constrain the events being returned by specifying event types.
  // If the list is empty then all event types will be returned.
  repeated Type.Enum type = 1;

  // Constrain the events being returned by specifying event sources.
  // If the list is empty then all event sources will be returned.
  // 
  // x-constraint:
  // - /components/schemas/Port/properties/name
  // - /components/schemas/Bgp.V4RouteRange/name
  // - /components/schemas/Bgp.V6RouteRange/name
  // 
  repeated string source = 2;
}

// A container that describes what events a system should provide and
// optionally where to publish them.
message EventSubscription {

  // Description missing in models
  optional EventRequest events = 1;

  // Indicates where a client wants to be notified of the events set in
  // the events property.
  // If this property is empty or null then no event notifications will
  // be forwarded.
  optional string callback_url = 2;
}

// Configuration of LLDP protocol IEEE Ref: https://www.ieee802.org/1/files/public/docs2002/lldp-protocol-00.pdf
message Lldp {

  // The unique name of the object on which LLDP is running.
  // required = true
  LldpConnection connection = 1;

  // The Chassis ID is a mandatory TLV which identifies the chassis component of the endpoint
  // identifier associated  with the transmitting LLDP agent. If mac address is specified
  // it should be in colon seperated mac address format.
  optional LldpChassisId chassis_id = 2;

  // The Port ID is a mandatory TLV which identifies the port component of the endpoint
  // identifier associated with  the transmitting LLDP agent. If the specified port is
  // an IEEE 802.3 Repeater port, then this TLV is optional.
  optional LldpPortId port_id = 3;

  // The system name field shall contain an alpha-numeric string that indicates the system's
  // administratively assigned  name. The system name should be the system's fully qualified
  // domain name. If implementations support IETF RFC  3418, the sysName object should
  // be used for this field.
  optional LldpSystemName system_name = 4;

  // Specifies the amount of time in seconds a receiving device should maintain LLDP information
  // sent  by the device before discarding it.
  // default = 120
  optional uint32 hold_time = 5;

  // Set the transmission frequency of LLDP updates in seconds.
  // default = 30
  optional uint32 advertisement_interval = 6;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  string name = 7;
}

// LLDP connection to a test port. In future if more connection options arise  LLDP
// connection object will be enhanced.
message LldpConnection {

  message Choice {
    enum Enum {
      unspecified = 0;
      port_name = 1;
    }
  }
  // The name of the test port or other connection objects on which LLDP is configured.
  optional Choice.Enum choice = 1;

  // Name of the test port on which LLDP is configured on.
  // 
  // x-constraint:
  // - /components/schemas/Port/properties/name
  // 
  optional string port_name = 2;
}

// The Chassis ID is a mandatory TLV which identifies the chassis component of the endpoint
// identifier associated  with the transmitting LLDP agent. This field identifies the
// format and source of the chassis identifier string.  It is based on the enumerator
// defined by the LldpChassisIdSubtype object from IEEE 802.1AB MIB.
message LldpChassisId {

  message Choice {
    enum Enum {
      unspecified = 0;
      mac_address_subtype = 1;
      interface_name_subtype = 2;
      local_subtype = 3;
    }
  }
  // Chassis ID subtype to be used in Chassis ID TLV.
  // default = Choice.Enum.mac_address_subtype
  optional Choice.Enum choice = 1;

  // Description missing in models
  optional LldpChassisMacSubType mac_address_subtype = 2;

  // Name of an interface of the chassis that uniquely identifies the chassis.
  optional string interface_name_subtype = 3;

  // Locally assigned name of the chassis.
  optional string local_subtype = 4;
}

// The Port ID is a mandatory TLV which identifies the port component of the endpoint
// identifier associated with  the transmitting LLDP agent.This field identifies the
// format and source of the port identifier string. It is  based on the enumerator defined
// by the PtopoPortIdType object from RFC2922.
message LldpPortId {

  message Choice {
    enum Enum {
      unspecified = 0;
      mac_address_subtype = 1;
      interface_name_subtype = 2;
      local_subtype = 3;
    }
  }
  // Port ID subtype to be used in Port ID TLV.
  // default = Choice.Enum.interface_name_subtype
  optional Choice.Enum choice = 1;

  // The MAC Address configured in the Port ID TLV.
  optional string mac_address_subtype = 2;

  // Description missing in models
  optional LldpPortInterfaceNameSubType interface_name_subtype = 3;

  // The Locally assigned name configured in the Port ID TLV.
  optional string local_subtype = 4;
}

// The MAC address configured in the Chassis ID TLV.
message LldpChassisMacSubType {

  message Choice {
    enum Enum {
      unspecified = 0;
      auto = 1;
      value = 2;
    }
  }
  // In auto mode the system generated value is set for this property, while if the choice
  // is selected as value,  a user configured value will be used for this property.
  // default = Choice.Enum.auto
  optional Choice.Enum choice = 1;

  // The OTG implementation must provide a system generated value for this property.
  optional string auto = 2;

  // User must specify a value if mode is not auto.
  optional string value = 3;
}

// The interface name configured in the Port ID TLV.
message LldpPortInterfaceNameSubType {

  message Choice {
    enum Enum {
      unspecified = 0;
      auto = 1;
      value = 2;
    }
  }
  // In auto mode the system generated value is set for this property, while if the choice
  // is selected as value,  a user configured value will be used for this property.
  // default = Choice.Enum.auto
  optional Choice.Enum choice = 1;

  // The OTG implementation must provide a system generated value for this property.
  optional string auto = 2;

  // User must specify a value if mode is not auto.
  optional string value = 3;
}

// The system Name configured in the System Name TLV.
message LldpSystemName {

  message Choice {
    enum Enum {
      unspecified = 0;
      auto = 1;
      value = 2;
    }
  }
  // In auto mode the system generated value is set for this property, while if the choice
  // is selected as value,  a user configured value will be used for this property.
  // default = Choice.Enum.auto
  optional Choice.Enum choice = 1;

  // The OTG implementation must provide a system generated value for this property.
  optional string auto = 2;

  // User must specify a value if mode is not auto.
  optional string value = 3;
}

// Error response generated while serving API request.
message Error {

  // Numeric status code based on the underlying transport being used.
  // The API server MUST set this code explicitly based on following references:
  // - HTTP 4xx errors: https://datatracker.ietf.org/doc/html/rfc9110#section-15.5
  // - HTTP 5xx errors: https://datatracker.ietf.org/doc/html/rfc9110#section-15.6
  // - gRPC errors: https://grpc.github.io/grpc/core/md_doc_statuscodes.html
  // required = true
  int32 code = 1;

  message Kind {
    enum Enum {
      unspecified = 0;
      validation = 1;
      internal = 2;
    }
  }
  // Classification of error originating from within API server that may not be mapped
  // to the value in `code`.
  // Absence of this field may indicate that the error did not originate from within API
  // server.
  optional Kind.Enum kind = 2;

  // List of error messages generated while executing the request.
  repeated string errors = 3;
}

// A list of warnings that have occurred while executing the request.
message Warning {

  // A list of any system specific warnings that have occurred while
  // executing the request.
  repeated string warnings = 1;
}

// Request for updating specific attributes of resources in traffic generator
message ConfigUpdate {

  message Choice {
    enum Enum {
      unspecified = 0;
      flows = 1;
    }
  }
  // Description missing in models
  optional Choice.Enum choice = 1;

  // Description missing in models
  optional FlowsUpdate flows = 2;
}

// A container of flows with associated properties to be updated without affecting the
// flows current transmit state.
message FlowsUpdate {

  message PropertyNames {
    enum Enum {
      unspecified = 0;
      rate = 1;
      size = 2;
    }
  }
  // Flow properties to be updated without affecting the transmit state.
  repeated PropertyNames.Enum property_names = 1;

  // The list of configured flows for which given property will be updated.
  repeated Flow flows = 2;
}

// Request for setting operational state of configured resources.
message ControlState {

  message Choice {
    enum Enum {
      unspecified = 0;
      port = 1;
      protocol = 2;
      traffic = 3;
    }
  }
  // Description missing in models
  // required = true
  Choice.Enum choice = 1;

  // Description missing in models
  optional StatePort port = 2;

  // Description missing in models
  optional StateProtocol protocol = 3;

  // Description missing in models
  optional StateTraffic traffic = 4;
}

// States associated with configured ports.
message StatePort {

  message Choice {
    enum Enum {
      unspecified = 0;
      link = 1;
      capture = 2;
    }
  }
  // Description missing in models
  // required = true
  Choice.Enum choice = 1;

  // Description missing in models
  optional StatePortLink link = 2;

  // Description missing in models
  optional StatePortCapture capture = 3;
}

// States associated with configured flows
message StateTraffic {

  message Choice {
    enum Enum {
      unspecified = 0;
      flow_transmit = 1;
    }
  }
  // Description missing in models
  // required = true
  Choice.Enum choice = 1;

  // Description missing in models
  optional StateTrafficFlowTransmit flow_transmit = 2;
}

// States associated with protocols on configured resources.
message StateProtocol {

  message Choice {
    enum Enum {
      unspecified = 0;
      all = 1;
      route = 2;
      lacp = 3;
    }
  }
  // Description missing in models
  // required = true
  Choice.Enum choice = 1;

  // Description missing in models
  optional StateProtocolAll all = 2;

  // Description missing in models
  optional StateProtocolRoute route = 3;

  // Description missing in models
  optional StateProtocolLacp lacp = 4;
}

// Deprecated: Please use `StatePortLink` instead
// 
// Sets the link state of configured ports.
message LinkState {

  // The names of port objects to. An empty or null list will control all port objects.
  // 
  // x-constraint:
  // - /components/schemas/Port/properties/name
  // 
  repeated string port_names = 1;

  message State {
    enum Enum {
      unspecified = 0;
      up = 1;
      down = 2;
    }
  }
  // The link state.
  // required = true
  State.Enum state = 2;
}

// Deprecated: Please use `StateTrafficFlowTransmit` instead
// 
// Flow transmit state.
message TransmitState {

  // The names of flows to which the transmit state will be applied to. If the list of
  // flow_names is empty or null the state will be applied to all configured flows.
  // If the list is not empty any flow that is not included in the list of flow_names
  // MUST be ignored and not included in the state change.
  // 
  // x-constraint:
  // - /components/schemas/Flow/properties/name
  // 
  repeated string flow_names = 1;

  message State {
    enum Enum {
      unspecified = 0;
      start = 1;
      stop = 2;
      pause = 3;
      resume = 4;
    }
  }
  // The transmit state.
  // If the value of the state property is 'start' then all flows defined by the 'flow_names'
  // property will be started and the metric counters MUST be cleared prior to starting
  // the flow(s).
  // If the value of the state property is 'stop' then all flows defined by the 'flow_names'
  // property will be stopped and the metric counters MUST NOT be cleared.
  // If the value of the state property is 'pause' then all flows defined by the 'flow_names'
  // property will be paused and the metric counters MUST NOT be cleared.
  // If the value of the state property is 'resume' then any paused flows defined by the
  // 'flow_names' property will start transmit at the point at which they were paused.
  // Any flow that is stopped will start transmit at the beginning of the flow. The flow(s)
  // MUST NOT have their metric counters cleared.
  // required = true
  State.Enum state = 2;
}

// Deprecated: Please use `StatePortCapture` instead
// 
// Control port capture state
message CaptureState {

  // The names of ports to which the capture state will be applied to. If the list of
  // port_names is empty or null the state will be applied to all configured ports.
  // If the list is not empty any port that is not included in the list of port_names
  // MUST be ignored and not included in the state change.
  // 
  // x-constraint:
  // - /components/schemas/Port/properties/name
  // 
  repeated string port_names = 1;

  message State {
    enum Enum {
      unspecified = 0;
      start = 1;
      stop = 2;
    }
  }
  // The capture state.
  // required = true
  State.Enum state = 2;
}

// Deprecated: Please use `StateProtocolRoute` instead
// 
// Sets the device route state
message RouteState {

  // The names of device route objects to control. If no names are specified then all
  // route objects that match the x-constraint will be affected.
  // 
  // x-constraint:
  // - /components/schemas/Bgp.V4RouteRange/properties/name
  // - /components/schemas/Bgp.V6RouteRange/properties/name
  // - /components/schemas/Isis.V4RouteRange/properties/name
  // - /components/schemas/Isis.V6RouteRange/properties/name
  // 
  repeated string names = 1;

  message State {
    enum Enum {
      unspecified = 0;
      withdraw = 1;
      advertise = 2;
    }
  }
  // Route specific states
  // required = true
  State.Enum state = 2;
}

// Deprecated: Please use `StateProtocolAll` instead
// 
// Sets all configured protocols to `start` or `stop` state. Setting protocol state
// to `start`  shall be a no-op if preceding `set_config` API call was made with  `config.options.protocol_options.auto_start_all`
// set to `true` or if all the configured protocols are already started.
message ProtocolState {

  message State {
    enum Enum {
      unspecified = 0;
      start = 1;
      stop = 2;
    }
  }
  // Protocol specific states
  // required = true
  State.Enum state = 1;
}

// Deprecated: Please use `State.Protocol` instead
// 
// Sets attributes for the requested state/actions to be performed on device(s)
message DeviceState {

  message Choice {
    enum Enum {
      unspecified = 0;
      lacp_member_state = 1;
    }
  }
  // Description missing in models
  optional Choice.Enum choice = 1;

  // Description missing in models
  optional LacpMemberState lacp_member_state = 2;
}

// Sets the link of configured ports.
message StatePortLink {

  // The names of target ports. An empty or null list will target all ports.
  // 
  // x-constraint:
  // - /components/schemas/Port/properties/name
  // 
  repeated string port_names = 1;

  message State {
    enum Enum {
      unspecified = 0;
      up = 1;
      down = 2;
    }
  }
  // The link state.
  // required = true
  State.Enum state = 2;
}

// Sets the capture state of configured ports
message StatePortCapture {

  // The names of ports to which the capture state will be applied to. If the list of
  // port_names is empty or null the state will be applied to all configured ports.
  // If the list is not empty any port that is not included in the list of port_names
  // MUST be ignored and not included in the state change.
  // 
  // x-constraint:
  // - /components/schemas/Port/properties/name
  // 
  repeated string port_names = 1;

  message State {
    enum Enum {
      unspecified = 0;
      start = 1;
      stop = 2;
    }
  }
  // The capture state.
  // required = true
  State.Enum state = 2;
}

// Provides state control of flow transmission.
message StateTrafficFlowTransmit {

  // The names of flows to which the transmit state will be applied to. If the list of
  // flow_names is empty or null the state will be applied to all configured flows.
  // If the list is not empty any flow that is not included in the list of flow_names
  // MUST be ignored and not included in the state change.
  // 
  // x-constraint:
  // - /components/schemas/Flow/properties/name
  // 
  repeated string flow_names = 1;

  message State {
    enum Enum {
      unspecified = 0;
      start = 1;
      stop = 2;
      pause = 3;
      resume = 4;
    }
  }
  // The transmit state.
  // If the value of the state property is 'start' then all flows defined by the 'flow_names'
  // property will be started and the metric counters MUST be cleared prior to starting
  // the flow(s).
  // If the value of the state property is 'stop' then all flows defined by the 'flow_names'
  // property will be stopped and the metric counters MUST NOT be cleared.
  // If the value of the state property is 'pause' then all flows defined by the 'flow_names'
  // property will be paused and the metric counters MUST NOT be cleared.
  // If the value of the state property is 'resume' then any paused flows defined by the
  // 'flow_names' property will start transmit at the point at which they were paused.
  // Any flow that is stopped will start transmit at the beginning of the flow. The flow(s)
  // MUST NOT have their metric counters cleared.
  optional State.Enum state = 2;
}

// Sets all configured protocols to `start` or `stop` state.
// Setting protocol state to `start` shall be a no-op if preceding `set_config` API
// call was made with `config.options.protocol_options.auto_start_all` set to `true`
// or if all the configured protocols are already started.
message StateProtocolAll {

  message State {
    enum Enum {
      unspecified = 0;
      start = 1;
      stop = 2;
    }
  }
  // Protocol states
  // required = true
  State.Enum state = 1;
}

// Sets the state of configured routes
message StateProtocolRoute {

  // The names of device route objects to control. If no names are specified then all
  // route objects that match the x-constraint will be affected.
  // 
  // x-constraint:
  // - /components/schemas/Bgp.V4RouteRange/properties/name
  // - /components/schemas/Bgp.V6RouteRange/properties/name
  // - /components/schemas/Isis.V4RouteRange/properties/name
  // - /components/schemas/Isis.V6RouteRange/properties/name
  // 
  repeated string names = 1;

  message State {
    enum Enum {
      unspecified = 0;
      withdraw = 1;
      advertise = 2;
    }
  }
  // Route states
  // required = true
  State.Enum state = 2;
}

// Sets state of configured LACP
message StateProtocolLacp {

  message Choice {
    enum Enum {
      unspecified = 0;
      admin = 1;
    }
  }
  // Description missing in models
  // required = true
  Choice.Enum choice = 1;

  // Description missing in models
  optional StateProtocolLacpAdmin admin = 2;
}

// Sets admin state of LACP configured on LAG members
message StateProtocolLacpAdmin {

  // The names of LAG members (ports) for which the state has to be applied. An empty
  // or null list will control all LAG members.
  // 
  // x-constraint:
  // - /components/schemas/Port/properties/name
  // 
  repeated string lag_member_names = 1;

  message State {
    enum Enum {
      unspecified = 0;
      up = 1;
      down = 2;
    }
  }
  // The LACP Member admin state. 'up' will send LACPDUs with 'sync' flag set on selected
  // member ports. 'down' will send LACPDUs with 'sync' flag unset on selected member
  // ports.
  optional State.Enum state = 2;
}

// Deprecated: Please use `StateProtocolLacpAdmin` instead
// 
// Set LACP state for specified LAG Member Port(s).
message LacpMemberState {

  // The names of LAG members (ports) for which the state has to be applied. An empty
  // or null list will control all LAG members.
  // 
  // x-constraint:
  // - /components/schemas/Port/properties/name
  // 
  repeated string lag_member_port_names = 1;

  message State {
    enum Enum {
      unspecified = 0;
      up = 1;
      down = 2;
    }
  }
  // The LACP Member admin state. 'up' will send LACPDUs with 'sync' flag set on selected
  // member ports. 'down' will send LACPDUs with 'sync' flag unset on selected member
  // ports.
  // required = true
  State.Enum state = 2;
}

// Request for triggering action against configured resources.
message ControlAction {

  message Choice {
    enum Enum {
      unspecified = 0;
      protocol = 1;
    }
  }
  // Description missing in models
  // required = true
  Choice.Enum choice = 1;

  // Description missing in models
  optional ActionProtocol protocol = 2;
}

// Response for action triggered against configured resources along with warnings.
message ControlActionResponse {

  // List of warnings generated while triggering specified action
  repeated string warnings = 1;

  // Description missing in models
  optional ActionResponse response = 2;
}

// Response for action triggered against configured resources.
message ActionResponse {

  message Choice {
    enum Enum {
      unspecified = 0;
      protocol = 1;
    }
  }
  // Description missing in models
  // required = true
  Choice.Enum choice = 1;

  // Description missing in models
  optional ActionResponseProtocol protocol = 2;
}

// Actions associated with protocols on configured resources.
message ActionProtocol {

  message Choice {
    enum Enum {
      unspecified = 0;
      ipv4 = 1;
      ipv6 = 2;
      bgp = 3;
    }
  }
  // Description missing in models
  // required = true
  Choice.Enum choice = 1;

  // Description missing in models
  optional ActionProtocolIpv4 ipv4 = 2;

  // Description missing in models
  optional ActionProtocolIpv6 ipv6 = 3;

  // Description missing in models
  optional ActionProtocolBgp bgp = 4;
}

// Response for actions associated with protocols on configured resources.
message ActionResponseProtocol {

  message Choice {
    enum Enum {
      unspecified = 0;
      ipv4 = 1;
      ipv6 = 2;
    }
  }
  // Description missing in models
  // required = true
  Choice.Enum choice = 1;

  // Description missing in models
  optional ActionResponseProtocolIpv4 ipv4 = 2;

  // Description missing in models
  optional ActionResponseProtocolIpv6 ipv6 = 3;
}

// Actions associated with IPv4 on configured resources.
message ActionProtocolIpv4 {

  message Choice {
    enum Enum {
      unspecified = 0;
      ping = 1;
    }
  }
  // Description missing in models
  // required = true
  Choice.Enum choice = 1;

  // Description missing in models
  optional ActionProtocolIpv4Ping ping = 2;
}

// Response for actions associated with IPv4 on configured resources.
message ActionResponseProtocolIpv4 {

  message Choice {
    enum Enum {
      unspecified = 0;
      ping = 1;
    }
  }
  // Description missing in models
  // required = true
  Choice.Enum choice = 1;

  // Description missing in models
  optional ActionResponseProtocolIpv4Ping ping = 2;
}

// Request for initiating ping between multiple source and destination pairs.
message ActionProtocolIpv4Ping {

  // List of IPv4 ping requests.
  repeated ActionProtocolIpv4PingRequest requests = 1;
}

// Under Review: Most ping request parameters are still TBD.
// 
// Request for initiating ping between a single source and destination pair.
// For ping request, 1 IPv4 ICMP Echo Request shall be sent and wait for ping response
// to either succeed or time out. The API wait timeout for each request shall be 300ms.
message ActionProtocolIpv4PingRequest {

  // Name of source IPv4 interface to be used.
  // 
  // x-constraint:
  // - /components/schemas/Device.Ipv4/properties/name
  // 
  optional string src_name = 1;

  // Destination IPv4 address to ping.
  optional string dst_ip = 2;
}

// Response for ping initiated between multiple source and destination pairs.
message ActionResponseProtocolIpv4Ping {

  // List of responses for IPv4 ping responses.
  repeated ActionResponseProtocolIpv4PingResponse responses = 1;
}

// Response for ping initiated between a single source and destination pair.
message ActionResponseProtocolIpv4PingResponse {

  // Name of source IPv4 interface used for ping.
  // 
  // x-constraint:
  // - /components/schemas/Device.Ipv4/properties/name
  // 
  // required = true
  string src_name = 1;

  // Destination IPv4 address used for ping.
  // required = true
  string dst_ip = 2;

  message Result {
    enum Enum {
      unspecified = 0;
      succeeded = 1;
      failed = 2;
    }
  }
  // Result of the ping request.
  // required = true
  Result.Enum result = 3;
}

// Actions associated with IPv6 on configured resources.
message ActionProtocolIpv6 {

  message Choice {
    enum Enum {
      unspecified = 0;
      ping = 1;
    }
  }
  // Description missing in models
  // required = true
  Choice.Enum choice = 1;

  // Description missing in models
  optional ActionProtocolIpv6Ping ping = 2;
}

// Response for actions associated with IPv6 on configured resources.
message ActionResponseProtocolIpv6 {

  message Choice {
    enum Enum {
      unspecified = 0;
      ping = 1;
    }
  }
  // Description missing in models
  // required = true
  Choice.Enum choice = 1;

  // Description missing in models
  optional ActionResponseProtocolIpv6Ping ping = 2;
}

// Request for initiating ping between multiple source and destination pairs.
message ActionProtocolIpv6Ping {

  // List of IPv6 ping requests.
  repeated ActionProtocolIpv6PingRequest requests = 1;
}

// Under Review: Most ping request parameters are still TBD.
// 
// Request for initiating ping between a single source and destination pair.
// For ping request, 1 IPv6 ICMP Echo Request shall be sent and wait for ping response
// to either succeed or time out. The API wait timeout for each request shall be 300ms.
message ActionProtocolIpv6PingRequest {

  // Name of source IPv6 interface to be used.
  // 
  // x-constraint:
  // - /components/schemas/Device.Ipv6/properties/name
  // 
  optional string src_name = 1;

  // Destination IPv6 address to ping.
  optional string dst_ip = 2;
}

// Response for ping initiated between multiple source and destination pairs.
message ActionResponseProtocolIpv6Ping {

  // List of responses for IPv6 ping responses.
  repeated ActionResponseProtocolIpv6PingResponse responses = 1;
}

// Response for ping initiated between a single source and destination pair.
message ActionResponseProtocolIpv6PingResponse {

  // Name of source IPv6 interface used for ping.
  // 
  // x-constraint:
  // - /components/schemas/Device.Ipv6/properties/name
  // 
  // required = true
  string src_name = 1;

  // Destination IPv6 address used for ping.
  // required = true
  string dst_ip = 2;

  message Result {
    enum Enum {
      unspecified = 0;
      succeeded = 1;
      failed = 2;
    }
  }
  // Result of the ping request.
  // required = true
  Result.Enum result = 3;
}

// Actions associated with BGP on configured resources.
message ActionProtocolBgp {

  message Choice {
    enum Enum {
      unspecified = 0;
      notification = 1;
      initiate_graceful_restart = 2;
    }
  }
  // Description missing in models
  // required = true
  Choice.Enum choice = 1;

  // Description missing in models
  optional ActionProtocolBgpNotification notification = 2;

  // Description missing in models
  optional ActionProtocolBgpInitiateGracefulRestart initiate_graceful_restart = 3;
}

// A NOTIFICATION message is sent when an error is detected with the BGP session, such
// as hold timer expiring, misconfigured AS number  or a BGP session reset is requested.
// This causes the BGP connection to close. Send explicit NOTIFICATIONs for list of
// specified  BGP peers. If a user wants to send custom Error Code and Error Subcode
// the custom object should be configured. A user can send IANA defined BGP NOTIFICATIONs
// according to https://www.iana.org/assignments/bgp-parameters/bgp-parameters.xhtml.
// 
message ActionProtocolBgpNotification {

  // The names of BGP Peers to send NOTIFICATION to. If no name is specified then NOTIFICATION
  // will be sent to all configured BGP peers.
  // 
  // x-constraint:
  // - /components/schemas/Device.Bgp/properties/name
  // 
  repeated string names = 1;

  message Choice {
    enum Enum {
      unspecified = 0;
      cease = 1;
      message_header_error = 2;
      open_message_error = 3;
      update_message_error = 4;
      hold_timer_expired = 5;
      finite_state_machine_error = 6;
      custom = 7;
    }
  }
  // Each BGP NOTIFICATION message includes an Error Code field indicating what type of
  // problem occurred. For certain Error Codes, an Error  Subcode field provides additional
  // details about the specific nature of the problem.  The choice value will provide
  // the Error Code used in NOTIFICATION message.  The Subcode can be set for each of
  // the corresponding errors except for Hold Timer Expired error and BGP Finite State
  // Machine error.  In both of these cases Subcode 0 will be sent. If a user wants to
  // use non zero Sub Code then custom choice can be used.
  // default = Choice.Enum.cease
  optional Choice.Enum choice = 2;

  // Description missing in models
  optional DeviceBgpCeaseError cease = 3;

  // Description missing in models
  optional DeviceBgpMessageHeaderError message_header_error = 4;

  // Description missing in models
  optional DeviceBgpOpenMessageError open_message_error = 5;

  // Description missing in models
  optional DeviceBgpUpdateMessageError update_message_error = 6;

  // Description missing in models
  optional DeviceBgpHoldTimerExpired hold_timer_expired = 7;

  // Description missing in models
  optional DeviceBgpFiniteStateMachineError finite_state_machine_error = 8;

  // Description missing in models
  optional DeviceBgpCustomError custom = 9;
}

// Initiates BGP Graceful Restart process for the selected BGP peers. If no name is
// specified then Graceful Restart will be sent to all configured BGP peers.
message ActionProtocolBgpInitiateGracefulRestart {

  // The names of device BGP peers objects to control.
  // 
  // x-constraint:
  // - /components/schemas/Device.Bgp/properties/name
  // 
  repeated string peer_names = 1;

  // Duration (in seconds) after which selected BGP peers will initiate
  // Graceful restart by sending the Open Message with Restart State bit set in the Graceful
  // Restart capability.
  // default = 30
  optional uint32 restart_delay = 2;
}

// Description missing in models
message Ping {

  message Choice {
    enum Enum {
      unspecified = 0;
      ipv4 = 1;
      ipv6 = 2;
    }
  }
  // IPv4 or IPv6 ping.
  // default = Choice.Enum.ipv4
  optional Choice.Enum choice = 1;

  // Description missing in models
  optional PingIpv4 ipv4 = 2;

  // Description missing in models
  optional PingIpv6 ipv6 = 3;
}

// Description missing in models
message PingIpv4 {

  // A base IPv4 interface
  // 
  // x-constraint:
  // - /components/schemas/Device.Ipv4/properties/name
  // 
  optional string src_name = 1;

  // IPv4 address to ping
  optional string dst_ip = 2;
}

// Description missing in models
message PingIpv6 {

  // A base IPv6 interface
  // 
  // x-constraint:
  // - /components/schemas/Device.Ipv6/properties/name
  // 
  optional string src_name = 1;

  // IPv6 addresses to ping.
  optional string dst_ip = 2;
}

// Ping request details
message PingRequest {

  // Array of ping requests
  repeated Ping endpoints = 1;
}

// A container for ping responses.
message PingResponse {

  // Description missing in models
  repeated Response responses = 1;
}

// Description missing in models
message Response {

  // The name of the source IPv4 or IPv6 interface from which ping was sent.
  // 
  // x-constraint:
  // - /components/schemas/Device.Ipv4/properties/name
  // - /components/schemas/Device.Ipv6/properties/name
  // 
  optional string src_name = 1;

  // Destination address.
  optional string dst_ip = 2;

  message Result {
    enum Enum {
      unspecified = 0;
      success = 1;
      failure = 2;
    }
  }
  // Result of the ping request.
  // default = Result.Enum.failure
  optional Result.Enum result = 3;
}

// Request to traffic generator for metrics of choice.
message MetricsRequest {

  message Choice {
    enum Enum {
      unspecified = 0;
      port = 1;
      flow = 2;
      bgpv4 = 3;
      bgpv6 = 4;
      isis = 5;
      lag = 6;
      lacp = 7;
      lldp = 8;
      rsvp = 9;
    }
  }
  // Description missing in models
  // default = Choice.Enum.port
  optional Choice.Enum choice = 1;

  // Description missing in models
  optional PortMetricsRequest port = 2;

  // Description missing in models
  optional FlowMetricsRequest flow = 3;

  // Description missing in models
  optional Bgpv4MetricsRequest bgpv4 = 4;

  // Description missing in models
  optional Bgpv6MetricsRequest bgpv6 = 5;

  // Description missing in models
  optional IsisMetricsRequest isis = 6;

  // Description missing in models
  optional LagMetricsRequest lag = 7;

  // Description missing in models
  optional LacpMetricsRequest lacp = 8;

  // Description missing in models
  optional LldpMetricsRequest lldp = 9;

  // Description missing in models
  optional RsvpMetricsRequest rsvp = 10;
}

// Response containing chosen traffic generator metrics.
message MetricsResponse {

  message Choice {
    enum Enum {
      unspecified = 0;
      flow_metrics = 1;
      port_metrics = 2;
      bgpv4_metrics = 3;
      bgpv6_metrics = 4;
      isis_metrics = 5;
      lag_metrics = 6;
      lacp_metrics = 7;
      lldp_metrics = 8;
      rsvp_metrics = 9;
    }
  }
  // Description missing in models
  // default = Choice.Enum.port_metrics
  optional Choice.Enum choice = 1;

  // Description missing in models
  repeated PortMetric port_metrics = 2;

  // Description missing in models
  repeated FlowMetric flow_metrics = 3;

  // Description missing in models
  repeated Bgpv4Metric bgpv4_metrics = 4;

  // Description missing in models
  repeated Bgpv6Metric bgpv6_metrics = 5;

  // Description missing in models
  repeated IsisMetric isis_metrics = 6;

  // Description missing in models
  repeated LagMetric lag_metrics = 7;

  // Description missing in models
  repeated LacpMetric lacp_metrics = 8;

  // Description missing in models
  repeated LldpMetric lldp_metrics = 9;

  // Description missing in models
  repeated RsvpMetric rsvp_metrics = 10;
}

// The port result request to the traffic generator
message PortMetricsRequest {

  // The names of objects to return results for. An empty list will return all port row
  // results.
  // 
  // x-constraint:
  // - /components/schemas/Port/properties/name
  // 
  repeated string port_names = 1;

  message ColumnNames {
    enum Enum {
      unspecified = 0;
      transmit = 1;
      location = 2;
      link = 3;
      capture = 4;
      frames_tx = 5;
      frames_rx = 6;
      bytes_tx = 7;
      bytes_rx = 8;
      frames_tx_rate = 9;
      frames_rx_rate = 10;
      bytes_tx_rate = 11;
      bytes_rx_rate = 12;
    }
  }
  // The list of column names that the returned result set will contain. If the list is
  // empty then all columns will be returned. The name of the port cannot be excluded.
  repeated ColumnNames.Enum column_names = 2;
}

// Description missing in models
message PortMetric {

  // The name of a configured port
  // 
  // x-constraint:
  // - /components/schemas/Port/properties/name
  // 
  optional string name = 1;

  // The state of the connection to the test port location. The format should be the configured
  // port location along with  any custom connection state message.
  optional string location = 2;

  message Link {
    enum Enum {
      unspecified = 0;
      up = 1;
      down = 2;
    }
  }
  // The state of the test port link The string can be up, down or a custom error message.
  optional Link.Enum link = 3;

  message Capture {
    enum Enum {
      unspecified = 0;
      started = 1;
      stopped = 2;
    }
  }
  // The state of the test port capture infrastructure. The string can be started, stopped
  // or a custom error message.
  optional Capture.Enum capture = 4;

  // The current total number of frames transmitted
  optional uint64 frames_tx = 5;

  // The current total number of valid frames received
  optional uint64 frames_rx = 6;

  // The current total number of bytes transmitted
  optional uint64 bytes_tx = 7;

  // The current total number of valid bytes received
  optional uint64 bytes_rx = 8;

  // The current rate of frames transmitted
  optional float frames_tx_rate = 9;

  // The current rate of valid frames received
  optional float frames_rx_rate = 10;

  // The current rate of bytes transmitted
  optional float bytes_tx_rate = 11;

  // The current rate of bytes received
  optional float bytes_rx_rate = 12;

  message Transmit {
    enum Enum {
      unspecified = 0;
      started = 1;
      stopped = 2;
    }
  }
  // The transmit state of the flow.
  optional Transmit.Enum transmit = 13;
}

// The container for a flow metric request.
message FlowMetricsRequest {

  // Flow metrics will be retrieved for these flow names.
  // If no flow names are specified then all flows will be returned.
  // 
  // x-constraint:
  // - /components/schemas/Flow/properties/name
  // 
  repeated string flow_names = 1;

  message MetricNames {
    enum Enum {
      unspecified = 0;
      transmit = 1;
      frames_tx = 2;
      frames_rx = 3;
      bytes_tx = 4;
      bytes_rx = 5;
      frames_tx_rate = 6;
      frames_rx_rate = 7;
    }
  }
  // The list of metric names that the returned result set will contain. If the list is
  // empty then all metrics will be returned.
  repeated MetricNames.Enum metric_names = 3;

  // Description missing in models
  optional FlowTaggedMetricsFilter tagged_metrics = 4;
}

// Filter for tagged metrics
message FlowTaggedMetricsFilter {

  // Controls inclusion/exclusion of tagged metrics when fetching flow metrics.
  // default = True
  optional bool include = 1;

  // Controls inclusion/exclusion of tagged metrics where each underlying attributes has
  // zero value or absent value.
  // default = False
  optional bool include_empty_metrics = 2;

  message MetricNames {
    enum Enum {
      unspecified = 0;
      frames_tx = 1;
      frames_rx = 2;
      bytes_tx = 3;
      bytes_rx = 4;
      frames_tx_rate = 5;
      frames_rx_rate = 6;
    }
  }
  // The list of metric names that the returned result set will contain. If the list is
  // empty then all metrics will be returned.
  repeated MetricNames.Enum metric_names = 3;

  // List of filters to selectively fetch tagged metrics with certain tag and corresponding
  // value.
  repeated FlowMetricTagFilter filters = 4;
}

// A container for filtering ingress and/or egress metric tags.
// The Tx stats may not be applicable in both the request and response filter.
message FlowMetricTagFilter {

  // A metric tag name that MUST exist in a flow packet or
  // flow egress_packet configuration
  optional string name = 1;

  // A list of filters that can be applied to the metric tag name.
  // By default all values will be included in the flow metric results.
  repeated string values = 2;
}

// A container for flow metrics.
// The container is keyed by the name, port_tx and port_rx.
message FlowMetric {

  // The name of the flow
  optional string name = 1;

  // The name of the transmit port
  optional string port_tx = 2;

  // The name of the receive port
  optional string port_rx = 3;

  message Transmit {
    enum Enum {
      unspecified = 0;
      started = 1;
      stopped = 2;
      paused = 3;
    }
  }
  // The transmit state of the flow.
  optional Transmit.Enum transmit = 5;

  // The current total number of frames transmitted
  optional uint64 frames_tx = 6;

  // The current total number of valid frames received
  optional uint64 frames_rx = 7;

  // The current total number of bytes transmitted
  optional uint64 bytes_tx = 8;

  // The current total number of bytes received
  optional uint64 bytes_rx = 9;

  // The current rate of frames transmitted
  optional float frames_tx_rate = 10;

  // The current rate of valid frames received
  optional float frames_rx_rate = 11;

  // The percentage of lost frames
  optional float loss = 12;

  // Description missing in models
  optional MetricTimestamp timestamps = 13;

  // Description missing in models
  optional MetricLatency latency = 14;

  // List of metrics corresponding to a set of values applicable
  // for configured metric tags in ingress or egress packet header fields of corresponding
  // flow.
  // The container is keyed by list of tag-value pairs.
  repeated FlowTaggedMetric tagged_metrics = 15;
}

// Metrics for each set of values applicable for configured
// metric tags in ingress or egress packet header fields of corresponding flow.
// The container is keyed by list of tag-value pairs.
message FlowTaggedMetric {

  // List of tag and value pairs
  repeated FlowMetricTag tags = 1;

  // The current total number of frames transmitted
  optional uint64 frames_tx = 2;

  // The current total number of valid frames received
  optional uint64 frames_rx = 3;

  // The current total number of bytes transmitted
  optional uint64 bytes_tx = 4;

  // The current total number of bytes received
  optional uint64 bytes_rx = 5;

  // The current rate of frames transmitted
  optional float frames_tx_rate = 6;

  // The current rate of valid frames received
  optional float frames_rx_rate = 7;

  // The percentage of lost frames
  optional float loss = 8;

  // Description missing in models
  optional MetricTimestamp timestamps = 9;

  // Description missing in models
  optional MetricLatency latency = 10;
}

// Description missing in models
message FlowMetricTag {

  // Name of packet field metric tag
  optional string name = 1;

  // Description missing in models
  optional FlowMetricTagValue value = 2;
}

// A container for metric tag value
message FlowMetricTagValue {

  message Choice {
    enum Enum {
      unspecified = 0;
      hex = 1;
      str = 2;
    }
  }
  // Available formats for metric tag value
  // default = Choice.Enum.hex
  optional Choice.Enum choice = 1;

  // Value represented in hexadecimal format
  optional string hex = 2;

  // Value represented in string format
  optional string str = 3;
}

// The container for timestamp metrics.
// The container will be empty if the timestamp has not been configured for
// the flow.
message MetricTimestamp {

  // First timestamp in nanoseconds
  optional double first_timestamp_ns = 1;

  // Last timestamp in nanoseconds
  optional double last_timestamp_ns = 2;
}

// The container for latency metrics.
// The min/max/avg values are dependent on the type of latency measurement
// mode that is configured.
// The container will be empty if the latency has not been configured for
// the flow.
message MetricLatency {

  // Minimum latency in nanoseconds
  optional double minimum_ns = 1;

  // Maximum latency in nanoseconds
  optional double maximum_ns = 2;

  // Average latency in nanoseconds
  optional double average_ns = 3;
}

// The request to retrieve BGPv4 per peer metrics/statistics.
message Bgpv4MetricsRequest {

  // The names of BGPv4 peers to return results for. An empty list will return results
  // for all BGPv4 peers.
  // 
  // x-constraint:
  // - /components/schemas/Bgp.V4peer/properties/name
  // 
  repeated string peer_names = 1;

  message ColumnNames {
    enum Enum {
      unspecified = 0;
      session_state = 1;
      session_flap_count = 2;
      routes_advertised = 3;
      routes_received = 4;
      route_withdraws_sent = 5;
      route_withdraws_received = 6;
      updates_sent = 7;
      updates_received = 8;
      opens_sent = 9;
      opens_received = 10;
      keepalives_sent = 11;
      keepalives_received = 12;
      notifications_sent = 13;
      notifications_received = 14;
      fsm_state = 15;
    }
  }
  // The list of column names that the returned result set will contain. If the list is
  // empty then all columns will be returned except for any result_groups. The name of
  // the BGPv4 peer cannot be excluded.
  repeated ColumnNames.Enum column_names = 2;
}

// BGPv4 per peer statistics information.
message Bgpv4Metric {

  // The name of a configured BGPv4 peer.
  optional string name = 1;

  message SessionState {
    enum Enum {
      unspecified = 0;
      up = 1;
      down = 2;
    }
  }
  // Session state as up or down. Up refers to an Established state and Down refers to
  // any other state.
  optional SessionState.Enum session_state = 2;

  // Number of times the session went from Up to Down state.
  optional uint32 session_flap_count = 3;

  // Number of routes advertised.
  optional uint64 routes_advertised = 4;

  // Number of routes received.
  optional uint64 routes_received = 5;

  // Number of route withdraws sent.
  optional uint64 route_withdraws_sent = 6;

  // Number of route withdraws received.
  optional uint64 route_withdraws_received = 7;

  // Number of Update messages sent.
  optional uint64 updates_sent = 8;

  // Number of Update messages received.
  optional uint64 updates_received = 9;

  // Number of Open messages sent.
  optional uint64 opens_sent = 10;

  // Number of Open messages received.
  optional uint64 opens_received = 11;

  // Number of Keepalive messages sent.
  optional uint64 keepalives_sent = 12;

  // Number of Keepalive messages received.
  optional uint64 keepalives_received = 13;

  // Number of Notification messages sent.
  optional uint64 notifications_sent = 14;

  // Number of Notification messages received.
  optional uint64 notifications_received = 15;

  message FsmState {
    enum Enum {
      unspecified = 0;
      idle = 1;
      connect = 2;
      active = 3;
      opensent = 4;
      openconfirm = 5;
      established = 6;
    }
  }
  // BGP peer FSM (Finite State Machine) state as Idle, Connect, Active, OpenSent, OpenConfirm
  // and Established. In all the states except Established the BGP session is down. Idle
  // refers to the Idle state of the FSM. Connect refers to the state where the session
  // is waiting for the underlying transport session to be established. Active refers
  // to the state where the session is awaiting for a connection from the remote peer.
  // OpenSent refers to the state where the session is in the process of being established.
  // The local system has sent an OPEN message. OpenConfirm refers to the state where
  // the session is in the process of being established. The local system has sent and
  // received an OPEN message and is awaiting a NOTIFICATION or KEEPALIVE message from
  // remote peer. Established refers to the state where the BGP session with the peer
  // is established.
  optional FsmState.Enum fsm_state = 16;
}

// The request to retrieve BGPv6 per peer metrics/statistics.
message Bgpv6MetricsRequest {

  // The names of BGPv6 peers to return results for. An empty list will return results
  // for all BGPv6 peers.
  // 
  // x-constraint:
  // - /components/schemas/Bgp.V6peer/properties/name
  // 
  repeated string peer_names = 1;

  message ColumnNames {
    enum Enum {
      unspecified = 0;
      session_state = 1;
      session_flap_count = 2;
      routes_advertised = 3;
      routes_received = 4;
      route_withdraws_sent = 5;
      route_withdraws_received = 6;
      updates_sent = 7;
      updates_received = 8;
      opens_sent = 9;
      opens_received = 10;
      keepalives_sent = 11;
      keepalives_received = 12;
      notifications_sent = 13;
      notifications_received = 14;
      fsm_state = 15;
    }
  }
  // The list of column names that the returned result set will contain. If the list is
  // empty then all columns will be returned except for any result_groups. The name of
  // the BGPv6 peer cannot be excluded.
  repeated ColumnNames.Enum column_names = 2;
}

// BGPv6 per peer statistics information.
message Bgpv6Metric {

  // The name of a configured BGPv6 peer.
  optional string name = 1;

  message SessionState {
    enum Enum {
      unspecified = 0;
      up = 1;
      down = 2;
    }
  }
  // Session state as up or down. Up refers to an Established state and Down refers to
  // any other state.
  optional SessionState.Enum session_state = 2;

  // Number of times the session went from Up to Down state.
  optional uint32 session_flap_count = 3;

  // Number of routes advertised.
  optional uint64 routes_advertised = 4;

  // Number of routes received.
  optional uint64 routes_received = 5;

  // Number of route withdraws sent.
  optional uint64 route_withdraws_sent = 6;

  // Number of route withdraws received.
  optional uint64 route_withdraws_received = 7;

  // Number of Update messages sent.
  optional uint64 updates_sent = 8;

  // Number of Update messages received.
  optional uint64 updates_received = 9;

  // Number of Open messages sent.
  optional uint64 opens_sent = 10;

  // Number of Open messages received.
  optional uint64 opens_received = 11;

  // Number of Keepalive messages sent.
  optional uint64 keepalives_sent = 12;

  // Number of Keepalive messages received.
  optional uint64 keepalives_received = 13;

  // Number of Notification messages sent.
  optional uint64 notifications_sent = 14;

  // Number of Notification messages received.
  optional uint64 notifications_received = 15;

  message FsmState {
    enum Enum {
      unspecified = 0;
      idle = 1;
      connect = 2;
      active = 3;
      opensent = 4;
      openconfirm = 5;
      established = 6;
    }
  }
  // BGP peer FSM (Finite State Machine) state as Idle, Connect, Active, OpenSent, OpenConfirm
  // and Established. In all the states except Established the BGP session is down. Idle
  // refers to the Idle state of the FSM. Connect refers to the state where the session
  // is waiting for the underlying transport session to be established. Active refers
  // to the state where the session is awaiting for a connection from the remote peer.
  // OpenSent refers to the state where the session is in the process of being established.
  // The local system has sent an OPEN message. OpenConfirm refers to the state where
  // the session is in the process of being established. The local system has sent and
  // received an OPEN message and is awaiting a NOTIFICATION or KEEPALIVE message from
  // remote peer. Established refers to the state where the BGP session with the peer
  // is established.
  optional FsmState.Enum fsm_state = 16;
}

// The request to retrieve ISIS per Router metrics/statistics.
message IsisMetricsRequest {

  // The names of ISIS Routers to return results for. An empty list will return results
  // for all ISIS router.
  // 
  // x-constraint:
  // - /components/schemas/Device.IsisRouter/properties/name
  // 
  repeated string router_names = 1;

  message ColumnNames {
    enum Enum {
      unspecified = 0;
      l1_sessions_up = 1;
      l1_session_flap = 2;
      l1_database_size = 3;
      l1_broadcast_hellos_sent = 4;
      l1_broadcast_hellos_received = 5;
      l1_point_to_point_hellos_sent = 6;
      l1_point_to_point_hellos_received = 7;
      l1_psnp_sent = 8;
      l1_psnp_received = 9;
      l1_csnp_sent = 10;
      l1_csnp_received = 11;
      l1_lsp_sent = 12;
      l1_lsp_received = 13;
      l2_sessions_up = 14;
      l2_session_flap = 15;
      l2_database_size = 16;
      l2_broadcast_hellos_sent = 17;
      l2_broadcast_hellos_received = 18;
      l2_point_to_point_hellos_sent = 19;
      l2_point_to_point_hellos_received = 20;
      l2_psnp_sent = 21;
      l2_psnp_received = 22;
      l2_csnp_sent = 23;
      l2_csnp_received = 24;
      l2_lsp_sent = 25;
      l2_lsp_received = 26;
    }
  }
  // The list of column names that the returned result set will contain. If the list is
  // empty then all columns will be returned except for any result_groups. The name of
  // the ISIS Router cannot be excluded.
  repeated ColumnNames.Enum column_names = 2;
}

// ISIS per router statistics information.
message IsisMetric {

  // The name of a configured ISIS router.
  optional string name = 1;

  // The number of Level 1 (L1) sessions that are fully up.
  optional uint32 l1_sessions_up = 2;

  // The number of Level 1 Sessions Flap.
  optional uint32 l1_session_flap = 3;

  // Number of Level 1 Hello messages sent.
  optional uint64 l1_broadcast_hellos_sent = 4;

  // Number of Level 1 Hello messages received.
  optional uint64 l1_broadcast_hellos_received = 5;

  // Number of Level 1 Point-to-Point(P2P) Hello messages sent.
  optional uint64 l1_point_to_point_hellos_sent = 6;

  // Number of Level 1 Point-to-Point(P2P) Hello messages received.
  optional uint64 l1_point_to_point_hellos_received = 7;

  // Number of Link State Updates (LSPs) in the Level 1 LSP Databases.
  optional uint32 l1_database_size = 8;

  // Number of Level 1 (L1) Partial Sequence Number Packet (PSNPs) sent.
  optional uint64 l1_psnp_sent = 9;

  // Number of Level 1 (L1) Complete Sequence Number Packet (PSNPs) received.
  optional uint64 l1_psnp_received = 10;

  // Number of Level 1 (L1) Complete Sequence Number Packet (CSNPs) sent.
  optional uint64 l1_csnp_sent = 11;

  // Number of Level 1 (L1) Complete Sequence Number Packet (CSNPs) received.
  optional uint64 l1_csnp_received = 12;

  // Number of Level 1 (L1) Link State Protocol Data Units (LSPs) sent.
  optional uint32 l1_lsp_sent = 13;

  // Number of Level 1 (L1) Link State Protocol Data Units (LSPs) received.
  optional uint32 l1_lsp_received = 14;

  // The number of Level 2 (L2) sessions that are fully up.
  optional uint32 l2_sessions_up = 15;

  // The number of Level 2 Sessions Flap.
  optional uint32 l2_session_flap = 16;

  // Number of Level 2 Hello messages sent.
  optional uint64 l2_broadcast_hellos_sent = 17;

  // Number of Level 2 Hello messages received.
  optional uint64 l2_broadcast_hellos_received = 18;

  // Number of Level 2 Point-to-Point(P2P) Hello messages sent.
  optional uint64 l2_point_to_point_hellos_sent = 19;

  // Number of Level 2 Point-to-Point(P2P) Hello messages received.
  optional uint64 l2_point_to_point_hellos_received = 20;

  // Number of Link State Updates (LSPs) in the Level 2 LSP Databases.
  optional uint32 l2_database_size = 21;

  // Number of Level 2 (L2) Partial Sequence Number Packet (PSNPs) sent.
  optional uint64 l2_psnp_sent = 22;

  // Number of Level 2 (L2) Complete Sequence Number Packet (PSNPs) received.
  optional uint64 l2_psnp_received = 23;

  // Number of Level 2 (L2) Complete Sequence Number Packet (CSNPs) sent.
  optional uint64 l2_csnp_sent = 24;

  // Number of Level 2 (L2) Complete Sequence Number Packet (CSNPs) received.
  optional uint64 l2_csnp_received = 25;

  // Number of Level 2 (L2) Link State Protocol Data Units (LSPs) sent.
  optional uint32 l2_lsp_sent = 26;

  // Number of Level 2 (L2) Link State Protocol Data Units (LSPs) received.
  optional uint32 l2_lsp_received = 27;
}

// The request to retrieve per LAG metrics/statistics.
message LagMetricsRequest {

  // The names of LAGs to return results for. An empty list will return results for all
  // LAGs.
  // 
  // x-constraint:
  // - /components/schemas/Lag/properties/name
  // 
  repeated string lag_names = 1;

  message ColumnNames {
    enum Enum {
      unspecified = 0;
      oper_status = 1;
      member_ports_up = 2;
      frames_tx = 3;
      frames_rx = 4;
      bytes_tx = 5;
      bytes_rx = 6;
      frames_tx_rate = 7;
      frames_rx_rate = 8;
      bytes_tx_rate = 9;
      bytes_rx_rate = 10;
    }
  }
  // The list of column names that the returned result set will contain. If the list is
  // empty then all columns will be returned. The name of the LAG cannot be excluded.
  repeated ColumnNames.Enum column_names = 2;
}

// Description missing in models
message LagMetric {

  // The name of a configured LAG
  // 
  // x-constraint:
  // - /components/schemas/Lag/properties/name
  // 
  optional string name = 1;

  message OperStatus {
    enum Enum {
      unspecified = 0;
      up = 1;
      down = 2;
    }
  }
  // The current operational state of the LAG. The state can be up or down. State 'up'
  // indicates member_ports_up >= min_links.
  optional OperStatus.Enum oper_status = 2;

  // The number of LAG member ports up.
  optional uint64 member_ports_up = 3;

  // The current total number of frames transmitted.
  optional uint64 frames_tx = 4;

  // The current total number of valid frames received.
  optional uint64 frames_rx = 5;

  // The current total number of bytes transmitted.
  optional uint64 bytes_tx = 6;

  // The current total number of valid bytes received.
  optional uint64 bytes_rx = 7;

  // The current rate of frames transmitted.
  optional float frames_tx_rate = 8;

  // The current rate of valid frames received.
  optional float frames_rx_rate = 9;

  // The current rate of bytes transmitted.
  optional float bytes_tx_rate = 10;

  // The current rate of bytes received.
  optional float bytes_rx_rate = 11;
}

// The request to retrieve LACP per LAG member metrics/statistics.
message LacpMetricsRequest {

  // The names of LAG (ports group) for which LACP metrics to be returned. An empty list
  // will return metrics for all LAGs.
  // 
  // x-constraint:
  // - /components/schemas/Lag/properties/name
  // 
  repeated string lag_names = 1;

  // The names of LAG members (ports) for which LACP metrics to be returned. An empty
  // list will return metrics for all LAG members.
  // 
  // x-constraint:
  // - /components/schemas/Port/properties/name
  // 
  repeated string lag_member_port_names = 2;

  message ColumnNames {
    enum Enum {
      unspecified = 0;
      lacp_packets_rx = 1;
      lacp_packets_tx = 2;
      lacp_rx_errors = 3;
      activity = 4;
      timeout = 5;
      synchronization = 6;
      aggregatable = 7;
      collecting = 8;
      distributing = 9;
      system_id = 10;
      oper_key = 11;
      partner_id = 12;
      partner_key = 13;
      port_num = 14;
      partner_port_num = 15;
    }
  }
  // The list of column names that the returned result set will contain. If the list is
  // empty then all columns will be returned. The name of LAG and LAG member can not be
  // excluded.
  repeated ColumnNames.Enum column_names = 3;
}

// LACP metrics (statistics) per LAG member.
message LacpMetric {

  // The name of a LAG (ports group) configured with LACP.
  optional string lag_name = 1;

  // The name of a LAG member (port) configured with LACP.
  optional string lag_member_port_name = 2;

  // Number of LACPDUs received.
  optional uint64 lacp_packets_rx = 3;

  // Number of LACPDUs transmitted.
  optional uint64 lacp_packets_tx = 4;

  // Number of LACPDUs receive packet errors.
  optional uint64 lacp_rx_errors = 5;

  message Activity {
    enum Enum {
      unspecified = 0;
      active = 1;
      passive = 2;
    }
  }
  // Indicates participant is active or passive.
  optional Activity.Enum activity = 6;

  message Timeout {
    enum Enum {
      unspecified = 0;
      short = 1;
      long = 2;
    }
  }
  // The timeout type (short or long) used by the participant.
  optional Timeout.Enum timeout = 7;

  message Synchronization {
    enum Enum {
      unspecified = 0;
      in_sync = 1;
      out_sync = 2;
    }
  }
  // Indicates whether the participant is in-sync or out-of-sync.
  optional Synchronization.Enum synchronization = 8;

  // A true value indicates that the participant will allow the link to be used as part
  // of the aggregate. A false value indicates the link should be used as an  individual
  // link.
  optional bool aggregatable = 9;

  // If true, the participant is collecting incoming frames on the link, otherwise false.
  optional bool collecting = 10;

  // When true, the participant is distributing outgoing frames; when false, distribution
  // is disabled.
  optional bool distributing = 11;

  // MAC address that defines the local system ID for the aggregate interface.
  optional string system_id = 12;

  // Current operational value of the key for the aggregate interface.
  optional uint32 oper_key = 13;

  // MAC address representing the protocol partner's interface system ID.
  optional string partner_id = 14;

  // Operational value of the protocol partner's key.
  optional uint32 partner_key = 15;

  // Port number of the local (actor) aggregation member.
  optional uint32 port_num = 16;

  // Port number of the partner (remote) port for this member port.
  optional uint32 partner_port_num = 17;
}

// The request to retrieve LLDP per instance metrics/statistics.
message LldpMetricsRequest {

  // The names of LLDP instances to return results for. An empty list will return results
  // for all LLDP instances.
  // 
  // x-constraint:
  // - /components/schemas/Lldp/properties/name
  // 
  repeated string lldp_names = 1;

  message ColumnNames {
    enum Enum {
      unspecified = 0;
      frames_rx = 1;
      frames_tx = 2;
      frames_error_rx = 3;
      frames_discard = 4;
      tlvs_discard = 5;
      tlvs_unknown = 6;
    }
  }
  // The requested list of column names for the result set. If the list is empty then
  // metrics for all columns will be returned. The name of LLDP instance can not be excluded.
  repeated ColumnNames.Enum column_names = 2;
}

// LLDP per instance statistics information.
message LldpMetric {

  // The name of the configured LLDP instance.
  optional string name = 1;

  // Number of LLDP frames received.
  optional uint64 frames_rx = 2;

  // Number of LLDP frames transmitted.
  optional uint64 frames_tx = 3;

  // Number of LLDP frames received with packet errors. This stat should be incremented
  // based on statsFramesInErrorsTotal increment rule in section 10.3.2 of IEEE Std 802.1
  // AB-2005.
  optional uint64 frames_error_rx = 4;

  // Number of LLDP frames received that are discarded. This stat should be incremented
  // when one or more of the three mandatory  TLVs at the beginning of the LLDPDU is missing,
  // out of order or  contains an out of range information string length. This stat should
  // follow the validation rules in section 10.3.2 of IEEE  Std 802.1 AB-2005.
  optional uint64 frames_discard = 5;

  // Number of LLDP tlvs received that are discarded. If any TLV contains  an error condition
  // specific for that particular TLV or if any TLV  extends past the physical end of
  // the frame then these TLVs will be discarded.
  optional uint64 tlvs_discard = 6;

  // Number of LLDP unknown tlvs received. If the OUI of the organizationlly specific
  // TLV and/or organizationally defined subtype are not recognized,or if TLV type  value
  // is in the range of reserved TLV types then these TLVs will be considered as  unknown
  // TLVs.
  optional uint64 tlvs_unknown = 7;
}

// The request to retrieve RSVP-TE per Router metrics/statistics.
message RsvpMetricsRequest {

  // The names of RSVP-TE Routers to return results for. An empty list as input will return
  // results for all RSVP-TE routers.
  // 
  // x-constraint:
  // - /components/schemas/Device.Rsvp/properties/name
  // 
  repeated string router_names = 1;

  message ColumnNames {
    enum Enum {
      unspecified = 0;
      ingress_p2p_lsps_configured = 1;
      ingress_p2p_lsps_up = 2;
      egress_p2p_lsps_up = 3;
      lsp_flap_count = 4;
      paths_tx = 5;
      paths_rx = 6;
      resvs_tx = 7;
      resvs_rx = 8;
      path_tears_tx = 9;
      path_tears_rx = 10;
      resv_tears_tx = 11;
      resv_tears_rx = 12;
      path_errors_tx = 13;
      path_errors_rx = 14;
      resv_errors_tx = 15;
      resv_errors_rx = 16;
      resv_conf_tx = 17;
      resv_conf_rx = 18;
      hellos_tx = 19;
      hellos_rx = 20;
      acks_tx = 21;
      acks_rx = 22;
      nacks_tx = 23;
      nacks_rx = 24;
      srefresh_tx = 25;
      srefresh_rx = 26;
      bundle_tx = 27;
      bundle_rx = 28;
      path_reevaluation_request_tx = 29;
      path_reoptimizations = 30;
    }
  }
  // The list of column names that the returned result set will contain. If the input
  // list is empty then all columns will be returned except for any result_groups.
  // 
  repeated ColumnNames.Enum column_names = 2;
}

// RSVP-TE per router statistics information.
message RsvpMetric {

  // The name of a configured RSVP router.
  optional string name = 1;

  // The number of ingress point-to-point LSPs configured or transiting through the RSVP
  // router which have been initated from the test port.
  optional uint32 ingress_p2p_lsps_configured = 2;

  // The number of ingress point-to-point LSPs for which Resv has been received and is
  // currently up.
  optional uint32 ingress_p2p_lsps_up = 3;

  // The number of egress point-to-point LSPs for which Path requests were successfully
  // processed and is currently up.
  optional uint32 egress_p2p_lsps_up = 4;

  // The number of times an LSP went from up to down state either because it timed out
  // while waiting for Refreshes or  a PathTear or ResvTear message was received which
  // caused the LSP to flap.
  optional uint32 lsp_flap_count = 5;

  // The number of Path messages sent by this RSVP router.
  optional uint64 paths_tx = 6;

  // The number of Path messages received by this RSVP router.
  optional uint64 paths_rx = 7;

  // The number of Resv messages sent by this RSVP router.
  optional uint64 resvs_tx = 8;

  // The number of Resv messages received by this RSVP router.
  optional uint64 resvs_rx = 9;

  // The number of  Path Tear messages sent by this RSVP router.
  optional uint64 path_tears_tx = 10;

  // The number of Path Tear messages received by this RSVP router.
  optional uint64 path_tears_rx = 11;

  // The number of  Resv Tear messages sent by this RSVP router.
  optional uint64 resv_tears_tx = 12;

  // The number of Resv Tear messages received by this RSVP router.
  optional uint64 resv_tears_rx = 13;

  // The number of Path Error messages sent by this RSVP router.
  optional uint64 path_errors_tx = 14;

  // The number of Path Error messages received by this RSVP router.
  optional uint64 path_errors_rx = 15;

  // The number of Resv Error messages sent by this RSVP router.
  optional uint64 resv_errors_tx = 16;

  // The number of Resv Error messages received by this RSVP router.
  optional uint64 resv_errors_rx = 17;

  // The number of ResvConf messages sent by this RSVP router.
  optional uint64 resv_conf_tx = 18;

  // The number of ResvConf messages received by this RSVP router.
  optional uint64 resv_conf_rx = 19;

  // The number of Hello messages sent by this RSVP router.
  optional uint64 hellos_tx = 20;

  // The number of Hello messages received by this RSVP router.
  optional uint64 hellos_rx = 21;

  // The number of Ack messages sent by this RSVP router.
  optional uint64 acks_tx = 22;

  // The number of Ack messages received by this RSVP router.
  optional uint64 acks_rx = 23;

  // The number of Nack messages sent by this RSVP router.
  optional uint64 nacks_tx = 24;

  // The number of Nack messages received by this RSVP router.
  optional uint64 nacks_rx = 25;

  // The number of SRefresh messages sent by this RSVP router.
  optional uint64 srefresh_tx = 26;

  // The number of SRefresh messages received by this RSVP router.
  optional uint64 srefresh_rx = 27;

  // The number of Bundle messages sent by this RSVP router.
  optional uint64 bundle_tx = 28;

  // The number of Bundle messages received by this RSVP router.
  optional uint64 bundle_rx = 29;

  // The number of Path messages with Path Re-evaluation Request enabled sent by this
  // RSVP router.
  optional uint64 path_reevaluation_request_tx = 30;

  // The number of successfully completed Make-Before-Break operations on LSPs on this
  // RSVP router.
  optional uint64 path_reoptimizations = 31;
}

// Request to traffic generator for states of choice
message StatesRequest {

  message Choice {
    enum Enum {
      unspecified = 0;
      ipv4_neighbors = 1;
      ipv6_neighbors = 2;
      bgp_prefixes = 3;
      isis_lsps = 4;
      lldp_neighbors = 5;
      rsvp_lsps = 6;
    }
  }
  // Description missing in models
  // default = Choice.Enum.ipv4_neighbors
  optional Choice.Enum choice = 1;

  // Description missing in models
  optional Neighborsv4StatesRequest ipv4_neighbors = 2;

  // Description missing in models
  optional Neighborsv6StatesRequest ipv6_neighbors = 3;

  // Description missing in models
  optional BgpPrefixStateRequest bgp_prefixes = 4;

  // Description missing in models
  optional IsisLspsStateRequest isis_lsps = 5;

  // Description missing in models
  optional LldpNeighborsStateRequest lldp_neighbors = 6;

  // Description missing in models
  optional RsvpLspsStateRequest rsvp_lsps = 7;
}

// Response containing chosen traffic generator states
message StatesResponse {

  message Choice {
    enum Enum {
      unspecified = 0;
      ipv4_neighbors = 1;
      ipv6_neighbors = 2;
      bgp_prefixes = 3;
      isis_lsps = 4;
      lldp_neighbors = 5;
      rsvp_lsps = 6;
    }
  }
  // Description missing in models
  // default = Choice.Enum.ipv4_neighbors
  optional Choice.Enum choice = 1;

  // Description missing in models
  repeated Neighborsv4State ipv4_neighbors = 2;

  // Description missing in models
  repeated Neighborsv6State ipv6_neighbors = 3;

  // Description missing in models
  repeated BgpPrefixesState bgp_prefixes = 4;

  // Description missing in models
  repeated IsisLspsState isis_lsps = 5;

  // Description missing in models
  repeated LldpNeighborsState lldp_neighbors = 6;

  // Description missing in models
  repeated RsvpLspsState rsvp_lsps = 7;
}

// The request to retrieve IPv4 Neighbor state (ARP cache entries) of a network interface(s).
message Neighborsv4StatesRequest {

  // The names of Ethernet interfaces for which Neighbor state (ARP cache entries) will
  // be retrieved. If no names are specified then the results will contain Neighbor state
  // (ARP cache entries) for all available Ethernet interfaces.
  // 
  // x-constraint:
  // - /components/schemas/Device.Ethernet/properties/name
  // 
  repeated string ethernet_names = 1;
}

// IPv4 Neighbor state (ARP cache entry).
message Neighborsv4State {

  // The name of the Ethernet interface associated with the Neighbor state (ARP cache
  // entry).
  // required = true
  string ethernet_name = 1;

  // The IPv4 address of the neighbor.
  // required = true
  string ipv4_address = 2;

  // The link-layer address (MAC) of the neighbor.
  optional string link_layer_address = 3;
}

// The request to retrieve IPv6 Neighbor state (NDISC cache entries) of a network interface(s).
message Neighborsv6StatesRequest {

  // The names of Ethernet interfaces for which Neighbor state (NDISC cache entries) will
  // be retrieved. If no names are specified then the results will contain Neighbor state
  // (NDISC cache entries) for all available Ethernet interfaces.
  // 
  // x-constraint:
  // - /components/schemas/Device.Ethernet/properties/name
  // 
  repeated string ethernet_names = 1;
}

// IPv6 Neighbor state (NDISC cache entry).
message Neighborsv6State {

  // The name of the Ethernet interface associated with the Neighbor state (NDISC cache
  // entry).
  // required = true
  string ethernet_name = 1;

  // The IPv6 address of the neighbor.
  // required = true
  string ipv6_address = 2;

  // The link-layer address (MAC) of the neighbor.
  optional string link_layer_address = 3;
}

// The request to retrieve BGP peer prefix information.
message BgpPrefixStateRequest {

  // The names of BGP peers for which prefix information will be retrieved. If no names
  // are specified then the results will contain prefix information for all configured
  // BGP peers.
  // 
  // x-constraint:
  // - /components/schemas/Bgp.V4Peer/properties/name
  // - /components/schemas/Bgp.V6Peer/properties/name
  // 
  repeated string bgp_peer_names = 1;

  message PrefixFilters {
    enum Enum {
      unspecified = 0;
      ipv4_unicast = 1;
      ipv6_unicast = 2;
    }
  }
  // Specify which prefixes to return. If the list is empty or missing then all prefixes
  // will be returned.
  repeated PrefixFilters.Enum prefix_filters = 2;

  // The IPv4 unicast results can be filtered by specifying additional prefix search criteria.
  // If the ipv4_unicast_filters property is missing or empty then all IPv4 prefixes will
  // be returned.
  repeated BgpPrefixIpv4UnicastFilter ipv4_unicast_filters = 3;

  // The IPv6 unicast results can be filtered by specifying additional prefix search criteria.
  // If the ipv6_unicast_filters property is missing or empty then all IPv6 prefixes will
  // be returned.
  repeated BgpPrefixIpv6UnicastFilter ipv6_unicast_filters = 4;
}

// Description missing in models
message BgpPrefixIpv4UnicastFilter {

  // The addresses to match. If the addresses property is missing or empty then all addresses
  // will match.
  repeated string addresses = 1;

  // The prefix length to match. If the prefix length is missing then all prefix lengths
  // will match.
  optional uint32 prefix_length = 2;

  message Origin {
    enum Enum {
      unspecified = 0;
      igp = 1;
      egp = 2;
      incomplete = 3;
    }
  }
  // The origin to match. If the origin is missing then all origins will match.
  optional Origin.Enum origin = 3;

  // The path id to match. If the path id is missing then all path ids will match.
  optional uint32 path_id = 4;
}

// Description missing in models
message BgpPrefixIpv6UnicastFilter {

  // The addresses to match. If the addresses property is missing or empty then all addresses
  // will match.
  repeated string addresses = 1;

  // The prefix length to match. If the prefix length is missing then all prefix lengths
  // will match.
  optional uint32 prefix_length = 2;

  message Origin {
    enum Enum {
      unspecified = 0;
      igp = 1;
      egp = 2;
      incomplete = 3;
    }
  }
  // The origin to match. If the origin is missing then all origins will match.
  optional Origin.Enum origin = 3;

  // The path id to match. If the path id is missing then all path ids will match.
  optional uint32 path_id = 4;
}

// BGP peer prefixes.
message BgpPrefixesState {

  // The name of a BGP peer.
  optional string bgp_peer_name = 1;

  // Description missing in models
  repeated BgpPrefixIpv4UnicastState ipv4_unicast_prefixes = 2;

  // Description missing in models
  repeated BgpPrefixIpv6UnicastState ipv6_unicast_prefixes = 3;
}

// IPv4 unicast prefix.
message BgpPrefixIpv4UnicastState {

  // An IPv4 unicast address
  optional string ipv4_address = 1;

  // The length of the prefix.
  optional uint32 prefix_length = 2;

  message Origin {
    enum Enum {
      unspecified = 0;
      igp = 1;
      egp = 2;
      incomplete = 3;
    }
  }
  // The origin of the prefix.
  optional Origin.Enum origin = 3;

  // The path id.
  optional uint32 path_id = 4;

  // The IPv4 address of the egress interface.
  optional string ipv4_next_hop = 5;

  // The IPv6 address of the egress interface.
  optional string ipv6_next_hop = 6;

  // Optional community attributes.
  repeated ResultBgpCommunity communities = 7;

  // Description missing in models
  optional ResultBgpAsPath as_path = 8;
}

// IPv6 unicast prefix.
message BgpPrefixIpv6UnicastState {

  // An IPv6 unicast address
  optional string ipv6_address = 1;

  // The length of the prefix.
  optional uint32 prefix_length = 2;

  message Origin {
    enum Enum {
      unspecified = 0;
      igp = 1;
      egp = 2;
      incomplete = 3;
    }
  }
  // The origin of the prefix.
  optional Origin.Enum origin = 3;

  // The path id.
  optional uint32 path_id = 4;

  // The IPv4 address of the egress interface.
  optional string ipv4_next_hop = 5;

  // The IPv6 address of the egress interface.
  optional string ipv6_next_hop = 6;

  // Optional community attributes.
  repeated ResultBgpCommunity communities = 7;

  // Description missing in models
  optional ResultBgpAsPath as_path = 8;
}

// BGP communities provide additional capability for tagging routes and  for modifying
// BGP routing policy on upstream and downstream routers. BGP community is a 32-bit
// number which is broken into 16-bit AS number and  a 16-bit custom value.
message ResultBgpCommunity {

  message Type {
    enum Enum {
      unspecified = 0;
      manual_as_number = 1;
      no_export = 2;
      no_advertised = 3;
      no_export_subconfed = 4;
      llgr_stale = 5;
      no_llgr = 6;
    }
  }
  // The type of community AS number. If community type is manual_as_number then as_number
  // and as_custom will be available.
  optional Type.Enum type = 1;

  // First two octets of 32 bit community AS number.
  optional uint32 as_number = 2;

  // Last two octets of the community value.
  optional uint32 as_custom = 3;
}

// This attribute identifies the autonomous systems through  which routing information
// carried in this UPDATE message has passed.
message ResultBgpAsPath {

  // AS Path segments present in the received AS Path attribute.
  repeated ResultBgpAsPathSegment segments = 1;
}

// Configuration for a single BGP AS path segment
message ResultBgpAsPathSegment {

  message Type {
    enum Enum {
      unspecified = 0;
      as_seq = 1;
      as_set = 2;
      as_confed_seq = 3;
      as_confed_set = 4;
    }
  }
  // AS sequence is the most common type of AS_PATH, it contains the  list of ASNs starting
  // with the most recent ASN being added read  from left to right.
  // The other three AS_PATH types are used for Confederations - AS_SET is the type of
  // AS_PATH attribute that summarizes routes using using the aggregate-address command,
  // allowing AS_PATHs to be  summarized in the update as well. - AS_CONFED_SEQ gives
  // the list of ASNs in the path starting with the  most recent ASN to be added reading
  // left to right - AS_CONFED_SET will allow summarization of multiple AS PATHs to be
  // sent in BGP Updates.
  optional Type.Enum type = 1;

  // The AS numbers in this AS path segment.
  repeated uint32 as_numbers = 2;
}

// The request to retrieve ISIS Link State PDU (LSP) information learned by the router.
message IsisLspsStateRequest {

  // The names of ISIS routers for which learned information is requested. An empty list
  // will return results for all ISIS routers.
  // 
  // x-constraint:
  // - /components/schemas/Device.IsisRouter/properties/name
  // 
  repeated string isis_router_names = 1;
}

// The result of ISIS LSP information that are retrieved.
message IsisLspsState {

  // The name of the ISIS Router.
  optional string isis_router_name = 1;

  // One or more LSPs that are learned by this ISIS router.
  repeated IsisLspState lsps = 2;
}

// ISIS LSP.
message IsisLspState {

  // LSP ID in the format, e.g. '640000000001-00-00'. LSP ID consists of the System ID
  // of a neighbor, the Pseudonode ID, and the LSP number. The last two bytes represent
  // Pseudonode ID and LSP number respectively. A pseudonode is a logical representation
  // of the LAN which is generated by a Designated Intermediate System (DIS) on a LAN
  // segment. If one LSP exceeds the maximum LSP size then it is sent in another LSP with
  // the LSP number incremented by one. A router's learned LSP gets refreshed by 'remaining_lifetime'.
  // Then the sequence number is incremented by 1.
  // required = true
  string lsp_id = 1;

  message PduType {
    enum Enum {
      unspecified = 0;
      level_1 = 1;
      level_2 = 2;
    }
  }
  // Link State PDU type.
  optional PduType.Enum pdu_type = 2;

  // Remaining lifetime in seconds before LSP expires.
  optional uint64 remaining_lifetime = 3;

  // Sequence number of the LSP.
  optional uint64 sequence_number = 4;

  // Total length of the LSP.
  optional uint32 pdu_length = 5;

  // LSP Type-Block flags.
  optional IsisLspFlags flags = 6;

  // IS Type - bits 1 and 2 indicate the type of Intermediate System.
  // 1 - ( i.e. bit 1 set) Level 1 Intermediate system.
  // 2 - Unused value.
  // 3 - (i.e. bits 1 and 2 set) Level 2 Intermediate system.
  optional uint32 is_type = 7;

  // It refers to Link State PDU State TLVs container.
  optional IsisLspTlvs tlvs = 8;
}

// This contains the list of TLVs present in one LSP.
message IsisLspTlvs {

  // Array of Hostname TLVs ( type 137) present in this LSP.
  repeated IsisLspHostname hostname_tlvs = 1;

  // Array of IS-Reachability TLVs (type 2) present in this LSP.
  repeated IsisLspIsReachabilityTlv is_reachability_tlvs = 2;

  // Array of Extended IS-Reachability TLVs (type 22) present in this LSP.
  repeated IsisLspExtendedIsReachabilityTlv extended_is_reachability_tlvs = 3;

  // Array of IPv4 Internal Reachability TLVs (type 128) present in this LSP.
  repeated IsisLspIpv4InternalReachabilityTlv ipv4_internal_reachability_tlvs = 4;

  // Array of IPv4 External Reachability TLVs (type 130) present in this LSP.
  repeated IsisLspIpv4ExternalReachabilityTlv ipv4_external_reachability_tlvs = 5;

  // Array of IPv4 Extended Reachability TLVs (type 135) present in this LSP.
  repeated IsisLspExtendedIpv4ReachabilityTlv extended_ipv4_reachability_tlvs = 6;

  // Array of IPv6 Reachability TLVs (type 236) present in this LSP.
  repeated IsisLspIpv6ReachabilityTlv ipv6_reachability_tlvs = 7;
}

// It contains Hostname for the TLV 137.
message IsisLspHostname {

  // Hostname for an ISIS router.
  optional string hostname = 1;
}

// LSP Type flags.
message IsisLspFlags {

  // When set, the originator supports partition repair.
  optional bool partition_repair = 1;

  // When set, the originator is attached to another area using the referred metric.
  optional bool attached_error = 2;

  // When set, the originator is attached to another
  // area using the referred metric.
  optional bool attached_expense = 3;

  // Delay Metric - when set, the originator is attached to another
  // area using the referred metric.
  optional bool attached_delay = 4;

  // Default Metric - when set, the originator is attached to another
  // area using the referred metric.
  optional bool attached_default = 5;

  // Overload bit - when set, the originator is overloaded, and must
  // be avoided in path calculation.
  optional bool overload = 6;
}

// This container describes list of ISIS neighbors and attributes in IS-Reachability
// TLV (type 2).
message IsisLspIsReachabilityTlv {

  // This container describes Intermediate System (IS) neighbors.
  repeated IsisLspneighbor neighbors = 1;
}

// This is list of ISIS neighbors and attributes in Extended-IS-Reachability TLV (type
// 22).
message IsisLspExtendedIsReachabilityTlv {

  // This container describes IS neighbors.
  repeated IsisLspneighbor neighbors = 1;
}

// This contains IS neighbors.
message IsisLspneighbor {

  // The System ID for this emulated ISIS router, e.g. 640100010000.
  optional string system_id = 1;
}

// This container defines list of IPv4 internal reachability information in one IPv4
// internal reachability TLV.
// This is advertised when the origin-type is set 'internal' in route range configurations.
message IsisLspIpv4InternalReachabilityTlv {

  // Describes list of IPv4 prefixes in this TLV.
  repeated IsisLspV4Prefix prefixes = 1;
}

// This container defines list of IPv4 external reachability information in one IPv4
// external reachability TLV.
// This is advertised when the origin-type is set 'external' in route range configurations.
message IsisLspIpv4ExternalReachabilityTlv {

  // Describes list of IPv4 prefixes in this TLV..
  repeated IsisLspV4Prefix prefixes = 1;
}

// This group defines attributes of an IPv4 standard prefix.
message IsisLspV4Prefix {

  // An IPv4 unicast prefix reachable via the originator of this LSP.
  optional string ipv4_address = 1;

  // The length of the IPv4 prefix.
  optional uint32 prefix_length = 2;

  message RedistributionType {
    enum Enum {
      unspecified = 0;
      up = 1;
      down = 2;
    }
  }
  // Up (0)-used when a prefix is initially advertised within the ISIS L3 hierarchy,
  // and for all other prefixes in L1 and L2 LSPs. (default)
  // Down (1)-used when an L1/L2 router advertises L2 prefixes in L1 LSPs.
  // The prefixes are being advertised from a higher level (L2) down to a lower level
  // (L1).
  optional RedistributionType.Enum redistribution_type = 3;

  // ISIS default metric value.
  optional uint32 default_metric = 4;

  message OriginType {
    enum Enum {
      unspecified = 0;
      internal = 1;
      external = 2;
    }
  }
  // The origin of the advertised route-internal or external to the ISIS area. Options
  // include the following:
  // Internal-for intra-area routes, through Level 1 LSPs.
  // External-for inter-area routes redistributed within L1, through Level
  // 1 LSPs.
  optional OriginType.Enum origin_type = 5;
}

// This container defines list of IPv4 extended reachability information in one Extended
// IPv4 External Reachability TLV.
// It is advertised when the 'wide metric' is enabled.
message IsisLspExtendedIpv4ReachabilityTlv {

  // IPv4 prefix contained within extended reachability TLVs.
  repeated IsisLspExtendedV4Prefix prefixes = 1;
}

// This group defines attributes of an IPv4 standard prefix.
message IsisLspExtendedV4Prefix {

  // An IPv4 unicast prefix reachable via the originator of this LSP.
  optional string ipv4_address = 1;

  // The length of the IPv4 prefix.
  optional uint32 prefix_length = 2;

  // ISIS wide metric.
  optional uint32 metric = 3;

  message RedistributionType {
    enum Enum {
      unspecified = 0;
      up = 1;
      down = 2;
    }
  }
  // Up (0)-used when a prefix is initially advertised within the ISIS L3 hierarchy,
  // and for all other prefixes in L1 and L2 LSPs. (default)
  // Down (1)-used when an L1/L2 router advertises L2 prefixes in L1 LSPs.
  // The prefixes are being advertised from a higher level (L2) down to a lower level
  // (L1).
  optional RedistributionType.Enum redistribution_type = 4;

  // Description missing in models
  optional IsisLspPrefixAttributes prefix_attributes = 5;
}

// It defines list of IPv6 extended reachability information in one IPv6 Reachability
// TLV.
message IsisLspIpv6ReachabilityTlv {

  // IPv6 prefix contained within reachability TLVs.
  repeated IsisLspV6Prefix prefixes = 1;
}

// It defines attributes of an IPv6 standard prefix.
message IsisLspV6Prefix {

  // An IPv6 unicast prefix reachable via the originator of this LSP.
  optional string ipv6_address = 1;

  // The length of the IPv6 prefix.
  optional uint32 prefix_length = 2;

  // ISIS wide metric.
  optional uint32 metric = 3;

  message RedistributionType {
    enum Enum {
      unspecified = 0;
      up = 1;
      down = 2;
    }
  }
  // Up (0)-used when a prefix is initially advertised within the ISIS L3 hierarchy,
  // and for all other prefixes in L1 and L2 LSPs. (default)
  // Down (1)-used when an L1/L2 router advertises L2 prefixes in L1 LSPs.
  // The prefixes are being advertised from a higher level (L2) down to a lower level
  // (L1).
  optional RedistributionType.Enum redistribution_type = 4;

  message OriginType {
    enum Enum {
      unspecified = 0;
      internal = 1;
      external = 2;
    }
  }
  // The origin of the advertised route-internal or external to the ISIS area. Options
  // include the following:
  // Internal-for intra-area routes, through Level 1 LSPs.
  // External-for inter-area routes redistributed within L1, through Level
  // 1 LSPs.
  optional OriginType.Enum origin_type = 5;

  // Description missing in models
  optional IsisLspPrefixAttributes prefix_attributes = 6;
}

// This contains the properties of ISIS Prefix attributes for  the extended IPv4 and
// IPv6 reachability. https://www.rfc-editor.org/rfc/rfc7794.html
message IsisLspPrefixAttributes {

  // External Prefix Flag (Bit 0)
  optional bool x_flag = 1;

  // Re-advertisement Flag (Bit 1)
  optional bool r_flag = 2;

  // Node Flag (Bit 2)
  optional bool n_flag = 3;
}

// The request to retrieve LLDP neighbor information for a given instance.
message LldpNeighborsStateRequest {

  // The names of LLDP instances for which neighbor information will be retrieved. If
  // no names are specified then the results will contain neighbor information for all
  // configured LLDP instances.
  // 
  // x-constraint:
  // - /components/schemas/Lldp/properties/name
  // 
  repeated string lldp_names = 1;

  // Specify the neighbors for which information will be returned. If empty  or missing
  // then information for all neighbors will be returned.
  repeated string neighbor_id_filters = 2;
}

// LLDP neighbor information.
message LldpNeighborsState {

  // The name of the LLDP instance.
  optional string lldp_name = 1;

  // The system name field shall contain an alpha-numeric string that  indicates the system's
  // administratively assigned name. The system name  should be the system's fully qualified
  // domain name. If implementations  support IETF RFC 3418, the sysName object should
  // be used for this field.
  optional string system_name = 2;

  // The system description field shall contain an alpha-numeric string that  is the textual
  // description of the network entity. The system description  should include the full
  // name and version identification of the system's  hardware type, software operating
  // system, and networking software. If  implementations support IETF RFC 3418, the sysDescr
  // object should be used  for this field.
  optional string system_description = 3;

  // The Chassis ID is a mandatory TLV which identifies the chassis component of  the
  // endpoint identifier associated with the transmitting LLDP agent.
  optional string chassis_id = 4;

  message ChassisIdType {
    enum Enum {
      unspecified = 0;
      port_component = 1;
      network_address = 2;
      chassis_component = 3;
      mac_address = 4;
      interface_name = 5;
      local = 6;
      interface_alias = 7;
    }
  }
  // This field identifies the format and source of the chassis identifier string.  It
  // is an enumerator defined by the LldpChassisIdSubtype object from IEEE 802.1AB  MIB.
  optional ChassisIdType.Enum chassis_id_type = 5;

  // System generated identifier for the neighbor on the LLDP instance.
  optional string neighbor_id = 6;

  // Age since discovery in seconds.
  optional uint64 age = 7;

  // Seconds since last update received.
  optional uint64 last_update = 8;

  // The time-to-live (TTL) in seconds is a mandatory TLV which indicates how long information
  // from the neighbor  should be considered valid.
  optional uint32 ttl = 9;

  // The Port ID is a mandatory TLV which identifies the port component of the endpoint
  // identifier associated with  the transmitting LLDP agent. If the specified port is
  // an IEEE 802.3 Repeater port, then this TLV is optional.
  optional string port_id = 10;

  message PortIdType {
    enum Enum {
      unspecified = 0;
      port_component = 1;
      network_address = 2;
      agent_circuit_id = 3;
      mac_address = 4;
      interface_name = 5;
      local = 6;
      interface_alias = 7;
    }
  }
  // This field identifies the format and source of the port identifier string. It is
  // an enumerator defined by the PtopoPortIdType object from RFC2922.
  optional PortIdType.Enum port_id_type = 11;

  // The binary string containing the actual port identifier for the port which this LLDP
  // PDU was transmitted. The source  and format of this field is defined by PtopoPortId
  // from RFC2922.
  optional string port_description = 12;

  // The Management Address is a mandatory TLV which identifies a network address associated
  // with the local LLDP agent, which  can be used to reach the agent on the port identified
  // in the Port ID TLV.
  optional string management_address = 13;

  // The enumerated value for the network address type identified in this TLV. This enumeration
  // is defined in the 'Assigned Numbers'  RFC [RFC3232] and the ianaAddressFamilyNumbers
  // object.
  optional string management_address_type = 14;

  // Description missing in models
  repeated LldpCustomTLVState custom_tlvs = 15;

  // Description missing in models
  repeated LldpCapabilityState capabilities = 16;
}

// Custom TLV received from a neighbor.Custom TLVs are organization specific TLVs advertised
// with TLV type 127.
message LldpCustomTLVState {

  // The integer value identifying the type of information contained in the value field.
  optional uint32 custom_type = 1;

  // The organizationally unique identifier field shall contain the organization's OUI
  // as defined in Clause 9 of IEEE Std 802. The high-order octet is 0 and the low-order
  // 3 octets are the SMI Network Management Private Enterprise Code of the Vendor in
  // network byte order,  as defined in the 'Assigned Numbers' RFC [RFC3232].
  optional string oui = 2;

  // The organizationally defined subtype field shall contain a unique subtype value assigned
  // by the defining organization.
  optional string oui_subtype = 3;
}

// LLDP system capability advertised by the neighbor
message LldpCapabilityState {

  message CapabilityName {
    enum Enum {
      unspecified = 0;
      mac_bridge = 1;
      two_port_mac_relay = 2;
      repeater = 3;
      docsis_cable_device = 4;
      s_vlan = 5;
      telephone = 6;
      other = 7;
      router = 8;
      c_vlan = 9;
      station_only = 10;
      wlan_access_point = 11;
    }
  }
  // Name of the system capability advertised by the neighbor. Capabilities are represented
  // in a bitmap that defines the primary functions of the system.  The capabilities are
  // defined in IEEE 802.1AB.
  optional CapabilityName.Enum capability_name = 1;

  // Indicates whether the corresponding system capability is enabled on the neighbor.
  optional bool capability_enabled = 2;
}

// The request to retrieve RSVP Label Switched Path (LSP) information learned by the
// router.
message RsvpLspsStateRequest {

  // The names of RSVP-TE routers for which learned information is requested. An empty
  // list will return results for all RSVP=TE routers.
  // 
  // x-constraint:
  // - /components/schemas/Device.Rsvp/properties/name
  // 
  repeated string rsvp_router_names = 1;
}

// Discovered IPv4 Point-to-Point LSPs of a RSVP-TE router.
message RsvpLspsState {

  // The name of the RSVP-TE Router.
  optional string rsvp_router_name = 1;

  // IPv4 Point-to-Point RSVP-TE Discovered LSPs.
  repeated RsvpIPv4LspState ipv4_lsps = 2;
}

// IPv4 RSVP-TE Discovered LSPs.
message RsvpIPv4LspState {

  // The origin IPv4 address of RSVP session.
  optional string source_address = 1;

  // The IPv4 destination address of RSVP session.
  optional string destination_address = 2;

  // It refers to the RSVP LSP properties.
  optional RsvpLspState lsp = 3;

  // It refers to RSVP RRO objects container.
  repeated RsvpLspIpv4Rro rros = 4;

  // It refers to RSVP ERO objects container.
  repeated RsvpLspIpv4Ero eros = 5;
}

// IPv4 RSVP-TE Discovered LSPs.
message RsvpLspState {

  // The tunnel id of RSVP session which acts as an identifier that remains constant over
  // the life of the tunnel.
  optional uint32 tunnel_id = 1;

  // The lsp-id of RSVP session which acts as a differentiator for two lsps originating
  // from the same headend, commonly used to distinguish RSVP sessions during make before
  // break operations.
  optional uint32 lsp_id = 2;

  // The value of RSVP-TE Session Name field of the Session Attribute object.
  optional string session_name = 3;

  // The label received by RSVP-TE ingress.
  optional uint32 label_in = 4;

  // The label assigned by RSVP-TE egress.
  optional uint32 label_out = 5;

  message SessionStatus {
    enum Enum {
      unspecified = 0;
      up = 1;
      down = 2;
    }
  }
  // Operational state of the RSVP LSP.
  optional SessionStatus.Enum session_status = 6;

  message LastFlapReason {
    enum Enum {
      unspecified = 0;
      resv_tear = 1;
      path_tear = 2;
      path_timeout = 3;
    }
  }
  // The reason for the last flap of this RSVP session.
  optional LastFlapReason.Enum last_flap_reason = 7;

  // The tunnel UP time in milli seconds. If the tunnel is DOWN the UP time will be zero.
  optional uint64 up_time = 8;
}

// This contains the list of Record Route Object(RRO) objects associated with the traffic
// engineering tunnel. The  Record Route Object(RRO) is used in RSVP-TE to record the
// route traversed by the LSP. The RRO might be present in both   Path message and Resv
// message, the RRO stores the IP addresses of the routers that the traffic engineering
// tunnel  traversed and also the label generated and distributed by the routers. The
// RROs in the Resv message mirrors that of  the Path message, the only difference is
// that the RRO in a Resv message records the path information in the reverse  direction.
// 
message RsvpLspIpv4Rro {

  // The IPv4 addresses of the routers that the traffic engineering tunnel traversed.
  optional string address = 1;

  // Label reported for RRO hop. When the Label_Recording flag is set in the Session Attribute
  // object, nodes doing route recording should include the Label Record subobject containing
  // the reported label.
  optional uint32 reported_label = 2;
}

// This contains the list of sub-objects included in the Explicit Route Object(ERO)
// object send in the PATH message from the ingress. These sub-objects contain the intermediate
// hops to be traversed by the LSP while being forwarded  towards the egress endpoint.
message RsvpLspIpv4Ero {

  // The IPv4 prefix indicated by the ERO. Specified only when the ERO hop is an IPv4
  // prefix.
  optional string prefix = 1;

  // The autonomous system number indicated by the ERO. Specified only when the ERO hop
  // is an  2 or 4-byte AS number.
  optional uint32 asn = 2;

  message Type {
    enum Enum {
      unspecified = 0;
      ipv4 = 1;
      ipv6 = 2;
      asn = 3;
      asn4 = 4;
      label = 5;
      unnumbered_interface = 6;
    }
  }
  // The type indicated by the ERO.
  optional Type.Enum type = 3;
}

// The capture result request to the traffic generator. Stops the port capture on the
// port_name and returns the capture.
message CaptureRequest {

  // The name of a port a capture is started on.
  // 
  // x-constraint:
  // - /components/schemas/Port/properties/name
  // 
  // required = true
  string port_name = 1;
}

// mac counter pattern
message PatternFlowEthernetDstCounter {

  // Description missing in models
  // default = 00:00:00:00:00:00
  optional string start = 1;

  // Description missing in models
  // default = 00:00:00:00:00:01
  optional string step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowEthernetDstMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 48
  optional uint32 length = 3;
}

// Destination MAC address
message PatternFlowEthernetDst {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      auto = 1;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.auto
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 00:00:00:00:00:00
  optional string value = 2;

  // Description missing in models
  // default = ['00:00:00:00:00:00']
  repeated string values = 3;

  // The OTG implementation can provide a system generated
  // value for this property. If the OTG is unable to generate a value
  // the default value must be used.
  // default = 00:00:00:00:00:00
  optional string auto = 4;

  // Description missing in models
  optional PatternFlowEthernetDstCounter increment = 6;

  // Description missing in models
  optional PatternFlowEthernetDstCounter decrement = 7;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowEthernetDstMetricTag metric_tags = 8;
}

// mac counter pattern
message PatternFlowEthernetSrcCounter {

  // Description missing in models
  // default = 00:00:00:00:00:00
  optional string start = 1;

  // Description missing in models
  // default = 00:00:00:00:00:01
  optional string step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowEthernetSrcMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 48
  optional uint32 length = 3;
}

// Source MAC address
message PatternFlowEthernetSrc {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 00:00:00:00:00:00
  optional string value = 2;

  // Description missing in models
  // default = ['00:00:00:00:00:00']
  repeated string values = 3;

  // Description missing in models
  optional PatternFlowEthernetSrcCounter increment = 5;

  // Description missing in models
  optional PatternFlowEthernetSrcCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowEthernetSrcMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowEthernetEtherTypeCounter {

  // Description missing in models
  // default = 65535
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowEthernetEtherTypeMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Ethernet type
message PatternFlowEthernetEtherType {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      auto = 1;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.auto
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 65535
  optional uint32 value = 2;

  // Description missing in models
  // default = [65535]
  repeated uint32 values = 3;

  // The OTG implementation can provide a system generated
  // value for this property. If the OTG is unable to generate a value
  // the default value must be used.
  // default = 65535
  optional uint32 auto = 4;

  // Description missing in models
  optional PatternFlowEthernetEtherTypeCounter increment = 6;

  // Description missing in models
  optional PatternFlowEthernetEtherTypeCounter decrement = 7;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowEthernetEtherTypeMetricTag metric_tags = 8;
}

// integer counter pattern
message PatternFlowEthernetPfcQueueCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowEthernetPfcQueueMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 3
  optional uint32 length = 3;
}

// Priority flow control queue
message PatternFlowEthernetPfcQueue {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowEthernetPfcQueueCounter increment = 5;

  // Description missing in models
  optional PatternFlowEthernetPfcQueueCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowEthernetPfcQueueMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowVlanPriorityCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowVlanPriorityMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 3
  optional uint32 length = 3;
}

// Priority code point
message PatternFlowVlanPriority {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowVlanPriorityCounter increment = 5;

  // Description missing in models
  optional PatternFlowVlanPriorityCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowVlanPriorityMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowVlanCfiCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowVlanCfiMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// Canonical format indicator or drop elegible indicator
message PatternFlowVlanCfi {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowVlanCfiCounter increment = 5;

  // Description missing in models
  optional PatternFlowVlanCfiCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowVlanCfiMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowVlanIdCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowVlanIdMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 12
  optional uint32 length = 3;
}

// Vlan identifier
message PatternFlowVlanId {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowVlanIdCounter increment = 5;

  // Description missing in models
  optional PatternFlowVlanIdCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowVlanIdMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowVlanTpidCounter {

  // Description missing in models
  // default = 33024
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowVlanTpidMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Protocol identifier
message PatternFlowVlanTpid {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 33024
  optional uint32 value = 2;

  // Description missing in models
  // default = [33024]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowVlanTpidCounter increment = 5;

  // Description missing in models
  optional PatternFlowVlanTpidCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowVlanTpidMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowVxlanFlagsCounter {

  // Description missing in models
  // default = 8
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowVxlanFlagsMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 8
  optional uint32 length = 3;
}

// Flags field with a bit format of RRRRIRRR. The I flag MUST be set to 1 for a valid
// vxlan network id (VNI).   The other 7 bits (designated R) are reserved fields and
// MUST be  set to zero on transmission and ignored on receipt.
message PatternFlowVxlanFlags {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 8
  optional uint32 value = 2;

  // Description missing in models
  // default = [8]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowVxlanFlagsCounter increment = 5;

  // Description missing in models
  optional PatternFlowVxlanFlagsCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowVxlanFlagsMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowVxlanReserved0Counter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowVxlanReserved0MetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 24
  optional uint32 length = 3;
}

// Reserved field
message PatternFlowVxlanReserved0 {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowVxlanReserved0Counter increment = 5;

  // Description missing in models
  optional PatternFlowVxlanReserved0Counter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowVxlanReserved0MetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowVxlanVniCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowVxlanVniMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 24
  optional uint32 length = 3;
}

// VXLAN network id
message PatternFlowVxlanVni {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      auto = 1;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.auto
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // The OTG implementation can provide a system generated
  // value for this property. If the OTG is unable to generate a value
  // the default value must be used.
  // default = 0
  optional uint32 auto = 4;

  // Description missing in models
  optional PatternFlowVxlanVniCounter increment = 6;

  // Description missing in models
  optional PatternFlowVxlanVniCounter decrement = 7;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowVxlanVniMetricTag metric_tags = 8;
}

// integer counter pattern
message PatternFlowVxlanReserved1Counter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowVxlanReserved1MetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 8
  optional uint32 length = 3;
}

// Reserved field
message PatternFlowVxlanReserved1 {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowVxlanReserved1Counter increment = 5;

  // Description missing in models
  optional PatternFlowVxlanReserved1Counter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowVxlanReserved1MetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIpv4VersionCounter {

  // Description missing in models
  // default = 4
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv4VersionMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 4
  optional uint32 length = 3;
}

// Version
message PatternFlowIpv4Version {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 4
  optional uint32 value = 2;

  // Description missing in models
  // default = [4]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowIpv4VersionCounter increment = 5;

  // Description missing in models
  optional PatternFlowIpv4VersionCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv4VersionMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIpv4HeaderLengthCounter {

  // Description missing in models
  // default = 5
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv4HeaderLengthMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 4
  optional uint32 length = 3;
}

// Header length
message PatternFlowIpv4HeaderLength {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      auto = 1;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.auto
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 5
  optional uint32 value = 2;

  // Description missing in models
  // default = [5]
  repeated uint32 values = 3;

  // The OTG implementation can provide a system generated
  // value for this property. If the OTG is unable to generate a value
  // the default value must be used.
  // default = 5
  optional uint32 auto = 4;

  // Description missing in models
  optional PatternFlowIpv4HeaderLengthCounter increment = 6;

  // Description missing in models
  optional PatternFlowIpv4HeaderLengthCounter decrement = 7;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv4HeaderLengthMetricTag metric_tags = 8;
}

// integer counter pattern
message PatternFlowIpv4TotalLengthCounter {

  // Description missing in models
  // default = 46
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv4TotalLengthMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Total length
message PatternFlowIpv4TotalLength {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      auto = 1;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.auto
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 46
  optional uint32 value = 2;

  // Description missing in models
  // default = [46]
  repeated uint32 values = 3;

  // The OTG implementation can provide a system generated
  // value for this property. If the OTG is unable to generate a value
  // the default value must be used.
  // default = 46
  optional uint32 auto = 4;

  // Description missing in models
  optional PatternFlowIpv4TotalLengthCounter increment = 6;

  // Description missing in models
  optional PatternFlowIpv4TotalLengthCounter decrement = 7;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv4TotalLengthMetricTag metric_tags = 8;
}

// integer counter pattern
message PatternFlowIpv4IdentificationCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv4IdentificationMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Identification
message PatternFlowIpv4Identification {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowIpv4IdentificationCounter increment = 5;

  // Description missing in models
  optional PatternFlowIpv4IdentificationCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv4IdentificationMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIpv4ReservedCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv4ReservedMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// Reserved flag.
message PatternFlowIpv4Reserved {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowIpv4ReservedCounter increment = 5;

  // Description missing in models
  optional PatternFlowIpv4ReservedCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv4ReservedMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIpv4DontFragmentCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv4DontFragmentMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// Dont fragment flag If the dont_fragment flag is set and fragmentation is required
// to route the packet then the packet is dropped.
message PatternFlowIpv4DontFragment {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowIpv4DontFragmentCounter increment = 5;

  // Description missing in models
  optional PatternFlowIpv4DontFragmentCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv4DontFragmentMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIpv4MoreFragmentsCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv4MoreFragmentsMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// More fragments flag
message PatternFlowIpv4MoreFragments {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowIpv4MoreFragmentsCounter increment = 5;

  // Description missing in models
  optional PatternFlowIpv4MoreFragmentsCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv4MoreFragmentsMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIpv4FragmentOffsetCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv4FragmentOffsetMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 5
  optional uint32 length = 3;
}

// Fragment offset
message PatternFlowIpv4FragmentOffset {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowIpv4FragmentOffsetCounter increment = 5;

  // Description missing in models
  optional PatternFlowIpv4FragmentOffsetCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv4FragmentOffsetMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIpv4TimeToLiveCounter {

  // Description missing in models
  // default = 64
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv4TimeToLiveMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 8
  optional uint32 length = 3;
}

// Time to live
message PatternFlowIpv4TimeToLive {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 64
  optional uint32 value = 2;

  // Description missing in models
  // default = [64]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowIpv4TimeToLiveCounter increment = 5;

  // Description missing in models
  optional PatternFlowIpv4TimeToLiveCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv4TimeToLiveMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIpv4ProtocolCounter {

  // Description missing in models
  // default = 61
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv4ProtocolMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 8
  optional uint32 length = 3;
}

// Protocol, default is 61 any host internal protocol
message PatternFlowIpv4Protocol {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      auto = 1;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.auto
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 61
  optional uint32 value = 2;

  // Description missing in models
  // default = [61]
  repeated uint32 values = 3;

  // The OTG implementation can provide a system generated
  // value for this property. If the OTG is unable to generate a value
  // the default value must be used.
  // default = 61
  optional uint32 auto = 4;

  // Description missing in models
  optional PatternFlowIpv4ProtocolCounter increment = 6;

  // Description missing in models
  optional PatternFlowIpv4ProtocolCounter decrement = 7;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv4ProtocolMetricTag metric_tags = 8;
}

// Header checksum
message PatternFlowIpv4HeaderChecksum {

  message Choice {
    enum Enum {
      unspecified = 0;
      generated = 1;
      custom = 2;
    }
  }
  // The type of checksum
  // default = Choice.Enum.generated
  optional Choice.Enum choice = 1;

  message Generated {
    enum Enum {
      unspecified = 0;
      good = 1;
      bad = 2;
    }
  }
  // A system generated checksum value
  // default = Generated.Enum.good
  optional Generated.Enum generated = 2;

  // A custom checksum value
  optional uint32 custom = 3;
}

// ipv4 counter pattern
message PatternFlowIpv4SrcCounter {

  // Description missing in models
  // default = 0.0.0.0
  optional string start = 1;

  // Description missing in models
  // default = 0.0.0.1
  optional string step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv4SrcMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 32
  optional uint32 length = 3;
}

// Source address
message PatternFlowIpv4Src {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0.0.0.0
  optional string value = 2;

  // Description missing in models
  // default = ['0.0.0.0']
  repeated string values = 3;

  // Description missing in models
  optional PatternFlowIpv4SrcCounter increment = 5;

  // Description missing in models
  optional PatternFlowIpv4SrcCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv4SrcMetricTag metric_tags = 7;
}

// ipv4 counter pattern
message PatternFlowIpv4DstCounter {

  // Description missing in models
  // default = 0.0.0.0
  optional string start = 1;

  // Description missing in models
  // default = 0.0.0.1
  optional string step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv4DstMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 32
  optional uint32 length = 3;
}

// Destination address
message PatternFlowIpv4Dst {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0.0.0.0
  optional string value = 2;

  // Description missing in models
  // default = ['0.0.0.0']
  repeated string values = 3;

  // Description missing in models
  optional PatternFlowIpv4DstCounter increment = 5;

  // Description missing in models
  optional PatternFlowIpv4DstCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv4DstMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIpv4PriorityRawCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv4PriorityRawMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 8
  optional uint32 length = 3;
}

// Raw priority
message PatternFlowIpv4PriorityRaw {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowIpv4PriorityRawCounter increment = 5;

  // Description missing in models
  optional PatternFlowIpv4PriorityRawCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv4PriorityRawMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIpv4DscpPhbCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv4DscpPhbMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 6
  optional uint32 length = 3;
}

// Per hop behavior
message PatternFlowIpv4DscpPhb {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowIpv4DscpPhbCounter increment = 5;

  // Description missing in models
  optional PatternFlowIpv4DscpPhbCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv4DscpPhbMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIpv4DscpEcnCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv4DscpEcnMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 2
  optional uint32 length = 3;
}

// Explicit congestion notification
message PatternFlowIpv4DscpEcn {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowIpv4DscpEcnCounter increment = 5;

  // Description missing in models
  optional PatternFlowIpv4DscpEcnCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv4DscpEcnMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIpv4TosPrecedenceCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv4TosPrecedenceMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 3
  optional uint32 length = 3;
}

// Precedence
message PatternFlowIpv4TosPrecedence {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowIpv4TosPrecedenceCounter increment = 5;

  // Description missing in models
  optional PatternFlowIpv4TosPrecedenceCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv4TosPrecedenceMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIpv4TosDelayCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv4TosDelayMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// Delay
message PatternFlowIpv4TosDelay {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowIpv4TosDelayCounter increment = 5;

  // Description missing in models
  optional PatternFlowIpv4TosDelayCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv4TosDelayMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIpv4TosThroughputCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv4TosThroughputMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// Throughput
message PatternFlowIpv4TosThroughput {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowIpv4TosThroughputCounter increment = 5;

  // Description missing in models
  optional PatternFlowIpv4TosThroughputCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv4TosThroughputMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIpv4TosReliabilityCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv4TosReliabilityMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// Reliability
message PatternFlowIpv4TosReliability {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowIpv4TosReliabilityCounter increment = 5;

  // Description missing in models
  optional PatternFlowIpv4TosReliabilityCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv4TosReliabilityMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIpv4TosMonetaryCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv4TosMonetaryMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// Monetary
message PatternFlowIpv4TosMonetary {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowIpv4TosMonetaryCounter increment = 5;

  // Description missing in models
  optional PatternFlowIpv4TosMonetaryCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv4TosMonetaryMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIpv4TosUnusedCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv4TosUnusedMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// Unused
message PatternFlowIpv4TosUnused {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowIpv4TosUnusedCounter increment = 5;

  // Description missing in models
  optional PatternFlowIpv4TosUnusedCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv4TosUnusedMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIpv6VersionCounter {

  // Description missing in models
  // default = 6
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv6VersionMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 4
  optional uint32 length = 3;
}

// Version number
message PatternFlowIpv6Version {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 6
  optional uint32 value = 2;

  // Description missing in models
  // default = [6]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowIpv6VersionCounter increment = 5;

  // Description missing in models
  optional PatternFlowIpv6VersionCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv6VersionMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIpv6TrafficClassCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv6TrafficClassMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 8
  optional uint32 length = 3;
}

// Traffic class
message PatternFlowIpv6TrafficClass {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowIpv6TrafficClassCounter increment = 5;

  // Description missing in models
  optional PatternFlowIpv6TrafficClassCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv6TrafficClassMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIpv6FlowLabelCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv6FlowLabelMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 20
  optional uint32 length = 3;
}

// Flow label
message PatternFlowIpv6FlowLabel {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowIpv6FlowLabelCounter increment = 5;

  // Description missing in models
  optional PatternFlowIpv6FlowLabelCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv6FlowLabelMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIpv6PayloadLengthCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv6PayloadLengthMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Payload length
message PatternFlowIpv6PayloadLength {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      auto = 1;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.auto
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // The OTG implementation can provide a system generated
  // value for this property. If the OTG is unable to generate a value
  // the default value must be used.
  // default = 0
  optional uint32 auto = 4;

  // Description missing in models
  optional PatternFlowIpv6PayloadLengthCounter increment = 6;

  // Description missing in models
  optional PatternFlowIpv6PayloadLengthCounter decrement = 7;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv6PayloadLengthMetricTag metric_tags = 8;
}

// integer counter pattern
message PatternFlowIpv6NextHeaderCounter {

  // Description missing in models
  // default = 59
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv6NextHeaderMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 8
  optional uint32 length = 3;
}

// Next header
message PatternFlowIpv6NextHeader {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      auto = 1;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.auto
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 59
  optional uint32 value = 2;

  // Description missing in models
  // default = [59]
  repeated uint32 values = 3;

  // The OTG implementation can provide a system generated
  // value for this property. If the OTG is unable to generate a value
  // the default value must be used.
  // default = 59
  optional uint32 auto = 4;

  // Description missing in models
  optional PatternFlowIpv6NextHeaderCounter increment = 6;

  // Description missing in models
  optional PatternFlowIpv6NextHeaderCounter decrement = 7;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv6NextHeaderMetricTag metric_tags = 8;
}

// integer counter pattern
message PatternFlowIpv6HopLimitCounter {

  // Description missing in models
  // default = 64
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv6HopLimitMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 8
  optional uint32 length = 3;
}

// Hop limit
message PatternFlowIpv6HopLimit {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 64
  optional uint32 value = 2;

  // Description missing in models
  // default = [64]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowIpv6HopLimitCounter increment = 5;

  // Description missing in models
  optional PatternFlowIpv6HopLimitCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv6HopLimitMetricTag metric_tags = 7;
}

// ipv6 counter pattern
message PatternFlowIpv6SrcCounter {

  // Description missing in models
  // default = ::0
  optional string start = 1;

  // Description missing in models
  // default = ::1
  optional string step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv6SrcMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 128
  optional uint32 length = 3;
}

// Source address
message PatternFlowIpv6Src {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = ::0
  optional string value = 2;

  // Description missing in models
  // default = ['::0']
  repeated string values = 3;

  // Description missing in models
  optional PatternFlowIpv6SrcCounter increment = 5;

  // Description missing in models
  optional PatternFlowIpv6SrcCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv6SrcMetricTag metric_tags = 7;
}

// ipv6 counter pattern
message PatternFlowIpv6DstCounter {

  // Description missing in models
  // default = ::0
  optional string start = 1;

  // Description missing in models
  // default = ::1
  optional string step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv6DstMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 128
  optional uint32 length = 3;
}

// Destination address
message PatternFlowIpv6Dst {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = ::0
  optional string value = 2;

  // Description missing in models
  // default = ['::0']
  repeated string values = 3;

  // Description missing in models
  optional PatternFlowIpv6DstCounter increment = 5;

  // Description missing in models
  optional PatternFlowIpv6DstCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv6DstMetricTag metric_tags = 7;
}

// mac counter pattern
message PatternFlowPfcPauseDstCounter {

  // Description missing in models
  // default = 01:80:c2:00:00:01
  optional string start = 1;

  // Description missing in models
  // default = 00:00:00:00:00:01
  optional string step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowPfcPauseDstMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 48
  optional uint32 length = 3;
}

// Destination MAC address
message PatternFlowPfcPauseDst {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 01:80:c2:00:00:01
  optional string value = 2;

  // Description missing in models
  // default = ['01:80:c2:00:00:01']
  repeated string values = 3;

  // Description missing in models
  optional PatternFlowPfcPauseDstCounter increment = 5;

  // Description missing in models
  optional PatternFlowPfcPauseDstCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowPfcPauseDstMetricTag metric_tags = 7;
}

// mac counter pattern
message PatternFlowPfcPauseSrcCounter {

  // Description missing in models
  // default = 00:00:00:00:00:00
  optional string start = 1;

  // Description missing in models
  // default = 00:00:00:00:00:01
  optional string step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowPfcPauseSrcMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 48
  optional uint32 length = 3;
}

// Source MAC address
message PatternFlowPfcPauseSrc {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 00:00:00:00:00:00
  optional string value = 2;

  // Description missing in models
  // default = ['00:00:00:00:00:00']
  repeated string values = 3;

  // Description missing in models
  optional PatternFlowPfcPauseSrcCounter increment = 5;

  // Description missing in models
  optional PatternFlowPfcPauseSrcCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowPfcPauseSrcMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowPfcPauseEtherTypeCounter {

  // Description missing in models
  // default = 34824
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowPfcPauseEtherTypeMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Ethernet type
message PatternFlowPfcPauseEtherType {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 34824
  optional uint32 value = 2;

  // Description missing in models
  // default = [34824]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowPfcPauseEtherTypeCounter increment = 5;

  // Description missing in models
  optional PatternFlowPfcPauseEtherTypeCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowPfcPauseEtherTypeMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowPfcPauseControlOpCodeCounter {

  // Description missing in models
  // default = 257
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowPfcPauseControlOpCodeMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Control operation code
message PatternFlowPfcPauseControlOpCode {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 257
  optional uint32 value = 2;

  // Description missing in models
  // default = [257]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowPfcPauseControlOpCodeCounter increment = 5;

  // Description missing in models
  optional PatternFlowPfcPauseControlOpCodeCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowPfcPauseControlOpCodeMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowPfcPauseClassEnableVectorCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowPfcPauseClassEnableVectorMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Destination
message PatternFlowPfcPauseClassEnableVector {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowPfcPauseClassEnableVectorCounter increment = 5;

  // Description missing in models
  optional PatternFlowPfcPauseClassEnableVectorCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowPfcPauseClassEnableVectorMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowPfcPausePauseClass0Counter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowPfcPausePauseClass0MetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Pause class 0
message PatternFlowPfcPausePauseClass0 {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowPfcPausePauseClass0Counter increment = 5;

  // Description missing in models
  optional PatternFlowPfcPausePauseClass0Counter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowPfcPausePauseClass0MetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowPfcPausePauseClass1Counter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowPfcPausePauseClass1MetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Pause class 1
message PatternFlowPfcPausePauseClass1 {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowPfcPausePauseClass1Counter increment = 5;

  // Description missing in models
  optional PatternFlowPfcPausePauseClass1Counter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowPfcPausePauseClass1MetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowPfcPausePauseClass2Counter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowPfcPausePauseClass2MetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Pause class 2
message PatternFlowPfcPausePauseClass2 {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowPfcPausePauseClass2Counter increment = 5;

  // Description missing in models
  optional PatternFlowPfcPausePauseClass2Counter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowPfcPausePauseClass2MetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowPfcPausePauseClass3Counter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowPfcPausePauseClass3MetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Pause class 3
message PatternFlowPfcPausePauseClass3 {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowPfcPausePauseClass3Counter increment = 5;

  // Description missing in models
  optional PatternFlowPfcPausePauseClass3Counter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowPfcPausePauseClass3MetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowPfcPausePauseClass4Counter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowPfcPausePauseClass4MetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Pause class 4
message PatternFlowPfcPausePauseClass4 {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowPfcPausePauseClass4Counter increment = 5;

  // Description missing in models
  optional PatternFlowPfcPausePauseClass4Counter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowPfcPausePauseClass4MetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowPfcPausePauseClass5Counter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowPfcPausePauseClass5MetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Pause class 5
message PatternFlowPfcPausePauseClass5 {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowPfcPausePauseClass5Counter increment = 5;

  // Description missing in models
  optional PatternFlowPfcPausePauseClass5Counter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowPfcPausePauseClass5MetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowPfcPausePauseClass6Counter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowPfcPausePauseClass6MetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Pause class 6
message PatternFlowPfcPausePauseClass6 {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowPfcPausePauseClass6Counter increment = 5;

  // Description missing in models
  optional PatternFlowPfcPausePauseClass6Counter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowPfcPausePauseClass6MetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowPfcPausePauseClass7Counter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowPfcPausePauseClass7MetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Pause class 7
message PatternFlowPfcPausePauseClass7 {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowPfcPausePauseClass7Counter increment = 5;

  // Description missing in models
  optional PatternFlowPfcPausePauseClass7Counter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowPfcPausePauseClass7MetricTag metric_tags = 7;
}

// mac counter pattern
message PatternFlowEthernetPauseDstCounter {

  // Description missing in models
  // default = 01:80:c2:00:00:01
  optional string start = 1;

  // Description missing in models
  // default = 00:00:00:00:00:01
  optional string step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowEthernetPauseDstMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 48
  optional uint32 length = 3;
}

// Destination MAC address
message PatternFlowEthernetPauseDst {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 01:80:c2:00:00:01
  optional string value = 2;

  // Description missing in models
  // default = ['01:80:c2:00:00:01']
  repeated string values = 3;

  // Description missing in models
  optional PatternFlowEthernetPauseDstCounter increment = 5;

  // Description missing in models
  optional PatternFlowEthernetPauseDstCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowEthernetPauseDstMetricTag metric_tags = 7;
}

// mac counter pattern
message PatternFlowEthernetPauseSrcCounter {

  // Description missing in models
  // default = 00:00:00:00:00:00
  optional string start = 1;

  // Description missing in models
  // default = 00:00:00:00:00:01
  optional string step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowEthernetPauseSrcMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 48
  optional uint32 length = 3;
}

// Source MAC address
message PatternFlowEthernetPauseSrc {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 00:00:00:00:00:00
  optional string value = 2;

  // Description missing in models
  // default = ['00:00:00:00:00:00']
  repeated string values = 3;

  // Description missing in models
  optional PatternFlowEthernetPauseSrcCounter increment = 5;

  // Description missing in models
  optional PatternFlowEthernetPauseSrcCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowEthernetPauseSrcMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowEthernetPauseEtherTypeCounter {

  // Description missing in models
  // default = 34824
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowEthernetPauseEtherTypeMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Ethernet type
message PatternFlowEthernetPauseEtherType {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 34824
  optional uint32 value = 2;

  // Description missing in models
  // default = [34824]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowEthernetPauseEtherTypeCounter increment = 5;

  // Description missing in models
  optional PatternFlowEthernetPauseEtherTypeCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowEthernetPauseEtherTypeMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowEthernetPauseControlOpCodeCounter {

  // Description missing in models
  // default = 1
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowEthernetPauseControlOpCodeMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Control operation code
message PatternFlowEthernetPauseControlOpCode {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 1
  optional uint32 value = 2;

  // Description missing in models
  // default = [1]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowEthernetPauseControlOpCodeCounter increment = 5;

  // Description missing in models
  optional PatternFlowEthernetPauseControlOpCodeCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowEthernetPauseControlOpCodeMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowEthernetPauseTimeCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowEthernetPauseTimeMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Time
message PatternFlowEthernetPauseTime {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowEthernetPauseTimeCounter increment = 5;

  // Description missing in models
  optional PatternFlowEthernetPauseTimeCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowEthernetPauseTimeMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowTcpSrcPortCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowTcpSrcPortMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Source port
message PatternFlowTcpSrcPort {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowTcpSrcPortCounter increment = 5;

  // Description missing in models
  optional PatternFlowTcpSrcPortCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowTcpSrcPortMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowTcpDstPortCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowTcpDstPortMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Destination port
message PatternFlowTcpDstPort {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowTcpDstPortCounter increment = 5;

  // Description missing in models
  optional PatternFlowTcpDstPortCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowTcpDstPortMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowTcpSeqNumCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowTcpSeqNumMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 32
  optional uint32 length = 3;
}

// Sequence number
message PatternFlowTcpSeqNum {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowTcpSeqNumCounter increment = 5;

  // Description missing in models
  optional PatternFlowTcpSeqNumCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowTcpSeqNumMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowTcpAckNumCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowTcpAckNumMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 32
  optional uint32 length = 3;
}

// Acknowledgement number
message PatternFlowTcpAckNum {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowTcpAckNumCounter increment = 5;

  // Description missing in models
  optional PatternFlowTcpAckNumCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowTcpAckNumMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowTcpDataOffsetCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowTcpDataOffsetMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 4
  optional uint32 length = 3;
}

// The number of 32 bit words in the TCP header. This indicates where the data begins.
message PatternFlowTcpDataOffset {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowTcpDataOffsetCounter increment = 5;

  // Description missing in models
  optional PatternFlowTcpDataOffsetCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowTcpDataOffsetMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowTcpEcnNsCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowTcpEcnNsMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// Explicit congestion notification, concealment protection.
message PatternFlowTcpEcnNs {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowTcpEcnNsCounter increment = 5;

  // Description missing in models
  optional PatternFlowTcpEcnNsCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowTcpEcnNsMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowTcpEcnCwrCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowTcpEcnCwrMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// Explicit congestion notification, congestion window reduced.
message PatternFlowTcpEcnCwr {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowTcpEcnCwrCounter increment = 5;

  // Description missing in models
  optional PatternFlowTcpEcnCwrCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowTcpEcnCwrMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowTcpEcnEchoCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowTcpEcnEchoMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// Explicit congestion notification, echo. 1 indicates the peer is ecn capable. 0 indicates
// that a packet with ipv4.ecn = 11 in the ip header was  received during normal transmission.
message PatternFlowTcpEcnEcho {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowTcpEcnEchoCounter increment = 5;

  // Description missing in models
  optional PatternFlowTcpEcnEchoCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowTcpEcnEchoMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowTcpCtlUrgCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowTcpCtlUrgMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// A value of 1 indicates that the urgent pointer field is significant.
message PatternFlowTcpCtlUrg {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowTcpCtlUrgCounter increment = 5;

  // Description missing in models
  optional PatternFlowTcpCtlUrgCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowTcpCtlUrgMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowTcpCtlAckCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowTcpCtlAckMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// A value of 1 indicates that the ackknowledgment field is significant.
message PatternFlowTcpCtlAck {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowTcpCtlAckCounter increment = 5;

  // Description missing in models
  optional PatternFlowTcpCtlAckCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowTcpCtlAckMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowTcpCtlPshCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowTcpCtlPshMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// Asks to push the buffered data to the receiving application.
message PatternFlowTcpCtlPsh {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowTcpCtlPshCounter increment = 5;

  // Description missing in models
  optional PatternFlowTcpCtlPshCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowTcpCtlPshMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowTcpCtlRstCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowTcpCtlRstMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// Reset the connection.
message PatternFlowTcpCtlRst {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowTcpCtlRstCounter increment = 5;

  // Description missing in models
  optional PatternFlowTcpCtlRstCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowTcpCtlRstMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowTcpCtlSynCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowTcpCtlSynMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// Synchronize sequenece numbers.
message PatternFlowTcpCtlSyn {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowTcpCtlSynCounter increment = 5;

  // Description missing in models
  optional PatternFlowTcpCtlSynCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowTcpCtlSynMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowTcpCtlFinCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowTcpCtlFinMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// Last packet from the sender.
message PatternFlowTcpCtlFin {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowTcpCtlFinCounter increment = 5;

  // Description missing in models
  optional PatternFlowTcpCtlFinCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowTcpCtlFinMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowTcpWindowCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowTcpWindowMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Tcp connection window.
message PatternFlowTcpWindow {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowTcpWindowCounter increment = 5;

  // Description missing in models
  optional PatternFlowTcpWindowCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowTcpWindowMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowUdpSrcPortCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowUdpSrcPortMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Source port
message PatternFlowUdpSrcPort {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowUdpSrcPortCounter increment = 5;

  // Description missing in models
  optional PatternFlowUdpSrcPortCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowUdpSrcPortMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowUdpDstPortCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowUdpDstPortMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Destination port
message PatternFlowUdpDstPort {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowUdpDstPortCounter increment = 5;

  // Description missing in models
  optional PatternFlowUdpDstPortCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowUdpDstPortMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowUdpLengthCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowUdpLengthMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Length
message PatternFlowUdpLength {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowUdpLengthCounter increment = 5;

  // Description missing in models
  optional PatternFlowUdpLengthCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowUdpLengthMetricTag metric_tags = 7;
}

// UDP checksum
message PatternFlowUdpChecksum {

  message Choice {
    enum Enum {
      unspecified = 0;
      generated = 1;
      custom = 2;
    }
  }
  // The type of checksum
  // default = Choice.Enum.generated
  optional Choice.Enum choice = 1;

  message Generated {
    enum Enum {
      unspecified = 0;
      good = 1;
      bad = 2;
    }
  }
  // A system generated checksum value
  // default = Generated.Enum.good
  optional Generated.Enum generated = 2;

  // A custom checksum value
  optional uint32 custom = 3;
}

// integer counter pattern
message PatternFlowGreChecksumPresentCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGreChecksumPresentMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// Checksum present bit
message PatternFlowGreChecksumPresent {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowGreChecksumPresentCounter increment = 5;

  // Description missing in models
  optional PatternFlowGreChecksumPresentCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGreChecksumPresentMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGreReserved0Counter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGreReserved0MetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 12
  optional uint32 length = 3;
}

// Reserved bits
message PatternFlowGreReserved0 {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowGreReserved0Counter increment = 5;

  // Description missing in models
  optional PatternFlowGreReserved0Counter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGreReserved0MetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGreVersionCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGreVersionMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 3
  optional uint32 length = 3;
}

// GRE version number
message PatternFlowGreVersion {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowGreVersionCounter increment = 5;

  // Description missing in models
  optional PatternFlowGreVersionCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGreVersionMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGreProtocolCounter {

  // Description missing in models
  // default = 2048
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGreProtocolMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Protocol type of encapsulated payload
message PatternFlowGreProtocol {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 2048
  optional uint32 value = 2;

  // Description missing in models
  // default = [2048]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowGreProtocolCounter increment = 5;

  // Description missing in models
  optional PatternFlowGreProtocolCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGreProtocolMetricTag metric_tags = 7;
}

// Optional checksum of GRE header and payload. Only present if the checksum_present
// bit is set.
message PatternFlowGreChecksum {

  message Choice {
    enum Enum {
      unspecified = 0;
      generated = 1;
      custom = 2;
    }
  }
  // The type of checksum
  // default = Choice.Enum.generated
  optional Choice.Enum choice = 1;

  message Generated {
    enum Enum {
      unspecified = 0;
      good = 1;
      bad = 2;
    }
  }
  // A system generated checksum value
  // default = Generated.Enum.good
  optional Generated.Enum generated = 2;

  // A custom checksum value
  optional uint32 custom = 3;
}

// integer counter pattern
message PatternFlowGreReserved1Counter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGreReserved1MetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Optional reserved field. Only present if the checksum_present bit is set.
message PatternFlowGreReserved1 {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowGreReserved1Counter increment = 5;

  // Description missing in models
  optional PatternFlowGreReserved1Counter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGreReserved1MetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGtpv1VersionCounter {

  // Description missing in models
  // default = 1
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGtpv1VersionMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 3
  optional uint32 length = 3;
}

// GTPv1 version
message PatternFlowGtpv1Version {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 1
  optional uint32 value = 2;

  // Description missing in models
  // default = [1]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowGtpv1VersionCounter increment = 5;

  // Description missing in models
  optional PatternFlowGtpv1VersionCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGtpv1VersionMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGtpv1ProtocolTypeCounter {

  // Description missing in models
  // default = 1
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGtpv1ProtocolTypeMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// Protocol type, GTP is 1, GTP' is 0
message PatternFlowGtpv1ProtocolType {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 1
  optional uint32 value = 2;

  // Description missing in models
  // default = [1]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowGtpv1ProtocolTypeCounter increment = 5;

  // Description missing in models
  optional PatternFlowGtpv1ProtocolTypeCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGtpv1ProtocolTypeMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGtpv1ReservedCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGtpv1ReservedMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// Reserved field
message PatternFlowGtpv1Reserved {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowGtpv1ReservedCounter increment = 5;

  // Description missing in models
  optional PatternFlowGtpv1ReservedCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGtpv1ReservedMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGtpv1EFlagCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGtpv1EFlagMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// Extension header field present
message PatternFlowGtpv1EFlag {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowGtpv1EFlagCounter increment = 5;

  // Description missing in models
  optional PatternFlowGtpv1EFlagCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGtpv1EFlagMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGtpv1SFlagCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGtpv1SFlagMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// Sequence number field present
message PatternFlowGtpv1SFlag {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowGtpv1SFlagCounter increment = 5;

  // Description missing in models
  optional PatternFlowGtpv1SFlagCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGtpv1SFlagMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGtpv1PnFlagCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGtpv1PnFlagMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// N-PDU field present
message PatternFlowGtpv1PnFlag {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowGtpv1PnFlagCounter increment = 5;

  // Description missing in models
  optional PatternFlowGtpv1PnFlagCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGtpv1PnFlagMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGtpv1MessageTypeCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGtpv1MessageTypeMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 8
  optional uint32 length = 3;
}

// The type of GTP message Different types of messages are defined in 3GPP TS 29.060
// section 7.1
message PatternFlowGtpv1MessageType {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowGtpv1MessageTypeCounter increment = 5;

  // Description missing in models
  optional PatternFlowGtpv1MessageTypeCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGtpv1MessageTypeMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGtpv1MessageLengthCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGtpv1MessageLengthMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// The length of the payload (the bytes following the mandatory 8-byte GTP header) in
// bytes that includes any optional fields
message PatternFlowGtpv1MessageLength {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowGtpv1MessageLengthCounter increment = 5;

  // Description missing in models
  optional PatternFlowGtpv1MessageLengthCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGtpv1MessageLengthMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGtpv1TeidCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGtpv1TeidMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 32
  optional uint32 length = 3;
}

// Tunnel endpoint identifier (TEID) used to multiplex connections in the same GTP tunnel
message PatternFlowGtpv1Teid {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowGtpv1TeidCounter increment = 5;

  // Description missing in models
  optional PatternFlowGtpv1TeidCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGtpv1TeidMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGtpv1SquenceNumberCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGtpv1SquenceNumberMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Sequence number. Exists if any of the e_flag, s_flag, or pn_flag bits are on.  Must
// be interpreted only if the s_flag bit is on.
message PatternFlowGtpv1SquenceNumber {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowGtpv1SquenceNumberCounter increment = 5;

  // Description missing in models
  optional PatternFlowGtpv1SquenceNumberCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGtpv1SquenceNumberMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGtpv1NPduNumberCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGtpv1NPduNumberMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 8
  optional uint32 length = 3;
}

// N-PDU number. Exists if any of the e_flag, s_flag, or pn_flag bits are on.  Must
// be interpreted only if the pn_flag bit is on.
message PatternFlowGtpv1NPduNumber {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowGtpv1NPduNumberCounter increment = 5;

  // Description missing in models
  optional PatternFlowGtpv1NPduNumberCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGtpv1NPduNumberMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGtpv1NextExtensionHeaderTypeCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGtpv1NextExtensionHeaderTypeMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 8
  optional uint32 length = 3;
}

// Next extension header. Exists if any of the e_flag, s_flag, or pn_flag bits are on.
// Must be interpreted only if the e_flag bit is on.
message PatternFlowGtpv1NextExtensionHeaderType {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowGtpv1NextExtensionHeaderTypeCounter increment = 5;

  // Description missing in models
  optional PatternFlowGtpv1NextExtensionHeaderTypeCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGtpv1NextExtensionHeaderTypeMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGtpExtensionExtensionLengthCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGtpExtensionExtensionLengthMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 8
  optional uint32 length = 3;
}

// This field states the length of this extension header,  including the length, the
// contents, and the next extension header field, in 4-octet units, so the length of
// the extension must  always be a multiple of 4.
message PatternFlowGtpExtensionExtensionLength {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowGtpExtensionExtensionLengthCounter increment = 5;

  // Description missing in models
  optional PatternFlowGtpExtensionExtensionLengthCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGtpExtensionExtensionLengthMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGtpExtensionContentsCounter {

  // Description missing in models
  // default = 0
  optional uint64 start = 1;

  // Description missing in models
  // default = 1
  optional uint64 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGtpExtensionContentsMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 48
  optional uint32 length = 3;
}

// The extension header contents
message PatternFlowGtpExtensionContents {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint64 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint64 values = 3;

  // Description missing in models
  optional PatternFlowGtpExtensionContentsCounter increment = 5;

  // Description missing in models
  optional PatternFlowGtpExtensionContentsCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGtpExtensionContentsMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGtpExtensionNextExtensionHeaderCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGtpExtensionNextExtensionHeaderMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 8
  optional uint32 length = 3;
}

// It states the type of the next extension, or 0 if no next  extension exists.  This
// permits chaining several next extension headers.
message PatternFlowGtpExtensionNextExtensionHeader {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowGtpExtensionNextExtensionHeaderCounter increment = 5;

  // Description missing in models
  optional PatternFlowGtpExtensionNextExtensionHeaderCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGtpExtensionNextExtensionHeaderMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGtpv2VersionCounter {

  // Description missing in models
  // default = 2
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGtpv2VersionMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 3
  optional uint32 length = 3;
}

// Version number
message PatternFlowGtpv2Version {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 2
  optional uint32 value = 2;

  // Description missing in models
  // default = [2]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowGtpv2VersionCounter increment = 5;

  // Description missing in models
  optional PatternFlowGtpv2VersionCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGtpv2VersionMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGtpv2PiggybackingFlagCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGtpv2PiggybackingFlagMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// If piggybacking_flag is set to 1 then another GTP-C message with its own header shall
// be present at the end of the current message
message PatternFlowGtpv2PiggybackingFlag {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowGtpv2PiggybackingFlagCounter increment = 5;

  // Description missing in models
  optional PatternFlowGtpv2PiggybackingFlagCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGtpv2PiggybackingFlagMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGtpv2TeidFlagCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGtpv2TeidFlagMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// If teid_flag is set to 1 then the TEID field will be present  between the message
// length and the sequence number. All messages except Echo and Echo reply require TEID
// to be present
message PatternFlowGtpv2TeidFlag {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowGtpv2TeidFlagCounter increment = 5;

  // Description missing in models
  optional PatternFlowGtpv2TeidFlagCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGtpv2TeidFlagMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGtpv2Spare1Counter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGtpv2Spare1MetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 3
  optional uint32 length = 3;
}

// A 3-bit reserved field (must be 0).
message PatternFlowGtpv2Spare1 {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowGtpv2Spare1Counter increment = 5;

  // Description missing in models
  optional PatternFlowGtpv2Spare1Counter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGtpv2Spare1MetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGtpv2MessageTypeCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGtpv2MessageTypeMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 8
  optional uint32 length = 3;
}

// An 8-bit field that indicates the type of GTP message. Different types of messages
// are defined in 3GPP TS 29.060 section 7.1
message PatternFlowGtpv2MessageType {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowGtpv2MessageTypeCounter increment = 5;

  // Description missing in models
  optional PatternFlowGtpv2MessageTypeCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGtpv2MessageTypeMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGtpv2MessageLengthCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGtpv2MessageLengthMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// A 16-bit field that indicates the length of the payload in bytes, excluding the mandatory
// GTP-c header (first 4 bytes). Includes the TEID and sequence_number if they are present.
message PatternFlowGtpv2MessageLength {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowGtpv2MessageLengthCounter increment = 5;

  // Description missing in models
  optional PatternFlowGtpv2MessageLengthCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGtpv2MessageLengthMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGtpv2TeidCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGtpv2TeidMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 32
  optional uint32 length = 3;
}

// Tunnel endpoint identifier. A 32-bit (4-octet) field used to multiplex different
// connections in the same GTP tunnel. Is present only if the teid_flag is set.
message PatternFlowGtpv2Teid {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowGtpv2TeidCounter increment = 5;

  // Description missing in models
  optional PatternFlowGtpv2TeidCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGtpv2TeidMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGtpv2SequenceNumberCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGtpv2SequenceNumberMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 24
  optional uint32 length = 3;
}

// The sequence number
message PatternFlowGtpv2SequenceNumber {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowGtpv2SequenceNumberCounter increment = 5;

  // Description missing in models
  optional PatternFlowGtpv2SequenceNumberCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGtpv2SequenceNumberMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGtpv2Spare2Counter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGtpv2Spare2MetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 8
  optional uint32 length = 3;
}

// Reserved field
message PatternFlowGtpv2Spare2 {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowGtpv2Spare2Counter increment = 5;

  // Description missing in models
  optional PatternFlowGtpv2Spare2Counter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGtpv2Spare2MetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowArpHardwareTypeCounter {

  // Description missing in models
  // default = 1
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowArpHardwareTypeMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Network link protocol type
message PatternFlowArpHardwareType {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 1
  optional uint32 value = 2;

  // Description missing in models
  // default = [1]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowArpHardwareTypeCounter increment = 5;

  // Description missing in models
  optional PatternFlowArpHardwareTypeCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowArpHardwareTypeMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowArpProtocolTypeCounter {

  // Description missing in models
  // default = 2048
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowArpProtocolTypeMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// The internetwork protocol for which the ARP request is intended
message PatternFlowArpProtocolType {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 2048
  optional uint32 value = 2;

  // Description missing in models
  // default = [2048]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowArpProtocolTypeCounter increment = 5;

  // Description missing in models
  optional PatternFlowArpProtocolTypeCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowArpProtocolTypeMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowArpHardwareLengthCounter {

  // Description missing in models
  // default = 6
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowArpHardwareLengthMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 8
  optional uint32 length = 3;
}

// Length (in octets) of a hardware address
message PatternFlowArpHardwareLength {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 6
  optional uint32 value = 2;

  // Description missing in models
  // default = [6]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowArpHardwareLengthCounter increment = 5;

  // Description missing in models
  optional PatternFlowArpHardwareLengthCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowArpHardwareLengthMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowArpProtocolLengthCounter {

  // Description missing in models
  // default = 4
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowArpProtocolLengthMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 8
  optional uint32 length = 3;
}

// Length (in octets) of internetwork addresses
message PatternFlowArpProtocolLength {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 4
  optional uint32 value = 2;

  // Description missing in models
  // default = [4]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowArpProtocolLengthCounter increment = 5;

  // Description missing in models
  optional PatternFlowArpProtocolLengthCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowArpProtocolLengthMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowArpOperationCounter {

  // Description missing in models
  // default = 1
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowArpOperationMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// The operation that the sender is performing
message PatternFlowArpOperation {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 1
  optional uint32 value = 2;

  // Description missing in models
  // default = [1]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowArpOperationCounter increment = 5;

  // Description missing in models
  optional PatternFlowArpOperationCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowArpOperationMetricTag metric_tags = 7;
}

// mac counter pattern
message PatternFlowArpSenderHardwareAddrCounter {

  // Description missing in models
  // default = 00:00:00:00:00:00
  optional string start = 1;

  // Description missing in models
  // default = 00:00:00:00:00:01
  optional string step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowArpSenderHardwareAddrMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 48
  optional uint32 length = 3;
}

// Media address of the sender
message PatternFlowArpSenderHardwareAddr {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 00:00:00:00:00:00
  optional string value = 2;

  // Description missing in models
  // default = ['00:00:00:00:00:00']
  repeated string values = 3;

  // Description missing in models
  optional PatternFlowArpSenderHardwareAddrCounter increment = 5;

  // Description missing in models
  optional PatternFlowArpSenderHardwareAddrCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowArpSenderHardwareAddrMetricTag metric_tags = 7;
}

// ipv4 counter pattern
message PatternFlowArpSenderProtocolAddrCounter {

  // Description missing in models
  // default = 0.0.0.0
  optional string start = 1;

  // Description missing in models
  // default = 0.0.0.1
  optional string step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowArpSenderProtocolAddrMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 32
  optional uint32 length = 3;
}

// Internetwork address of the sender
message PatternFlowArpSenderProtocolAddr {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0.0.0.0
  optional string value = 2;

  // Description missing in models
  // default = ['0.0.0.0']
  repeated string values = 3;

  // Description missing in models
  optional PatternFlowArpSenderProtocolAddrCounter increment = 5;

  // Description missing in models
  optional PatternFlowArpSenderProtocolAddrCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowArpSenderProtocolAddrMetricTag metric_tags = 7;
}

// mac counter pattern
message PatternFlowArpTargetHardwareAddrCounter {

  // Description missing in models
  // default = 00:00:00:00:00:00
  optional string start = 1;

  // Description missing in models
  // default = 00:00:00:00:00:01
  optional string step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowArpTargetHardwareAddrMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 48
  optional uint32 length = 3;
}

// Media address of the target
message PatternFlowArpTargetHardwareAddr {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 00:00:00:00:00:00
  optional string value = 2;

  // Description missing in models
  // default = ['00:00:00:00:00:00']
  repeated string values = 3;

  // Description missing in models
  optional PatternFlowArpTargetHardwareAddrCounter increment = 5;

  // Description missing in models
  optional PatternFlowArpTargetHardwareAddrCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowArpTargetHardwareAddrMetricTag metric_tags = 7;
}

// ipv4 counter pattern
message PatternFlowArpTargetProtocolAddrCounter {

  // Description missing in models
  // default = 0.0.0.0
  optional string start = 1;

  // Description missing in models
  // default = 0.0.0.1
  optional string step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowArpTargetProtocolAddrMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 32
  optional uint32 length = 3;
}

// Internetwork address of the target
message PatternFlowArpTargetProtocolAddr {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0.0.0.0
  optional string value = 2;

  // Description missing in models
  // default = ['0.0.0.0']
  repeated string values = 3;

  // Description missing in models
  optional PatternFlowArpTargetProtocolAddrCounter increment = 5;

  // Description missing in models
  optional PatternFlowArpTargetProtocolAddrCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowArpTargetProtocolAddrMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIcmpEchoTypeCounter {

  // Description missing in models
  // default = 8
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIcmpEchoTypeMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 8
  optional uint32 length = 3;
}

// The type of ICMP echo packet
message PatternFlowIcmpEchoType {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 8
  optional uint32 value = 2;

  // Description missing in models
  // default = [8]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowIcmpEchoTypeCounter increment = 5;

  // Description missing in models
  optional PatternFlowIcmpEchoTypeCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIcmpEchoTypeMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIcmpEchoCodeCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIcmpEchoCodeMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 8
  optional uint32 length = 3;
}

// The ICMP subtype.  The default code for ICMP echo request and reply is 0.
message PatternFlowIcmpEchoCode {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowIcmpEchoCodeCounter increment = 5;

  // Description missing in models
  optional PatternFlowIcmpEchoCodeCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIcmpEchoCodeMetricTag metric_tags = 7;
}

// ICMP checksum
message PatternFlowIcmpEchoChecksum {

  message Choice {
    enum Enum {
      unspecified = 0;
      generated = 1;
      custom = 2;
    }
  }
  // The type of checksum
  // default = Choice.Enum.generated
  optional Choice.Enum choice = 1;

  message Generated {
    enum Enum {
      unspecified = 0;
      good = 1;
      bad = 2;
    }
  }
  // A system generated checksum value
  // default = Generated.Enum.good
  optional Generated.Enum generated = 2;

  // A custom checksum value
  optional uint32 custom = 3;
}

// integer counter pattern
message PatternFlowIcmpEchoIdentifierCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIcmpEchoIdentifierMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// ICMP identifier
message PatternFlowIcmpEchoIdentifier {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowIcmpEchoIdentifierCounter increment = 5;

  // Description missing in models
  optional PatternFlowIcmpEchoIdentifierCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIcmpEchoIdentifierMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIcmpEchoSequenceNumberCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIcmpEchoSequenceNumberMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// ICMP sequence number
message PatternFlowIcmpEchoSequenceNumber {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowIcmpEchoSequenceNumberCounter increment = 5;

  // Description missing in models
  optional PatternFlowIcmpEchoSequenceNumberCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIcmpEchoSequenceNumberMetricTag metric_tags = 7;
}

// ICMP checksum
message PatternFlowIcmpCommonChecksum {

  message Choice {
    enum Enum {
      unspecified = 0;
      generated = 1;
      custom = 2;
    }
  }
  // The type of checksum
  // default = Choice.Enum.generated
  optional Choice.Enum choice = 1;

  message Generated {
    enum Enum {
      unspecified = 0;
      good = 1;
      bad = 2;
    }
  }
  // A system generated checksum value
  // default = Generated.Enum.good
  optional Generated.Enum generated = 2;

  // A custom checksum value
  optional uint32 custom = 3;
}

// integer counter pattern
message PatternFlowIcmpNextFieldsIdentifierCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIcmpNextFieldsIdentifierMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// ICMP identifier
message PatternFlowIcmpNextFieldsIdentifier {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowIcmpNextFieldsIdentifierCounter increment = 5;

  // Description missing in models
  optional PatternFlowIcmpNextFieldsIdentifierCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIcmpNextFieldsIdentifierMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIcmpNextFieldsSequenceNumberCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIcmpNextFieldsSequenceNumberMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// ICMP sequence number
message PatternFlowIcmpNextFieldsSequenceNumber {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowIcmpNextFieldsSequenceNumberCounter increment = 5;

  // Description missing in models
  optional PatternFlowIcmpNextFieldsSequenceNumberCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIcmpNextFieldsSequenceNumberMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIcmpv6EchoTypeCounter {

  // Description missing in models
  // default = 128
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIcmpv6EchoTypeMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 8
  optional uint32 length = 3;
}

// ICMPv6 echo type
message PatternFlowIcmpv6EchoType {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 128
  optional uint32 value = 2;

  // Description missing in models
  // default = [128]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowIcmpv6EchoTypeCounter increment = 5;

  // Description missing in models
  optional PatternFlowIcmpv6EchoTypeCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIcmpv6EchoTypeMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIcmpv6EchoCodeCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIcmpv6EchoCodeMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 8
  optional uint32 length = 3;
}

// ICMPv6 echo sub type
message PatternFlowIcmpv6EchoCode {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowIcmpv6EchoCodeCounter increment = 5;

  // Description missing in models
  optional PatternFlowIcmpv6EchoCodeCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIcmpv6EchoCodeMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIcmpv6EchoIdentifierCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIcmpv6EchoIdentifierMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// ICMPv6 echo identifier
message PatternFlowIcmpv6EchoIdentifier {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowIcmpv6EchoIdentifierCounter increment = 5;

  // Description missing in models
  optional PatternFlowIcmpv6EchoIdentifierCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIcmpv6EchoIdentifierMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIcmpv6EchoSequenceNumberCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIcmpv6EchoSequenceNumberMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// ICMPv6 echo sequence number
message PatternFlowIcmpv6EchoSequenceNumber {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowIcmpv6EchoSequenceNumberCounter increment = 5;

  // Description missing in models
  optional PatternFlowIcmpv6EchoSequenceNumberCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIcmpv6EchoSequenceNumberMetricTag metric_tags = 7;
}

// ICMPv6 checksum
message PatternFlowIcmpv6EchoChecksum {

  message Choice {
    enum Enum {
      unspecified = 0;
      generated = 1;
      custom = 2;
    }
  }
  // The type of checksum
  // default = Choice.Enum.generated
  optional Choice.Enum choice = 1;

  message Generated {
    enum Enum {
      unspecified = 0;
      good = 1;
      bad = 2;
    }
  }
  // A system generated checksum value
  // default = Generated.Enum.good
  optional Generated.Enum generated = 2;

  // A custom checksum value
  optional uint32 custom = 3;
}

// ICMPv6 checksum
message PatternFlowIcmpv6CommonChecksum {

  message Choice {
    enum Enum {
      unspecified = 0;
      generated = 1;
      custom = 2;
    }
  }
  // The type of checksum
  // default = Choice.Enum.generated
  optional Choice.Enum choice = 1;

  message Generated {
    enum Enum {
      unspecified = 0;
      good = 1;
      bad = 2;
    }
  }
  // A system generated checksum value
  // default = Generated.Enum.good
  optional Generated.Enum generated = 2;

  // A custom checksum value
  optional uint32 custom = 3;
}

// integer counter pattern
message PatternFlowPppAddressCounter {

  // Description missing in models
  // default = 255
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowPppAddressMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 8
  optional uint32 length = 3;
}

// PPP address
message PatternFlowPppAddress {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 255
  optional uint32 value = 2;

  // Description missing in models
  // default = [255]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowPppAddressCounter increment = 5;

  // Description missing in models
  optional PatternFlowPppAddressCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowPppAddressMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowPppControlCounter {

  // Description missing in models
  // default = 3
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowPppControlMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 8
  optional uint32 length = 3;
}

// PPP control
message PatternFlowPppControl {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 3
  optional uint32 value = 2;

  // Description missing in models
  // default = [3]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowPppControlCounter increment = 5;

  // Description missing in models
  optional PatternFlowPppControlCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowPppControlMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowPppProtocolTypeCounter {

  // Description missing in models
  // default = 33
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowPppProtocolTypeMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// PPP protocol type
message PatternFlowPppProtocolType {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      auto = 1;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.auto
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 33
  optional uint32 value = 2;

  // Description missing in models
  // default = [33]
  repeated uint32 values = 3;

  // The OTG implementation can provide a system generated
  // value for this property. If the OTG is unable to generate a value
  // the default value must be used.
  // default = 33
  optional uint32 auto = 4;

  // Description missing in models
  optional PatternFlowPppProtocolTypeCounter increment = 6;

  // Description missing in models
  optional PatternFlowPppProtocolTypeCounter decrement = 7;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowPppProtocolTypeMetricTag metric_tags = 8;
}

// integer counter pattern
message PatternFlowIgmpv1VersionCounter {

  // Description missing in models
  // default = 1
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIgmpv1VersionMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 4
  optional uint32 length = 3;
}

// Version number
message PatternFlowIgmpv1Version {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 1
  optional uint32 value = 2;

  // Description missing in models
  // default = [1]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowIgmpv1VersionCounter increment = 5;

  // Description missing in models
  optional PatternFlowIgmpv1VersionCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIgmpv1VersionMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIgmpv1TypeCounter {

  // Description missing in models
  // default = 1
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIgmpv1TypeMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 4
  optional uint32 length = 3;
}

// Type of message
message PatternFlowIgmpv1Type {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 1
  optional uint32 value = 2;

  // Description missing in models
  // default = [1]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowIgmpv1TypeCounter increment = 5;

  // Description missing in models
  optional PatternFlowIgmpv1TypeCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIgmpv1TypeMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIgmpv1UnusedCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIgmpv1UnusedMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 8
  optional uint32 length = 3;
}

// Unused
message PatternFlowIgmpv1Unused {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowIgmpv1UnusedCounter increment = 5;

  // Description missing in models
  optional PatternFlowIgmpv1UnusedCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIgmpv1UnusedMetricTag metric_tags = 7;
}

// Checksum
message PatternFlowIgmpv1Checksum {

  message Choice {
    enum Enum {
      unspecified = 0;
      generated = 1;
      custom = 2;
    }
  }
  // The type of checksum
  // default = Choice.Enum.generated
  optional Choice.Enum choice = 1;

  message Generated {
    enum Enum {
      unspecified = 0;
      good = 1;
      bad = 2;
    }
  }
  // A system generated checksum value
  // default = Generated.Enum.good
  optional Generated.Enum generated = 2;

  // A custom checksum value
  optional uint32 custom = 3;
}

// ipv4 counter pattern
message PatternFlowIgmpv1GroupAddressCounter {

  // Description missing in models
  // default = 0.0.0.0
  optional string start = 1;

  // Description missing in models
  // default = 0.0.0.1
  optional string step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIgmpv1GroupAddressMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 32
  optional uint32 length = 3;
}

// Group address
message PatternFlowIgmpv1GroupAddress {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0.0.0.0
  optional string value = 2;

  // Description missing in models
  // default = ['0.0.0.0']
  repeated string values = 3;

  // Description missing in models
  optional PatternFlowIgmpv1GroupAddressCounter increment = 5;

  // Description missing in models
  optional PatternFlowIgmpv1GroupAddressCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIgmpv1GroupAddressMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowMplsLabelCounter {

  // Description missing in models
  // default = 16
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowMplsLabelMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 20
  optional uint32 length = 3;
}

// Label of routers
message PatternFlowMplsLabel {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      auto = 1;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.auto
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 16
  optional uint32 value = 2;

  // Description missing in models
  // default = [16]
  repeated uint32 values = 3;

  // The OTG implementation can provide a system generated
  // value for this property. If the OTG is unable to generate a value
  // the default value must be used.
  // default = 16
  optional uint32 auto = 4;

  // Description missing in models
  optional PatternFlowMplsLabelCounter increment = 6;

  // Description missing in models
  optional PatternFlowMplsLabelCounter decrement = 7;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowMplsLabelMetricTag metric_tags = 8;
}

// integer counter pattern
message PatternFlowMplsTrafficClassCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowMplsTrafficClassMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 3
  optional uint32 length = 3;
}

// Traffic class
message PatternFlowMplsTrafficClass {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowMplsTrafficClassCounter increment = 5;

  // Description missing in models
  optional PatternFlowMplsTrafficClassCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowMplsTrafficClassMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowMplsBottomOfStackCounter {

  // Description missing in models
  // default = 1
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowMplsBottomOfStackMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// Bottom of stack
message PatternFlowMplsBottomOfStack {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      auto = 1;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.auto
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 1
  optional uint32 value = 2;

  // Description missing in models
  // default = [1]
  repeated uint32 values = 3;

  // The OTG implementation can provide a system generated
  // value for this property. If the OTG is unable to generate a value
  // the default value must be used.
  // default = 1
  optional uint32 auto = 4;

  // Description missing in models
  optional PatternFlowMplsBottomOfStackCounter increment = 6;

  // Description missing in models
  optional PatternFlowMplsBottomOfStackCounter decrement = 7;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowMplsBottomOfStackMetricTag metric_tags = 8;
}

// integer counter pattern
message PatternFlowMplsTimeToLiveCounter {

  // Description missing in models
  // default = 64
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowMplsTimeToLiveMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 8
  optional uint32 length = 3;
}

// Time to live
message PatternFlowMplsTimeToLive {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 64
  optional uint32 value = 2;

  // Description missing in models
  // default = [64]
  repeated uint32 values = 3;

  // Description missing in models
  optional PatternFlowMplsTimeToLiveCounter increment = 5;

  // Description missing in models
  optional PatternFlowMplsTimeToLiveCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowMplsTimeToLiveMetricTag metric_tags = 7;
}

// Version details
message Version {

  // Version of API specification
  // default =
  optional string api_spec_version = 1;

  // Version of SDK generated from API specification
  // default =
  optional string sdk_version = 2;

  // Version of application consuming or serving the API
  // default =
  optional string app_version = 3;
}

// The request has succeeded with no application content but the server
// may return a list of detailed warnings.
message Success {
  Warning warning = 1;
}

// The request did not succeed and server has responded with error details.
message Failure {
  Error error = 1;
}

message SetConfigRequest {
  Config config = 1;
}

message UpdateConfigRequest {
  ConfigUpdate config_update = 1;
}
message SetConfigResponse {
  Warning warning = 1;
}

message GetConfigResponse {
  Config config = 1;
}

message UpdateConfigResponse {
  Warning warning = 1;
}


message SetControlStateRequest {
  ControlState control_state = 1;
}
message SetControlStateResponse {
  Warning warning = 1;
}


message SetControlActionRequest {
  ControlAction control_action = 1;
}
message SetControlActionResponse {
  ControlActionResponse control_action_response = 1;
}


message SetTransmitStateRequest {
  TransmitState transmit_state = 1;
}
message SetTransmitStateResponse {
  Warning warning = 1;
}


message SetLinkStateRequest {
  LinkState link_state = 1;
}
message SetLinkStateResponse {
  Warning warning = 1;
}


message SetCaptureStateRequest {
  CaptureState capture_state = 1;
}
message SetCaptureStateResponse {
  Warning warning = 1;
}


message UpdateFlowsRequest {
  FlowsUpdate flows_update = 1;
}
message UpdateFlowsResponse {
  Config config = 1;
}


message SetRouteStateRequest {
  RouteState route_state = 1;
}
message SetRouteStateResponse {
  Warning warning = 1;
}


message SendPingRequest {
  PingRequest ping_request = 1;
}
message SendPingResponse {
  PingResponse ping_response = 1;
}


message SetProtocolStateRequest {
  ProtocolState protocol_state = 1;
}
message SetProtocolStateResponse {
  Warning warning = 1;
}


message SetDeviceStateRequest {
  DeviceState device_state = 1;
}
message SetDeviceStateResponse {
  Warning warning = 1;
}


message GetMetricsRequest {
  MetricsRequest metrics_request = 1;
}
message GetMetricsResponse {
  MetricsResponse metrics_response = 1;
}


message GetStatesRequest {
  StatesRequest states_request = 1;
}
message GetStatesResponse {
  StatesResponse states_response = 1;
}


message GetCaptureRequest {
  CaptureRequest capture_request = 1;
}
message GetCaptureResponse {
  bytes response_bytes = 1;
}

message GetVersionResponse {
  Version version = 1;
}


// Description missing in models
//
// For all RPCs defined in this service, API Server SHOULD provide JSON
// representation of `Error` message as an error string upon failure, ensuring
// name of enum constants (instead of value) for `kind` property is present
// in the representation
service Openapi {

  // Sets configuration resources on the traffic generator.
  rpc SetConfig(SetConfigRequest) returns (SetConfigResponse);
  // Description missing in models
  rpc GetConfig(google.protobuf.Empty) returns (GetConfigResponse);
  // Updates specific attributes of resources configured on the traffic generator. The
  // fetched configuration shall reflect the updates applied successfully.
  // The Response.Warnings in the Success response is available for implementers to disclose
  // additional information about a state change including any implicit changes that are
  // outside the scope of the state change.
  rpc UpdateConfig(UpdateConfigRequest) returns (UpdateConfigResponse);
  // Sets the operational state of configured resources.
  rpc SetControlState(SetControlStateRequest) returns (SetControlStateResponse);
  // Triggers actions against configured resources.
  rpc SetControlAction(SetControlActionRequest) returns (SetControlActionResponse);
  // Deprecated: Please use `set_control_state` with `traffic.flow_transmit` choice instead
  // 
  // Updates the state of configuration resources on the traffic generator.
  // The Response.Warnings in the Success response is available for implementers to disclose
  // additional information about a state change including any implicit changes that are
  // outside the scope of the state change.
  rpc SetTransmitState(SetTransmitStateRequest) returns (SetTransmitStateResponse);
  // Deprecated: Please use `set_control_state` with `port.link` choice instead
  // 
  // Updates the state of configuration resources on the traffic generator.
  rpc SetLinkState(SetLinkStateRequest) returns (SetLinkStateResponse);
  // Deprecated: Please use `set_control_state` with `port.capture` choice instead
  // 
  // Updates the state of configuration resources on the traffic generator.
  rpc SetCaptureState(SetCaptureStateRequest) returns (SetCaptureStateResponse);
  // Deprecated: Please use `update_config` with `flow` choice instead
  // 
  // Updates flow properties without disruption of transmit state.
  rpc UpdateFlows(UpdateFlowsRequest) returns (UpdateFlowsResponse);
  // Deprecated: Please use `set_control_state` with `protocol.route` choice instead
  // 
  // Updates the state of configuration resources on the traffic generator.
  rpc SetRouteState(SetRouteStateRequest) returns (SetRouteStateResponse);
  // Deprecated: Please use `set_control_action` with `protocol.ipv*.ping` choice instead
  // 
  // API to send an IPv4 and/or IPv6 ICMP Echo Request(s) between endpoints. For each
  // endpoint 1 ping packet will be sent and API shall wait for ping response to either
  // be successful or timeout. The API wait timeout for each request is 300ms.
  rpc SendPing(SendPingRequest) returns (SendPingResponse);
  // Deprecated: Please use `set_control_state` with `protocol.all` choice instead
  // 
  // Sets all configured protocols to `start` or `stop` state.
  rpc SetProtocolState(SetProtocolStateRequest) returns (SetProtocolStateResponse);
  // Deprecated: Please use `set_control_state` with `protocol` choice instead
  // 
  // Set specific state/actions on device configuration resources on the traffic generator.
  rpc SetDeviceState(SetDeviceStateRequest) returns (SetDeviceStateResponse);
  // Description missing in models
  rpc GetMetrics(GetMetricsRequest) returns (GetMetricsResponse);
  // Description missing in models
  rpc GetStates(GetStatesRequest) returns (GetStatesResponse);
  // Description missing in models
  rpc GetCapture(GetCaptureRequest) returns (GetCaptureResponse);
  // Description missing in models
  rpc GetVersion(google.protobuf.Empty) returns (GetVersionResponse);
}
