/* Open Traffic Generator API 1.45.1
 * Open Traffic Generator API defines a model-driven, vendor-neutral and standard
 * interface for emulating layer 2-7 network devices and generating test traffic.
 * 
 * Contributions can be made in the following ways:
 * - [open an issue](https://github.com/open-traffic-generator/models/issues) in the
 * models repository
 * - [fork the models repository](https://github.com/open-traffic-generator/models)
 * and submit a PR
 * License: MIT */

syntax = "proto3";

package otg;

option go_package = "./otg;otg";

import "google/protobuf/descriptor.proto";
import "google/protobuf/empty.proto";

// A container for all models that are part of the configuration.
message Config {

  // The ports that will be configured on the traffic generator.
  repeated Port ports = 1;

  // The LAGs that will be configured on the traffic generator.
  repeated Lag lags = 2;

  // The layer1 settings that will be configured on the traffic generator.
  // Since layer1 settings usually vary across variety of test ports, these
  // most likely won't be portable.
  repeated Layer1 layer1 = 3;

  // The capture settings that will be configured on the traffic generator.
  repeated Capture captures = 4;

  // The emulated devices that will be configured on the traffic generator.
  // Each device contains configurations for network interfaces and
  // protocols running on top of those interfaces.
  repeated Device devices = 5;

  // The flows that will be configured on the traffic generator.
  repeated Flow flows = 6;

  // Description missing in models
  Event events = 7;

  // Description missing in models
  ConfigOptions options = 8;

  // LLDP protocol that will be configured on traffic generator.
  repeated Lldp lldp = 9;

  // Description missing in models
  StatefulFlow stateful_flows = 10;

  // Container for specification of desired tracking, based on certain offset and length
  // of bits
  // for received packets on specified receive ports.
  // It enables the user to retrieve information based on number of unique packets
  // received for each unique value in the bits being tracked from the beginning of the
  // test.
  repeated EgressOnlyTracking egress_only_tracking = 11;
}

// Global configuration options.
message ConfigOptions {

  // Description missing in models
  PortOptions port_options = 1;

  // Description missing in models
  ProtocolOptions protocol_options = 2;

  // Description missing in models
  repeated PerPortOptions per_port_options = 3;
}

// An abstract test port.
message Port {

  // The location of a test port.  It is the endpoint where packets will emit from.
  // Test port locations can be the following:
  // - physical appliance with multiple ports
  // - physical chassis with multiple cards and ports
  // - local interface
  // - virtual machine, docker container, kubernetes cluster
  // 
  // The test port location format is implementation specific. Use the /results/capabilities
  // API to determine what formats an  implementation supports for the location property.
  // Get the configured location state by using the /results/port API.
  optional string location = 1;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  optional string name = 2;
}

// Common port options that apply to all configured Port objects.
message PortOptions {

  // Preempt all the test port locations as defined by the  Port.Port.properties.location.
  // If the test ports defined by their location values are in use and  this value is
  // true, the test ports will be preempted.
  // default = False
  optional bool location_preemption = 1;

  // Check and validate that flow payload has not been modified when received on Rx port.
  // It applies to all flows across all ports and if set to true, it is reported in data
  // integrity in port statistics with frame count both for frames with unmodified payload
  // as frames_rx and for frames which has payload modified during transit as errors.
  // default = False
  optional bool data_integrity = 2;
}

// The container for LAG (ports group) - aggregation of multiple LAG members (ports)
message Lag {

  // Description missing in models
  repeated LagPort ports = 1;

  // Description missing in models
  LagProtocol protocol = 2;

  // Specifies the mininum number of member interfaces that must be active for the aggregate
  // interface to be available.
  // If the aggregate interface is not available due to min-links criterion not being
  // met, LACPDUs continue to be transmitted and received by the member interfaces if
  // LACP is enabled, but other PDUs are not transmitted or received.
  // default = 1
  optional uint32 min_links = 3;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  optional string name = 4;
}

// The container for a port's ethernet interface and LAG protocol settings
message LagPort {

  // The name of a port object that will be part of the LAG.
  // 
  // x-constraint:
  // - /components/schemas/Port/properties/name
  // 
  // required = true
  optional string port_name = 1;

  // Description missing in models
  LagPortLacp lacp = 2;

  // Description missing in models
  // required = true
  DeviceEthernetBase ethernet = 3;
}

// Description missing in models
message LagProtocol {

  message Choice {
    enum Enum {
      unspecified = 0;
      lacp = 1;
      static = 2;
    }
  }
  // The type of controlling protocol for the LAG (ports group).
  // default = Choice.Enum.lacp
  optional Choice.Enum choice = 1;

  // Description missing in models
  LagProtocolLacp lacp = 2;

  // Description missing in models
  LagProtocolStatic static = 3;
}

// The container for static link aggregation protocol settings.
message LagProtocolStatic {

  // The static lag id
  // default = 0
  optional uint32 lag_id = 1;
}

// The container for link aggregation control protocol settings of a LAG (ports group).
message LagProtocolLacp {

  // The actor system id
  // default = 00:00:00:00:00:00
  optional string actor_system_id = 1;

  // The actor system priority
  // default = 0
  optional uint32 actor_system_priority = 2;

  // The actor key
  // default = 0
  optional uint32 actor_key = 3;
}

// The container for link aggregation control protocol settings of a LAG member (port).
message LagPortLacp {

  // The actor port number
  // default = 0
  optional uint32 actor_port_number = 1;

  // The actor port priority
  // default = 1
  optional uint32 actor_port_priority = 2;

  message ActorActivity {
    enum Enum {
      unspecified = 0;
      passive = 1;
      active = 2;
    }
  }
  // Sets the value of LACP actor activity as either passive or active.
  // Passive indicates the port's preference for not transmitting  LACPDUs unless its
  // partner's control is Active.
  // Active indicates the port's preference to participate in the  protocol regardless
  // of the partner's control value.
  // default = ActorActivity.Enum.active
  optional ActorActivity.Enum actor_activity = 3;

  // This field defines how frequently LACPDUs are sent to the link partner
  // default = 0
  optional uint32 lacpdu_periodic_time_interval = 4;

  // This timer is used to detect whether received protocol information has expired
  // default = 0
  optional uint32 lacpdu_timeout = 5;
}

// Base Ethernet interface.
message DeviceEthernetBase {

  // Media Access Control address.The implementation should ensure that the 'mac' field
  // is explicitly configured by the user for  all types of interfaces as denoted by 'connection'
  // attribute except 'simulated_link' where 'mac' is not mandatory.
  optional string mac = 1;

  // Maximum Transmission Unit.
  // default = 1500
  optional uint32 mtu = 2;

  // List of VLANs
  repeated DeviceVlan vlans = 3;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  optional string name = 4;
}

// An Ethernet interface with IPv4 and IPv6 addresses. The implementation should ensure
// that the 'mac' field is explicitly configured by the user for  all types of interfaces
// as denoted by 'connection' attribute except 'simulated_link' where MAC is not mandatory.
message DeviceEthernet {

  // Device connection to physical, LAG or another device.
  EthernetConnection connection = 2;

  // List of IPv4 addresses and their gateways.
  repeated DeviceIpv4 ipv4_addresses = 3;

  // List of global IPv6 addresses and their gateways.
  // The Link Local IPv6 address will be automatically generated.
  repeated DeviceIpv6 ipv6_addresses = 4;

  // Media Access Control address.The implementation should ensure that the 'mac' field
  // is explicitly configured by the user for  all types of interfaces as denoted by 'connection'
  // attribute except 'simulated_link' where 'mac' is not mandatory.
  optional string mac = 5;

  // Maximum Transmission Unit.
  // default = 1500
  optional uint32 mtu = 6;

  // List of VLANs
  repeated DeviceVlan vlans = 7;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  optional string name = 8;

  // List of DHCPv4 Clients Configuration.
  repeated DeviceDhcpv4client dhcpv4_interfaces = 9;

  // List of DHCPv6 Clients Configuration.
  repeated DeviceDhcpv6client dhcpv6_interfaces = 10;
}

// Ethernet interface connection to a port, LAG, VXLAN tunnel or a Simulated Internal
// Link used to create simulated topologies behind an emulated router.
message EthernetConnection {

  message Choice {
    enum Enum {
      unspecified = 0;
      port_name = 1;
      lag_name = 2;
      vxlan_name = 3;
      simulated_link = 4;
    }
  }
  // port_name, lag_name, vxlan_name or simulated_link
  optional Choice.Enum choice = 1;

  // Name of the port that the Ethernet interface is configured on.
  // 
  // x-constraint:
  // - /components/schemas/Port/properties/name
  // 
  optional string port_name = 2;

  // Name of the LAG that the Ethernet interface is configured on.
  // 
  // x-constraint:
  // - /components/schemas/Lag/properties/name
  // 
  optional string lag_name = 3;

  // Name of the VXLAN instance (or VXLAN tunnel) that this Ethernet interface is connected
  // to.
  // 
  // x-constraint:
  // - #/components/schemas/Vxlan.V4Tunnel/properties/name
  // - #/components/schemas/Vxlan.V6Tunnel/properties/name
  // 
  optional string vxlan_name = 4;

  // Description missing in models
  EthernetSimulatedLink simulated_link = 5;
}

// Details of the internal link which can be used to create simulated device topologies
// behind an emulated router. MAC, VLAN and MTU information for the internal links are
// not used for purposes of emulating Simulated Topologies ( e.g. by ISIS Emulated Router
// behind which this is configured )
message EthernetSimulatedLink {

  // Name of the remote end of the simulated interface which also must be a simulated_link
  // on a device which might be acting either as an unconnected device in a simulated
  // topology
  // ( all ethernet links of type simulated_link ) or an emulated device connected to
  // the Device Under Test (has at atleast one ethernet interface with connection to the
  // port or
  // lag connected to the DUT)
  // 
  // x-constraint:
  // - #/components/schemas/Device.Ethernet/properties/name
  // 
  optional string remote_simulated_link = 1;

  message LinkType {
    enum Enum {
      unspecified = 0;
      primary = 1;
      secondary = 2;
    }
  }
  // By default, simulated links are treated as Primary links , which means that the intention
  // is for connected device to advertise this and full topology of devices connected
  // to it.
  // e.g. when advertised as ISIS Simulated Topology.
  // 
  // All simulated links inside one topology subset would normally can point to only other
  // unconnected devices in the same topology or to the 'root' emulated device.
  // If a link is designated as secondary , only that link information will be advertised
  // by the IGP e.g. ISIS , and not the entire topology behind it.
  // The optional secondary option allows emulation of external link scenarios where a
  // simulated device (e.g. part of a ISIS simulated topology ) is advertised as reachable
  // part of the topology
  // by the emulated router behind which this is configured , as well as the other end
  // of the secondary link which could be
  // - 1) either a simulated device behind a different emulated router.
  // - 2) or an emulated router on same or different port.
  // This allows emulation of scenarios where one device/router is emulated to be reachable
  // from different Emulated Routers connected to the Device Under Test. (e.g. for FRR
  // scenarios)
  // 
  // If an implementation does not support multiple primary links from same simulated
  // topology i.e. full topology advertised via multiple emulated routers, it should return
  // an error
  // during set_config operation with such a topology.
  // default = LinkType.Enum.primary
  optional LinkType.Enum link_type = 2;
}

// Emulated VLAN protocol.
message DeviceVlan {

  message Tpid {
    enum Enum {
      unspecified = 0;
      x8100 = 1;
      x88A8 = 2;
      x9100 = 3;
      x9200 = 4;
      x9300 = 5;
    }
  }
  // Tag protocol identifier
  // default = Tpid.Enum.x8100
  optional Tpid.Enum tpid = 1;

  // Priority code point
  // default = 0
  optional uint32 priority = 2;

  // VLAN identifier
  // default = 1
  optional uint32 id = 3;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  optional string name = 4;
}

// An IPv4 interface with gateway
message DeviceIpv4 {

  // The IPv4 address of the gateway
  // required = true
  optional string gateway = 1;

  // Description missing in models
  DeviceIpv4GatewayMAC gateway_mac = 2;

  // The IPv4 address
  // required = true
  optional string address = 3;

  // The prefix of the IPv4 address.
  // default = 24
  optional uint32 prefix = 4;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  optional string name = 5;
}

// An IPv4 Loopback interface.
message DeviceIpv4Loopback {

  // The unique name of the Ethernet interface behind which this Loopback  interface will
  // be created.
  // 
  // x-constraint:
  // - /components/schemas/Device.Ethernet/properties/name
  // 
  // required = true
  optional string eth_name = 1;

  // The IPv4 Loopback address with prefix length of 32.
  // default = 0.0.0.0
  optional string address = 2;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  optional string name = 3;
}

// By default auto(resolved gateway mac) is set.  Setting a value would mean that ARP
// will not be used for learning MAC of connected device. The user-configured MAC address
// will be used for auto-filling the destination
// MAC address in the control and data packets sent from this IPv4 endpoint
// whenever applicable.
message DeviceIpv4GatewayMAC {

  message Choice {
    enum Enum {
      unspecified = 0;
      auto = 1;
      value = 2;
    }
  }
  // auto or configured value.
  // default = Choice.Enum.auto
  optional Choice.Enum choice = 1;

  // The OTG implementation can provide a system generated value for this property. If
  // the OTG is unable to generate a value the default value must be used.
  // default = 00:00:00:00:00:00
  optional string auto = 2;

  // Description missing in models
  // default = 00:00:00:00:00:00
  optional string value = 3;
}

// An IPv6 interface with gateway.
message DeviceIpv6 {

  // The IPv6 gateway address.
  // required = true
  optional string gateway = 1;

  // Description missing in models
  DeviceIpv6GatewayMAC gateway_mac = 2;

  // The IPv6 address.
  // required = true
  optional string address = 3;

  // The network prefix.
  // default = 64
  optional uint32 prefix = 4;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  optional string name = 5;
}

// An IPv6 Loopback interface
message DeviceIpv6Loopback {

  // The unique name of the Ethernet interface behind which this Loopback
  // interface will be created.
  // 
  // x-constraint:
  // - /components/schemas/Device.Ethernet/properties/name
  // 
  // required = true
  optional string eth_name = 1;

  // The IPv6 Loopback address with prefix length of 128.
  // default = ::0
  optional string address = 2;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  optional string name = 3;
}

// By default auto(resolved gateway mac) is set. Setting a value would mean that ND
// will not be used for learning MAC of connected device. The user-configured MAC address
// will be used for auto-filling the destination
// MAC address in the control and data packets sent from this IPv6 endpoint
// whenever applicable.
message DeviceIpv6GatewayMAC {

  message Choice {
    enum Enum {
      unspecified = 0;
      auto = 1;
      value = 2;
    }
  }
  // auto or configured value.
  // default = Choice.Enum.auto
  optional Choice.Enum choice = 1;

  // The OTG implementation can provide a system generated value for this property. If
  // the OTG is unable to generate a value the default value must be used.
  // default = 00:00:00:00:00:00
  optional string auto = 2;

  // Description missing in models
  // default = 00:00:00:00:00:00
  optional string value = 3;
}

// Configuration for emulated DHCPv4 Client on a single Interface. https://www.rfc-editor.org/rfc/rfc2131.html
message DeviceDhcpv4client {

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  optional string name = 1;

  message Choice {
    enum Enum {
      unspecified = 0;
      first_server = 1;
      server_address = 2;
    }
  }
  // The client receives one or more DHCPOFFER messages from one or more servers and client
  // may choose to wait for multiple responses.
  // The client chooses one server from which to request configuration
  // parameters, based on the configuration parameters offered in the DHCPOFFER messages.
  // - first_server: if selected, the subnet accepts the IP addresses offered by the first
  // server to respond with an offer of IP addresses.
  // - server_address: The address of the DHCP server from which the subnet will accept
  // IP addresses.
  // default = Choice.Enum.first_server
  optional Choice.Enum choice = 2;

  // The address of the DHCP server.
  optional string server_address = 4;

  // If the broadcast bit is set, then the server and relay agent broadcast DHCPOFFER
  // and DHCPACK messages.
  // default = False
  optional bool broadcast = 5;

  // Optional parameters field request list of DHCPv4 Client.
  Dhcpv4ClientParams parameters_request_list = 6;
}

// Configuration Parameter request list by emulated DHCPv4 Client.
message Dhcpv4ClientParams {

  // Request for the subnet mask option specifies the client's subnet mask as per RFC950.
  // 
  // default = True
  optional bool subnet_mask = 1;

  // Request for the router option that specifies a list of IP addresses for routers on
  // the client's subnet.
  // default = True
  optional bool router = 2;

  // Request for the renewal timer, T1. When the timer expires, the client transitions
  // from the BOUND state to the RENEWING state.
  // default = False
  optional bool renewal_timer = 3;

  // Request for the rebinding timer (T2). When expires, the client transitions to the
  // REBINDING state.
  // default = False
  optional bool rebinding_timer = 4;
}

// Configuration for emulated DHCPv6 Client on a single Interface. If the DHCPv6 Client
// receives one or more  DHCPv6 ADVERTISE messages from one or more servers then the
// client chooses one server from which to request  configuration parameters, based
// on the configuration parameters offered by the server in the DHCPv6 ADVERTISE  messages.
// If all configuration parameters match then the first server will be chosen. https://www.rfc-editor.org/rfc/rfc8415.html
message DeviceDhcpv6client {

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  optional string name = 1;

  // If Rapid Commit is set, client initiates Rapid Commit two-message exchange by including
  // Rapid Commit option  in Solicit message.
  // default = False
  optional bool rapid_commit = 2;

  // Each IA has an associated IAID. Differnet IA options represent different types of
  // IPv6 addresses and parameters
  // accepted by DHCPv6 clients each used in different context by an IPv6 node.
  DeviceDhcpv6clientIaType ia_type = 3;

  // Each DHCP client and server has a DUID. DHCP clients and servers use DUIDs to identify
  // each other.
  DeviceDhcpv6clientDuidType duid_type = 4;

  // The options requested by a client from a server in the options request option.
  DeviceDhcpv6ClientOptionsRequest options_request = 5;

  // Optional DHCPv4 Client options that are sent in Dhcp client messages.
  DeviceDhcpv6ClientOptions options = 6;
}

// DHCP client options, these configured options are sent in Dhcp client messages.
message DeviceDhcpv6ClientOptionsRequest {

  // List of options requested by a client from a server.
  repeated Dhcpv6ClientOptionsOptionsRequest request = 1;

  // The list of dhcpv6 client messages where this option is included.
  // required = true
  Dhcpv6ClientOptionsIncludedMessages associated_dhcp_messages = 2;
}

// DHCP client options, these configured options are sent in Dhcp client messages.
message DeviceDhcpv6ClientOptions {

  // A client uses multicast to reach all servers or an individual server. An individual
  // server is indicated by
  // specifying that server's DUID in a Server Identifier option in the client's message
  // (all servers will receive
  // this message but only the indicated server will respond). All servers are indicated
  // by not supplying this option.
  Dhcpv6ClientOptionsServerIdentifier server_identifier = 1;

  // The vendor class option is used by a client to identify the vendor that manufactured
  // the hardware on which
  // the client is running. The information contained in the data area of this option
  // is contained in one or more
  // opaque fields that identify details of the hardware configuration.
  Dhcpv6ClientOptionsVendorClass vendor_class = 2;

  // This option is used by clients to exchange vendor-specific information with servers.
  Dhcpv6ClientOptionsVendorInfo vendor_info = 3;

  // DHCPv6 server needs to know the FQDN of the client for the addresses for the client's
  // IA_NA bindings in order to
  // update the IPv6-address-to-FQDN mapping. This option allows the client to convey
  // its FQDN to the server. The Client
  // FQDN option also contains Flags that DHCPv6 clients and servers use to negotiate
  // who does which update.
  Dhcpv6ClientOptionsFqdn fqdn = 4;
}

// Description missing in models
message DeviceDhcpv6clientIaType {

  message Choice {
    enum Enum {
      unspecified = 0;
      iana = 1;
      iata = 2;
      iapd = 3;
      ianapd = 4;
    }
  }
  // Identity Association: Each IA has an associated IAID. IA_NA and IA_TA options represent
  // different types of  IPv6 addresses and parameters accepted by DHCPv6 clients each
  // used in different context by an IPv6 node. IA_NA  is the Identity Association for
  // Non-temporary Addresses option. IA_TA is the Identity Association for Temporary
  // Addresses option. IA_PD and IA_NAPD options represent one or more IPv6 prefix and
  // parameters. IA_PD is the Identity  Association for Prefix Delegation and IA_NAPD
  // s the Identity Association for Temporary Prefix Delegation.
  // default = Choice.Enum.iana
  optional Choice.Enum choice = 1;

  // Description missing in models
  DeviceDhcpv6clientIaTimeValue iana = 2;

  // Description missing in models
  DeviceDhcpv6clientIaTimeValue iapd = 3;

  // Description missing in models
  DeviceDhcpv6clientIaTimeValue ianapd = 4;
}

// The container for the suggested times at which the client contacts the server or
// any available server.
message DeviceDhcpv6clientIaTimeValue {

  // The suggested time at which the client contacts the server from which the addresses
  // were obtained to  extend the lifetimes of the addresses assigned. T1 is a time duration
  // relative to the current time expressed  in units of seconds. If set to 0 server will
  // ignore it. If the maximum value is specified it means infinite time.
  // default = 302400
  optional uint32 t1 = 1;

  // The suggested time at which the client contacts any available server to extend the
  // lifetimes of the addresses assigned.  T2 is a time duration relative to the current
  // time expressed in units of seconds. If set to 0 server will ignore it. If  the maximum
  // value is specified it means infinite time
  // default = 483840
  optional uint32 t2 = 2;
}

// Description missing in models
message DeviceDhcpv6clientDuidType {

  message Choice {
    enum Enum {
      unspecified = 0;
      llt = 1;
      en = 2;
      ll = 3;
    }
  }
  // Each DHCP client and server has a DUID. DHCP clients use DUIDs to identify a server
  // in messages where a server needs  to be identified.
  // default = Choice.Enum.llt
  optional Choice.Enum choice = 1;

  // Description missing in models
  DeviceDhcpv6clientNoDuid llt = 2;

  // Description missing in models
  DeviceDhcpv6clientDuidValue en = 3;

  // Description missing in models
  DeviceDhcpv6clientNoDuid ll = 4;
}

// The container for the DUID-EN. This consists of the 4-octet vendor's registered Private
// Enterprise Number  as maintained by IANA [IANA-PEN] followed by a unique identifier
// assigned by the vendor.
message DeviceDhcpv6clientDuidValue {

  // 4-octet vendor's registered Private Enterprise Number as maintained by IANA [IANA-PEN].
  // default = 10
  optional uint32 enterprise_id = 1;

  // Unique identifier assigned by the vendor.
  // default = 10
  optional uint32 vendor_id = 2;
}

// The container for DUID-LL and DUID-LLT.
message DeviceDhcpv6clientNoDuid {
}

// Description missing in models
message Dhcpv6ClientOptionsServerIdentifier {

  message Choice {
    enum Enum {
      unspecified = 0;
      duid_llt = 1;
      duid_en = 2;
      duid_ll = 3;
      duid_uuid = 4;
    }
  }
  // The Identifier option is used to carry a DUID. The option code is 2. The server identifier
  // identifies  a server. This option is used when client wants to contact a particular
  // server.
  // default = Choice.Enum.duid_ll
  optional Choice.Enum choice = 1;

  // Description missing in models
  Dhcpv6ClientOptionsDuidLlt duid_llt = 2;

  // Description missing in models
  Dhcpv6ClientOptionsDuidEn duid_en = 3;

  // Description missing in models
  Dhcpv6ClientOptionsDuidLl duid_ll = 4;

  // Description missing in models
  Dhcpv6ClientOptionsDuidUuid duid_uuid = 5;
}

// DUID based on Link Layer address plus time. Hardware Type will be auto assigned to
// ethernet type.
message Dhcpv6ClientOptionsDuidLlt {

  // The time value is the time that the DUID is generated represented in seconds since
  // midnight (UTC), January 1,
  // 2000, modulo 2^32. The DUID generatation time will the current time when dhcpv6 client
  // contacts the server.
  // required = true
  optional uint32 time = 1;

  // The link-layer address is stored in canonical form, as described in RFC 2464.
  // 
  // required = true
  Dhcpv6ClientOptionsLinkLayerAddress link_layer_address = 2;
}

// DUID assigned by vendor based on enterprise number.
message Dhcpv6ClientOptionsDuidEn {

  // Vendor's registered private enterprise number as maintained by IANA.
  // required = true
  optional uint32 enterprise_number = 1;

  // The unique identifier assigned by the vendor.
  // required = true
  optional string identifier = 2;
}

// DUID based on Link Layer address. Hardware Type will be auto assigned to ethernet
// type.
message Dhcpv6ClientOptionsDuidLl {

  // The link-layer address is stored in canonical form, as described in RFC 2464.
  // 
  // required = true
  Dhcpv6ClientOptionsLinkLayerAddress link_layer_address = 1;
}

// DUID embedded a Universally Unique IDentifier (UUID). A UUID is an identifier that
// is unique across both  space and time, with respect to the space of all UUIDs.
message Dhcpv6ClientOptionsDuidUuid {

  // The version number is in the most significant 4 bits of the timestamp (bits 4 through
  // 7 of the time_hi_and_version field).
  Dhcpv6ClientOptionsDuidUuidVersion version = 1;

  // The variant field determines the layout of the UUID. It is multiplexed with clock_seq_hi_and_reserved.
  // 
  Dhcpv6ClientOptionsDuidUuidVariant variant = 2;

  // The low field of the timestamp.
  // default = 0
  optional uint32 time_low = 3;

  // The middle field of the timestamp.
  // default = 0
  optional uint32 time_mid = 4;

  // The high field of the timestamp multiplexed with the version number.
  // default = 0
  optional uint32 time_hi_and_version = 5;

  // The high field of the clock sequence multiplexed with the variant.
  // default = 0
  optional uint32 clock_seq_hi_and_reserved = 6;

  // The low field of the clock sequence.
  // default = 0
  optional uint32 clock_seq_low = 7;

  // The spatially unique node identifier.
  // default = 00:00:00:00:00:00
  optional string node = 8;
}

// The version number is in the most significant 4 bits of the timestamp (bits 4 through
// 7 of the time_hi_and_version field).
message Dhcpv6ClientOptionsDuidUuidVersion {

  message Choice {
    enum Enum {
      unspecified = 0;
      v_1 = 1;
      v_2 = 2;
      v_3 = 3;
      v_4 = 4;
      v_5 = 5;
    }
  }
  // The version values are from 1 to 5 in the most significant 4 bits of the timestamp
  // (bits 4 through 7 of the  time_hi_and_version field).
  // default = Choice.Enum.v_1
  optional Choice.Enum choice = 1;
}

// The variant field determines the layout of the UUID.  That is, the interpretation
// of all other bits in the  UUID depends on the setting of the bits in the variant
// field).
message Dhcpv6ClientOptionsDuidUuidVariant {

  message Choice {
    enum Enum {
      unspecified = 0;
      ncs = 1;
      dce = 2;
      guid = 3;
      var_reserved = 4;
    }
  }
  // The current variants are ncs, dce,microsoft guid and reserved.
  // default = Choice.Enum.ncs
  optional Choice.Enum choice = 1;
}

// The link-layer address configured in DUID llt or DUID ll.
message Dhcpv6ClientOptionsLinkLayerAddress {

  // The MAC address that becomes part of DUID llt or DUID ll.
  // required = true
  optional string value = 3;
}

// Description missing in models
message Dhcpv6ClientOptionsOptionsRequest {

  message Choice {
    enum Enum {
      unspecified = 0;
      vendor_information = 1;
      name_servers = 2;
      fqdn = 3;
      bootfile_url = 4;
      sztp = 5;
      custom = 6;
    }
  }
  // The Option Request option is used to identify a list of options in a message between
  // a client and a server. The  option code is 6. - Vendor_specific information option,
  // requested by clients for vendor-specific informations from servers. - DNS Recursive
  // Name Server Option, requested by clients to get the list ofIPv6 addresses of DNS
  // recursive name
  // servers to which DNS queries may be sent by the client resolver in order of preference.
  // - Client FQDN option - indicates whether the client or the DHCP server should update
  // DNS with the AAAA record
  // corresponding to the assigned IPv6 address and the FQDN provided in this option.
  // The DHCP server always updates
  // the PTR record.
  // - bootfile_url, if client is configured for network booting then the client must
  // use this option to obtain the boot
  // file url from the server.
  // - sztp. Securely provision a networking device when it is booting in a factory-default
  // state.
  // default = Choice.Enum.vendor_information
  optional Choice.Enum choice = 1;

  // Description missing in models
  Dhcpv6ClientOptionsCustom custom = 2;
}

// The Custom option is used to provide a not so well known option in the message between
// a client and a server.
message Dhcpv6ClientOptionsCustom {

  // The type of the Custom option TLV.
  // required = true
  optional uint32 type = 1;
}

// This option is used by a client to identify the vendor that manufactured the hardware
// on which the client is running. The option code is 16.
message Dhcpv6ClientOptionsVendorClass {

  // The vendor's registered Enterprise Number as registered with IANA.
  // required = true
  optional uint32 enterprise_number = 1;

  // The opaque data representing the hardware configuration of the host on which the
  // client is running. Examples of  class data instances might include the version of
  // the operating system the client is running or the amount of memory  installed on
  // the client.
  repeated string class_data = 2;

  // The dhcpv6 client messages where this option is included.
  // required = true
  Dhcpv6ClientOptionsIncludedMessages associated_dhcp_messages = 3;
}

// The dhcpv6 client messages where the option will be included. If all is selected
// the selected option will be added in the all the Dhcpv6 client messages, else based
// on the selection in particular Dhcpv6 client messages the option will be included.
message Dhcpv6ClientOptionsIncludedMessages {

  message Choice {
    enum Enum {
      unspecified = 0;
      all = 1;
      msg_types = 2;
    }
  }
  // The client message name where the option is included, by default it is all.
  // default = Choice.Enum.all
  optional Choice.Enum choice = 1;

  // User must specify the Dhcpv6 message type.
  repeated Dhcpv6ClientOptionsMessageType msg_types = 2;
}

// The dhcpv6 client messages where the option will be included.
message Dhcpv6ClientOptionsMessageType {

  message Choice {
    enum Enum {
      unspecified = 0;
      solicit = 1;
      request = 2;
      inform_request = 3;
      release = 4;
      renew = 5;
      rebind = 6;
    }
  }
  // The client message name where the option is included, by default it is all.
  // default = Choice.Enum.solicit
  optional Choice.Enum choice = 1;
}

// This option is used by clients to exchange vendor-specific information. The option
// code is 17.
message Dhcpv6ClientOptionsVendorInfo {

  // The vendor's registered Enterprise Number as registered with IANA.
  // required = true
  optional uint32 enterprise_number = 1;

  // An opaque object of octets,interpreted by vendor-specific code on the clients and
  // servers.
  repeated Dhcpv6OptionsVendorSpecificOptions option_data = 2;

  // The list of dhcpv6 client messages where this option is included.
  // required = true
  Dhcpv6ClientOptionsIncludedMessages associated_dhcp_messages = 3;
}

// This option is used by servers to exchange vendor-specific information. The option
// code is 17.
message Dhcpv6ServerOptionsVendorInfo {

  // The vendor's registered Enterprise Number as registered with IANA.
  // required = true
  optional uint32 enterprise_number = 1;

  // An opaque object of octets,interpreted by vendor-specific code on the clients and
  // servers.
  repeated Dhcpv6OptionsVendorSpecificOptions option_data = 2;

  // The list of dhcpv6 client messages where this option is included.
  // required = true
  Dhcpv6ServerOptionsIncludedMessages associated_dhcp_messages = 3;
}

// The dhcpv6 server messages where the option will be included. If all is selected
// the selected option will be added  in the all the Dhcpv6 server messages, else based
// on the selection in particular Dhcpv6 server messages the option  will be included.
message Dhcpv6ServerOptionsIncludedMessages {

  message Choice {
    enum Enum {
      unspecified = 0;
      all = 1;
      msg_types = 2;
    }
  }
  // The server message name where the option is included, by default it is all.
  // default = Choice.Enum.all
  optional Choice.Enum choice = 1;

  // User must specify the Dhcpv6 message type.
  repeated Dhcpv6ServerOptionsMessageType msg_types = 2;
}

// The dhcpv6 server messages where the option will be included.
message Dhcpv6ServerOptionsMessageType {

  message Choice {
    enum Enum {
      unspecified = 0;
      advertise = 1;
      reply = 2;
      re_configure = 3;
    }
  }
  // The server message name where the option is included, by default it is all.
  // default = Choice.Enum.advertise
  optional Choice.Enum choice = 1;
}

// The encapsulated vendor-specific options field is encoded as a sequence of code/length/value
// fields of  identical format to the DHCP options field. The option codes are defined
// by the vendor identified in the  enterprise-number field and are not managed by IANA.
message Dhcpv6OptionsVendorSpecificOptions {

  // The code for the encapsulated option.
  // required = true
  optional uint32 code = 1;

  // The data for the encapsulated option.
  // required = true
  optional string data = 2;
}

// DHCPv6 server needs to know the FQDN of the client for the addresses for the client's
// IA_NA bindings in order to update the IPv6-address-to-FQDN mapping. This option allows
// the client to convey its FQDN to the server. The Client  FQDN option also contains
// Flags that DHCPv6 clients and servers use to negotiate who does which updates. The
// option code is 39.
message Dhcpv6ClientOptionsFqdn {

  // The S bit indicates whether the server should or should not perform the AAAA RR (FQDN-to-address)
  // DNS updates.  A client sets the bit to 0 to indicate that the server should not perform
  // the updates and 1 to indicate that the  server should perform the updates. The state
  // of the bit in the reply from the server indicates the action to be  taken by the
  // server. If it is 1, the server has taken responsibility for AAAA RR updates for the
  // FQDN.
  // default = True
  optional bool flag_s = 1;

  // The O bit indicates whether the server has overridden the client's preference for
  // the S bit. A client must set this  bit to 0. A server must set this bit to 1 if the
  // S bit in its reply to the client does not match the S bit received  from the client.
  // default = False
  optional bool flag_o = 2;

  // The N bit indicates whether the server should not perform any DNS updates. A client
  // sets this bit to 0 to request that  the server should perform updates (the PTR RR
  // and possibly the AAAA RR based on the S bit) or to 1 to request that the  server
  // should not perform any DNS updates. A server sets the N bit to indicate whether the
  // server shall (0) or shall not (1)  perform DNS updates. If the N bit is 1, the S
  // bit MUST be 0.
  // default = False
  optional bool flag_n = 3;

  // The Domain Name part of the option carries all or part of the FQDN of a DHCPv6 client.
  // A client MAY also leave the  Domain Name field empty if it desires the server to
  // provide a name. A fully qualified domain name (FQDN) is the complete  address of
  // an internet host or computer. It provides its exact location within the domain name
  // system (DNS) by specifying  the hostname, domain name and top-level domain (TLD).
  // An FQDN isn't the same as a URL but rather is a part of it that fully  identifies
  // the server to which the request is addressed. An FQDN doesn't carry the TCP/IP protocol
  // information, such as Hypertext  Transfer Protocol (HTTP) or Hypertext Transfer Protocol
  // Secure (HTTPS), which is always used at the beginning of a URL. Therefore,  adding
  // the prefix http:// or https:// to the FQDN turns it into a full URL. One example
  // can be microsoft.com.
  // required = true
  optional string domain_name = 4;

  // The list of dhcpv6 client messages where this option is included.
  Dhcpv6ClientOptionsIncludedMessages associated_dhcp_messages = 5;
}

// The server sends this option to inform the client about a URL to a boot file. This
// information is required for booting  over the network includes the details about
// the server on which the boot files can be found, the protocol to be used for  the
// download (for example,HTTP or TFTP, and the path and name of the boot file on the
// server. The option code is 59. The URL will contain the network communication protocol,
// a subdomain, a domain name, and its extension. If the host in the URL  is expressed
// using an IPv6 address rather than a domain name, the address in the URL then must
// be enclosed in [ and ]  characters, conforming to [RFC3986]. Eg of a boot file url
// can be tftp://[xxxx:xxxx:xxxx:xxxx::xxxx]/mboot.efi.
message Dhcpv6ServerOptionsBootfileUrl {

  // The URL for the boot file. It must comply with STD 66 format.
  // required = true
  optional string url = 1;

  // They are used to specify parameters for the boot file (similar to the command line
  // arguments in most modern operating  systems). For example, these parameters could
  // be used to specify the root file system of the OS kernel, or the location  from which
  // a second-stage boot-loader program can download its configuration file.
  repeated Dhcpv6ServerOptionsBootFileParams bootfile_params = 2;

  // The list of dhcpv6 client messages where this option is included.
  Dhcpv6ServerOptionsIncludedMessages associated_dhcp_messages = 3;
}

// The option code is 60. They are used to specify parameters for the boot file (similar
// to the command line arguments in most  modern operating systems).  For example, these
// parameters could be used to specify the root file system of the OS kernel, or  the
// location from which a second-stage boot-loader program can download its configuration
// file.
message Dhcpv6ServerOptionsBootFileParams {

  // UTF-8 strings are parameters needed for booting, e.g., kernel parameters.
  // required = true
  optional string parameter = 1;
}

// A container for layer1 settings.
message Layer1 {

  // A list of unique names of port objects that will share the
  // choice settings.
  // 
  // x-constraint:
  // - /components/schemas/Port/properties/name
  // 
  repeated string port_names = 1;

  message Speed {
    enum Enum {
      unspecified = 0;
      speed_10_fd_mbps = 1;
      speed_10_hd_mbps = 2;
      speed_100_fd_mbps = 3;
      speed_100_hd_mbps = 4;
      speed_1_gbps = 5;
      speed_10_gbps = 6;
      speed_25_gbps = 7;
      speed_40_gbps = 8;
      speed_50_gbps = 9;
      speed_100_gbps = 10;
      speed_200_gbps = 11;
      speed_400_gbps = 12;
      speed_800_gbps = 13;
    }
  }
  // Set the speed if supported. When no speed is explicitly set, the current
  // speed of underlying test interface shall be assumed.
  optional Speed.Enum speed = 2;

  message Media {
    enum Enum {
      unspecified = 0;
      copper = 1;
      fiber = 2;
      sgmii = 3;
    }
  }
  // Set the type of media for test interface if supported. When no media
  // type is explicitly set, the current media type of underlying test
  // interface shall be assumed.
  optional Media.Enum media = 3;

  // Enable promiscuous mode on test interface. A warning shall be raised if
  // this field is set to `true`, even when it's not supported, ignoring
  // the setting altogether.
  // default = True
  optional bool promiscuous = 4;

  // Set the maximum transmission unit size. A warning shall be raised if
  // the specified value is valid but not supported, ignoring the setting altogether.
  // default = 1500
  optional uint32 mtu = 5;

  // Under Review: This field is currently under review for pending exploration on use
  // cases
  // 
  // Set to true to override the auto_negotiate, link_training
  // and rs_fec settings for gigabit ethernet interfaces.
  optional bool ieee_media_defaults = 6;

  // Under Review: This field is currently under review for pending exploration on use
  // cases, given that a separate configuration called `AutoNegotiation` already exists.
  // 
  // Enable/disable auto negotiation.
  optional bool auto_negotiate = 7;

  // Description missing in models
  Layer1AutoNegotiation auto_negotiation = 8;

  // Description missing in models
  Layer1FlowControl flow_control = 9;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  optional string name = 10;
}

// Configuration for auto negotiation settings
message Layer1AutoNegotiation {

  // If auto_negotiate is true and the interface supports this option
  // then this speed will be advertised.
  // default = True
  optional bool advertise_1000_mbps = 1;

  // If auto_negotiate is true and the interface supports this option
  // then this speed will be advertised.
  // default = True
  optional bool advertise_100_fd_mbps = 2;

  // If auto_negotiate is true and the interface supports this option
  // then this speed will be advertised.
  // default = True
  optional bool advertise_100_hd_mbps = 3;

  // If auto_negotiate is true and the interface supports this option
  // then this speed will be advertised.
  // default = True
  optional bool advertise_10_fd_mbps = 4;

  // If auto_negotiate is true and the interface supports this option
  // then this speed will be advertised.
  // default = True
  optional bool advertise_10_hd_mbps = 5;

  // Enable/disable gigabit ethernet link training.
  // default = False
  optional bool link_training = 6;

  // Enable/disable gigabit ethernet reed solomon forward error correction (RS FEC).
  // default = False
  optional bool rs_fec = 7;
}

// A container for layer1 receive flow control settings.
// To enable flow control settings on ports this object must be a valid
// object not a null value.
message Layer1FlowControl {

  // The 48bit mac address that the layer1 port names will listen on
  // for a directed pause.
  // default = 01:80:C2:00:00:01
  optional string directed_address = 1;

  message Choice {
    enum Enum {
      unspecified = 0;
      ieee_802_1qbb = 1;
      ieee_802_3x = 2;
    }
  }
  // The type of priority flow control.
  // default = Choice.Enum.ieee_802_1qbb
  optional Choice.Enum choice = 2;

  // Description missing in models
  Layer1Ieee8021qbb ieee_802_1qbb = 3;

  // Description missing in models
  Layer1Ieee8023x ieee_802_3x = 4;
}

// A container for ieee 802.3x rx pause settings
message Layer1Ieee8023x {
}

// These settings enhance the existing 802.3x pause priority capabilities
// to enable flow control based on 802.1p priorities (classes of service).
message Layer1Ieee8021qbb {

  // The upper limit on the transmit time of a queue after receiving a
  // message to pause a specified priority.
  // A value of 0 or null indicates that pfc delay will not be enabled.
  // default = 0
  optional uint32 pfc_delay = 1;

  // The valid values are null, 0 - 7.
  // A null value indicates there is no setting for this pfc class.
  // default = 0
  optional uint32 pfc_class_0 = 2;

  // The valid values are null, 0 - 7.
  // A null value indicates there is no setting for this pfc class.
  // default = 1
  optional uint32 pfc_class_1 = 3;

  // The valid values are null, 0 - 7.
  // A null value indicates there is no setting for this pfc class.
  // default = 2
  optional uint32 pfc_class_2 = 4;

  // The valid values are null, 0 - 7.
  // A null value indicates there is no setting for this pfc class.
  // default = 3
  optional uint32 pfc_class_3 = 5;

  // The valid values are null, 0 - 7.
  // A null value indicates there is no setting for this pfc class.
  // default = 4
  optional uint32 pfc_class_4 = 6;

  // The valid values are null, 0 - 7.
  // A null value indicates there is no setting for this pfc class.
  // default = 5
  optional uint32 pfc_class_5 = 7;

  // The valid values are null, 0 - 7.
  // A null value indicates there is no setting for this pfc class.
  // default = 6
  optional uint32 pfc_class_6 = 8;

  // The valid values are null, 0 - 7.
  // A null value indicates there is no setting for this pfc class.
  // default = 7
  optional uint32 pfc_class_7 = 9;
}

// Configuration for capture settings.
message Capture {

  // The unique names of ports that the capture settings will apply to. Port_names cannot
  // be duplicated between capture objects.
  // 
  // x-constraint:
  // - /components/schemas/Port/properties/name
  // 
  repeated string port_names = 1;

  // A list of filters to apply to the capturing ports. If no filters are specified then
  // all packets will be captured. A capture can have multiple filters. The number of
  // filters supported is determined by the implementation which can be retrieved using
  // the capabilities API.
  // When multiple filters are specified the capture implementation  must && (and) all
  // the filters.
  repeated CaptureFilter filters = 2;

  // Overwrite the capture buffer.
  // default = True
  optional bool overwrite = 3;

  // The maximum size of each captured packet. If no value is specified or it is null
  // then the entire packet will be captured.
  optional uint32 packet_size = 4;

  message Format {
    enum Enum {
      unspecified = 0;
      pcap = 1;
      pcapng = 2;
    }
  }
  // The format of the capture file.
  // default = Format.Enum.pcap
  optional Format.Enum format = 5;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  optional string name = 6;
}

// Configuration for capture filters
message CaptureFilter {

  message Choice {
    enum Enum {
      unspecified = 0;
      custom = 1;
      ethernet = 2;
      vlan = 3;
      ipv4 = 4;
      ipv6 = 5;
    }
  }
  // The type of capture filter.
  // default = Choice.Enum.custom
  optional Choice.Enum choice = 1;

  // Offset from last filter in the list. If no filters are present it is offset from
  // position 0. Multiple custom filters can be present, the length of each custom filter
  // is the length of the value being filtered.
  CaptureCustom custom = 2;

  // Description missing in models
  CaptureEthernet ethernet = 3;

  // Description missing in models
  CaptureVlan vlan = 4;

  // Description missing in models
  CaptureIpv4 ipv4 = 5;

  // Description missing in models
  CaptureIpv6 ipv6 = 6;
}

// Description missing in models
message CaptureCustom {

  // The bit offset of field to filter on
  optional uint32 offset = 1;

  // The bit length of field to filter on
  // default = 8
  optional uint32 bit_length = 2;

  // Description missing in models
  // default = 00
  optional string value = 3;

  // Description missing in models
  // default = 00
  optional string mask = 4;

  // Description missing in models
  // default = False
  optional bool negate = 5;
}

// Description missing in models
message CaptureField {

  // Description missing in models
  // default = 00
  optional string value = 1;

  // Description missing in models
  // default = 00
  optional string mask = 2;

  // Description missing in models
  // default = False
  optional bool negate = 3;
}

// Description missing in models
message CaptureEthernet {

  // Description missing in models
  CaptureField src = 1;

  // Description missing in models
  CaptureField dst = 2;

  // Description missing in models
  CaptureField ether_type = 3;

  // Description missing in models
  CaptureField pfc_queue = 4;
}

// Description missing in models
message CaptureVlan {

  // Description missing in models
  CaptureField priority = 1;

  // Description missing in models
  CaptureField cfi = 2;

  // Description missing in models
  CaptureField id = 3;

  // Description missing in models
  CaptureField protocol = 4;
}

// Description missing in models
message CaptureIpv4 {

  // Description missing in models
  CaptureField version = 1;

  // Description missing in models
  CaptureField header_length = 2;

  // Description missing in models
  CaptureField priority = 3;

  // Description missing in models
  CaptureField total_length = 4;

  // Description missing in models
  CaptureField identification = 5;

  // Description missing in models
  CaptureField reserved = 6;

  // Description missing in models
  CaptureField dont_fragment = 7;

  // Description missing in models
  CaptureField more_fragments = 8;

  // Description missing in models
  CaptureField fragment_offset = 9;

  // Description missing in models
  CaptureField time_to_live = 10;

  // Description missing in models
  CaptureField protocol = 11;

  // Description missing in models
  CaptureField header_checksum = 12;

  // Description missing in models
  CaptureField src = 13;

  // Description missing in models
  CaptureField dst = 14;
}

// Description missing in models
message CaptureIpv6 {

  // Description missing in models
  CaptureField version = 1;

  // Description missing in models
  CaptureField traffic_class = 2;

  // Description missing in models
  CaptureField flow_label = 3;

  // Description missing in models
  CaptureField payload_length = 4;

  // Description missing in models
  CaptureField next_header = 5;

  // Description missing in models
  CaptureField hop_limit = 6;

  // Description missing in models
  CaptureField src = 7;

  // Description missing in models
  CaptureField dst = 8;
}

// A container for emulated or simulated interfaces, loopback interfaces and protocol
// configurations.
message Device {

  // Ethernet configuration for one or more emulated or simulated network interfaces.
  repeated DeviceEthernet ethernets = 1;

  // IPv4 Loopback interface that can be attached to an Ethernet in the same device  or
  // to an Ethernet in another device.
  repeated DeviceIpv4Loopback ipv4_loopbacks = 2;

  // IPv6 Loopback interface that can be attached to an Ethernet in the same device  or
  // to an Ethernet in another device.
  repeated DeviceIpv6Loopback ipv6_loopbacks = 3;

  // The properties of an IS-IS router and its children,  such as IS-IS interfaces and
  // route ranges.
  DeviceIsisRouter isis = 4;

  // The properties of BGP router and its children,  such as BGPv4, BGPv6 peers and their
  // route ranges.
  DeviceBgpRouter bgp = 5;

  // Configuration of VXLAN tunnel interfaces RFC Ref: https://datatracker.ietf.org/doc/html/rfc7348
  DeviceVxlan vxlan = 6;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  optional string name = 7;

  // The properties of an RSVP router and its children.
  DeviceRsvp rsvp = 8;

  // The properties of DHCP Server and its children, such as DHCPv4, DHCPv6 servers.
  DeviceDhcpServer dhcp_server = 9;

  // Configuration for OSPFv2 router.
  DeviceOspfv2Router ospfv2 = 10;

  // Configuration of MACsec device.
  DeviceMacsec macsec = 11;

  // Configuration for OSPFv3 router.
  DeviceOspfv3Router ospfv3 = 12;

  // Configuration for RoCEv2.
  DeviceRocev2Peer rocev2 = 13;

  // Configuration for BMP.
  DeviceBmp bmp = 14;
}

// Common options that apply to all configured protocols and interfaces.
message ProtocolOptions {

  // When set to true, all underlying resources for configured protocols   and interfaces
  // shall be created and corresponding protocol session negotiation shall be initiated.
  // Otherwise, when set to false,  corresponding protocol session negotiation will need
  // to be initiated  using a separate set_protocol_state API call.
  // default = True
  optional bool auto_start_all = 1;
}

// A container of properties for an ISIS router and its interfaces.
message DeviceIsisRouter {

  // This contains the properties of a Multi-Instance-capable routers or MI-RTR. Each
  // router can emulate one ISIS instance at a time.
  DeviceIsisMultiInstance instance = 1;

  // The System ID for this emulated ISIS router, e.g. 640100010000.
  // required = true
  optional string system_id = 2;

  // List of ISIS interfaces for this router.
  repeated IsisInterface interfaces = 3;

  // Contains basic properties of an ISIS Router.
  IsisBasic basic = 4;

  // Contains advance properties of an ISIS Router..
  IsisAdvanced advanced = 5;

  // ISIS Router authentication properties.
  IsisAuthentication router_auth = 6;

  // Emulated ISIS IPv4 routes.
  repeated IsisV4RouteRange v4_routes = 7;

  // Emulated ISIS IPv6 routes.
  repeated IsisV6RouteRange v6_routes = 8;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  optional string name = 9;

  // Optional Segment Routing (SR).
  IsisSegmentRouting segment_routing = 10;

  // Optional IS-IS Graceful Restart Configuration.
  IsisGracefulRestart graceful_restart = 11;
}

// This container properties of an Multi-Instance-capable router (MI-RTR).
message DeviceIsisMultiInstance {

  // Instance Identifier (IID) TLV will associate a PDU with an ISIS instance  by using
  // a unique 16-bit number and including one or more  Instance-Specific Topology Identifiers
  // (ITIDs).
  // default = 1
  optional uint32 iid = 1;

  // This contains one or more ITIDs that will be advertised in IID TLV.
  repeated uint32 itids = 2;
}

// Configuration for single ISIS interface.
message IsisInterface {

  // The unique name of the Ethernet interface on which ISIS is running. Two ISIS interfaces
  // cannot share the same Ethernet. The underlying Ethernet Interface can an emulated
  // or simulated interface. A simulated ethernet interface can be assumed to be connected
  // by  a primary (internal to a simulated topology)  or a secondary link (connected
  // to a device behind a different simulated topology).
  // 
  // x-constraint:
  // - /components/schemas/Device.Ethernet/properties/name
  // 
  // required = true
  optional string eth_name = 1;

  // The default metric cost for the interface.
  // default = 10
  optional uint32 metric = 2;

  message NetworkType {
    enum Enum {
      unspecified = 0;
      broadcast = 1;
      point_to_point = 2;
    }
  }
  // The type of network link.
  // default = NetworkType.Enum.broadcast
  optional NetworkType.Enum network_type = 3;

  message LevelType {
    enum Enum {
      unspecified = 0;
      level_1 = 1;
      level_2 = 2;
      level_1_2 = 3;
    }
  }
  // This indicates whether this router is participating in Level-1 (L1),
  // Level-2 (L2) or both L1 and L2 domains on this interface.
  // default = LevelType.Enum.level_2
  optional LevelType.Enum level_type = 4;

  // Settings of Level 1 Hello.
  IsisInterfaceLevel l1_settings = 5;

  // Settings of Level 2 Hello.
  IsisInterfaceLevel l2_settings = 6;

  // Contains the properties of multiple topologies.
  repeated IsisMT multi_topology_ids = 7;

  // Contains a list of Traffic Engineering attributes.
  repeated LinkStateTE traffic_engineering = 8;

  // The Circuit authentication method used for the interfaces on this emulated ISIS v4/v6
  // router.
  IsisInterfaceAuthentication authentication = 9;

  // Optional container for advanced interface properties.
  IsisInterfaceAdvanced advanced = 10;

  // Link protection on the ISIS link between two interfaces.
  IsisInterfaceLinkProtection link_protection = 11;

  // This contains list of SRLG values for the link between two interfaces.
  repeated uint32 srlg_values = 12;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  optional string name = 13;

  // List of Adjacency Segment Identifier (Adj-SID) sub-TLVs.
  repeated IsisInterfaceAdjacencySid adjacency_sids = 14;
}

// Configuration for the properties of Level 1 Hello.
message IsisInterfaceLevel {

  // The Priority setting in Level 1 LAN Hellos for Designated Router election.
  // default = 0
  optional uint32 priority = 1;

  // The Hello interval for Level 1 Hello messages, in seconds.
  // default = 10
  optional uint32 hello_interval = 2;

  // The Dead (Holding Time) interval for Level 1 Hello messages, in seconds.
  // default = 30
  optional uint32 dead_interval = 3;
}

// Configuration of properties per interface per topology when multiple topologies are
// configured in an ISIS router.
// in a ISIS router.
message IsisMT {

  // The Multi Topology ID for one of the topologies supported on the ISIS interface.
  // default = 0
  optional uint32 mt_id = 1;

  // Specifies the link metric for this topology on the ISIS interface.
  // default = 10
  optional uint32 link_metric = 2;
}

// A container for Traffic Engineering properties on a interface.
message LinkStateTE {

  // The Administrative group sub-TLV (sub-TLV 3). It is a 4-octet
  // user-defined bit mask used to assign administrative group numbers
  // to the interface, for use in assigning colors and resource classes.
  // Each set bit corresponds to a single administrative group for this
  // interface. The settings translate into Group numbers, which range
  // from 0 to 31 (integers).
  // default = 00000000
  optional string administrative_group = 1;

  // The user-assigned link metric for Traffic Engineering.
  // default = 0
  optional uint32 metric_level = 2;

  // The maximum link bandwidth (sub-TLV 9) in bytes/sec allowed for this
  // link for a direction.
  // default = 125000000
  optional uint32 max_bandwith = 3;

  // The maximum link bandwidth (sub-TLV 10) in bytes/sec allowed for this
  // link in a direction.
  // default = 125000000
  optional uint32 max_reservable_bandwidth = 4;

  // Configuration of bandwidths of priority 0 through priority 7.
  LinkStatepriorityBandwidths priority_bandwidths = 5;
}

// Specifies the amount of bandwidth that can be reserved with a setup priority of 0
// 
// through 7, arranged in increasing order with priority 0 having highest priority.
// 
// In ISIS, this is sent in sub-TLV (11) of Extended IS Reachability TLV.
message LinkStatepriorityBandwidths {

  // Specifies the amount of bandwidth that can be reserved for the Priority 0.
  // default = 125000000
  optional uint32 pb0 = 1;

  // Specifies the amount of bandwidth that can be reserved for the Priority 1.
  // default = 125000000
  optional uint32 pb1 = 2;

  // Specify the amount of bandwidth that can be reserved for the Priority 2.
  // default = 125000000
  optional uint32 pb2 = 3;

  // Specifies the amount of bandwidth that can be reserved for the Priority 3.
  // default = 125000000
  optional uint32 pb3 = 4;

  // Specifies the amount of bandwidth that can be reserved for the Priority 4.
  // default = 125000000
  optional uint32 pb4 = 5;

  // Specifies the amount of bandwidth that can be reserved for the Priority 5.
  // default = 125000000
  optional uint32 pb5 = 6;

  // Specifies the amount of bandwidth that can be reserved for the Priority 6.
  // default = 125000000
  optional uint32 pb6 = 7;

  // Specifies the amount of bandwidth that can be reserved for the Priority 7.
  // default = 125000000
  optional uint32 pb7 = 8;
}

// Optional container for circuit authentication properties.
message IsisInterfaceAuthentication {

  message AuthType {
    enum Enum {
      unspecified = 0;
      md5 = 1;
      password = 2;
    }
  }
  // The circuit authentication method.
  // required = true
  optional AuthType.Enum auth_type = 1;

  // MD5 key to be used for authentication.
  optional string md5 = 2;

  // The password, in clear text, to be used for Authentication.
  optional string password = 3;
}

// Optional container for advanced interface properties.
message IsisInterfaceAdvanced {

  // If a padded Hello message is received on the interface, the length of
  // the Hello packets sent out on that interface is adjusted to match.
  // default = True
  optional bool auto_adjust_mtu = 1;

  // If a Level 1 Hello is received on this emulated router for an area
  // not currently in its area list, an area from the received Hello is
  // added to that list. This ensures an area match for all future
  // Level 1 Hellos from the source L1 router.
  // default = True
  optional bool auto_adjust_area = 2;

  // If a Hello message listing supported protocols is received on this
  // emulated router, the supported protocols advertised by this router
  // are changed to match exactly.
  // default = False
  optional bool auto_adjust_supported_protocols = 3;

  // If it is true, the Point-to-Point circuit will include 3-way TLV in its Point-to-Point
  // IIH  and attempt to establish the adjacency as specified in RFC 5303. This field
  // is not applicable if network_type is set to 'broadcast' type in ISIS interface.
  // default = True
  optional bool enable_3way_handshake = 4;

  // If it is true, the Point-to-Point Hello messages will be sent to the unicast MAC
  // address.
  // default = False
  optional bool p2p_hellos_to_unicast_mac = 5;
}

// Optional container for the link protection sub TLV (type 20).
message IsisInterfaceLinkProtection {

  // Enable this to protect other link or links. LSPs on a link of this type are lost
  // if any of the links fail.
  // default = False
  optional bool extra_traffic = 1;

  // Enabling this signifies that there is no other link protecting this
  // link. LSPs on a link of this type are lost if the link fails.
  // default = False
  optional bool unprotected = 2;

  // Enable this to share the Extra Traffic links between one or more
  // links of type Shared.There are one or more disjoint links of type
  // Extra Traffic that are protecting this link.
  // default = False
  optional bool shared = 3;

  // Enabling this signifies that there is one dedicated disjoint link
  // of type Extra Traffic that is protecting this link.
  // default = False
  optional bool dedicated_1_to_1 = 4;

  // Enabling this signifies that a dedicated disjoint link is protecting
  // this link. However, the protecting link is not advertised in the
  // link state database and is therefore not available for the routing
  // of LSPs.
  // default = False
  optional bool dedicated_1_plus_1 = 5;

  // Enabling this signifies that a protection scheme that is more
  // reliable than Dedicated 1+1.
  // default = False
  optional bool enhanced = 6;

  // This is a Protection Scheme with value 0x40.
  // default = False
  optional bool reserved_40 = 7;

  // This is a Protection Scheme with value 0x80.
  // default = False
  optional bool reserved_80 = 8;
}

// Optional container for segment routing MPLS settings.
// If the container exists then the adjacency SID (segment identifier)
// sub TLV will be part of the packet.
// Reference: https://datatracker.ietf.org/doc/html/rfc8667#name-adjacency-segment-identifie.
message IsisInterfaceAdjacencySid {

  message Choice {
    enum Enum {
      unspecified = 0;
      sid_values = 1;
      sid_indices = 2;
    }
  }
  // Choice of whether Adjacency-SID carries and absolute value or a relative index to
  // the SRGB/SRLB Ranges.
  // Please refer to device.isis.segment_routing.router_capability.sr_capability.srgb_ranges
  // for the Segment Routing Global Block (SRGB) Descriptor and
  // device.isis.segment_routing.router_capability.srlb_ranges for the SR Local Block
  // (SRLB).
  // A user needs to configure at least one entry of SID value or SID index.
  // If no entry is configured, then an implementation may advertise appropriate default
  // SID Value/Index based on the choice. e.g. the first value
  // from the SRGB or SRLB range.
  // - sid_values: Adjacency-SID carries one or more values and then v_flag is set by
  // the implementation.
  // - sid_indices: Adjacency-SID carries one or more indices and then v_flag is unset
  // by the implementation.
  // default = Choice.Enum.sid_values
  optional Choice.Enum choice = 1;

  // The corresponding Adjacency SID as one or more absolute Values for the link.
  repeated uint32 sid_values = 2;

  // One or more adjacency Indices are relative to ranges defined for SRGB or SRLB.
  repeated uint32 sid_indices = 3;

  // The address family flag. If unset, then the Adj-SID refers
  // to an adjacency with outgoing IPv4 encapsulation.  If set then
  // the Adj-SID refers to an adjacency with outgoing IPv6
  // encapsulation.
  // default = True
  optional bool f_flag = 4;

  // The backup flag. If set, the Adj-SID is eligible for protection.
  // default = False
  optional bool b_flag = 5;

  // The local flag.  If set, then the value/index carried by
  // the Adj-SID has local significance. In this case, Adjacency_sid is from device.isis.segment_routing.router_capability.srlb_ranges.
  // default = True
  optional bool l_flag = 6;

  // The set flag. When set, the S-Flag indicates that the
  // Adj-SID refers to a set of adjacencies (and therefore MAY be
  // assigned to other adjacencies as well).
  // default = False
  optional bool s_flag = 7;

  // The persistent flag. When set, the P-Flag indicates that
  // the Adj-SID is persistently allocated, i.e., the Adj-SID value
  // remains consistent across router restart and/or interface flap.
  // default = False
  optional bool p_flag = 8;

  // The value represents the weight of the Adj-SID for the purpose of load balancing.
  // 
  // default = 0
  optional uint32 weight = 9;
}

// This contains ISIS router basic properties.
message IsisBasic {

  // IPv4 Traffic Engineering(TE) router id. This address should be configured as an IPv4
  // Loopback address in 'ipv4_loopbacks' in the Device.
  optional string ipv4_te_router_id = 1;

  // Host name for the router. The host name is transmitted in all the packets sent from
  // the router.
  optional string hostname = 2;

  // When set to true, it allows sending of more detailed metric information  for the
  // routes using 32-bit wide values using TLV 135 IP reachability and  more detailed
  // reachability information for IS reachability by using TLV 22.  The detailed usage
  // is described in RFC3784.
  // default = True
  optional bool enable_wide_metric = 3;

  // Configuration for controlling storage of ISIS learned LSPs are received from the
  // neighbors.
  // default = False
  optional bool learned_lsp_filter = 4;
}

// Contains ISIS router advanced properties.
message IsisAdvanced {

  // It enables padding of Hello message to MTU size.
  // default = True
  optional bool enable_hello_padding = 1;

  // The Number of Area Addresses permitted, with a valid range from 0 to 254.  A zero
  // indicates a maximum of 3 addresses.
  // default = 3
  optional uint32 max_area_addresses = 2;

  // Its combination of the ISP and HO-DSP.Usually all nodes within an area have  the
  // same area address. If no area addresses are configured, a default area of 490001
  // will be advertised.
  repeated string area_addresses = 3;

  // The rate at which LSPs are re-sent in seconds.
  // default = 600
  optional uint32 lsp_refresh_rate = 4;

  // The MaxAge for retaining a learned LSP on this router in seconds.
  // default = 1200
  optional uint32 lsp_lifetime = 5;

  // The number of milliseconds between transmissions of Partial Sequence Number PDU.
  // default = 2000
  optional uint32 psnp_interval = 6;

  // The number of milliseconds between transmissions of Partial Sequence Number PDU.
  // default = 10000
  optional uint32 csnp_interval = 7;

  // The maximum size in bytes of any LSP that can be transmitted over a link of equal
  // or less  than maximum MTU size.
  // default = 1492
  optional uint32 max_lsp_size = 8;

  // The number of seconds between transmissions of LSPs/MGROUP-PDUs.
  // default = 5000
  optional uint32 lsp_mgroup_min_trans_interval = 9;

  // If the Attached bit is enabled, it indicates that the ISIS router is attached to
  // another area  or the Level 2 backbone. The purpose of an Attached-Bit is to accomplish
  // Inter-Area Routing.  When an L1/L2 router is connected to more than one area, it
  // sets the Attached-bit on its L1 LSP. This can cause a default route ( 0.0.0.0/0 )
  // to be installed by the receiving router.
  // default = True
  optional bool enable_attached_bit = 10;
}

// This contains ISIS Area/Domain authentication properties.
message IsisAuthentication {

  // Do not verify MD5 checksum in received LSPs.
  // default = True
  optional bool ignore_receive_md5 = 1;

  // The Area authentication method used for the emulated ISIS router.
  // This is used for L1 LSPs.
  IsisAuthenticationBase area_auth = 2;

  // The Domain authentication method used for the emulated ISIS router.
  // This is used for L2 LSPs.
  IsisAuthenticationBase domain_auth = 3;
}

// Optional container for ISIS authentication properties.
message IsisAuthenticationBase {

  message AuthType {
    enum Enum {
      unspecified = 0;
      md5 = 1;
      password = 2;
    }
  }
  // The authentication method.
  // required = true
  optional AuthType.Enum auth_type = 1;

  // Authentication as an MD5 key.
  optional string md5 = 2;

  // Authentication as a clear text password.
  optional string password = 3;
}

// Emulated ISIS IPv4 routes.
message IsisV4RouteRange {

  // A list of group of IPv4 route addresses.
  repeated V4RouteAddress addresses = 1;

  // The user-defined metric associated with this route range.
  // default = 0
  optional uint32 link_metric = 2;

  message OriginType {
    enum Enum {
      unspecified = 0;
      internal = 1;
      external = 2;
    }
  }
  // The origin of the advertised route-internal or external to the ISIS area. Options
  // include the following:
  // Internal-for intra-area routes, through Level 1 LSPs.
  // External-for inter-area routes redistributed within L1, through Level
  // 1 LSPs.
  // default = OriginType.Enum.internal
  optional OriginType.Enum origin_type = 3;

  message RedistributionType {
    enum Enum {
      unspecified = 0;
      up = 1;
      down = 2;
    }
  }
  // Defines the Up/Down (Redistribution) bit defined for TLVs 128 and 130 by RFC 2966.
  // It is used for domain-wide advertisement of prefix information.
  // 
  // Up (0)-used when a prefix is initially advertised within the ISIS L3
  // hierarchy,
  // and for all other prefixes in L1 and L2 LSPs. (default)
  // Down (1)-used when an L1/L2 router advertises L2 prefixes in L1 LSPs.
  // 
  // The prefixes are being advertised from a higher level (L2) down to a lower level
  // (L1).
  // default = RedistributionType.Enum.up
  optional RedistributionType.Enum redistribution_type = 4;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  optional string name = 5;

  // Specifies whether the sub-TLV for IPv4/IPv6 Extended Reachability Attribute Flags
  // will be advertised or not.
  // default = False
  optional bool prefix_attr_enabled = 6;

  // External Prefix Flag (Bit 0)
  // default = False
  optional bool x_flag = 7;

  // Re-advertisement Flag (Bit 1)
  // default = False
  optional bool r_flag = 8;

  // Node Flag (Bit 2)
  // default = False
  optional bool n_flag = 9;

  // A list of SID paramters for a group of IPv4 route addresses.
  repeated IsisSRPrefixSid prefix_sids = 10;
}

// A container for IPv4 route addresses.
message V4RouteAddress {

  // The starting address of the network.
  // required = true
  optional string address = 1;

  // The IPv4 network prefix length to be applied to the address.
  // default = 24
  optional uint32 prefix = 2;

  // The total number of addresses in the range.
  // default = 1
  optional uint32 count = 3;

  // Increments the network address prefixes within a route range  where multiple routes
  // are present.  The value is incremented according to the Prefix Length and Step.
  // default = 1
  optional uint32 step = 4;
}

// A container for IPv6 route addresses.
message V6RouteAddress {

  // The starting address of the network.
  // required = true
  optional string address = 1;

  // The IPv6 network prefix length to be applied to the address.
  // default = 64
  optional uint32 prefix = 2;

  // The total number of addresses in the range.
  // default = 1
  optional uint32 count = 3;

  // Increments the network address prefixes within a route range  where multiple routes
  // are present.  The value is incremented according to the Prefix Length and Step.
  // default = 1
  optional uint32 step = 4;
}

// A container for MAC route addresses.
message MACRouteAddress {

  // The starting address of the MAC Range.
  // required = true
  optional string address = 1;

  // The MAC prefix length to be applied to the address.
  // default = 48
  optional uint32 prefix = 2;

  // The total number of mac addresses in the range.
  // default = 1
  optional uint32 count = 3;

  // Increments the mac address prefixes within a mac range  where multiple routes are
  // present.  The value is incremented according to the mac prefix Length and Step.
  // default = 1
  optional uint32 step = 4;
}

// A container of MPLS Prefix Label Value/Index in the address range.
message RouteMplsLabelValue {

  // The starting Label Value/Index.
  // default = 16
  optional uint32 start = 1;

  // The maximum value of Label Value/Index in the range after which next Label will start
  // from the 'start' Label.
  // default = 1048575
  optional uint32 max = 2;

  // Increments the Label Value/Index within a route range where multiple routes are present.
  // default = 1
  optional uint32 step = 3;
}

// This contains the properties of IS-IS Prefix-SID and its attributes for  the extended
// Ipv4 and Ipv6 reachability. Reference: https://datatracker.ietf.org/doc/html/rfc8667#name-prefix-segment-identifier-p.
message IsisSRPrefixSid {

  message Choice {
    enum Enum {
      unspecified = 0;
      sid_values = 1;
      sid_indices = 2;
    }
  }
  // Choice of whether Prefix-SID carries and absolute value or a relative index to the
  // SRGB/SRLB Ranges.
  // Please refer to device.isis.segment_routing.router_capability.sr_capability.srgb_ranges
  // for the Segment Routing Global Block (SRGB) Descriptor and
  // device.isis.segment_routing.router_capability.srlb_ranges for the SR Local Block
  // (SRLB).
  // A user needs to configure at least one entry of SID value or SID index.
  // If no entry is configured, then an implementation may advertise appropriate default
  // SID Value/Index based on the choice. e.g. the first value
  // from the SRGB or SRLB range.
  // - sid_values: Prefix-SID carries one or more values and then v_flag is set by the
  // implementation.
  // - sid_indices: Prefix-SID carries one or more indices and then v_flag is unset by
  // the implementation.
  // default = Choice.Enum.sid_indices
  optional Choice.Enum choice = 1;

  // SID/Label as one or more absolute values that are associated with the IGP Prefix
  // segment attached to the specific IPv4 or IPv6 prefix.
  repeated uint32 sid_values = 2;

  // One or more SID/Label Indices that are associated with the IGP Prefix segment attached
  // to the specific IPv4 or IPv6 prefix.
  repeated uint32 sid_indices = 3;

  // R-Flag: Re-advertisement Flag.
  // If set, then the prefix to which this Prefix-SID is attached has been propagated
  // by the router
  // from either another level (i.e., from Level-1 to Level-2 or the opposite) or redistribution
  // (e.g., from another protocol).
  // default = False
  optional bool r_flag = 4;

  // N-Flag: Node-SID flag.
  // If set, then the Prefix-SID refers to the router identified by the prefix.
  // Typically, the N-Flag is set on Prefix-SIDs that are attached to a router loopback
  // address.
  // The N-Flag is set when the Prefix-SID is a Node-SID as described in [RFC8402].
  // default = False
  optional bool n_flag = 5;

  // P-Flag: No-PHP (No Penultimate Hop-Popping) Flag.
  // If set, then the penultimate hop MUST NOT pop the Prefix-SID before delivering the
  // packet to the node that advertised the Prefix-SID.
  // default = False
  optional bool p_flag = 6;

  // E-Flag: Explicit-Null Flag.
  // If set, any upstream neighbor of the Prefix-SID originator MUST replace the Prefix-SID
  // with a Prefix-SID
  // that has an Explicit NULL value (0 for IPv4 and 2 for IPv6) before forwarding the
  // packet.
  // default = False
  optional bool e_flag = 7;

  // The local flag. If set, then the value/index carried by
  // the Prefix-SID has local significance and the Prefix SID is from Please refer to
  // device.isis.segment_routing.router_capability.srlb_ranges.
  // default = False
  optional bool l_flag = 8;

  // The Isis may use various algorithms when calculating reachability to other nodes
  // or to prefixes attached to these nodes.
  // Refernce: https://datatracker.ietf.org/doc/html/rfc8667#SRALGOSUBTLV
  // default = 0
  optional uint32 algorithm = 9;
}

// Emulated ISIS IPv6 routes.
message IsisV6RouteRange {

  // A list of group of IPv6 route addresses.
  repeated V6RouteAddress addresses = 1;

  // The user-defined metric associated with this route range.
  // default = 0
  optional uint32 link_metric = 2;

  message OriginType {
    enum Enum {
      unspecified = 0;
      internal = 1;
      external = 2;
    }
  }
  // The origin of the advertised route-internal or external to the ISIS area. Options
  // include the following:
  // Internal-for intra-area routes, through Level 1 LSPs.
  // External-for inter-area routes redistributed within L1, through Level
  // 1 LSPs.
  // default = OriginType.Enum.internal
  optional OriginType.Enum origin_type = 3;

  message RedistributionType {
    enum Enum {
      unspecified = 0;
      up = 1;
      down = 2;
    }
  }
  // Defines the Up/Down (Redistribution) bit defined for TLVs 128 and 130 by RFC 2966.
  // It is used for domain-wide advertisement of prefix information.
  // 
  // Up (0)-used when a prefix is initially advertised within the ISIS L3
  // hierarchy,
  // and for all other prefixes in L1 and L2 LSPs. (default)
  // Down (1)-used when an L1/L2 router advertises L2 prefixes in L1 LSPs.
  // 
  // The prefixes are being advertised from a higher level (L2) down to a lower level
  // (L1).
  // default = RedistributionType.Enum.up
  optional RedistributionType.Enum redistribution_type = 4;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  optional string name = 5;

  // Specifies whether the sub-TLV for IPv4/IPv6 Extended Reachability Attribute Flags
  // will be advertised or not.
  // default = False
  optional bool prefix_attr_enabled = 6;

  // External Prefix Flag (Bit 0)
  // default = False
  optional bool x_flag = 7;

  // Re-advertisement Flag (Bit 1)
  // default = False
  optional bool r_flag = 8;

  // Node Flag (Bit 2)
  // default = False
  optional bool n_flag = 9;

  // A list of SID parameters for a group of IPv6 route addresses.
  repeated IsisSRPrefixSid prefix_sids = 10;
}

// Segment Routing (SR) allows for a flexible definition of end-to-end paths within
// IGP topologies by encoding paths as sequences of topological sub-paths,
// called segments. These segments are advertised by the link-state routing protocols
// (IS-IS and OSPF).
// Prefix segments represent an ECMP-aware shortest path to a prefix (or a node), as
// per the state of the IGP topology.
// Adjacency segments represent a hop over a specific adjacency between two nodes in
// the IGP.
// A prefix segment is typically a multi-hop path while an adjacency segment, in most
// of the cases, is a one-hop path.
// These segments act as topological sub-paths that can be combined together to form
// the required path.
// Reference: https://datatracker.ietf.org/doc/html/rfc8667.:w
// An implementation may advertise Router Capability with default values if a user does
// not even set the properties
// of Router Capability and Segment Routing Capability.
message IsisSegmentRouting {

  // Optional IS-IS TLV named CAPABILITY, formed of multiple sub-TLVs, which allows a
  // router to announce its
  // capabilities within an IS-IS level or the entire routing domain.
  IsisRouterCapability router_capability = 1;
}

// Container for the configuration of IS-IS Router CAPABILITY TLV.
// https://datatracker.ietf.org/doc/html/rfc7981#section-2.
// An implementation should set default values appropriately if any mandatory item is
// not configured by a user.
message IsisRouterCapability {

  message Choice {
    enum Enum {
      unspecified = 0;
      ipv4_te_router_id = 1;
      interface_ip = 2;
      custom_router_cap_id = 3;
    }
  }
  // The Router Capability ID SHOULD be identical to the value advertised in the Traffic
  // Engineering Router ID TLV [RFC5305].
  // If no Traffic Engineering Router ID is assigned, the Router ID SHOULD be identical
  // to an IP Interface Address [RFC1195]
  // advertised by the originating IS.
  // If the originating node does not support IPv4, then the reserved value 0.0.0.0 MUST
  // be used in the Router ID field,
  // and the IPv6 TE Router ID sub-TLV [RFC5316] MUST be present in the TLV.
  // - ipv4_te_router_id: IPv4 Traffic Engineering(TE) router id (defined in isis.basic.ipv4_te_router_id)
  // to be used as Router Capability ID.
  // - interface_ip: When this is chosen the first IPv4 address of the first eth interface
  // associated with this isis router instance should be assigned as the Router Capability
  // ID.
  // - custom_router_cap_id: This option should be chosen when Router Capability ID needs
  // to be configured different from above two options.
  // default = Choice.Enum.ipv4_te_router_id
  optional Choice.Enum choice = 1;

  // Router Capability ID in IPv4 address format.
  // default = 0.0.0.0
  optional string custom_router_cap_id = 2;

  message SBit {
    enum Enum {
      unspecified = 0;
      flood = 1;
      not_flood = 2;
    }
  }
  // S bit (0x01): If the S bit is set(1), the IS-IS Router CAPABILITY TLV
  // MUST be flooded across the entire routing domain.  If the S bit is
  // not set(0), the TLV MUST NOT be leaked between levels.  This bit MUST
  // NOT be altered during the TLV leaking.
  // default = SBit.Enum.not_flood
  optional SBit.Enum s_bit = 3;

  message DBit {
    enum Enum {
      unspecified = 0;
      down = 1;
      not_down = 2;
    }
  }
  // D bit (0x02): When the IS-IS Router CAPABILITY TLV is leaked from
  // Level 2 (L2) to Level 1 (L1), the D bit MUST be set.  Otherwise, this
  // bit MUST be clear.  IS-IS Router CAPABILITY TLVs with the D bit set
  // MUST NOT be leaked from Level 1 to Level 2.  This is to prevent TLV looping.
  // default = DBit.Enum.not_down
  optional DBit.Enum d_bit = 4;

  // SR-Capabilities.
  IsisSRCapability sr_capability = 5;

  // This contains one or more Segment Routing Algorithm that a router may use various
  // algorithms when calculating
  // reachability to other nodes or to prefixes attached to these nodes.
  // The Isis may use various algorithms when calculating reachability to other nodes
  // or to prefixes attached to these
  // nodes. Examples of these algorithms are metric-based SPF, various sorts of Constrained
  // SPF, etc.
  // - 0: SPF algorithm based on link metric.
  // - 1: Strict SPF algorithm based on link metric.
  // Reference: https://datatracker.ietf.org/doc/html/rfc8665#name-igp-algorithm-types-registr.
  // When the originating router does not advertise the SR-Algorithm sub-TLV, it implies
  // that algorithm 0 is the only algorithm supported by the routers.
  // When the originating router does advertise the SR-Algorithm sub-TLV, then algorithm
  // 0 MUST be present while non-zero algorithms MAY be present.
  repeated uint32 algorithms = 6;

  // This contains the list of SR Local Block (SRLB)
  repeated IsisSRSrlb srlb_ranges = 7;
}

// Container for the configuration of IS-IS SR-CAPABILITY TLV that Segment Routing requires
// 
// each router to advertise its SR data plane capability and the range of MPLS label
// values
// it uses for Segment Routing in the case where global SIDs are allocated (i.e., global
// indexes).
// Reference: https://datatracker.ietf.org/doc/html/rfc8667#name-sr-capabilities-sub-tlv.
// An implementation should set default values appropriately if any mandatory item is
// not configured by a user.
message IsisSRCapability {

  // 1 octet of flags.
  IsisSRCapabilityFlags flags = 1;

  // This contains the list of SRGB.
  // If no SRGB range is configured, implementation should send one SRGB range with default
  // values.
  repeated IsisSRSrgb srgb_ranges = 2;
}

// Container for the configuration of IS-IS SR-CAPABILITY flags.
// The Router Capability TLV specifies flags that control its advertisement.
// The SR-Capabilities sub-TLV MUST be propagated throughout the level and MUST NOT
// be advertised across level boundaries.
// Therefore, Router Capability TLV distribution flags are set accordingly, i.e.,
// the S-Flag in the Router Capability TLV [RFC7981] MUST be unset.
// Reference: https://datatracker.ietf.org/doc/html/rfc8667#section-3.1-5.1.1.6.1.
message IsisSRCapabilityFlags {

  // I-Flag for the MPLS IPv4 Flag. If set, then the router is capable of processing SR-MPLS-encapsulated
  // IPv4 packets on all interfaces.
  // default = True
  optional bool ipv4_mpls = 1;

  // V-Flag for the MPLS IPv6 Flag. If set, then the router is capable of processing SR-MPLS-encapsulated
  // IPv6 packets on all interfaces.
  // default = True
  optional bool ipv6_mpls = 2;
}

// This contains the propeties of Segment Routing Global Block (SRGB) Descriptor. Reference:
// https://datatracker.ietf.org/doc/html/rfc8667#section-3.1-7.1.1
message IsisSRSrgb {

  // The SID/Label sub-TLV contains the first value of the SRGB while the range contains
  // the number of SRGB elements.
  // default = 16000
  optional uint32 starting_sid = 1;

  // This represents the number of SID in a SRGB range.
  // default = 8000
  optional uint32 range = 2;
}

// The SR Local Block (SRLB) sub-TLV contains the range of labels the node has reserved
// for Local SIDs.
// Local SIDs are used for Adjacency SIDs or locally significant Prefix SIDs and may
// also be allocated by components other than the IS-IS protocol.
// As an example, an application or a controller may instruct the router to allocate
// a specific Local SID. Therefore,
// in order for such applications or controllers to know what Local SIDs are available
// in the router,
// it is required that the router advertises its SRLB.
// Reference: https://datatracker.ietf.org/doc/html/rfc8667#name-sr-local-block-sub-tlv.
message IsisSRSrlb {

  // The SID/Label sub-TLV contains the first value of the SRLB while the range contains
  // the number of SRLB elements.
  // default = 16000
  optional uint32 starting_sid = 1;

  // This represents the number of SIDs in a SRLB range.
  // default = 8000
  optional uint32 range = 2;
}

// Contains IS-IS Graceful configuration parameters.
// Reference: https://datatracker.ietf.org/doc/html/rfc8706
message IsisGracefulRestart {

  // The emulated IS-IS router will acting in as the Helper for the DUT that is restarting.
  // It acknowledges the Restart TLV sent by the DUT by sending an IIH containing a Restart
  // TLV with the RA (Restart Acknowledgment) bit set.
  // default = True
  optional bool helper_mode = 1;
}

// Configuration for one or more IPv4 or IPv6 BGP peers.
message DeviceBgpRouter {

  // The BGP router ID is a unique identifier used by BGP. It is a 32-bit value that is
  // often represented by an IPv4 address.
  // required = true
  optional string router_id = 1;

  // This contains an array of references to IPv4 interfaces,  each of which will have
  // list of peers to different destinations.
  repeated BgpV4Interface ipv4_interfaces = 2;

  // This contains an array of references to IPv6 interfaces,  each of which will have
  // list of peers to different destinations.
  repeated BgpV6Interface ipv6_interfaces = 3;
}

// All errors detected while processing the Message Header are indicated by sending
// the NOTIFICATION message  with the Error Code-Message Header Error. The Error Subcode
// elaborates on the specific nature of the error.
message DeviceBgpMessageHeaderError {

  message Subcode {
    enum Enum {
      unspecified = 0;
      connection_not_synchronized_code1_subcode1 = 1;
      bad_message_length_code1_subcode2 = 2;
      bad_message_type_code1_subcode3 = 3;
    }
  }
  // The Error Subcode indicates the specific type of error encountered during Message
  // Header processing.
  // default = Subcode.Enum.connection_not_synchronized_code1_subcode1
  optional Subcode.Enum subcode = 1;
}

// All errors detected while processing the OPEN message are indicated by sending the
// NOTIFICATION message  with the Error Code-Open Message Error. The Error Subcode elaborates
// on the specific nature of the error.
message DeviceBgpOpenMessageError {

  message Subcode {
    enum Enum {
      unspecified = 0;
      unsupported_version_number_code2_subcode1 = 1;
      error_peer_as_code2_subcode2 = 2;
      error_bgp_id_code2_subcode3 = 3;
      unsupported_optional_parameter_code2_subcode4 = 4;
      auth_failed_code2_subcode5 = 5;
      unsupported_hold_time_code2_subcode6 = 6;
      unsupported_capability_code2_subcode7 = 7;
    }
  }
  // The Error Subcode indicates the specific type of error encountered during OPEN message
  // processing.
  // default = Subcode.Enum.unsupported_version_number_code2_subcode1
  optional Subcode.Enum subcode = 1;
}

// All errors detected while processing the UPDATE message are indicated by sending
// the NOTIFICATION message  with the Error Code-Update Message Error. The Error Subcode
// elaborates on the specific nature of the error.
message DeviceBgpUpdateMessageError {

  message Subcode {
    enum Enum {
      unspecified = 0;
      malformed_attrib_list_code3_subcode1 = 1;
      unrecognized_wellknown_attrib_code3_subcode2 = 2;
      wellknown_attrib_missing_code3_subcode3 = 3;
      attrib_flags_error_code3_subcode4 = 4;
      attrib_length_error_code3_subcode5 = 5;
      invalid_origin_attrib_code3_subcode6 = 6;
      as_routing_loop_code3_subcode7 = 7;
      invalid_nhop_attrib_code3_subcode8 = 8;
      error_optional_attrib_code3_subcode9 = 9;
      invalid_network_field_code3_subcode10 = 10;
      abnormal_aspath_code3_subcode11 = 11;
    }
  }
  // The Error Subcode, the specific type of error encountered during UPDATE processing.
  // default = Subcode.Enum.malformed_attrib_list_code3_subcode1
  optional Subcode.Enum subcode = 1;
}

// If a system does not receive successive KEEPALIVE, UPDATE, and/or NOTIFICATION messages
// within the period specified  in the Hold Time field of the OPEN message, then the
// NOTIFICATION message with the Hold Timer Expired Error Code(Error Code 4) is  sent
// and the BGP connection is closed. The Sub Code used is 0. If a user wants to use
// non zero Sub Code then CustomError can be used.
message DeviceBgpHoldTimerExpired {
}

// Any error detected by the BGP Finite State Machine (e.g., receipt of an unexpected
// event) is indicated by  sending the NOTIFICATION message with the Error Code-Finite
// State Machine Error(Error Code 5). The Sub Code used is 0.  If a user wants to use
// non zero Sub Code then CustomError can be used.
message DeviceBgpFiniteStateMachineError {
}

// In the absence of any fatal errors, a BGP peer can close its BGP connection by sending
// the NOTIFICATION message with the  Error Code Cease. The 'hard_reset_code6_subcode9'
// subcode for Cease Notification can be used to signal a hard reset that will indicate
// that  Graceful Restart cannot be performed, even when Notification extensions to
// Graceful Restart procedure is supported.
message DeviceBgpCeaseError {

  message Subcode {
    enum Enum {
      unspecified = 0;
      max_number_prefix_reached_code6_subcode1 = 1;
      admin_shutdown_code6_subcode2 = 2;
      peer_deleted_code6_subcode3 = 3;
      admin_reset_code6_subcode4 = 4;
      connection_reject_code6_subcode5 = 5;
      other_config_changes_code6_subcode6 = 6;
      connection_collision_resolution_code6_subcode7 = 7;
      out_of_resources_code6_subcode8 = 8;
      bfd_session_down_code6_subcode10 = 9;
      hard_reset_code6_subcode9 = 10;
    }
  }
  // The Error Subcode to be sent to the peer in the Cease NOTIFICATION.
  // default = Subcode.Enum.admin_shutdown_code6_subcode2
  optional Subcode.Enum subcode = 1;
}

// A BGP peer can send NOTIFICATION message with user defined Error Code and Error Subcode.
message DeviceBgpCustomError {

  // The Error code to be sent in the NOTIFICATION message to peer.
  optional uint32 code = 1;

  // The Error Subcode to be sent in the NOTIFICATION message to peer.
  optional uint32 subcode = 2;
}

// Configuration for emulated BGPv4 peers and routes.
message BgpV4Peer {

  // IPv4 address of the BGP peer for the session.
  // required = true
  optional string peer_address = 1;

  // This contains the list of Ethernet Virtual Private Network (EVPN) Ethernet Segments
  // (ES) Per BGP Peer for IPv4 Address Family Identifier (AFI).
  // 
  // Each Ethernet Segment contains a list of EVPN Instances (EVIs) .
  // Each EVI contains a list of Broadcast Domains.
  // Each Broadcast Domain contains a list of MAC/IP Ranges.
  // 
  // <Ethernet Segment, EVI, Broadcast Domain> is responsible for advertising Ethernet
  // Auto-discovery Route Per EVI (Type 1).
  // 
  // <Ethernet Segment, EVI> is responsible for advertising Ethernet Auto-discovery Route
  // Per Ethernet Segment (Type 1).
  // 
  // <Ethernet Segment, EVI, Broadcast Domain, MAC/IP> is responsible for advertising
  // MAC/IP Advertisement Route (Type 2).
  // 
  // <Ethernet Segment, EVI, Broadcast Domain> is responsible for advertising Inclusive
  // Multicast Ethernet Tag Route (Type 3).
  // 
  // Ethernet Segment is responsible for advertising Ethernet Segment Route (Type 4).
  repeated BgpV4EthernetSegment evpn_ethernet_segments = 2;

  message AsType {
    enum Enum {
      unspecified = 0;
      ibgp = 1;
      ebgp = 2;
    }
  }
  // The type of BGP autonomous system. External BGP is used for BGP links between two
  // or more autonomous systems (ebgp). Internal BGP is used within a single autonomous
  // system (ibgp). BGP property defaults are aligned with this object defined as an internal
  // BGP peer. If the as_type is specified as 'ebgp' then other properties will need to
  // be specified as per an external BGP peer. Specifically, for 'ebgp',  'as_set_mode'
  // attribute in 'as_path' field  in any Route Range should be changed from default value
  // 'do_not_include_local_as' to any other value.
  // required = true
  optional AsType.Enum as_type = 3;

  // Autonomous System Number (AS number or ASN)
  // required = true
  optional uint32 as_number = 4;

  message AsNumberWidth {
    enum Enum {
      unspecified = 0;
      two = 1;
      four = 2;
    }
  }
  // The width in bytes of the as_number values. Any as_number values that exceeds the
  // width MUST result in an error.
  // default = AsNumberWidth.Enum.four
  optional AsNumberWidth.Enum as_number_width = 5;

  // Description missing in models
  BgpAdvanced advanced = 6;

  // Description missing in models
  BgpCapability capability = 7;

  // Description missing in models
  BgpLearnedInformationFilter learned_information_filter = 8;

  // Emulated BGPv4 route ranges.
  repeated BgpV4RouteRange v4_routes = 9;

  // Emulated BGPv6 route ranges.
  repeated BgpV6RouteRange v6_routes = 10;

  // Segment Routing Traffic Engineering (SR TE) Policies for IPv4 Address Family Identifier
  // (AFI).
  repeated BgpSrteV4Policy v4_srte_policies = 11;

  // Segment Routing Traffic Engineering (SR TE) Policies for IPv6 Address Family Identifier
  // (AFI).
  repeated BgpSrteV6Policy v6_srte_policies = 12;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  optional string name = 13;

  // Description missing in models
  BgpGracefulRestart graceful_restart = 14;

  // BGP Updates to be sent to the peer as specified after the session is established.
  // 
  BgpUpdateReplay replay_updates = 15;
}

// Configuration for emulated BGPv4 peers and routes on a single IPv4 interface.
message BgpV4Interface {

  // The unique name of the IPv4,  Loopback IPv4 interface or DHCPv4 client used as the
  // source IP for this list of BGP peers.
  // 
  // x-constraint:
  // - /components/schemas/Device.Ipv4/properties/name
  // - /components/schemas/Device.Ipv4Loopback/properties/name
  // - /components/schemas/Device.Dhcpv4client/properties/name
  // 
  // required = true
  optional string ipv4_name = 1;

  // This contains the list of BGPv4 peers configured on this interface.
  repeated BgpV4Peer peers = 2;
}

// Configuration for BGP Ethernet Segment ranges. Advertises following routes -
// 
// Type 4 - Ethernet Segment Route
message BgpV4EthernetSegment {

  // Designated Forwarder (DF) election configuration.
  BgpEthernetSegmentDfElection df_election = 1;

  // This contains the list of EVIs.
  repeated BgpV4EvpnEvis evis = 2;

  // 10-octet Ethernet Segment Identifier (ESI) Example - For multi-home scenario nonZero
  // ESI is '10000000000000000000' .
  // default = 00000000000000000000
  optional string esi = 3;

  message ActiveMode {
    enum Enum {
      unspecified = 0;
      single_active = 1;
      all_active = 2;
    }
  }
  // Single Active or All Active mode Redundancy mode selection for Multi-home.
  // default = ActiveMode.Enum.all_active
  optional ActiveMode.Enum active_mode = 4;

  // The label value to be advertised as ESI Label in ESI Label Extended Community. This
  // is included in Ethernet Auto-discovery per ES Routes advertised by a router.
  // default = 0
  optional uint32 esi_label = 5;

  // Description missing in models
  BgpRouteAdvanced advanced = 6;

  // Optional community settings.
  repeated BgpCommunity communities = 7;

  // Optional Extended Community settings. The Extended Communities Attribute is a transitive
  // optional BGP attribute, with the Type Code 16. Community and Extended Communities
  // attributes are utilized to trigger routing decisions, such as acceptance, rejection,
  // preference, or redistribution. An extended community is an 8-Bytes value. It is
  // divided into two main parts. The first 2 Bytes of the community encode a type and
  // sub-type fields and the last 6 Bytes carry a unique set of data in a format defined
  // by the type and sub-type field. Extended communities provide a larger  range for
  // grouping or categorizing communities. When type is administrator_as_2octet or administrator_as_4octet,
  // the valid sub types are route target and origin. The valid value for  administrator_as_2octet
  // and administrator_as_4octet type is either two byte AS followed by four byte local
  // administrator id or four byte AS followed by two  byte local administrator id.  When
  // type is administrator_ipv4_address the valid sub types are route target and origin.
  // The valid value for  administrator_ipv4_address is a four byte IPv4 address followed
  // by a two byte local administrator id.  When type is opaque, valid sub types are color
  // and encapsulation. When sub type is color, first two bytes of the value field contain
  // flags and last four bytes  contains the value of the color. When sub type is encapsulation
  // the first four bytes of value field are reserved and last two bytes carries the tunnel
  // type from  IANA's ETHER TYPES registry e.g IPv4 (protocol type = 0x0800), IPv6 (protocol
  // type = 0x86dd), and MPLS (protocol type = 0x8847). When type is administrator_as_2octet_link_bandwidth
  // the valid sub type is extended_bandwidth. The first two bytes of the value field
  // contains the AS number and the last four bytes contains the bandwidth in IEEE floating
  // point format.  When type is evpn the valid subtype is mac_address. In the value field
  // the low-order bit of the first byte(Flags) is defined as the Sticky/static flag and
  // may be set to 1, indicating the MAC address is static and cannot move. The second
  // byte is reserved and the  last four bytes contain the sequence number which is used
  // to ensure that PEs retain the correct MAC/IP Advertisement route when multiple updates
  // occur for the same MAC address.
  repeated BgpExtCommunity ext_communities = 8;

  // Optional AS PATH settings.
  BgpAsPath as_path = 9;
}

// Configuration for Designated Forwarder (DF) election among the Provider Edge (PE)
// routers on the same Ethernet Segment.
message BgpEthernetSegmentDfElection {

  // The DF election timer in seconds.
  // default = 3
  optional uint32 election_timer = 1;
}

// Configuration for advanced BGP route range settings.
message BgpRouteAdvanced {

  // BGP Multi Exit Discriminator attribute sent to the peer to help in the route selection
  // process.  If set to true, the Multi Exit Discriminator attribute will be included
  // in the route advertisement.
  // default = True
  optional bool include_multi_exit_discriminator = 3;

  // The multi exit discriminator (MED) value used for route selection sent to the peer.
  optional uint32 multi_exit_discriminator = 1;

  // If set to true, the Origin attribute will be included in the route advertisement.
  // default = True
  optional bool include_origin = 4;

  message Origin {
    enum Enum {
      unspecified = 0;
      igp = 1;
      egp = 2;
      incomplete = 3;
    }
  }
  // The origin attribute of a prefix can take three values: the prefix originates from
  // an interior routing protocol 'igp',  it originates from 'egp' or the origin is 'incomplete',
  // if the prefix is learned through other means.
  // default = Origin.Enum.igp
  optional Origin.Enum origin = 2;

  // BGP Local Preference attribute sent to the peer to indicate the degree of preference
  // for externally learned routes. If set to true, the Local Preference attribute will
  // be included  in the route advertisement. This should be included only for internal
  // peers.
  // default = True
  optional bool include_local_preference = 5;

  // Value to be set in Local Preference attribute if include_local_preference is set
  // to true. It is  used for the selection of the path for the traffic leaving the AS.
  // The route with the  highest local preference value is preferred.
  // default = 100
  optional uint32 local_preference = 6;
}

// BGP communities provide additional capability for tagging routes and  for modifying
// BGP routing policy on upstream and downstream routers. BGP community is a 32-bit
// number which is broken into 16-bit AS number and  a 16-bit custom value.
message BgpCommunity {

  message Type {
    enum Enum {
      unspecified = 0;
      manual_as_number = 1;
      no_export = 2;
      no_advertised = 3;
      no_export_subconfed = 4;
      llgr_stale = 5;
      no_llgr = 6;
    }
  }
  // The type of community AS number.
  optional Type.Enum type = 1;

  // First two octets of 32 bit community AS number.
  // default = 0
  optional uint32 as_number = 2;

  // Last two octets of the community value.
  // default = 0
  optional uint32 as_custom = 3;
}

// The Extended Communities Attribute is a transitive optional BGP attribute, with the
// Type Code 16. Community and Extended Communities  attributes are utilized to trigger
// routing decisions, such as acceptance, rejection,  preference, or redistribution.
// An extended community is an 8-Bytes value. It is divided into two main parts. The
// first 2 Bytes of the community encode a type and sub-type fields and the last 6 Bytes
// carry a unique set of data in a  format defined by the type and sub-type field. Extended
// communities provide a larger  range for grouping or categorizing communities.
message BgpExtCommunity {

  message Type {
    enum Enum {
      unspecified = 0;
      administrator_as_2octet = 1;
      administrator_ipv4_address = 2;
      administrator_as_4octet = 3;
      opaque = 4;
      evpn = 5;
      administrator_as_2octet_link_bandwidth = 6;
    }
  }
  // Extended Community Type field of 1 Byte.
  // - administrator_as_2octet: Two-Octet AS Specific Extended Community (RFC 4360).
  // - administrator_ipv4_address: IPv4 Address Specific Extended Community (RFC 4360).
  // - administrator_as_4octet:  4-Octet AS Specific Extended Community (RFC 5668).
  // - opaque: Opaque Extended Community (RFC 7432).
  // - evpn: EVPN Extended Community (RFC 7153).
  // - administrator_as_2octet_link_bandwidth : Link Bandwidth Extended Community (RFC
  // 7153).
  optional Type.Enum type = 1;

  message Subtype {
    enum Enum {
      unspecified = 0;
      route_target = 1;
      origin = 2;
      extended_bandwidth = 3;
      color = 4;
      encapsulation = 5;
      mac_address = 6;
    }
  }
  // Extended Community Sub Type field of 1 Byte.
  // - route_target: Route Target.
  // - origin: Origin.
  // - extended_bandwidth: Specifies the link bandwidth.
  // - color: Specifies the color value.
  // - encapsulation: Specifies the Encapsulation Extended Community.
  // - mac_address: Specifies the Extended community MAC address.
  optional Subtype.Enum subtype = 2;

  // Extended Community value of 6 Bytes. Example - for the Opaque type and Color subtype
  // value can be '0000000000c8'  for the color value 200.
  optional string value = 3;
}

// This attribute identifies the autonomous systems through  which routing information
// carried in this UPDATE message has passed. This contains the configuration of how
// to include the Local AS in the AS path attribute of the MP REACH NLRI. It also contains
// optional configuration of additional AS Path Segments that can be included in the
// AS Path attribute. The AS Path consists of a Set or Sequence of Autonomous Systems
// (AS) numbers  that a routing information passes through to reach the destination.
message BgpAsPath {

  message AsSetMode {
    enum Enum {
      unspecified = 0;
      do_not_include_local_as = 1;
      include_as_seq = 2;
      include_as_set = 3;
      include_as_confed_seq = 4;
      include_as_confed_set = 5;
      prepend_to_first_segment = 6;
    }
  }
  // Defines how the Local AS should be included in the MP REACH NLRI. For iBGP sessions,
  // Do Not Include Local AS must be chosen. For eBGP sessions, any choice other than
  // Do Not Include Local AS can be chosen.
  // default = AsSetMode.Enum.do_not_include_local_as
  optional AsSetMode.Enum as_set_mode = 1;

  // The additional AS path segments to be added in the NLRI.  By default, an empty AS
  // path is always included and  the local AS is added to it as per the value of 'as_set_mode'
  // attribute.
  repeated BgpAsPathSegment segments = 2;
}

// Configuration for a single BGP AS path segment
message BgpAsPathSegment {

  message Type {
    enum Enum {
      unspecified = 0;
      as_seq = 1;
      as_set = 2;
      as_confed_seq = 3;
      as_confed_set = 4;
    }
  }
  // AS sequence is the most common type of AS_PATH, it contains the  list of ASNs starting
  // with the most recent ASN being added read  from left to right.
  // The other three AS_PATH types are used for Confederations - AS_SET is the type of
  // AS_PATH attribute that summarizes routes using using the aggregate-address command,
  // allowing AS_PATHs to be  summarized in the update as well. - AS_CONFED_SEQ gives
  // the list of ASNs in the path starting with the  most recent ASN to be added reading
  // left to right - AS_CONFED_SET will allow summarization of multiple AS PATHs to be
  // sent in BGP Updates.
  // default = Type.Enum.as_seq
  optional Type.Enum type = 1;

  // The AS numbers in this AS path segment.
  repeated uint32 as_numbers = 2;
}

// This contains a list of different flavors of EVPN.
// For example EVPN over VXLAN or EVPN over MPLS etc to be configured per Ethernet segment.
// 
// Need to instantiate correct type of EVPN instance as per requirement.
message BgpV4EvpnEvis {

  message Choice {
    enum Enum {
      unspecified = 0;
      evi_vxlan = 1;
    }
  }
  // Description missing in models
  // default = Choice.Enum.evi_vxlan
  optional Choice.Enum choice = 1;

  // EVPN VXLAN instance to be configured per Ethernet Segment.
  BgpV4EviVxlan evi_vxlan = 2;
}

// Configuration for BGP EVPN EVI. Advertises following routes -
// 
// Type 3 - Inclusive Multicast Ethernet Tag Route
// 
// Type 1 -  Ethernet Auto-discovery Route (Per EVI)
// 
// Type 1 -  Ethernet Auto-discovery Route (Per ES)
message BgpV4EviVxlan {

  // This contains the list of Broadcast Domains to be configured per EVI.
  repeated BgpV4EviVxlanBroadcastDomain broadcast_domains = 1;

  message ReplicationType {
    enum Enum {
      unspecified = 0;
      ingress_replication = 1;
    }
  }
  // This model only supports Ingress Replication
  // default = ReplicationType.Enum.ingress_replication
  optional ReplicationType.Enum replication_type = 2;

  // Downstream assigned VNI to be carried as Part of P-Multicast Service Interface Tunnel
  // attribute (PMSI Tunnel Attribute) in Type 3 Inclusive Multicast Ethernet Tag Route.
  // default = 16
  optional uint32 pmsi_label = 3;

  // The Auto-discovery Route label (AD label) value, which gets advertised in the Ethernet
  // Auto-discovery Route per <EVI, ESI>
  // default = 0
  optional uint32 ad_label = 4;

  // Colon separated Extended Community value of 6 Bytes - AS number: Value identifying
  // an EVI.            Example - for the as_2octet 60005:100.
  BgpRouteDistinguisher route_distinguisher = 5;

  // List of Layer 2 Virtual Network Identifier (L2VNI) export targets associated with
  // this EVI.
  repeated BgpRouteTarget route_target_export = 6;

  // List of L2VNI import targets associated with this EVI.
  repeated BgpRouteTarget route_target_import = 7;

  // List of Layer 3 Virtual Network Identifier (L3VNI) Export Route Targets.
  repeated BgpRouteTarget l3_route_target_export = 8;

  // List of L3VNI Import Route Targets.
  repeated BgpRouteTarget l3_route_target_import = 9;

  // Description missing in models
  BgpRouteAdvanced advanced = 10;

  // Optional community settings.
  repeated BgpCommunity communities = 11;

  // Optional Extended Community settings. The Extended Communities Attribute is a transitive
  // optional BGP attribute, with the Type Code 16. Community and Extended Communities
  // attributes are utilized to trigger routing decisions, such as acceptance, rejection,
  // preference, or redistribution. An extended community is an 8-Bytes value. It is
  // divided into two main parts. The first 2 Bytes of the community encode a type and
  // sub-type fields and the last 6 Bytes carry a unique set of data in a format defined
  // by the type and sub-type field. Extended communities provide a larger  range for
  // grouping or categorizing communities. When type is administrator_as_2octet or administrator_as_4octet,
  // the valid sub types are route target and origin. The valid value for  administrator_as_2octet
  // and administrator_as_4octet type is either two byte AS followed by four byte local
  // administrator id or four byte AS followed by two  byte local administrator id.  When
  // type is administrator_ipv4_address the valid sub types are route target and origin.
  // The valid value for  administrator_ipv4_address is a four byte IPv4 address followed
  // by a two byte local administrator id.  When type is opaque, valid sub types are color
  // and encapsulation. When sub type is color, first two bytes of the value field contain
  // flags and last four bytes  contains the value of the color. When sub type is encapsulation
  // the first four bytes of value field are reserved and last two bytes carries the tunnel
  // type from  IANA's ETHER TYPES registry e.g IPv4 (protocol type = 0x0800), IPv6 (protocol
  // type = 0x86dd), and MPLS (protocol type = 0x8847). When type is administrator_as_2octet_link_bandwidth
  // the valid sub type is extended_bandwidth. The first two bytes of the value field
  // contains the AS number and the last four bytes contains the bandwidth in IEEE floating
  // point format.  When type is evpn the valid subtype is mac_address. In the value field
  // the low-order bit of the first byte(Flags) is defined as the Sticky/static flag and
  // may be set to 1, indicating the MAC address is static and cannot move. The second
  // byte is reserved and the  last four bytes contain the sequence number which is used
  // to ensure that PEs retain the correct MAC/IP Advertisement route when multiple updates
  // occur for the same MAC address.
  repeated BgpExtCommunity ext_communities = 12;

  // Optional AS PATH settings.
  BgpAsPath as_path = 13;
}

// Configuration for Broadcast Domains per EVI.
message BgpV4EviVxlanBroadcastDomain {

  // This contains the list of Customer MAC/IP Ranges to be configured per Broadcast Domain.
  // 
  // 
  // Advertises following route -
  // Type 2 - MAC/IP Advertisement Route.
  repeated BgpCMacIpRange cmac_ip_range = 1;

  // The Ethernet Tag ID of the Broadcast Domain.
  // default = 0
  optional uint32 ethernet_tag_id = 2;

  // VLAN-Aware service to be enabled or disabled.
  // default = False
  optional bool vlan_aware_service = 3;
}

// Configuration for MAC/IP Ranges per Broadcast Domain.
// 
// Advertises following route -
// 
// Type 2 - MAC/IP Advertisement Route.
message BgpCMacIpRange {

  // Host MAC address range per Broadcast Domain.
  MACRouteAddress mac_addresses = 1;

  // Layer 2 Virtual Network Identifier (L2VNI) to be advertised with MAC/IP Advertisement
  // Route (Type 2)
  // default = 0
  optional uint32 l2vni = 2;

  // Host IPv4 address range per Broadcast Domain.
  V4RouteAddress ipv4_addresses = 3;

  // Host IPv6 address range per Broadcast Domain.
  V6RouteAddress ipv6_addresses = 4;

  // Layer 3 Virtual Network Identifier (L3VNI) to be advertised with MAC/IP Advertisement
  // Route (Type 2).
  // default = 0
  optional uint32 l3vni = 5;

  // Include default Gateway Extended Community in MAC/IP Advertisement Route (Type 2).
  // default = False
  optional bool include_default_gateway = 6;

  // Description missing in models
  BgpRouteAdvanced advanced = 7;

  // Optional community settings.
  repeated BgpCommunity communities = 8;

  // Optional Extended Community settings. The Extended Communities Attribute is a transitive
  // optional BGP attribute, with the Type Code 16. Community and Extended Communities
  // attributes are utilized to trigger routing decisions, such as acceptance, rejection,
  // preference, or redistribution. An extended community is an 8-Bytes value. It is
  // divided into two main parts. The first 2 Bytes of the community encode a type and
  // sub-type fields and the last 6 Bytes carry a unique set of data in a format defined
  // by the type and sub-type field. Extended communities provide a larger  range for
  // grouping or categorizing communities. When type is administrator_as_2octet or administrator_as_4octet,
  // the valid sub types are route target and origin. The valid value for  administrator_as_2octet
  // and administrator_as_4octet type is either two byte AS followed by four byte local
  // administrator id or four byte AS followed by two  byte local administrator id.  When
  // type is administrator_ipv4_address the valid sub types are route target and origin.
  // The valid value for  administrator_ipv4_address is a four byte IPv4 address followed
  // by a two byte local administrator id.  When type is opaque, valid sub types are color
  // and encapsulation. When sub type is color, first two bytes of the value field contain
  // flags and last four bytes  contains the value of the color. When sub type is encapsulation
  // the first four bytes of value field are reserved and last two bytes carries the tunnel
  // type from  IANA's ETHER TYPES registry e.g IPv4 (protocol type = 0x0800), IPv6 (protocol
  // type = 0x86dd), and MPLS (protocol type = 0x8847). When type is administrator_as_2octet_link_bandwidth
  // the valid sub type is extended_bandwidth. The first two bytes of the value field
  // contains the AS number and the last four bytes contains the bandwidth in IEEE floating
  // point format.  When type is evpn the valid subtype is mac_address. In the value field
  // the low-order bit of the first byte(Flags) is defined as the Sticky/static flag and
  // may be set to 1, indicating the MAC address is static and cannot move. The second
  // byte is reserved and the  last four bytes contain the sequence number which is used
  // to ensure that PEs retain the correct MAC/IP Advertisement route when multiple updates
  // occur for the same MAC address.
  repeated BgpExtCommunity ext_communities = 9;

  // Optional AS PATH settings.
  BgpAsPath as_path = 10;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  optional string name = 11;
}

// BGP Route Distinguisher.
message BgpRouteDistinguisher {

  message RdType {
    enum Enum {
      unspecified = 0;
      as_2octet = 1;
      ipv4_address = 2;
      as_4octet = 3;
    }
  }
  // Route Distinguisher Type field of 2 Byte.
  // - as_2octet: Two-Octet AS Specific Extended Community (RFC 4360).
  // - ipv4_address: IPv4 Address Specific Extended Community (RFC 4360).
  // - as_4octet:  4-Octet AS Specific Extended Community (RFC 5668).
  // default = RdType.Enum.as_2octet
  optional RdType.Enum rd_type = 1;

  // Allow to automatically configure RD IP address  from local ip.
  // default = False
  optional bool auto_config_rd_ip_addr = 2;

  // Colon separated Extended Community value of 6 Bytes - AS number: Value.  Example
  // - for the as_2octet or as_4octet 60005:100,  for ipv4_address 1.1.1.1:100
  optional string rd_value = 3;
}

// BGP Route Target.
message BgpRouteTarget {

  message RtType {
    enum Enum {
      unspecified = 0;
      as_2octet = 1;
      ipv4_address = 2;
      as_4octet = 3;
    }
  }
  // Extended Community Type field of 2 Byte.
  // - as_2octet: Two-Octet AS Specific Extended Community (RFC 4360).
  // - ipv4_address: IPv4 Address Specific Extended Community (RFC 4360).
  // - as_4octet:  4-Octet AS Specific Extended Community (RFC 5668).
  optional RtType.Enum rt_type = 1;

  // Colon separated Extended Community value of 6 Bytes - AS number: Assigned Number.
  // Example - for the as_2octet or as_4octet 60005:100,  for ipv4_address 1.1.1.1:100
  optional string rt_value = 2;
}

// Configuration for BGP advanced settings.
message BgpAdvanced {

  // Number of seconds the sender proposes for the value of the Hold Timer.
  // default = 90
  optional uint32 hold_time_interval = 1;

  // Number of seconds between transmissions of Keepalive messages by this peer.
  // default = 30
  optional uint32 keep_alive_interval = 2;

  // The time interval at which Update messages are sent to the DUT, expressed as the
  // number of milliseconds between Update messages. The update interval 0 implies to
  // send all the updates as fast as possible.
  // default = 0
  optional uint32 update_interval = 3;

  // The limited number of iterations that a unit of data can experience before the data
  // is discarded. This is placed in the TTL field in the IP header of the  transmitted
  // packets.
  // default = 64
  optional uint32 time_to_live = 4;

  // The value to be used as a secret MD5 key for authentication. If not configured, MD5
  // authentication will not be enabled.
  optional string md5_key = 5;

  // If set to true, the local BGP peer will wait for the remote peer to initiate the
  // BGP session
  // by establishing the TCP connection, rather than initiating sessions from the local
  // peer.
  // default = False
  optional bool passive_mode = 6;

  // The TCP port number on which to accept BGP connections from the remote peer.
  // default = 179
  optional uint32 listen_port = 7;

  // Destination TCP port number of the BGP peer when initiating a
  // session from the local BGP peer.
  // default = 179
  optional uint32 neighbor_port = 8;
}

// Configuration for BGP capability settings.
message BgpCapability {

  // Support for the IPv4 Unicast address family.
  // default = True
  optional bool ipv4_unicast = 1;

  // Support for the IPv4 Multicast address family.
  // default = False
  optional bool ipv4_multicast = 2;

  // Support for the IPv4 Unicast address family.
  // default = True
  optional bool ipv6_unicast = 3;

  // Support for the IPv6 Multicast address family.
  // default = False
  optional bool ipv6_multicast = 4;

  // Support for VPLS as below.
  // RFC4761 - Virtual Private LAN Service (VPLS) using BGP for Auto-Discovery
  // and Signaling.
  // RFC6624 - Layer 2 Virtual Private Networks using BGP for Auto-Discovery
  // and Signaling.
  // default = False
  optional bool vpls = 5;

  // Support for the route refresh capabilities. Route Refresh allows the dynamic exchange
  // of route refresh requests  and routing information between BGP peers and the subsequent
  // re-advertisement  of the outbound or inbound routing table.
  // default = True
  optional bool route_refresh = 6;

  // Supports for the route constraint capabilities. Route Constraint allows the advertisement
  // of Route Target Membership  information. The BGP peers exchange Route Target Reachability
  // Information,  which is used to build a route distribution graph.  This limits the
  // propagation of VPN Network Layer Reachability Information (NLRI) between different
  // autonomous systems  or distinct clusters of the same autonomous system. This is supported
  // for Layer 3 Virtual Private Network scenario.
  // default = False
  optional bool route_constraint = 7;

  // Support for BGP Link State for ISIS and OSPF.
  // default = False
  optional bool link_state_non_vpn = 8;

  // Capability advertisement of BGP Link State for VPNs.
  // default = False
  optional bool link_state_vpn = 9;

  // Support for the EVPN address family.
  // default = False
  optional bool evpn = 10;

  // Support for extended Next Hop Encoding for Nexthop field in  IPv4 routes advertisement.
  // This allows IPv4 routes being advertised by IPv6 peers to  include an IPv6 Nexthop.
  // default = False
  optional bool extended_next_hop_encoding = 11;

  // Support for the IPv4 Multicast VPN address family.
  // default = False
  optional bool ipv4_multicast_vpn = 12;

  // Support for the IPv4 MPLS L3VPN address family.
  // default = False
  optional bool ipv4_mpls_vpn = 13;

  // Supports for IPv4 MDT address family messages.
  // default = False
  optional bool ipv4_mdt = 14;

  // Support for the IPv4 Multicast VPN address family.
  // default = False
  optional bool ipv4_multicast_mpls_vpn = 15;

  // Support for propagation of IPv4 unicast flow specification rules.
  // default = False
  optional bool ipv4_unicast_flow_spec = 16;

  // Support for IPv4 SRTE policy.
  // default = False
  optional bool ipv4_sr_te_policy = 17;

  // Support for IPv4 Unicast Add Path Capability.
  // default = False
  optional bool ipv4_unicast_add_path = 18;

  // Support for the IPv6 Multicast VPN address family.
  // default = False
  optional bool ipv6_multicast_vpn = 19;

  // Support for the IPv6 MPLS L3VPN address family.
  // default = False
  optional bool ipv6_mpls_vpn = 20;

  // Support for IPv6 MDT address family messages.
  // default = False
  optional bool ipv6_mdt = 21;

  // Support for the IPv6 Multicast VPN address family.
  // default = False
  optional bool ipv6_multicast_mpls_vpn = 22;

  // Support for propagation of IPv6 unicast flow specification rules.
  // default = False
  optional bool ipv6_unicast_flow_spec = 23;

  // Support for IPv6 SRTE policy.
  // default = False
  optional bool ipv6_sr_te_policy = 24;

  // Support for IPv6 Unicast Add Path Capability.
  // default = False
  optional bool ipv6_unicast_add_path = 25;

  // For Single Label binding to the IPv4 address prefix, BGP speaker will advertise (AFI,
  // SAFI) pair capability as (1, 4) in BGP Open Message under the Multiprotocol  extensions
  // capability.
  // default = False
  optional bool ipv4_mpls = 26;

  // For Single Label binding to the IPv4 address prefix, BGP speaker will advertise (AFI,
  // SAFI) pair capability as (2, 4) in BGP Open Message under the Multiprotocol  extensions
  // capability.
  // default = False
  optional bool ipv6_mpls = 27;

  // Support for Multiple Labels binding to the IPv4 address prefix.
  BgpCapabilityIpv4MplsMulti multiple_ipv4_mpls = 28;

  // Support for Multiple Labels binding to the IPv6 address prefix.
  BgpCapabilityIpv6MplsMulti multiple_ipv6_mpls = 29;
}

// The MPLS multiple Lable capability is advertised in Optional Capability under Multiple
// Label Capability (code 8). Reference: https://datatracker.ietf.org/doc/html/rfc8277#section-2.1.
// For Multiple Labels binding to the IPv6 address prefix, BGP speaker will advertise
// triple of the form <AFI=2, SAFI=4, Count=n> in BGP Open Message under the Multiprotocol
// extensions capability, where n = ipv6_mpls_multi, the numbers of labels.
message BgpCapabilityIpv4MplsMulti {

  // Number of Labels (n) in the triplet format <AFI=2, SAFI=4, Count=n>.
  // default = 2
  optional uint32 label_count = 1;
}

// The MPLS multiple Lable capability is advertised in Optional Capability under Multiple
// Label Capability (code 8). Reference: https://datatracker.ietf.org/doc/html/rfc8277#section-2.1.
// For Multiple Labels binding to the IPv6 address prefix, BGP speaker will advertise
// triple of the form <AFI=2, SAFI=4, Count=n> in BGP Open Message under the Multiprotocol
// extensions capability, where n = ipv6_mpls_multi, the numbers of labels.
message BgpCapabilityIpv6MplsMulti {

  // Number of Labels (n) in the triplet format <AFI=2, SAFI=4, Count=n>.
  // default = 2
  optional uint32 label_count = 1;
}

// Configuration for controlling storage of BGP learned information recieved from the
// peer.
message BgpLearnedInformationFilter {

  // If enabled, will store the information related to Unicast IPv4 Prefixes recieved
  // from the peer.
  // default = False
  optional bool unicast_ipv4_prefix = 1;

  // If enabled, will store the information related to Unicast IPv6 Prefixes recieved
  // from the peer.
  // default = False
  optional bool unicast_ipv6_prefix = 2;
}

// Emulated BGPv4 route range.
message BgpV4RouteRange {

  // A list of group of IPv4 route addresses.
  repeated V4RouteAddress addresses = 1;

  message NextHopMode {
    enum Enum {
      unspecified = 0;
      local_ip = 1;
      manual = 2;
    }
  }
  // Specify the NextHop in MP REACH NLRI. The mode for setting the IP address  of the
  // NextHop in the MP REACH NLRI can be one of the following:
  // Local IP: Automatically fills the Nexthop with the Local IP of the BGP
  // peer.
  // If BGP peer is of type IPv6, Nexthop Encoding capability should be enabled.
  // Manual: Override the Nexthop with any arbitrary IPv4/IPv6 address.
  // default = NextHopMode.Enum.local_ip
  optional NextHopMode.Enum next_hop_mode = 2;

  message NextHopAddressType {
    enum Enum {
      unspecified = 0;
      ipv4 = 1;
      ipv6 = 2;
    }
  }
  // If the Nexthop Mode is Manual, it sets the type of the NextHop IP address.
  // default = NextHopAddressType.Enum.ipv4
  optional NextHopAddressType.Enum next_hop_address_type = 3;

  // The IPv4 address of the next hop if the Nexthop Mode is manual and the Nexthop type
  // is IPv4. If BGP peer is of type IPv6, Nexthop Encoding capability should be enabled.
  // default = 0.0.0.0
  optional string next_hop_ipv4_address = 4;

  // The IPv6 address of the next hop if the Nexthop Mode is manual and the Nexthop type
  // is IPv6.
  // default = ::0
  optional string next_hop_ipv6_address = 5;

  // Description missing in models
  BgpRouteAdvanced advanced = 6;

  // Optional community settings.
  repeated BgpCommunity communities = 7;

  // Description missing in models
  BgpAsPath as_path = 8;

  // Description missing in models
  BgpAddPath add_path = 9;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  optional string name = 10;

  // Deprecated: This property is deprecated in favor of property extended_communities
  // 
  // Optional Extended Community settings. The Extended Communities Attribute is a transitive
  // optional BGP attribute, with the Type Code 16. Community and Extended Communities
  // attributes are utilized to trigger routing decisions, such as acceptance, rejection,
  // preference, or redistribution. An extended community is an 8-Bytes value. It is
  // divided into two main parts. The first 2 Bytes of the community encode a type and
  // sub-type fields and the last 6 Bytes carry a unique set of data in a format defined
  // by the type and sub-type field. Extended communities provide a larger  range for
  // grouping or categorizing communities. When type is administrator_as_2octet or administrator_as_4octet,
  // the valid sub types are route target and origin. The valid value for  administrator_as_2octet
  // and administrator_as_4octet type is either two byte AS followed by four byte local
  // administrator id or four byte AS followed by two  byte local administrator id.  When
  // type is administrator_ipv4_address the valid sub types are route target and origin.
  // The valid value for  administrator_ipv4_address is a four byte IPv4 address followed
  // by a two byte local administrator id.  When type is opaque, valid sub types are color
  // and encapsulation. When sub type is color, first two bytes of the value field contain
  // flags and last four bytes  contains the value of the color. When sub type is encapsulation
  // the first four bytes of value field are reserved and last two bytes carries the tunnel
  // type from  IANA's ETHER TYPES registry e.g IPv4 (protocol type = 0x0800), IPv6 (protocol
  // type = 0x86dd), and MPLS (protocol type = 0x8847). When type is administrator_as_2octet_link_bandwidth
  // the valid sub type is extended_bandwidth. The first two bytes of the value field
  // contains the AS number and the last four bytes contains the bandwidth in IEEE floating
  // point format.  When type is evpn the valid subtype is mac_address. In the value field
  // the low-order bit of the first byte(Flags) is defined as the Sticky/static flag and
  // may be set to 1, indicating the MAC address is static and cannot move. The second
  // byte is reserved and the  last four bytes contain the sequence number which is used
  // to ensure that PEs retain the correct MAC/IP Advertisement route when multiple updates
  // occur for the same MAC address.  Note evpn type is defined mainly for use with evpn
  // route updates and not for IPv4 and IPv6 route updates.
  repeated BgpExtCommunity ext_communities = 11;

  // Optional Extended Community settings. The Extended Communities Attribute is a transitive
  // optional BGP attribute, with the Type Code 16. Community and Extended Communities
  // attributes are utilized to trigger routing decisions, such as acceptance, rejection,
  // preference, or redistribution. An extended community is an eight byte value. It
  // is divided into two main parts. The first two bytes of the community encode a type
  // and sub-type fields and the last six bytes carry a unique set of data in a format
  // defined by the type and sub-type field. Extended communities provide a larger range
  // for grouping or categorizing communities.
  repeated BgpExtendedCommunity extended_communities = 12;

  // Optional configuration for a BGP speaker to Bind an Address Prefix to One or More
  // MPLS Labels.
  BgpMplsLabelBindings mpls_labels = 13;
}

// The BGP Additional Paths feature is a BGP extension that allows the  advertisement
// of multiple paths for the same prefix without the new  paths implicitly replacing
// any previous paths.
message BgpAddPath {

  // The id of the additional path.
  // default = 1
  optional uint32 path_id = 1;
}

// The Extended Communities Attribute is a optional BGP attribute,defined in RFC4360
// with the Type Code 16.  Community and Extended Communities  attributes are utilized
// to trigger routing decisions, such as acceptance, rejection,  preference, or redistribution.
// An extended community is an 8-Bytes value.It is divided into two main parts. The
// first 2 Bytes of the community  encode a type and optonal sub-type field. The last
// 6 bytes (or 7 bytes for types without a sub-type) carry a unique set of data in a
// format defined by the type and optional sub-type field.  Extended communities provide
// a larger  range for grouping or categorizing communities.
message BgpExtendedCommunity {

  message Choice {
    enum Enum {
      unspecified = 0;
      transitive_2octet_as_type = 1;
      transitive_ipv4_address_type = 2;
      transitive_4octet_as_type = 3;
      transitive_opaque_type = 4;
      transitive_evpn_type = 5;
      non_transitive_2octet_as_type = 6;
      custom = 7;
    }
  }
  // Description missing in models
  // default = Choice.Enum.transitive_2octet_as_type
  optional Choice.Enum choice = 1;

  // Description missing in models
  BgpExtendedCommunityTransitive2OctetAsType transitive_2octet_as_type = 2;

  // Description missing in models
  BgpExtendedCommunityTransitiveIpv4AddressType transitive_ipv4_address_type = 3;

  // Description missing in models
  BgpExtendedCommunityTransitive4OctetAsType transitive_4octet_as_type = 4;

  // Description missing in models
  BgpExtendedCommunityTransitiveOpaqueType transitive_opaque_type = 5;

  // Description missing in models
  BgpExtendedCommunityTransitiveEvpnType transitive_evpn_type = 6;

  // Description missing in models
  BgpExtendedCommunityNonTransitive2OctetAsType non_transitive_2octet_as_type = 7;

  // Description missing in models
  BgpExtendedCommunityCustomType custom = 8;
}

// The Route Target Community identifies one or more routers that may receive a set
// of routes (that carry this Community) carried by BGP.  It is sent with sub-type as
// 0x02.
message BgpExtendedCommunityTransitive2OctetAsTypeRouteTarget {

  // The two octet IANA assigned AS value assigned to the Autonomous System.
  // default = 100
  optional uint32 global_2byte_as = 1;

  // The Local Administrator sub-field contains a number from a numbering space that is
  // administered by the organization to which the Autonomous System number carried in
  // the Global Administrator sub-field has been assigned by an appropriate authority.
  // default = 1
  optional uint32 local_4byte_admin = 2;
}

// The Route Origin Community identifies one or more routers that inject a set of routes
// (that carry this Community) into BGP. It is sent with sub-type as 0x03 .
message BgpExtendedCommunityTransitive2OctetAsTypeRouteOrigin {

  // The two octet IANA assigned AS value assigned to the Autonomous System.
  // default = 100
  optional uint32 global_2byte_as = 1;

  // The Local Administrator sub-field contains a number from a numbering space that is
  // administered by the organization to which the Autonomous System number carried in
  // the Global Administrator sub-field has been assigned by an appropriate authority.
  // default = 1
  optional uint32 local_4byte_admin = 2;
}

// The Link Bandwidth Extended Community attribute is defined in draft-ietf-idr-link-bandwidth.
// (https://datatracker.ietf.org/doc/draft-ietf-idr-link-bandwidth) It is sent with
// sub-type as 0x04.
message BgpExtendedCommunityTransitive2OctetAsTypeLinkBandwidth {

  // The value of the Global Administrator subfield should represent the Autonomous System
  // of the router that attaches the Link Bandwidth Community. If four octet AS numbering
  // scheme is used, AS_TRANS (23456) should be used.
  // default = 100
  optional uint32 global_2byte_as = 1;

  // Bandwidth of the link in bytes per second. ( 1 Kbps is 1000 bytes per second and
  // 1 Mbps is 1000 Kbps per second )
  // default = 0
  optional float bandwidth = 2;
}

// The Transitive Two-Octet AS-Specific Extended Community is sent as type 0x00 .
// 
message BgpExtendedCommunityTransitive2OctetAsType {

  message Choice {
    enum Enum {
      unspecified = 0;
      route_target_subtype = 1;
      route_origin_subtype = 2;
      link_bandwidth_subtype = 3;
    }
  }
  // Description missing in models
  // default = Choice.Enum.route_target_subtype
  optional Choice.Enum choice = 1;

  // Description missing in models
  BgpExtendedCommunityTransitive2OctetAsTypeRouteTarget route_target_subtype = 2;

  // Description missing in models
  BgpExtendedCommunityTransitive2OctetAsTypeRouteOrigin route_origin_subtype = 3;

  // Description missing in models
  BgpExtendedCommunityTransitive2OctetAsTypeLinkBandwidth link_bandwidth_subtype = 4;
}

// The Route Origin Community identifies one or more routers that inject a set of routes
// (that carry this Community) into BGP It is sent with sub-type as 0x03.
message BgpExtendedCommunityTransitiveIpv4AddressTypeRouteOrigin {

  // An IPv4 unicast address assigned by one of the Internet registries.
  // default = 0.0.0.0
  optional string global_ipv4_admin = 1;

  // The Local Administrator sub-field contains a number from a numbering space that is
  // administered by the organization to which  the IP address carried in the Global Administrator
  // sub-field has been assigned by an appropriate authority.
  // default = 1
  optional uint32 local_2byte_admin = 2;
}

// The Route Target Community identifies one or more routers that may receive a set
// of routes (that carry this Community) carried by BGP.  It is sent with sub-type as
// 0x02.
message BgpExtendedCommunityTransitiveIpv4AddressTypeRouteTarget {

  // An IPv4 unicast address assigned by one of the Internet registries.
  // default = 0.0.0.0
  optional string global_ipv4_admin = 1;

  // The Local Administrator sub-field contains a number from a numbering space that is
  // administered by the organization to which  the IP address carried in the Global Administrator
  // sub-field has been assigned by an appropriate authority.
  // default = 1
  optional uint32 local_2byte_admin = 2;
}

// The Transitive IPv4 Address Specific Extended Community is sent as type 0x01.
message BgpExtendedCommunityTransitiveIpv4AddressType {

  message Choice {
    enum Enum {
      unspecified = 0;
      route_target_subtype = 1;
      route_origin_subtype = 2;
    }
  }
  // Description missing in models
  // default = Choice.Enum.route_target_subtype
  optional Choice.Enum choice = 1;

  // Description missing in models
  BgpExtendedCommunityTransitiveIpv4AddressTypeRouteTarget route_target_subtype = 2;

  // Description missing in models
  BgpExtendedCommunityTransitiveIpv4AddressTypeRouteOrigin route_origin_subtype = 3;
}

// The Route Target Community identifies one or more routers that may receive a set
// of routes (that carry this Community) carried by BGP.  It is sent with sub-type as
// 0x02
message BgpExtendedCommunityTransitive4OctetAsTypeRouteTarget {

  // The four octet IANA assigned AS value assigned to the Autonomous System.
  // default = 100
  optional uint32 global_4byte_as = 1;

  // The Local Administrator sub-field contains a number from a numbering space that is
  // administered by the organization to which the Autonomous System number carried in
  // the Global Administrator sub-field has been assigned by an appropriate authority.
  // default = 1
  optional uint32 local_2byte_admin = 2;
}

// The Route Origin Community identifies one or more routers that inject a set of routes
// (that carry this Community) into BGP. It is sent with sub-type as 0x03.
message BgpExtendedCommunityTransitive4OctetAsTypeRouteOrigin {

  // The four octet IANA assigned AS value assigned to the Autonomous System.
  // default = 100
  optional uint32 global_4byte_as = 1;

  // The Local Administrator sub-field contains a number from a numbering space that is
  // administered by the organization to which the Autonomous System number carried in
  // the Global Administrator sub-field has been assigned by an appropriate authority.
  // default = 1
  optional uint32 local_2byte_admin = 2;
}

// The Transitive Four-Octet AS-Specific Extended Community is sent as type 0x02. It
// is defined in RFC 5668.
message BgpExtendedCommunityTransitive4OctetAsType {

  message Choice {
    enum Enum {
      unspecified = 0;
      route_target_subtype = 1;
      route_origin_subtype = 2;
    }
  }
  // Description missing in models
  // default = Choice.Enum.route_target_subtype
  optional Choice.Enum choice = 1;

  // Description missing in models
  BgpExtendedCommunityTransitive4OctetAsTypeRouteTarget route_target_subtype = 2;

  // Description missing in models
  BgpExtendedCommunityTransitive4OctetAsTypeRouteOrigin route_origin_subtype = 3;
}

// The Color Community contains locally administrator defined 'color' value which is
// used in conjunction with Encapsulation  attribute to decide whether a data packet
// can be transmitted on a certain tunnel or not. It is defined in RFC9012 and sent
// with sub-type as 0x0b.
message BgpExtendedCommunityTransitiveOpaqueTypeColor {

  // Two octet flag values.
  // default = 0
  optional uint32 flags = 1;

  // The color value is user defined and configured locally and used to determine whether
  // a data packet can be transmitted on a certain tunnel or not in conjunction with the
  // Encapsulation attribute. It is defined in RFC9012.
  // default = 0
  optional uint32 color = 2;
}

// This identifies the type of tunneling technology being signalled. It is defined in
// RFC9012 and sent with sub-type as 0x0c.
message BgpExtendedCommunityTransitiveOpaqueTypeEncapsulation {

  // Four bytes of reserved values. Normally set to 0 on transmit and ignored on receive.
  // 
  // default = 0
  optional uint32 reserved = 1;

  // Identifies the type of tunneling technology being signalled. Initially defined in
  // RFC5512 and extended in RFC9012. Some of the important tunnel types include  1 L2TPv3
  // over IP	[RFC9012],
  // 2	GRE	[RFC9012]
  // 7	IP in IP	[RFC9012]
  // 8	VXLAN Encapsulation	[RFC8365]
  // 9	NVGRE Encapsulation	[RFC8365]
  // 10	MPLS Encapsulation	[RFC8365]
  // 15	SR TE Policy Type	[draft-ietf-idr-segment-routing-te-policy]
  // 19	Geneve Encapsulation	[RFC8926]
  // default = 1
  optional uint32 tunnel_type = 2;
}

// The Transitive Opaque Extended Community is sent as type 0x03.
message BgpExtendedCommunityTransitiveOpaqueType {

  message Choice {
    enum Enum {
      unspecified = 0;
      color_subtype = 1;
      encapsulation_subtype = 2;
    }
  }
  // Description missing in models
  // default = Choice.Enum.color_subtype
  optional Choice.Enum choice = 1;

  // Description missing in models
  BgpExtendedCommunityTransitiveOpaqueTypeColor color_subtype = 2;

  // Description missing in models
  BgpExtendedCommunityTransitiveOpaqueTypeEncapsulation encapsulation_subtype = 3;
}

// The Router MAC EVPN Community is defined in RFC9135 and normally sent only for EVPN
// Type-2 Routes . It is sent with sub-type 0x03.
message BgpExtendedCommunityTransitiveEvpnTypeRouterMac {

  // MAC Address of the PE Router.
  // default = 0:0:0:0:0:0
  optional string router_mac = 1;
}

// The Transitive EVPN Extended Community is sent as type 0x06 .
message BgpExtendedCommunityTransitiveEvpnType {

  message Choice {
    enum Enum {
      unspecified = 0;
      router_mac_subtype = 1;
    }
  }
  // Description missing in models
  // default = Choice.Enum.router_mac_subtype
  optional Choice.Enum choice = 1;

  // Description missing in models
  BgpExtendedCommunityTransitiveEvpnTypeRouterMac router_mac_subtype = 2;
}

// The Link Bandwidth Extended Community attribute is defined in draft-ietf-idr-link-bandwidth.
// It is sent with sub-type as 0x04.
message BgpExtendedCommunityNonTransitive2OctetAsTypeLinkBandwidth {

  // The value of the Global Administrator subfield should represent the Autonomous System
  // of the router that attaches the Link Bandwidth Community. If four octet AS numbering
  // scheme is used, AS_TRANS (23456) should be used.
  // default = 100
  optional uint32 global_2byte_as = 1;

  // Bandwidth of the link in bytes per second. ( 1 Kbps is 1000 bytes per second and
  // 1 Mbps is 1000 Kbps per second )
  // default = 0
  optional float bandwidth = 2;
}

// The Non-Transitive Two-Octet AS-Specific Extended Community is sent as type 0x40.
// 
message BgpExtendedCommunityNonTransitive2OctetAsType {

  message Choice {
    enum Enum {
      unspecified = 0;
      link_bandwidth_subtype = 1;
    }
  }
  // Description missing in models
  // default = Choice.Enum.link_bandwidth_subtype
  optional Choice.Enum choice = 1;

  // Description missing in models
  BgpExtendedCommunityNonTransitive2OctetAsTypeLinkBandwidth link_bandwidth_subtype = 2;
}

// Add a custom Extended Community with a combination of types , sub-types and values
// not explicitly specified above or not defined yet.
message BgpExtendedCommunityCustomType {

  // The type to be set in the Extended Community attribute. Accepts hexadecimal input
  // upto ff .
  // default = 00
  optional string community_type = 1;

  // The sub-type to be set in the Extended Community attribute. For certain types with
  // no sub-type this byte can also be used as part of an extended value field. Accepts
  // hexadecimal input upto ff.
  // default = 00
  optional string community_subtype = 2;

  // 6 byte hex value to be carried in the last 6 bytes of the Extended Community. Accepts
  // hexadecimal input upto ffffffffffff.
  // default = 000000000000
  optional string value = 3;
}

// BGP may be used to advertise that a particular node (N) has bound a particular MPLS
// label, or a particular sequence of MPLS labels,
// to a particular address prefix.
// This is done by sending a Multiprotocol BGP UPDATE message with with an MP_REACH_NLRI
// attribute.
// The Network Address of Next Hop field of that attribute contains an IP address of
// node N.
// References: https://datatracker.ietf.org/doc/html/rfc3107
// & https://datatracker.ietf.org/doc/html/rfc8277.
message BgpMplsLabelBindings {

  message Choice {
    enum Enum {
      unspecified = 0;
      labels = 1;
    }
  }
  // Bind one or more MPLS Labels or SR indices to Address Prefixes.
  // To advertise multiple labels for an address prefix, the BGP capabilities device.bgp.capablity.ipv4_mpls_multi/bgp.capablity.ipv6_mpls_multi
  // etc. to be configured first.
  // - labels: One or more Label Values are to be configured here.
  // default = Choice.Enum.labels
  optional Choice.Enum choice = 1;

  // Description missing in models
  repeated RouteMplsLabelValue labels = 2;
}

// Emulated BGPv6 route range.
message BgpV6RouteRange {

  // A list of group of IPv6 route addresses.
  repeated V6RouteAddress addresses = 1;

  message NextHopMode {
    enum Enum {
      unspecified = 0;
      local_ip = 1;
      manual = 2;
    }
  }
  // Specify the NextHop in MP REACH NLRI. The mode for setting the IP address  of the
  // NextHop in the MP REACH NLRI can be one of the following:
  // Local IP: Automatically fills the Nexthop with the Local IP of the BGP
  // peer.
  // If BGP peer is of type IPv6, Nexthop Encoding capability should be enabled.
  // Manual: Override the Nexthop with any arbitrary IPv4/IPv6 address.
  // default = NextHopMode.Enum.local_ip
  optional NextHopMode.Enum next_hop_mode = 2;

  message NextHopAddressType {
    enum Enum {
      unspecified = 0;
      ipv4 = 1;
      ipv6 = 2;
    }
  }
  // If the Nexthop Mode is Manual, it sets the type of the NextHop IP address.
  // default = NextHopAddressType.Enum.ipv6
  optional NextHopAddressType.Enum next_hop_address_type = 3;

  // The IPv4 address of the next hop if the Nexthop Mode is manual and the Nexthop type
  // is IPv4. If BGP peer is of type IPv6, Nexthop Encoding capability should be enabled.
  // default = 0.0.0.0
  optional string next_hop_ipv4_address = 4;

  // The IPv6 address of the next hop if the Nexthop Mode is manual and the Nexthop type
  // is IPv6.
  // default = ::0
  optional string next_hop_ipv6_address = 5;

  // Description missing in models
  BgpRouteAdvanced advanced = 6;

  // Optional community settings.
  repeated BgpCommunity communities = 7;

  // Description missing in models
  BgpAsPath as_path = 8;

  // Description missing in models
  BgpAddPath add_path = 9;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  optional string name = 10;

  // Deprecated: This property is deprecated in favor of property extended_communities
  // 
  // Optional Extended Community settings. The Extended Communities Attribute is a transitive
  // optional BGP attribute, with the Type Code 16. Community and Extended Communities
  // attributes are utilized to trigger routing decisions, such as acceptance, rejection,
  // preference, or redistribution. An extended community is an 8-Bytes value. It is
  // divided into two main parts. The first 2 Bytes of the community encode a type and
  // sub-type fields and the last 6 Bytes carry a unique set of data in a format defined
  // by the type and sub-type field. Extended communities provide a larger  range for
  // grouping or categorizing communities. When type is administrator_as_2octet or administrator_as_4octet,
  // the valid sub types are route target and origin. The valid value for  administrator_as_2octet
  // and administrator_as_4octet type is either two byte AS followed by four byte local
  // administrator id or four byte AS followed by two  byte local administrator id.  When
  // type is administrator_ipv4_address the valid sub types are route target and origin.
  // The valid value for  administrator_ipv4_address is a four byte IPv4 address followed
  // by a two byte local administrator id.  When type is opaque, valid sub types are color
  // and encapsulation. When sub type is color, first two bytes of the value field contain
  // flags and last four bytes  contains the value of the color. When sub type is encapsulation
  // the first four bytes of value field are reserved and last two bytes carries the tunnel
  // type from  IANA's ETHER TYPES registry e.g IPv4 (protocol type = 0x0800), IPv6 (protocol
  // type = 0x86dd), and MPLS (protocol type = 0x8847). When type is administrator_as_2octet_link_bandwidth
  // the valid sub type is extended_bandwidth. The first two bytes of the value field
  // contains the AS number and the last four bytes contains the bandwidth in IEEE floating
  // point format.  When type is evpn the valid subtype is mac_address. In the value field
  // the low-order bit of the first byte(Flags) is defined as the Sticky/static flag and
  // may be set to 1, indicating the MAC address is static and cannot move. The second
  // byte is reserved and the  last four bytes contain the sequence number which is used
  // to ensure that PEs retain the correct MAC/IP Advertisement route when multiple updates
  // occur for the same MAC address.  Note evpn type is defined mainly for use with evpn
  // route updates and not for IPv4 and IPv6 route updates.
  repeated BgpExtCommunity ext_communities = 11;

  // Optional Extended Community settings. The Extended Communities Attribute is a transitive
  // optional BGP attribute, with the Type Code 16. Community and Extended Communities
  // attributes are utilized to trigger routing decisions, such as acceptance, rejection,
  // preference, or redistribution. An extended community is an eight byte value. It
  // is divided into two main parts. The first two bytes of the community encode a type
  // and sub-type fields and the last six bytes carry a unique set of data in a format
  // defined by the type and sub-type field. Extended communities provide a larger range
  // for grouping or categorizing communities.
  repeated BgpExtendedCommunity extended_communities = 12;

  // Optional configuration for a BGP speaker to Bind an Address Prefix to One or More
  // MPLS Labels.
  BgpMplsLabelBindings mpls_labels = 13;
}

// Configuration for BGP Segment Routing Traffic Engineering(SRTE)
// policy.
// 
message BgpSrteV4Policy {

  // 4-octet value uniquely identifying the policy in the context of (color, endpoint)
  // tuple. It is used by the SR Policy originator to make unique (from an NLRI perspective)
  // both for multiple candidate  paths of the same SR Policy as well as candidate paths
  // of different SR Policies (i.e. with different segment list) with the same Color
  // and Endpoint but meant for different head-ends.
  // default = 1
  optional uint32 distinguisher = 1;

  // Policy color is used to match the color of the destination prefixes to steer traffic
  // into the SR Policy.
  // default = 100
  optional uint32 color = 2;

  // Specifies a single node or a set of nodes (e.g. an anycast address). It is selected
  // on the basis of the SR Policy type (AFI).
  // required = true
  optional string ipv4_endpoint = 3;

  message NextHopMode {
    enum Enum {
      unspecified = 0;
      local_ip = 1;
      manual = 2;
    }
  }
  // Mode for choosing the NextHop in MP REACH NLRI. Available modes are : Local IP: Automatically
  // fills the Nexthop with the Local IP of the BGP peer. For IPv6 BGP peer the Nexthop
  // Encoding capability should be enabled. Manual: Override the Nexthop with any arbitrary
  // IPv4/IPv6 address.
  // default = NextHopMode.Enum.local_ip
  optional NextHopMode.Enum next_hop_mode = 4;

  message NextHopAddressType {
    enum Enum {
      unspecified = 0;
      ipv4 = 1;
      ipv6 = 2;
    }
  }
  // Type of next hop IP address to be used when 'next_hop_mode' is set to 'manual'.
  // default = NextHopAddressType.Enum.ipv4
  optional NextHopAddressType.Enum next_hop_address_type = 5;

  // The IPv4 address of the next hop if the Nexthop type 'next_hop_mode' is 'manual'
  // and the Nexthop type 'next_hop_address_type' is IPv4. If BGP peer is of type IPv6,
  // Nexthop Encoding capability extended_next_hop_encoding should be enabled.
  optional string next_hop_ipv4_address = 6;

  // The IPv6 address of the next hop if the Nexthop Mode 'next_hop_address_type' is 'manual'
  // and the Nexthop type 'next_hop_address_type' is IPv6.
  optional string next_hop_ipv6_address = 7;

  // Description missing in models
  BgpRouteAdvanced advanced = 8;

  // Description missing in models
  BgpAddPath add_path = 9;

  // Description missing in models
  BgpAsPath as_path = 10;

  // Optional Community settings.
  repeated BgpCommunity communities = 11;

  // Optional Extended Community settings. The Extended Communities Attribute is a transitive
  // optional BGP attribute, with the Type Code 16. Community and Extended Communities
  // attributes are utilized to trigger routing decisions, such as acceptance, rejection,
  // preference, or redistribution. An extended community is an 8-Bytes value. It is
  // divided into two main parts. The first 2 Bytes of the community encode a type and
  // sub-type fields and the last 6 Bytes carry a unique set of data in a format defined
  // by the type and sub-type field. Extended communities provide a larger  range for
  // grouping or categorizing communities. When type is administrator_as_2octet or administrator_as_4octet,
  // the valid sub types are route target and origin. The valid value for  administrator_as_2octet
  // and administrator_as_4octet type is either two byte AS followed by four byte local
  // administrator id or four byte AS followed by two  byte local administrator id.  When
  // type is administrator_ipv4_address the valid sub types are route target and origin.
  // The valid value for  administrator_ipv4_address is a four byte IPv4 address followed
  // by a two byte local administrator id.  When type is opaque, valid sub types are color
  // and encapsulation. When sub type is color, first two bytes of the value field contain
  // flags and last four bytes  contains the value of the color. When sub type is encapsulation
  // the first four bytes of value field are reserved and last two bytes carries the tunnel
  // type from  IANA's ETHER TYPES registry e.g IPv4 (protocol type = 0x0800), IPv6 (protocol
  // type = 0x86dd), and MPLS (protocol type = 0x8847). When type is administrator_as_2octet_link_bandwidth
  // the valid sub type is extended_bandwidth. The first two bytes of the value field
  // contains the AS number and the last four bytes contains the bandwidth in IEEE floating
  // point format.  When type is evpn the valid subtype is mac_address. In the value field
  // the low-order bit of the first byte(Flags) is defined as the Sticky/static flag and
  // may be set to 1, indicating the MAC address is static and cannot move. The second
  // byte is reserved and the  last four bytes contain the sequence number which is used
  // to ensure that PEs retain the correct MAC/IP Advertisement route when multiple updates
  // occur for the same MAC address.
  repeated BgpExtCommunity ext_communities = 12;

  // List Tunnel Encapsulation Attributes.
  repeated BgpSrteV4TunnelTlv tunnel_tlvs = 13;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  optional string name = 14;

  // If enabled means that this part of the configuration including any active 'children'
  // nodes will be advertised to peer.  If disabled, this means that though config is
  // present, it is not taking any part of the test but can be activated at run-time to
  // advertise just this part of the configuration to the peer.
  // default = True
  optional bool active = 15;
}

// Configuration for BGP SRTE Tunnel TLV.
message BgpSrteV4TunnelTlv {

  // Description missing in models
  BgpSrteRemoteEndpointSubTlv remote_endpoint_sub_tlv = 1;

  // Description missing in models
  BgpSrteColorSubTlv color_sub_tlv = 2;

  // Description missing in models
  BgpSrteBindingSubTlv binding_sub_tlv = 3;

  // Description missing in models
  BgpSrtePreferenceSubTlv preference_sub_tlv = 4;

  // Description missing in models
  BgpSrtePolicyPrioritySubTlv policy_priority_sub_tlv = 5;

  // Description missing in models
  BgpSrtePolicyNameSubTlv policy_name_sub_tlv = 6;

  // Description missing in models
  BgpSrteExplicitNullLabelPolicySubTlv explicit_null_label_policy_sub_tlv = 7;

  // Description missing in models
  repeated BgpSrteSegmentList segment_lists = 8;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  optional string name = 9;

  // If enabled means that this part of the configuration including any active 'children'
  // nodes will be advertised to peer.  If disabled, this means that though config is
  // present, it is not taking any part of the test but can be activated at run-time to
  // advertise just this part of the configuration to the peer.
  // default = True
  optional bool active = 10;
}

// Configuration for the BGP remote endpoint sub TLV.
message BgpSrteRemoteEndpointSubTlv {

  // Autonomous system (AS) number
  // default = 0
  optional uint32 as_number = 1;

  message AddressFamily {
    enum Enum {
      unspecified = 0;
      ipv4 = 1;
      ipv6 = 2;
    }
  }
  // Determines the address type
  // default = AddressFamily.Enum.ipv4
  optional AddressFamily.Enum address_family = 2;

  // The IPv4 address of the Remote Endpoint.
  // default = 0.0.0.0
  optional string ipv4_address = 3;

  // The IPv6 address of the Remote Endpoint.
  // default = ::0
  optional string ipv6_address = 4;
}

// Configuration for the Policy Color attribute sub-TLV. The Color sub-TLV MAY be used
// as a way to color the corresponding Tunnel TLV. The Value field of the sub-TLV is
// eight octets long and consists of a Color Extended Community. First two octets of
// its Value field are 0x030b as type and subtype of extended  community. Remaining
// six octets are are exposed to configure.
message BgpSrteColorSubTlv {

  // Six octet values. Example: 000000000064 for color value 100.
  optional string color = 1;
}

// Configuration for the binding SID sub-TLV.  This is used to signal the binding SID
// related information  of the SR Policy candidate path.
message BgpSrteBindingSubTlv {

  message BindingSidType {
    enum Enum {
      unspecified = 0;
      no_binding = 1;
      four_octet_sid = 2;
      ipv6_sid = 3;
    }
  }
  // Type of the binding SID.  Supported types are No Binding SID or Four Octets Sid or
  // IPv6 SID.
  // default = BindingSidType.Enum.no_binding
  optional BindingSidType.Enum binding_sid_type = 1;

  // Binding SID is encoded in 4 octets.
  optional uint32 four_octet_sid = 2;

  // IPv6 SID value.
  optional string ipv6_sid = 3;

  // S-Flag encodes the Specified-BSID-only behavior.
  // default = False
  optional bool s_flag = 4;

  // I-Flag encodes the Drop Upon Invalid behavior.
  // default = False
  optional bool i_flag = 5;
}

// Configuration for BGP preference sub TLV of the SR Policy candidate path.
message BgpSrtePreferenceSubTlv {

  // The preference value of the SR Policy candidate path.
  // default = 0
  optional uint32 preference = 1;
}

// Configuration for the Policy Priority sub-TLV. The Policy Priority to indicate the
// order in which the SR policies  are re-computed upon topological change.
message BgpSrtePolicyPrioritySubTlv {

  // One-octet Priority value.
  optional uint32 policy_priority = 1;
}

// Configuration for the Policy Name sub-TLV. The Policy Name sub-TLV is used to attach
// a symbolic name to the SR Policy candidate path.
message BgpSrtePolicyNameSubTlv {

  // Symbolic name for the policy that should be a string of printable ASCII characters,
  // without a NULL terminator.
  optional string policy_name = 1;
}

// Configuration for BGP explicit null label policy sub TLV settings.
message BgpSrteExplicitNullLabelPolicySubTlv {

  message ExplicitNullLabelPolicy {
    enum Enum {
      unspecified = 0;
      reserved_enlp = 1;
      push_ipv4_enlp = 2;
      push_ipv6_enlp = 3;
      push_ipv4_ipv6_enlp = 4;
      do_not_push_enlp = 5;
    }
  }
  // The value of the explicit null label policy
  // default = ExplicitNullLabelPolicy.Enum.do_not_push_enlp
  optional ExplicitNullLabelPolicy.Enum explicit_null_label_policy = 1;
}

// Optional configuration for BGP SR TE Policy segment list. The Segment List sub-TLV
// encodes a single explicit path towards the Endpoint.
message BgpSrteSegmentList {

  // The Weight associated with a given path and the sub-TLV is optional.
  // default = 0
  optional uint32 weight = 1;

  // Description missing in models
  repeated BgpSrteSegment segments = 2;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  optional string name = 3;

  // If enabled means that this part of the configuration including any active 'children'
  // nodes will be advertised to peer.  If disabled, this means that though config is
  // present, it is not taking any part of the test but can be activated at run-time to
  // advertise just this part of the configuration to the peer.
  // default = True
  optional bool active = 4;
}

// A Segment sub-TLV describes a single segment in a segment list  i.e., a single element
// of the explicit path. The Segment sub-TLVs are optional.
message BgpSrteSegment {

  message SegmentType {
    enum Enum {
      unspecified = 0;
      type_a = 1;
      type_b = 2;
      type_c = 3;
      type_d = 4;
      type_e = 5;
      type_f = 6;
      type_g = 7;
      type_h = 8;
      type_i = 9;
      type_j = 10;
      type_k = 11;
    }
  }
  // Specify one of the segment type.
  // https://datatracker.ietf.org/doc/html/draft-ietf-idr-segment-routing-te-policy-13
  // Type  A: SID only, in the form of MPLS Label.
  // Type  B: SID only, in the form of IPv6 Address.
  // Type  C: IPv4 Node Address with optional SID.
  // Type  D: IPv6 Node Address with optional SID for SR MPLS.
  // Type  E: IPv4 Address and index with optional SID.
  // Type  F: IPv4 Local and Remote addresses with optional SID.
  // Type  G: IPv6 Address and index for local and remote pair with optional
  // SID for SR MPLS.
  // Type  H: IPv6 Local and Remote addresses with optional SID for SR MPLS.
  // Type  I: IPv6 Node Address with optional SID for SRv6.
  // Type  J: IPv6 Address and index for local and remote pair with optional
  // SID for SRv6.
  // Type  K: IPv6 Local and Remote addresses for SRv6.
  // required = true
  optional SegmentType.Enum segment_type = 1;

  // Description missing in models
  BgpSrteSegmentATypeSubTlv type_a = 2;

  // Description missing in models
  BgpSrteSegmentBTypeSubTlv type_b = 3;

  // Description missing in models
  BgpSrteSegmentCTypeSubTlv type_c = 4;

  // Description missing in models
  BgpSrteSegmentDTypeSubTlv type_d = 5;

  // Description missing in models
  BgpSrteSegmentETypeSubTlv type_e = 6;

  // Description missing in models
  BgpSrteSegmentFTypeSubTlv type_f = 7;

  // Description missing in models
  BgpSrteSegmentGTypeSubTlv type_g = 8;

  // Description missing in models
  BgpSrteSegmentHTypeSubTlv type_h = 9;

  // Description missing in models
  BgpSrteSegmentITypeSubTlv type_i = 10;

  // Description missing in models
  BgpSrteSegmentJTypeSubTlv type_j = 11;

  // Description missing in models
  BgpSrteSegmentKTypeSubTlv type_k = 12;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  optional string name = 13;

  // If enabled means that this part of the configuration including any active 'children'
  // nodes will be advertised to peer.  If disabled, this means that though config is
  // present, it is not taking any part of the test but can be activated at run-time to
  // advertise just this part of the configuration to the peer.
  // default = True
  optional bool active = 14;
}

// Configuration for SR-MPLS with Label, TC, Bottom-of-Stack and TTL.
message BgpSrteSrMplsSid {

  // Label value in [0, 2^20 -1].
  optional uint32 label = 1;

  // Traffic class in bits.
  optional uint32 tc = 2;

  // Bottom-of-Stack bit.
  optional bool s_bit = 3;

  // Time To Live.
  optional uint32 ttl = 4;
}

// Configuration for SRv6 Endpoint Behavior and SID Structure.  Its optional. Summation
// of lengths for Locator Block, Locator Node,  Function, and Argument MUST be less
// than or equal to 128.
message BgpSrteSRv6SIDEndpointBehaviorAndStructure {

  // SRv6 SID Locator Block length in bits.
  // default = 0
  optional uint32 lb_length = 1;

  // SRv6 SID Locator Node length in bits.
  // default = 0
  optional uint32 ln_length = 2;

  // SRv6 SID Function length in bits.
  // default = 0
  optional uint32 func_length = 3;

  // SRv6 SID Arguments length in bits.
  // default = 0
  optional uint32 arg_length = 4;
}

// Type  A: SID only, in the form of MPLS Label.
message BgpSrteSegmentATypeSubTlv {

  // One octet bitmap for flags including V-Flag, A-Flag, S-Flag, B-Flag etc. as defined
  // in https://datatracker.ietf.org/doc/html/draft-ietf-idr-segment-routing-te-policy-13#section-2.4.4.2.12
  optional string flags = 1;

  // Label value in [0, 2^20 -1].
  optional uint32 label = 2;

  // Traffic class in bits.
  optional uint32 tc = 3;

  // Bottom-of-Stack bit.
  optional bool s_bit = 4;

  // Time To Live.
  optional uint32 ttl = 5;
}

// Type  B: SID only, in the form of IPv6 address.
message BgpSrteSegmentBTypeSubTlv {

  // One octet bitmap for flags including V-Flag, A-Flag, S-Flag, B-Flag etc. as defined
  // in https://datatracker.ietf.org/doc/html/draft-ietf-idr-segment-routing-te-policy-13#section-2.4.4.2.12
  optional string flags = 1;

  // SRv6 SID.
  // required = true
  optional string srv6_sid = 2;

  // Optional SRv6 Endpoint Behavior and SID Structure.
  BgpSrteSRv6SIDEndpointBehaviorAndStructure srv6_sid_endpoint_behavior = 3;
}

// Type C: IPv4 Node Address with optional SID.
message BgpSrteSegmentCTypeSubTlv {

  // One octet bitmap for flags including V-Flag, A-Flag, S-Flag, B-Flag etc. as defined
  // in https://datatracker.ietf.org/doc/html/draft-ietf-idr-segment-routing-te-policy-13#section-2.4.4.2.12
  optional string flags = 1;

  // SR Algorithm identifier when A-Flag in on.
  // default = 0
  optional uint32 sr_algorithm = 2;

  // IPv4 address representing a node.
  // required = true
  optional string ipv4_node_address = 3;

  // Optional SR-MPLS SID.
  BgpSrteSrMplsSid sr_mpls_sid = 4;
}

// Type D: IPv6 Node Address with optional SID for SR MPLS.
message BgpSrteSegmentDTypeSubTlv {

  // One octet bitmap for flags including V-Flag, A-Flag, S-Flag, B-Flag etc. as defined
  // in https://datatracker.ietf.org/doc/html/draft-ietf-idr-segment-routing-te-policy-13#section-2.4.4.2.12
  optional string flags = 1;

  // specifying SR Algorithm when when A-Flag as defined in above flags.
  // default = 0
  optional uint32 sr_algorithm = 2;

  // IPv6 address representing a node.
  // required = true
  optional string ipv6_node_address = 3;

  // Optional SR-MPLS SID.
  BgpSrteSrMplsSid sr_mpls_sid = 4;
}

// Type E: IPv4 Address and Local Interface ID with optional SID
message BgpSrteSegmentETypeSubTlv {

  // One octet bitmap for flags including V-Flag, A-Flag, S-Flag, B-Flag etc. as defined
  // in https://datatracker.ietf.org/doc/html/draft-ietf-idr-segment-routing-te-policy-13#section-2.4.4.2.12
  optional string flags = 1;

  // Local Interface ID: The Interface Index as defined in [RFC8664].
  // default = 0
  optional uint32 local_interface_id = 2;

  // IPv4 address representing a node.
  // required = true
  optional string ipv4_node_address = 3;

  // Optional SR-MPLS SID.
  BgpSrteSrMplsSid sr_mpls_sid = 4;
}

// Type F: IPv4 Local and Remote addresses with optional SID.
message BgpSrteSegmentFTypeSubTlv {

  // One octet bitmap for flags including V-Flag, A-Flag, S-Flag, B-Flag etc. as defined
  // in https://datatracker.ietf.org/doc/html/draft-ietf-idr-segment-routing-te-policy-13#section-2.4.4.2.12
  optional string flags = 1;

  // Local IPv4 Address.
  // required = true
  optional string local_ipv4_address = 2;

  // Remote IPv4 Address.
  // required = true
  optional string remote_ipv4_address = 3;

  // Optional SR-MPLS SID.
  BgpSrteSrMplsSid sr_mpls_sid = 4;
}

// Type G: IPv6 Address, Interface ID for local and remote pair with optional SID for
// SR MPLS.
message BgpSrteSegmentGTypeSubTlv {

  // One octet bitmap for flags including V-Flag, A-Flag, S-Flag, B-Flag etc. as defined
  // in https://datatracker.ietf.org/doc/html/draft-ietf-idr-segment-routing-te-policy-13#section-2.4.4.2.12
  optional string flags = 1;

  // Local Interface ID: The Interface Index as defined in [RFC8664].
  // default = 0
  optional uint32 local_interface_id = 2;

  // IPv6 address representing a node.
  // required = true
  optional string local_ipv6_node_address = 3;

  // Local Interface ID: The Interface Index as defined in [RFC8664].
  // default = 0
  optional uint32 remote_interface_id = 4;

  // IPv6 address representing a node.
  // required = true
  optional string remote_ipv6_node_address = 5;

  // Optional SR-MPLS SID.
  BgpSrteSrMplsSid sr_mpls_sid = 6;
}

// Type H: IPv6 Local and Remote addresses with optional SID for SR MPLS.
message BgpSrteSegmentHTypeSubTlv {

  // One octet bitmap for flags including V-Flag, A-Flag, S-Flag, B-Flag etc. as defined
  // in https://datatracker.ietf.org/doc/html/draft-ietf-idr-segment-routing-te-policy-13#section-2.4.4.2.12
  optional string flags = 1;

  // Local IPv6 Address.
  // required = true
  optional string local_ipv6_address = 2;

  // Remote IPv6 Address.
  // required = true
  optional string remote_ipv6_address = 3;

  // Optional SR-MPLS SID.
  BgpSrteSrMplsSid sr_mpls_sid = 4;
}

// Type I: IPv6 Node Address with optional SRv6 SID.
message BgpSrteSegmentITypeSubTlv {

  // One octet bitmap for flags including V-Flag, A-Flag, S-Flag, B-Flag etc. as defined
  // in https://datatracker.ietf.org/doc/html/draft-ietf-idr-segment-routing-te-policy-13#section-2.4.4.2.12
  optional string flags = 1;

  // IPv6 address representing a node.
  // required = true
  optional string ipv6_node_address = 2;

  // Optional SRv6 SID.
  optional string srv6_sid = 3;

  // Optional SRv6 Endpoint Behavior and SID Structure.
  BgpSrteSRv6SIDEndpointBehaviorAndStructure srv6_sid_endpoint_behavior = 4;
}

// Type J: IPv6 Address, Interface ID for local and remote pair for SRv6 with optional
// SID.
message BgpSrteSegmentJTypeSubTlv {

  // One octet bitmap for flags including V-Flag, A-Flag, S-Flag, B-Flag etc. as defined
  // in https://datatracker.ietf.org/doc/html/draft-ietf-idr-segment-routing-te-policy-13#section-2.4.4.2.12
  optional string flags = 1;

  // SR Algorithm identifier when A-Flag in on.
  // default = 0
  optional uint32 sr_algorithm = 2;

  // Local Interface ID: The Interface Index as defined in [RFC8664].
  // default = 0
  optional uint32 local_interface_id = 3;

  // IPv6 address representing a node.
  // required = true
  optional string local_ipv6_node_address = 4;

  // Local Interface ID: The Interface Index as defined in [RFC8664].
  // default = 0
  optional uint32 remote_interface_id = 5;

  // IPv6 address representing a node.
  // required = true
  optional string remote_ipv6_node_address = 6;

  // Optional SRv6 SID.
  optional string srv6_sid = 7;

  // Optional SRv6 Endpoint Behavior and SID Structure.
  BgpSrteSRv6SIDEndpointBehaviorAndStructure srv6_sid_endpoint_behavior = 8;
}

// Type K: IPv6 Local and Remote addresses for SRv6 with optional SID.
message BgpSrteSegmentKTypeSubTlv {

  // One octet bitmap for flags including V-Flag, A-Flag, S-Flag, B-Flag etc. as defined
  // in https://datatracker.ietf.org/doc/html/draft-ietf-idr-segment-routing-te-policy-13#section-2.4.4.2.12
  optional string flags = 1;

  // SR Algorithm identifier when A-Flag in on.
  // default = 0
  optional uint32 sr_algorithm = 2;

  // IPv6 address representing a node.
  // required = true
  optional string local_ipv6_address = 3;

  // IPv6 address representing a node.
  // required = true
  optional string remote_ipv6_address = 4;

  // Optional SRv6 SID.
  optional string srv6_sid = 5;

  // Optional SRv6 Endpoint Behavior and SID Structure.
  BgpSrteSRv6SIDEndpointBehaviorAndStructure srv6_sid_endpoint_behavior = 6;
}

// Configuration for BGP Segment Routing Traffic Engineering policy.
// 
message BgpSrteV6Policy {

  // Identifies the policy in the context of (color and endpoint) tuple.  It is used by
  // the SR Policy originator to make unique multiple  occurrences of the same SR Policy.
  // default = 1
  optional uint32 distinguisher = 1;

  // Identifies the policy. It is used to match the color of the  destination prefixes
  // to steer traffic into the SR Policy.
  // default = 100
  optional uint32 color = 2;

  // Specifies a single node or a set of nodes (e.g., an anycast address). It is selected
  // on the basis of the SR Policy type (AFI).
  // required = true
  optional string ipv6_endpoint = 3;

  message NextHopMode {
    enum Enum {
      unspecified = 0;
      local_ip = 1;
      manual = 2;
    }
  }
  // Mode for choosing the NextHop in MP REACH NLRI. Available modes are : Local IP: Automatically
  // fills the Nexthop with the Local IP of the BGP peer. For IPv6 BGP peer the Nexthop
  // Encoding capability should be enabled. Manual: Override the Nexthop with any arbitrary
  // IPv4/IPv6 address.
  // default = NextHopMode.Enum.local_ip
  optional NextHopMode.Enum next_hop_mode = 4;

  message NextHopAddressType {
    enum Enum {
      unspecified = 0;
      ipv4 = 1;
      ipv6 = 2;
    }
  }
  // Type of next hop IP address to be used when 'next_hop_mode' is set to 'manual'.
  // default = NextHopAddressType.Enum.ipv6
  optional NextHopAddressType.Enum next_hop_address_type = 5;

  // The IPv4 address of the Nexthop if the 'next_hop_mode' is 'manual' and the Nexthop
  // type 'next_hop_address_type' is IPv4. If BGP peer is of type IPv6, Nexthop Encoding
  // capability extended_next_hop_encoding should be enabled.
  // default = 0.0.0.0
  optional string next_hop_ipv4_address = 6;

  // The IPv6 address of the next hop if the Nexthop Mode 'next_hop_address_type' is 'manual'
  // and the Nexthop type 'next_hop_address_type' is IPv6.
  // default = ::0
  optional string next_hop_ipv6_address = 7;

  // Description missing in models
  BgpRouteAdvanced advanced = 8;

  // Description missing in models
  BgpAddPath add_path = 9;

  // Description missing in models
  BgpAsPath as_path = 10;

  // Optional community settings.
  repeated BgpCommunity communities = 11;

  // Optional Extended Community settings. The Extended Communities Attribute is a transitive
  // optional BGP attribute, with the Type Code 16. Community and Extended Communities
  // attributes are utilized to trigger routing decisions, such as acceptance, rejection,
  // preference, or redistribution. An extended community is an 8-Bytes value. It is
  // divided into two main parts. The first 2 Bytes of the community encode a type and
  // sub-type fields and the last 6 Bytes carry a unique set of data in a format defined
  // by the type and sub-type field. Extended communities provide a larger  range for
  // grouping or categorizing communities. When type is administrator_as_2octet or administrator_as_4octet,
  // the valid sub types are route target and origin. The valid value for  administrator_as_2octet
  // and administrator_as_4octet type is either two byte AS followed by four byte local
  // administrator id or four byte AS followed by two  byte local administrator id.  When
  // type is administrator_ipv4_address the valid sub types are route target and origin.
  // The valid value for  administrator_ipv4_address is a four byte IPv4 address followed
  // by a two byte local administrator id.  When type is opaque, valid sub types are color
  // and encapsulation. When sub type is color, first two bytes of the value field contain
  // flags and last four bytes  contains the value of the color. When sub type is encapsulation
  // the first four bytes of value field are reserved and last two bytes carries the tunnel
  // type from  IANA's ETHER TYPES registry e.g IPv4 (protocol type = 0x0800), IPv6 (protocol
  // type = 0x86dd), and MPLS (protocol type = 0x8847). When type is administrator_as_2octet_link_bandwidth
  // the valid sub type is extended_bandwidth. The first two bytes of the value field
  // contains the AS number and the last four bytes contains the bandwidth in IEEE floating
  // point format.  When type is evpn the valid subtype is mac_address. In the value field
  // the low-order bit of the first byte(Flags) is defined as the Sticky/static flag and
  // may be set to 1, indicating the MAC address is static and cannot move. The second
  // byte is reserved and the  last four bytes contain the sequence number which is used
  // to ensure that PEs retain the correct MAC/IP Advertisement route when multiple updates
  // occur for the same MAC address.
  repeated BgpExtCommunity extcommunities = 12;

  // List of optional tunnel TLV settings.
  repeated BgpSrteV6TunnelTlv tunnel_tlvs = 13;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  optional string name = 14;

  // If enabled means that this part of the configuration including any active 'children'
  // nodes will be advertised to peer.  If disabled, this means that though config is
  // present, it is not taking any part of the test but can be activated at run-time to
  // advertise just this part of the configuration to the peer.
  // default = True
  optional bool active = 15;
}

// Configuration for BGP SRTE Tunnel TLV.
message BgpSrteV6TunnelTlv {

  // Description missing in models
  BgpSrteRemoteEndpointSubTlv remote_endpoint_sub_tlv = 1;

  // Description missing in models
  BgpSrteColorSubTlv color_sub_tlv = 2;

  // Description missing in models
  BgpSrteBindingSubTlv binding_sub_tlv = 3;

  // Description missing in models
  BgpSrtePreferenceSubTlv preference_sub_tlv = 4;

  // Description missing in models
  BgpSrtePolicyPrioritySubTlv policy_priority_sub_tlv = 5;

  // Description missing in models
  BgpSrtePolicyNameSubTlv policy_name_sub_tlv = 6;

  // Description missing in models
  BgpSrteExplicitNullLabelPolicySubTlv explicit_null_label_policy_sub_tlv = 7;

  // Description missing in models
  repeated BgpSrteSegmentList segment_lists = 8;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  optional string name = 9;

  // If enabled means that this part of the configuration including any active 'children'
  // nodes will be advertised to peer.  If disabled, this means that though config is
  // present, it is not taking any part of the test but can be activated at run-time to
  // advertise just this part of the configuration to the peer.
  // default = True
  optional bool active = 10;
}

// The Graceful Restart Capability (RFC 4724) is a BGP capability that can be used by
// a BGP speaker to indicate its ability to preserve its forwarding state during BGP
// restart. The Graceful Restart (GR) capability is advertised in OPEN messages sent
// between BGP peers. After a BGP session has been established, and the initial routing
// update has been completed,  an End-of-RIB (Routing Information Base) marker is sent
// in an UPDATE message to convey information  about routing convergence.
message BgpGracefulRestart {

  // If enabled, Graceful Restart capability is advertised in BGP OPEN messages.
  // default = False
  optional bool enable_gr = 1;

  // This is the estimated duration (in seconds) it will take for the BGP session to be
  // re-established after a restart.  This can be used to speed up routing convergence
  // by its peer in case the BGP speaker does not come back after a restart.
  // default = 45
  optional uint32 restart_time = 2;

  // If enabled, the Long-lived Graceful Restart Capability, or LLGR Capability
  // will be advertised.
  // This capability MUST be advertised in conjunction with the Graceful Restart
  // capability.
  // default = False
  optional bool enable_llgr = 3;

  // Duration (in seconds) specifying how long stale information (for the AFI/SAFI)
  // may be retained. This is a three byte field and is applicable
  // only if 'enable_llgr' is set to 'true'.
  // default = 10
  optional uint32 stale_time = 4;

  // If enabled, the N flag will be set in the Graceful Restart capability in the Open
  // message.
  // If both peers in a BGP connection has this enabled, Graceful Restart procedures are
  // performed
  // even if the peer goes down due to sending of a Notification Message as per RFC8538.
  // default = True
  optional bool enable_notification = 5;
}

// Ordered BGP Updates ( including both Advertise and Withdraws ) to be sent in the
// order given in the input to the peer after the BGP session is established.
message BgpUpdateReplay {

  message Choice {
    enum Enum {
      unspecified = 0;
      structured_pdus = 1;
      raw_bytes = 2;
    }
  }
  // Description missing in models
  // default = Choice.Enum.structured_pdus
  optional Choice.Enum choice = 1;

  // Description missing in models
  BgpStructuredPdus structured_pdus = 2;

  // Description missing in models
  BgpRawBytes raw_bytes = 3;
}

// Ordered BGP Updates ( including both Advertise and Withdraws ) to be sent in the
// order given in the input to the peer after the BGP session is established.
message BgpRawBytes {

  // Array of ordered BGP Updates ( including both Advertise and Withdraws ) to be sent
  // in the order given in the input to the peer after the BGP session is established.
  // 
  repeated BgpOneUpdateReplay updates = 1;
}

// Specification of one BGP Update to be sent to the BGP peer.
message BgpOneUpdateReplay {

  // Minimum time interval in milliseconds from previous Update from the sequence of BGP
  // Updates to be replayed.
  // default = 0
  optional uint32 time_gap = 1;

  // Bytes specified in hex format to be sent to peer after the BGP Update Header. The
  // Update Header will always have the  initial 16 bytes containing Marker bytes, 2 bytes
  // containing the Length and 1 byte containing the Type.The string MUST  contain sequence
  // of valid hex bytes. The bytes specified in hex format should be appended to the Update
  // message to be sent  to the peer after the fixed 19 bytes described above. This byte
  // stream can be of any length from 1 to 4077 bytes.The value  4077 is derived from
  // the maximum length allowed for a BGP message in RFC4271 which is 4096 minus mandatory
  // 19 bytes described  above. In the imported byte stream, one byte is represented as
  // string of 2 characters, for example 2 character string (0x)AB  represents value of
  // a single byte. So the maximum length of this attribute is 8154 (4077 * 2 hex characters
  // per byte).
  // required = true
  optional string update_bytes = 2;
}

// Ordered BGP Updates ( including both Advertise and Withdraws ) to be sent in the
// order given in the input to the peer after the BGP session is established.
message BgpStructuredPdus {

  // Array of ordered BGP Updates ( including both Advertise and Withdraws ) to be sent
  // in the order given in the input to the peer after the BGP session is established.
  // 
  repeated BgpOneStructuredUpdateReplay updates = 1;
}

// One structured BGP Update.
message BgpOneStructuredUpdateReplay {

  // Minimum time interval in milliseconds from previous Update from the sequence of BGP
  // Updates to be replayed.
  // default = 0
  optional uint32 time_gap = 1;

  // Attributes carried in the Update packet alongwith the reach/unreach prefixes.
  // 
  BgpAttributes path_attributes = 2;

  // The IPv4 prefixes to be included in the traditional UNREACH_NLRI.
  repeated BgpOneTraditionalNlriPrefix traditional_unreach_nlris = 3;

  // The IPv4 prefixes to be included in the traditional REACH_NLRI.
  repeated BgpOneTraditionalNlriPrefix traditional_reach_nlris = 4;
}

// TRADITIONAL_NLRI is an optional part of the the BGP Update which can carry only IPv4
// prefix information as defined in https://www.rfc-editor.org/rfc/rfc4271.html#section-4.3
// 
// and extended by https://datatracker.ietf.org/doc/html/rfc7911#section-3 to carry
// additional Path Id information per prefix.
message BgpOneTraditionalNlriPrefix {

  // The IPv4 address of the network.
  // default = 0.0.0.0
  optional string address = 1;

  // The IPv4 network prefix length to be applied to the address.
  // default = 24
  optional uint32 prefix = 2;

  // Description missing in models
  BgpNLRIPrefixPathId path_id = 3;
}

// One IPv4 NLRI Prefix.
message BgpOneIpv4NLRIPrefix {

  // The IPv4 address of the network.
  // default = 0.0.0.0
  optional string address = 1;

  // The IPv4 network prefix length to be applied to the address.
  // default = 24
  optional uint32 prefix = 2;

  // Description missing in models
  BgpNLRIPrefixPathId path_id = 3;
}

// One IPv6 NLRI Prefix.
message BgpOneIpv6NLRIPrefix {

  // The IPv6 address of the network.
  // default = 0::0
  optional string address = 1;

  // The IPv6 network prefix length to be applied to the address.
  // default = 64
  optional uint32 prefix = 2;

  // Description missing in models
  BgpNLRIPrefixPathId path_id = 3;
}

// Optional field in the NLRI carrying Path Id of the prefix.
message BgpNLRIPrefixPathId {

  // The value of the optional Path ID of the prefix.
  // default = 1
  optional uint32 value = 1;
}

// IPv4 Segment Routing Policy NLRI Prefix.
message BgpIpv4SrPolicyNLRIPrefix {

  // The 4-octet value uniquely identifying the policy in the context of <color, endpoint>
  // tuple.  The distinguisher has no semantic value and is solely used by the SR Policy
  // originator to make unique (from an NLRI perspective)  both for multiple candidate
  // paths of the same SR Policy as well as candidate paths of different SR Policies
  // (i.e. with different segment lists) with the same Color and Endpoint but meant for
  // different headends.
  // default = 1
  optional uint32 distinguisher = 1;

  // 4-octet value identifying (with the endpoint) the policy. The color is used to match
  // the color of the destination  prefixes to steer traffic into the SR Policy as specified
  // in section 8 of RFC9256.
  // default = 1
  optional uint32 color = 2;

  // Identifies the endpoint of a policy.  The Endpoint is an IPv4 address and can be
  // either a unicast or an unspecified address (0.0.0.0) as specified in section 2.1
  // of RFC9256.
  // default = 0.0.0.0
  optional string endpoint = 3;
}

// One IPv6 Segment Routing Policy NLRI Prefix.
message BgpIpv6SrPolicyNLRIPrefix {

  // The 4-octet value uniquely identifying the policy in the context of <color, endpoint>
  // tuple.  The distinguisher has no semantic value and is solely used by the SR Policy
  // originator to make unique (from an NLRI perspective)  both for multiple candidate
  // paths of the same SR Policy as well as candidate paths of different SR Policies
  // (i.e. with different segment lists) with the same Color and Endpoint but meant for
  // different headends.
  // default = 1
  optional uint32 distinguisher = 1;

  // 4-octet value identifying (with the endpoint) the policy. The color is used to match
  // the color of the destination  prefixes to steer traffic into the SR Policy as specified
  // in section 8 of RFC9256.
  // default = 1
  optional uint32 color = 2;

  // Identifies the endpoint of a policy.  The Endpoint may represent a single node or
  // a set of nodes (e.g., an anycast address). The Endpoint is an IPv6 address and can
  // be either a unicast or an unspecified address (0::0) as specified in section 2.1
  // of RFC9256.
  // default = 0::0
  optional string endpoint = 3;
}

// Attributes carried in the Update packet alongwith the reach/unreach prefixes.
message BgpAttributes {

  // Any attributes not present in the list of configurable attributes should be added
  // to the list of unknown attributes.
  repeated BgpAttributesOtherAttribute other_attributes = 1;

  message Origin {
    enum Enum {
      unspecified = 0;
      igp = 1;
      egp = 2;
      incomplete = 3;
    }
  }
  // The ORIGIN attribute is a mandatory attribute which can take three values:
  // the prefix originates from an interior routing protocol 'igp', it originates from
  // 'egp'
  // or the origin is 'incomplete',if the prefix is learned through other means.
  // 
  // default = Origin.Enum.incomplete
  optional Origin.Enum origin = 2;

  // AS_PATH attribute to be included in the Update.
  BgpAttributesAsPath as_path = 3;

  // AS4_PATH attribute to be included in the Update.
  BgpAttributesAs4Path as4_path = 4;

  // Description missing in models
  BgpAttributesNextHop next_hop = 5;

  // Description missing in models
  BgpAttributesMultiExitDiscriminator multi_exit_discriminator = 6;

  // Description missing in models
  BgpAttributesLocalPreference local_preference = 7;

  // If enabled, it indicates that the ATOMIC_AGGREGATOR attribute should be included
  // in the Update.
  // Presence of this attribute Indicates that this route might not be getting sent on
  // a fully optimized path
  // since some intermediate BGP speaker has aggregated the route.
  // 
  // default = False
  optional bool include_atomic_aggregator = 8;

  // Description missing in models
  BgpAttributesAggregator aggregator = 9;

  // Description missing in models
  BgpAttributesAs4Aggregator as4_aggregator = 10;

  // Description missing in models
  repeated BgpAttributesCommunity community = 11;

  // Description missing in models
  BgpAttributesOriginatorId originator_id = 12;

  // When a Route Reflector reflects a route, it prepends the local CLUSTER_ID to the
  // CLUSTER_LIST as defined in RFC4456.
  repeated string cluster_ids = 13;

  // Optional EXTENDED_COMMUNITY attribute settings.
  // The EXTENDED_COMMUNITY Attribute is a transitive optional BGP attribute, with the
  // Type Code 16. Community and Extended Communities  attributes
  // are utilized to trigger routing decisions, such as acceptance, rejection,  preference,
  // or redistribution. An extended community is an eight byte value.
  // It is divided into two main parts. The first two bytes of the community encode a
  // type and sub-type fields and the last six bytes carry a unique set
  // of data in a format defined by the type and sub-type field. Extended communities
  // provide a larger range for grouping or categorizing communities.
  repeated BgpExtendedCommunity extended_communities = 14;

  // Description missing in models
  BgpAttributesTunnelEncapsulation tunnel_encapsulation = 15;

  // Description missing in models
  BgpAttributesMpReachNlri mp_reach = 16;

  // Description missing in models
  BgpAttributesMpUnreachNlri mp_unreach = 17;
}

// One unknown attribute stored as hex bytes.
message BgpAttributesOtherAttribute {

  // Optional flag in the BGP attribute.
  // default = False
  optional bool flag_optional = 1;

  // Transitive flag in the BGP attribute.
  // default = False
  optional bool flag_transitive = 2;

  // Partial flag in the BGP attribute.
  // default = False
  optional bool flag_partial = 3;

  // Extended length flag in the BGP attribute.
  // default = False
  optional bool flag_extended_length = 4;

  // The value of the Type field in the attribute.
  // required = true
  optional uint32 type = 5;

  // Contents of the value field ( the contents after the initial two bytes containing
  // the Flags and Type field ) of the attribute in hex bytes.
  // It includes the contents of length of the extended length field if included.
  // required = true
  optional string raw_value = 6;
}

// The AS_PATH attribute identifies the autonomous systems through  which routing information
// carried in this UPDATE message has passed.
// This contains the configuration of how to include the Local AS in the AS path
// attribute of the MP REACH NLRI. It also contains optional configuration of
// additional AS Path Segments that can be included in the AS Path attribute.
// The AS Path consists of a Set or Sequence of Autonomous Systems (AS) numbers  that
// a routing information passes through to reach the destination.
// There are two modes in which AS numbers can be encoded in the AS Path Segments
// - When the AS Path is being exchanged between old and new BGP speakers or between
// two old BGP speakers , the AS numbers are encoded as 2 byte values.
// - When the AS Path is being exchanged between two new BGP speakers supporting 4 byte
// AS , the AS numbers are encoded as 4 byte values.
message BgpAttributesAsPath {

  message Choice {
    enum Enum {
      unspecified = 0;
      four_byte_as_path = 1;
      two_byte_as_path = 2;
    }
  }
  // Description missing in models
  // default = Choice.Enum.four_byte_as_path
  optional Choice.Enum choice = 1;

  // Description missing in models
  BgpAttributesAsPathFourByteAsPath four_byte_as_path = 2;

  // Description missing in models
  BgpAttributesAsPathTwoByteAsPath two_byte_as_path = 3;
}

// AS Paths with 4 byte AS numbers can be exchanged only if both BGP speakers support
// 4 byte AS number extensions.
message BgpAttributesAsPathFourByteAsPath {

  // The AS path segments containing 4 byte AS numbers to be added in the AS Path attribute.
  // By default, an empty AS path should always be included and for EBGP at minimum the
  // local AS number should be present in the AS Path.
  repeated BgpAttributesFourByteAsPathSegment segments = 1;
}

// Configuration for a single BGP AS path segment containing 4 byte AS numbers.
message BgpAttributesFourByteAsPathSegment {

  message Type {
    enum Enum {
      unspecified = 0;
      as_seq = 1;
      as_set = 2;
      as_confed_seq = 3;
      as_confed_set = 4;
    }
  }
  // AS sequence is the most common type of AS_PATH, it contains the  list
  // of ASNs starting with the most recent ASN being added read  from left
  // to right.
  // The other three AS_PATH types are used for Confederations
  // - AS_SET is the type of AS_PATH attribute that summarizes routes using
  // using the aggregate-address command, allowing AS_PATHs to be  summarized
  // in the update as well.
  // - AS_CONFED_SEQ gives the list of ASNs in the path starting with the  most
  // recent ASN to be added reading left to right
  // - AS_CONFED_SET will allow summarization of multiple AS PATHs to be  sent
  // in BGP Updates.
  // default = Type.Enum.as_seq
  optional Type.Enum type = 1;

  // The 4 byte AS numbers in this AS path segment.
  repeated uint32 as_numbers = 2;
}

// AS Paths with 2 byte AS numbers is used when any of the two scenarios occur :
// - An old BGP speaker and new BGP speaker are sending BGP Updates to one another.
// - Two old BGP speakers are sending BGP Updates to one another.
message BgpAttributesAsPathTwoByteAsPath {

  // The AS path segments containing 2 byte AS numbers to be added in the AS Path attribute.
  // By default, an empty AS path should always be included and for EBGP the sender's
  // AS number should be prepended to the AS Path.
  repeated BgpAttributesTwoByteAsPathSegment segments = 1;
}

// Configuration for a single BGP AS path segment containing 2 byte AS numbers.
message BgpAttributesTwoByteAsPathSegment {

  message Type {
    enum Enum {
      unspecified = 0;
      as_seq = 1;
      as_set = 2;
      as_confed_seq = 3;
      as_confed_set = 4;
    }
  }
  // AS sequence is the most common type of AS_PATH, it contains the  list
  // of ASNs starting with the most recent ASN being added read  from left
  // to right.
  // The other three AS_PATH types are used for Confederations
  // - AS_SET is the type of AS_PATH attribute that summarizes routes using
  // using the aggregate-address command, allowing AS_PATHs to be  summarized
  // in the update as well.
  // - AS_CONFED_SEQ gives the list of ASNs in the path starting with the  most
  // recent ASN to be added reading left to right
  // - AS_CONFED_SET will allow summarization of multiple AS PATHs to be  sent
  // in BGP Updates.
  // default = Type.Enum.as_seq
  optional Type.Enum type = 1;

  // The 2 byte AS numbers in this AS path segment.
  repeated uint32 as_numbers = 2;
}

// The AS4_PATH attribute identifies the autonomous systems through  which routing information
// carried in this UPDATE message has passed.
// This contains the configuration of how to include the Local AS in the AS path
// attribute of the MP REACH NLRI. It also contains optional configuration of
// additional AS Path Segments that can be included in the AS Path attribute.
// The AS Path consists of a Set or Sequence of Autonomous Systems (AS) numbers  that
// a routing information passes through to reach the destination.
// AS4_PATH is only exchanged in two scenarios:
// - When an old BGP speaker has to forward a received AS4_PATH containing 4 byte AS
// numbers to new BGP speaker.
// - When a new BGP speaker is connected to an old BGP speaker and has to propagate
// 4 byte AS numbers via the old BGP speaker.
// Its usage is described in RFC4893.
message BgpAttributesAs4Path {

  // The AS path segments containing 4 byte AS numbers to be added in the AS4_PATH attribute.
  repeated BgpAttributesFourByteAsPathSegment segments = 1;
}

// Optional AGGREGATOR attribute which maybe be added by a BGP speaker which performs
// route aggregation.
// When AGGREGATOR attribute is being sent to a new BGP speaker , the AS number is encoded
// as a 4 byte value.
// When AGGREGATOR attribute is being exchanged between a new and an old BGP speaker
// or between two old BGP speakers,
// the AS number is encoded as a 2 byte value.
// It contain the AS number and IP address of the speaker performing the aggregation.
// 
message BgpAttributesAggregator {

  message Choice {
    enum Enum {
      unspecified = 0;
      four_byte_as = 1;
      two_byte_as = 2;
    }
  }
  // Description missing in models
  // default = Choice.Enum.four_byte_as
  optional Choice.Enum choice = 1;

  // The value of the 4 byte  AS number of the BGP speaker which aggregated the route.
  // If the value of the AS number is less than 2 octets ( 65535 or less), the AS4_AGGREGATOR
  // object should not be sent.
  // default = 65536
  optional uint32 four_byte_as = 2;

  // The value of the 2 byte AS number of the BGP speaker which aggregated the route.
  // 
  // default = 1
  optional uint32 two_byte_as = 3;

  // The IPv4 address of the BGP speaker which aggregated the route.
  // default = 0.0.0.0
  optional string ipv4_address = 4;
}

// Optional AS4_AGGREGATOR attribute which maybe be added by a BGP speaker in one of
// two cases:
// - If it is a new BGP speaker speaking to an old BGP speaker and needs to send a 4
// byte value for the AS number of the BGP route aggregator.
// - If it is a old BGP speaker speaking to a new BGP speaker and has to transparently
// forward a received AS4_AGGREGATOR from some other peer.
// Its usage is described in RFC4893.
message BgpAttributesAs4Aggregator {

  // The value of the 4 byte AS number of the BGP speaker which aggregated the route.
  // 
  optional uint32 as_num = 1;

  // The IPv4 address of the BGP speaker which aggregated the route.
  // default = 0.0.0.0
  optional string ipv4_address = 2;
}

// The COMMUNITY attribute provide additional capability for tagging routes and for
// modifying BGP routing policy on
// upstream and downstream routers. BGP community is a 32-bit number which is broken
// into 16-bit AS number and a
// 16-bit custom value or it contains some pre-defined well known values.
// 
message BgpAttributesCommunity {

  message Choice {
    enum Enum {
      unspecified = 0;
      custom_community = 1;
      no_export = 2;
      no_advertised = 3;
      no_export_subconfed = 4;
      llgr_stale = 5;
      no_llgr = 6;
    }
  }
  // The type of community AS number.
  // required = true
  optional Choice.Enum choice = 1;

  // Description missing in models
  BgpAttributesCustomCommunity custom_community = 2;
}

// User defined COMMUNITY attribute containing 2 byte AS and custom 2 byte value defined
// by the administrator of the domain.
message BgpAttributesCustomCommunity {

  // First two octets of the community value containing a 2 byte AS number.
  // default = 0
  optional uint32 as_number = 1;

  // Last two octets of the community value in hex.  If user provides less than 4 hex
  // bytes, it should be left-padded with 0s.
  // default = 0000
  optional string custom = 2;
}

// Next hop to be sent inside MP_REACH NLRI or as the NEXT_HOP attribute if advertised
// as traditional NLRI.
message BgpAttributesNextHop {

  message Choice {
    enum Enum {
      unspecified = 0;
      ipv4 = 1;
      ipv6 = 2;
      ipv6_two_addresses = 3;
    }
  }
  // The type of the next HOP.
  // required = true
  optional Choice.Enum choice = 1;

  // The 4 byte IPv4 address of the next-hop from which the route was received.
  // default = 0.0.0.0
  optional string ipv4 = 2;

  // The 16 byte IPv6 address of the next-hop from which the route was received.
  // default = 0::0
  optional string ipv6 = 3;

  // Description missing in models
  BgpAttributesNextHopIpv6TwoAddresses ipv6_two_addresses = 4;
}

// There is a specific scenario in which it is possible to receive a Global and Link
// Local address in the Next Hop
// field in a MP_REACH attribute or in the NEXT_HOP attribute(RFC2545: Section 3).
message BgpAttributesNextHopIpv6TwoAddresses {

  // The first IPv6 next hop in the 32 byte IPv6 Next Hop.
  // default = 0::0
  optional string first = 1;

  // The second IPv6 next hop in the 32 byte IPv6 Next Hop.
  // default = 0::0
  optional string second = 2;
}

// The MP_REACH attribute is an optional attribute which can be included in the attributes
// of a BGP Update message as defined in https://datatracker.ietf.org/doc/html/rfc4760#section-3.
// The following AFI / SAFI combinations are supported:
// - IPv4 Unicast with AFI as 1 and SAFI as 1
// - IPv6 Unicast with AFI as 2 and SAFI as 1
// - Segment Routing Policy for IPv4 Unicast with AFI as 1 and SAFI as 73 ( draft-ietf-idr-sr-policy-safi-02
// Section 2.1 )
// - Segment Routing Policy for IPv6 Unicast with AFI as 2 and SAFI as 73
message BgpAttributesMpReachNlri {

  // Description missing in models
  BgpAttributesNextHop next_hop = 1;

  message Choice {
    enum Enum {
      unspecified = 0;
      ipv4_unicast = 1;
      ipv6_unicast = 2;
      ipv4_srpolicy = 3;
      ipv6_srpolicy = 4;
    }
  }
  // The AFI and SAFI to be sent in the MPREACH_NLRI in the Update.
  // required = true
  optional Choice.Enum choice = 2;

  // List of IPv4 prefixes being sent in the IPv4 Unicast MPREACH_NLRI .
  repeated BgpOneIpv4NLRIPrefix ipv4_unicast = 3;

  // List of IPv6 prefixes being sent in the IPv6 Unicast MPREACH_NLRI .
  repeated BgpOneIpv6NLRIPrefix ipv6_unicast = 4;

  // IPv4 endpoint with Segment Routing Policy being sent in the IPv4 MPREACH_NLRI .
  BgpIpv4SrPolicyNLRIPrefix ipv4_srpolicy = 5;

  // IPv6 endpoint with Segment Routing Policy being sent in the IPv6 MPREACH_NLRI .
  // 
  BgpIpv6SrPolicyNLRIPrefix ipv6_srpolicy = 6;
}

// The MP_UNREACH attribute is an optional attribute which can be included in the attributes
// of a BGP Update message as defined in https://datatracker.ietf.org/doc/html/rfc4760#section-3.
// The following AFI / SAFI combinations are supported:
// - IPv4 Unicast with AFI as 1 and SAFI as 1
// - IPv6 Unicast with AFI as 2 and SAFI as 1
// - Segment Routing Policy for IPv4 Unicast with AFI as 1 and SAFI as 73 (draft-ietf-idr-sr-policy-safi-02
// Section 2.1)
// - Segment Routing Policy for IPv6 Unicast with AFI as 2 and SAFI as 73
message BgpAttributesMpUnreachNlri {

  message Choice {
    enum Enum {
      unspecified = 0;
      ipv4_unicast = 1;
      ipv6_unicast = 2;
      ipv4_srpolicy = 3;
      ipv6_srpolicy = 4;
    }
  }
  // The AFI and SAFI to be sent in the MPUNREACH_NLRI in the Update.
  optional Choice.Enum choice = 1;

  // List of IPv4 prefixes being sent in the IPv4 Unicast MPUNREACH_NLRI .
  repeated BgpOneIpv4NLRIPrefix ipv4_unicast = 2;

  // List of IPv6 prefixes being sent in the IPv6 Unicast MPUNREACH_NLRI .
  repeated BgpOneIpv6NLRIPrefix ipv6_unicast = 3;

  // IPv4 endpoint with Segment Routing Policy being sent in the IPv4 MPUNREACH_NLRI .
  BgpIpv4SrPolicyNLRIPrefix ipv4_srpolicy = 4;

  // IPv6 endpoint with Segment Routing Policy being sent in the IPv4 MPUNREACH_NLRI .
  // 
  BgpIpv6SrPolicyNLRIPrefix ipv6_srpolicy = 5;
}

// Optional MULTI_EXIT_DISCRIMINATOR attribute sent to the peer to help in the route
// selection process.
message BgpAttributesMultiExitDiscriminator {

  // The multi exit discriminator (MED) value used for route selection sent to the peer.
  // 
  // default = 0
  optional uint32 value = 1;
}

// Optional LOCAL_PREFERENCE attribute sent to the peer to indicate the degree of preference
// 
// for externally learned routes.This should be included only for internal peers.It
// is
// used for the selection of the path for the traffic leaving the AS.The route with
// the
// highest local preference value is preferred.
message BgpAttributesLocalPreference {

  // Value to be set in the LOCAL_PREFERENCE attribute The multi exit discriminator (MED)
  // value used for route selection sent to the peer.
  // default = 100
  optional uint32 value = 1;
}

// Optional ORIGINATOR_ID attribute (type code 9) carries the Router Id of the route's
// originator in the local AS.
message BgpAttributesOriginatorId {

  // The value of the originator's Router Id.
  // default = 0.0.0.0
  optional string value = 1;
}

// The TUNNEL_ENCAPSULATION  attribute is used by a BGP speaker to inform other BGP
// speakers how to encapsulate packets that need to be sent to it.
// It is defined in RFC9012 and is assigned a Type code of 23.
message BgpAttributesTunnelEncapsulation {

  message Choice {
    enum Enum {
      unspecified = 0;
      sr_policy = 1;
    }
  }
  // Identifies a type of tunnel. The field contains values from the IANA registry BGP
  // Tunnel Encapsulation Attribute Tunnel Types.
  // default = Choice.Enum.sr_policy
  optional Choice.Enum choice = 1;

  // Description missing in models
  BgpAttributesSegmentRoutingPolicy sr_policy = 2;
}

// Optional Segment Routing Policy information as defined in draft-ietf-idr-sr-policy-safi-02.
// This information is carried in TUNNEL_ENCAPSULATION attribute with type set to  SR
// Policy (15).
message BgpAttributesSegmentRoutingPolicy {

  // Description missing in models
  BgpAttributesBsid binding_segment_identifier = 1;

  // The SRv6 Binding SID sub-TLV is an optional sub-TLV of type 20 that is used to signal
  // the SRv6 Binding SID
  // related information of an SR Policy candidate path.
  // - More than one SRv6 Binding SID sub-TLVs MAY be signaled in the same SR Policy
  // encoding to indicate one
  // or more SRv6 SIDs, each with potentially different SRv6 Endpoint Behaviors to
  // be instantiated.
  // - The format of the sub-TLV is defined in draft-ietf-idr-sr-policy-safi-02 Section
  // 2.4.3 .
  repeated BgpAttributesSrv6Bsid srv6_binding_segment_identifier = 2;

  // Description missing in models
  BgpAttributesSrPolicyPreference preference = 3;

  // Description missing in models
  BgpAttributesSrPolicyPriority priority = 4;

  // Description missing in models
  BgpAttributesSrPolicyPolicyName policy_name = 5;

  // Description missing in models
  BgpAttributesSrPolicyPolicyCandidateName policy_candidate_name = 6;

  // Description missing in models
  BgpAttributesSrPolicyExplicitNullPolicy explicit_null_label_policy = 7;

  // Description missing in models
  repeated BgpAttributesSrPolicySegmentList segment_list = 8;
}

// The Binding Segment Identifier is an optional sub-tlv of type 13 that can be sent
// with a SR Policy
// Tunnel Encapsulation attribute.
// When the active candidate path has a specified Binding Segment Identifier, the SR
// Policy uses that
// BSID if this value (label in MPLS, IPv6 address in SRv6) is available.
// - The format of the sub-TLV is defined in draft-ietf-idr-sr-policy-safi-02 Section
// 2.4.2 .
// - It is recommended that if SRv6 Binding SID is desired to be signalled, the SRv6
// Binding SID sub-TLV that enables
// the specification of the SRv6 Endpoint Behavior should be used.
message BgpAttributesBsid {

  message Choice {
    enum Enum {
      unspecified = 0;
      mpls = 1;
      srv6 = 2;
    }
  }
  // The type of Segment Identifier.
  // required = true
  optional Choice.Enum choice = 1;

  // Description missing in models
  BgpAttributesBsidMpls mpls = 2;

  // Description missing in models
  BgpAttributesBsidSrv6 srv6 = 3;
}

// When the active candidate path has a specified Binding Segment Identifier, the SR
// Policy uses that BSID defined
// as a MPLS label.The format of the sub-TLV is defined in draft-ietf-idr-sr-policy-safi-02
// Section 2.4.2 .
message BgpAttributesBsidMpls {

  // S-Flag: This flag encodes the Specified-BSID-only behavior. It's usage is
  // described in section 6.2.3 in [RFC9256].
  // default = False
  optional bool flag_specified_bsid_only = 1;

  // I-Flag: This flag encodes the Drop Upon Invalid behavior.
  // It's usage is described in section 8.2 in [RFC9256].
  // default = False
  optional bool flag_drop_upon_invalid = 2;

  // Description missing in models
  BgpAttributesSidMpls mpls_sid = 3;
}

// When the active candidate path has a specified Binding Segment Identifier, the SR
// Policy uses that BSID defined
// as an IPv6 Address.The format of the sub-TLV is defined in draft-ietf-idr-sr-policy-safi-02
// Section 2.4.2 .
message BgpAttributesBsidSrv6 {

  // S-Flag: This flag encodes the Specified-BSID-only behavior. It's usage is
  // described in section 6.2.3 in [RFC9256].
  // default = False
  optional bool flag_specified_bsid_only = 1;

  // I-Flag: This flag encodes the Drop Upon Invalid behavior.
  // It's usage is described in section 8.2 in [RFC9256].
  // default = False
  optional bool flag_drop_upon_invalid = 2;

  // IPv6 address denoting the SRv6 SID.
  // default = 0::0
  optional string ipv6_addr = 3;
}

// The SRv6 Binding SID sub-TLV is an optional sub-TLV of type 20 that is used to signal
// the SRv6 Binding SID
// related information of an SR Policy candidate path.
// - More than one SRv6 Binding SID sub-TLVs MAY be signaled in the same SR Policy
// encoding to indicate one or
// more SRv6 SIDs, each with potentially different SRv6 Endpoint Behaviors to be
// instantiated.
// - The format of the sub-TLV is defined in draft-ietf-idr-sr-policy-safi-02 Section
// 2.4.3 .
message BgpAttributesSrv6Bsid {

  // S-Flag: This flag encodes the Specified-BSID-only behavior. It's usage is
  // described in section 6.2.3 in [RFC9256].
  // default = False
  optional bool flag_specified_bsid_only = 1;

  // I-Flag: This flag encodes the Drop Upon Invalid behavior.
  // It's usage is described in section 8.2 in [RFC9256].
  // default = False
  optional bool flag_drop_upon_invalid = 2;

  // B-Flag: This flag, when set, indicates the presence of the SRv6 Endpoint Behavior
  // 
  // and SID Structure encoding specified in Section 2.4.4.2.4 of draft-ietf-idr-sr-policy-safi-02.
  // default = False
  optional bool flag_srv6_endpoint_behavior = 3;

  // IPv6 address denoting the SRv6 SID.
  // default = 0::0
  optional string ipv6_addr = 4;

  // Description missing in models
  BgpAttributesSegmentRoutingPolicySRv6SIDEndpointBehaviorAndStructure srv6_endpoint_behavior = 5;
}

// This carries a 20 bit Multi Protocol Label Switching alongwith 3 bits traffic class,
// 1 bit indicating presence
// or absence of Bottom-Of-Stack and 8 bits carrying the Time to Live value.
message BgpAttributesSidMpls {

  // 20 bit MPLS Label value.
  // default = 16
  optional uint32 label = 1;

  // 3 bits of Traffic Class.
  // default = 0
  optional uint32 traffic_class = 2;

  // Bottom of Stack
  // default = True
  optional bool flag_bos = 3;

  // 8 bits Time to Live
  // default = 63
  optional uint32 ttl = 4;
}

// An IPv6 address denoting a SRv6 SID.
message BgpAttributesSidSrv6 {

  // Description missing in models
  // default = 0::0
  optional string ip = 1;
}

// Optional Preference sub-tlv (Type 12) is used to select the best candidate path for
// an SR Policy.
// It is defined in Section 2.4.1 of draft-ietf-idr-sr-policy-safi-02 .
// 
message BgpAttributesSrPolicyPreference {

  // Value to be carried in the Preference sub-tlv.
  // default = 0
  optional uint32 value = 1;
}

// Optional Priority sub-tlv (Type 15) used to select the order in which policies should
// be re-computed.
// - It is defined in Section 2.4.6 of draft-ietf-idr-sr-policy-safi-02 .
message BgpAttributesSrPolicyPriority {

  // Value to be carried in the Priority sub-tlv.
  // default = 0
  optional uint32 value = 1;
}

// Optional Policy Candidate Path Name sub-tlv (Type 129) which carries the symbolic
// name for the SR Policy candidate path
// for debugging.
// - It is defined in Section 2.4.7 of draft-ietf-idr-sr-policy-safi-02 .
message BgpAttributesSrPolicyPolicyCandidateName {

  // Value of the symbolic Policy Candidate Path Name carried in the Policy Candidate
  // Path Name sub-tlv.
  // It is recommended that the size of the name is limited to 255 bytes.
  // required = true
  optional string value = 1;
}

// Optional Policy Name sub-tlv (Type 130) which carries the symbolic name for the SR
// Policy for which the
// candidate path is being advertised for debugging.
// - It is defined in Section 2.4.8 of draft-ietf-idr-sr-policy-safi-02 .
message BgpAttributesSrPolicyPolicyName {

  // Value of the symbolic policy name carried in the Policy Name sub-tlv.
  // It is recommended that the size of the name is limited to 255 bytes.
  // required = true
  optional string value = 1;
}

// This is an optional sub-tlv (Type 14) which indicates whether an Explicit NULL Label
// must be pushed on an unlabeled IP
// packet before other labels for IPv4 or IPv6 flows.
// - It is defined in Section 2.4.5 of draft-ietf-idr-sr-policy-safi-02.
message BgpAttributesSrPolicyExplicitNullPolicy {

  message Choice {
    enum Enum {
      unspecified = 0;
      unknown = 1;
      push_ipv4 = 2;
      push_ipv6 = 3;
      push_ipv4_and_ipv6 = 4;
      donot_push = 5;
    }
  }
  // The Explicit NULL Label policy.
  // default = Choice.Enum.push_ipv4_and_ipv6
  optional Choice.Enum choice = 1;
}

// One optional SEGMENT_LIST sub-tlv encoded with type of 128.
// One sub-tlv (Type 128) encodes a single explicit path towards the endpoint as described
// in
// section 5.1 of [RFC9256].
// The Segment List sub-TLV includes the elements of the paths (i.e., segments) as well
// 
// as an optional Weight sub-TLV.
message BgpAttributesSrPolicySegmentList {

  // Description missing in models
  BgpAttributesSegmentRoutingPolicySegmentListWeight weight = 1;

  // Description missing in models
  repeated BgpAttributesSegmentRoutingPolicySegmentListSegment segments = 2;
}

// The optional Weight sub-TLV (Type 9) specifies the weight associated with a given
// segment list. The weight is used for weighted multipath.
message BgpAttributesSegmentRoutingPolicySegmentListWeight {

  // Value of the weight.
  // default = 0
  optional uint32 value = 1;
}

// A Segment sub-TLV describes a single segment in a segment list  i.e., a single
// element of the explicit path. The Segment sub-TLVs are optional.
// Segment Types A and B are defined as described in 2.4.4.2.
// Segment Types C upto K are defined as described in in draft-ietf-idr-bgp-sr-segtypes-ext-03
// .
message BgpAttributesSegmentRoutingPolicySegmentListSegment {

  message Choice {
    enum Enum {
      unspecified = 0;
      type_a = 1;
      type_b = 2;
      type_c = 3;
      type_d = 4;
      type_e = 5;
      type_f = 6;
      type_g = 7;
      type_h = 8;
      type_i = 9;
      type_j = 10;
      type_k = 11;
    }
  }
  // Specify one of the segment types as defined in ietf-idr-segment-routing-te-policy
  // - Type  A: SID only, in the form of MPLS Label.
  // - Type  B: SID only, in the form of IPv6 Address.
  // - Type  C: IPv4 Prefix with optional SR Algorithm.
  // - Type  D: IPv6 Global Prefix with optional SR Algorithm for SR-MPLS.
  // - Type  E: IPv4 Prefix with Local Interface ID.
  // - Type  F: IPv4 Addresses for link endpoints as Local, Remote pair.
  // - Type  G: IPv6 Prefix and Interface ID for link endpoints as Local, Remote pair
  // for SR-MPLS.
  // - Type  H: IPv6 Addresses for link endpoints as Local, Remote pair for SR-MPLS.
  // - Type  I: IPv6 Global Prefix with optional SR Algorithm for SRv6.
  // - Type  J: IPv6 Prefix and Interface ID for link endpoints as Local, Remote pair
  // for SRv6.
  // - Type  K: IPv6 Addresses for link endpoints as Local, Remote pair for SRv6.
  // required = true
  optional Choice.Enum choice = 1;

  // Description missing in models
  BgpAttributesSegmentRoutingPolicyTypeA type_a = 2;

  // Description missing in models
  BgpAttributesSegmentRoutingPolicyTypeB type_b = 3;

  // Description missing in models
  BgpAttributesSegmentRoutingPolicyTypeC type_c = 4;

  // Description missing in models
  BgpAttributesSegmentRoutingPolicyTypeD type_d = 5;

  // Description missing in models
  BgpAttributesSegmentRoutingPolicyTypeE type_e = 6;

  // Description missing in models
  BgpAttributesSegmentRoutingPolicyTypeF type_f = 7;

  // Description missing in models
  BgpAttributesSegmentRoutingPolicyTypeG type_g = 8;

  // Description missing in models
  BgpAttributesSegmentRoutingPolicyTypeH type_h = 9;

  // Description missing in models
  BgpAttributesSegmentRoutingPolicyTypeI type_i = 10;

  // Description missing in models
  BgpAttributesSegmentRoutingPolicyTypeJ type_j = 11;

  // Description missing in models
  BgpAttributesSegmentRoutingPolicyTypeK type_k = 12;
}

// Type A: SID only, in the form of MPLS Label.
// It is encoded as a Segment of Type 1 in the SEGMENT_LIST sub-tlv.
message BgpAttributesSegmentRoutingPolicyTypeA {

  // Description missing in models
  BgpAttributesSegmentRoutingPolicyTypeFlags flags = 1;

  // Description missing in models
  BgpAttributesSidMpls mpls_sid = 2;
}

// Type B: SID only, in the form of IPv6 address.
// It is encoded as a Segment of Type 13 in the SEGMENT_LIST sub-tlv.
message BgpAttributesSegmentRoutingPolicyTypeB {

  // Description missing in models
  BgpAttributesSegmentRoutingPolicyTypeFlags flags = 1;

  // SRv6 SID.
  // default = 0::0
  optional string srv6_sid = 2;

  // Description missing in models
  BgpAttributesSegmentRoutingPolicySRv6SIDEndpointBehaviorAndStructure srv6_endpoint_behavior = 3;
}

// Type C: IPv4 Node Address with optional SID.
// It is encoded as a Segment of Type 3 in the SEGMENT_LIST sub-tlv.
message BgpAttributesSegmentRoutingPolicyTypeC {

  // Description missing in models
  BgpAttributesSegmentRoutingPolicyTypeFlags flags = 1;

  // SR Algorithm identifier when A-Flag in on. If A-flag is not enabled, it should be
  // set to 0 on transmission and ignored on receipt.
  // default = 0
  optional uint32 sr_algorithm = 2;

  // IPv4 address representing a node.
  // default = 0.0.0.0
  optional string ipv4_node_address = 3;

  // Optional SR-MPLS SID.
  BgpAttributesSidMpls sr_mpls_sid = 4;
}

// Type D: IPv6 Node Address with optional SID for SR MPLS.
// It is encoded as a Segment of Type 4 in the SEGMENT_LIST sub-tlv.
message BgpAttributesSegmentRoutingPolicyTypeD {

  // Description missing in models
  BgpAttributesSegmentRoutingPolicyTypeFlags flags = 1;

  // SR Algorithm identifier when A-Flag in on. If A-flag is not enabled, it should be
  // set to 0 on transmission and ignored on receipt.
  // default = 0
  optional uint32 sr_algorithm = 2;

  // IPv6 address representing a node.
  // default = 0::0
  optional string ipv6_node_address = 3;

  // Optional SR-MPLS SID.
  BgpAttributesSidMpls sr_mpls_sid = 4;
}

// Type E: IPv4 Address and Local Interface ID with optional SID
// It is encoded as a Segment of Type 5 in the SEGMENT_LIST sub-tlv.
message BgpAttributesSegmentRoutingPolicyTypeE {

  // Description missing in models
  BgpAttributesSegmentRoutingPolicyTypeFlags flags = 1;

  // The Interface Index as defined in [RFC8664].
  // default = 0
  optional uint32 local_interface_id = 2;

  // IPv4 address representing a node.
  // default = 0.0.0.0
  optional string ipv4_node_address = 3;

  // Optional SR-MPLS SID.
  BgpAttributesSidMpls sr_mpls_sid = 4;
}

// Type F: IPv4 Local and Remote addresses with optional SR-MPLS SID.
// It is encoded as a Segment of Type 6 in the SEGMENT_LIST sub-tlv.
message BgpAttributesSegmentRoutingPolicyTypeF {

  // Description missing in models
  BgpAttributesSegmentRoutingPolicyTypeFlags flags = 1;

  // Local IPv4 Address.
  // default = 0.0.0.0
  optional string local_ipv4_address = 2;

  // Remote IPv4 Address.
  // default = 0.0.0.0
  optional string remote_ipv4_address = 3;

  // Optional SR-MPLS SID.
  BgpAttributesSidMpls sr_mpls_sid = 4;
}

// Type G: IPv6 Address, Interface ID for local and remote pair with optional SID for
// SR MPLS.
// It is encoded as a Segment of Type 7 in the SEGMENT_LIST sub-tlv.
message BgpAttributesSegmentRoutingPolicyTypeG {

  // Description missing in models
  BgpAttributesSegmentRoutingPolicyTypeFlags flags = 1;

  // The local Interface Index as defined in [RFC8664].
  // default = 0
  optional uint32 local_interface_id = 2;

  // The IPv6 address representing the local node.
  // default = 0::0
  optional string local_ipv6_node_address = 3;

  // The remote Interface Index as defined in [RFC8664]. The value MAY be set to zero
  // when the local node address and interface identifiers are sufficient to describe
  // the link.
  // default = 0
  optional uint32 remote_interface_id = 4;

  // IPv6 address representing the remote node. The value MAY be set to zero when the
  // local node address and interface identifiers are sufficient to describe the link.
  // default = 0::0
  optional string remote_ipv6_node_address = 5;

  // Optional SR-MPLS SID.
  BgpAttributesSidMpls sr_mpls_sid = 6;
}

// Type H: IPv6 Local and Remote addresses with optional SID for SR MPLS.
// It is encoded as a Segment of Type 8 in the SEGMENT_LIST sub-tlv.
message BgpAttributesSegmentRoutingPolicyTypeH {

  // Description missing in models
  BgpAttributesSegmentRoutingPolicyTypeFlags flags = 1;

  // Local IPv6 Address.
  // default = 0::0
  optional string local_ipv6_address = 2;

  // Remote IPv6 Address.
  // default = 0::0
  optional string remote_ipv6_address = 3;

  // Optional SR-MPLS SID.
  BgpAttributesSidMpls sr_mpls_sid = 6;
}

// Type I: IPv6 Node Address with optional SR Algorithm and optional SRv6 SID.
// It is encoded as a Segment of Type 14 in the SEGMENT_LIST sub-tlv.
message BgpAttributesSegmentRoutingPolicyTypeI {

  // Description missing in models
  BgpAttributesSegmentRoutingPolicyTypeFlags flags = 1;

  // SR Algorithm identifier when A-Flag in on. If A-flag is not enabled, it should be
  // set to 0 on transmission and ignored on receipt.
  // default = 0
  optional uint32 sr_algorithm = 2;

  // IPv6 address representing a node.
  // default = 0::0
  optional string ipv6_node_address = 3;

  // Description missing in models
  BgpAttributesSidSrv6 srv6_sid = 4;

  // Description missing in models
  BgpAttributesSegmentRoutingPolicySRv6SIDEndpointBehaviorAndStructure srv6_endpoint_behavior = 5;
}

// Type J: IPv6 Address, Interface ID for local and remote pair for SRv6 with optional
// SID.
// It is encoded as a Segment of Type 15 in the SEGMENT_LIST sub-tlv.
message BgpAttributesSegmentRoutingPolicyTypeJ {

  // Description missing in models
  BgpAttributesSegmentRoutingPolicyTypeFlags flags = 1;

  // SR Algorithm identifier when A-Flag in on. If A-flag is not enabled, it should be
  // set to 0 on transmission and ignored on receipt.
  // default = 0
  optional uint32 sr_algorithm = 2;

  // The local Interface Index as defined in [RFC8664].
  // default = 0
  optional uint32 local_interface_id = 3;

  // The IPv6 address representing the local node.
  // default = 0::0
  optional string local_ipv6_node_address = 4;

  // The remote Interface Index as defined in [RFC8664]. The value MAY be set to zero
  // when the local node address and interface identifiers are sufficient to describe
  // the link.
  // default = 0
  optional uint32 remote_interface_id = 5;

  // IPv6 address representing the remote node. The value MAY be set to zero when the
  // local node address and interface identifiers are sufficient to describe the link.
  // default = 0::0
  optional string remote_ipv6_node_address = 6;

  // Description missing in models
  BgpAttributesSidSrv6 srv6_sid = 7;

  // Description missing in models
  BgpAttributesSegmentRoutingPolicySRv6SIDEndpointBehaviorAndStructure srv6_endpoint_behavior = 8;
}

// Type K: IPv6 Local and Remote addresses for SRv6 with optional SID.
// It is encoded as a Segment of Type 16 in the SEGMENT_LIST sub-tlv.
message BgpAttributesSegmentRoutingPolicyTypeK {

  // Description missing in models
  BgpAttributesSegmentRoutingPolicyTypeFlags flags = 1;

  // SR Algorithm identifier when A-Flag in on. If A-flag is not enabled, it should be
  // set to 0 on transmission and ignored on receipt.
  // default = 0
  optional uint32 sr_algorithm = 2;

  // Local IPv6 Address.
  // default = 0::0
  optional string local_ipv6_address = 3;

  // Remote IPv6 Address.
  // default = 0::0
  optional string remote_ipv6_address = 4;

  // Description missing in models
  BgpAttributesSidSrv6 srv6_sid = 5;

  // Description missing in models
  BgpAttributesSegmentRoutingPolicySRv6SIDEndpointBehaviorAndStructure srv6_endpoint_behavior = 6;
}

// Flags for each Segment in SEGMENT_LIST sub-tlv.
// - V-flag. Indicates verification is enabled. See section 5, of https://datatracker.ietf.org/doc/html/rfc9256
// - A-flag. Indicates presence of SR Algorithm field applicable to Segment Types C,
// D , I , J and K .
// - B-Flag. Indicates presence of SRv6 Endpoint Behavior and SID Structure encoding
// applicable to Segment Types B , I , J and K .
// - S-Flag: This flag, when set, indicates the presence of the SR-MPLS or SRv6 SID
// depending on the segment type. (draft-ietf-idr-bgp-sr-segtypes-ext-03 Section 2.10).
// This flag is applicable for Segment Types C, D, E, F, G, H, I, J, and K.
message BgpAttributesSegmentRoutingPolicyTypeFlags {

  // Indicates verification of segment data in is enabled.
  // default = False
  optional bool v_flag = 1;

  // Indicates presence of SR Algorithm field applicable to Segment Types 3, 4, and 9.
  // 
  // default = False
  optional bool a_flag = 2;

  // This flag, when set, indicates the presence of the SR-MPLS or SRv6 SID depending
  // on the segment type.
  // default = False
  optional bool s_flag = 3;

  // Indicates presence of SRv6 Endpoint Behavior and SID Structure encoding specified
  // in Section 2.4.4.2.4
  // of draft-ietf-idr-sr-policy-safi-02.
  // default = False
  optional bool b_flag = 4;
}

// Configuration for optional SRv6 Endpoint Behavior and SID Structure. Summation of
// lengths for Locator Block, Locator Node,  Function, and Argument MUST be less than
// or equal to 128. - This is specified in draft-ietf-idr-sr-policy-safi-02 Section
// 2.4.4.2.4
message BgpAttributesSegmentRoutingPolicySRv6SIDEndpointBehaviorAndStructure {

  // This is a 2-octet field that is used to specify the SRv6 Endpoint Behavior code point
  // for the SRv6 SID as defined
  // in section 9.2 of [RFC8986]. When set with the value 0xFFFF (i.e., Opaque), the choice
  // of SRv6 Endpoint Behavior is
  // left to the headend. Well known 16-bit values for this field are available at
  // https://www.iana.org/assignments/segment-routing/segment-routing.xhtml .
  // default = ffff
  optional string endpoint_behaviour = 1;

  // SRv6 SID Locator Block length in bits.
  // default = 0
  optional uint32 lb_length = 2;

  // SRv6 SID Locator Node length in bits.
  // default = 0
  optional uint32 ln_length = 3;

  // SRv6 SID Function length in bits.
  // default = 0
  optional uint32 func_length = 4;

  // SRv6 SID Arguments length in bits.
  // default = 0
  optional uint32 arg_length = 5;
}

// Optional field in the NLRI carrying the distinguisher for Segment Routing Policy
// NLRI with SAFI 73.
message BgpNLRIPrefixSegmentRoutingDistinguisher {

  // The value of the optional Segment Routing distinguisher of the prefix.
  // default = 1
  optional uint32 value = 1;
}

// Configuration for BGPv6 peer settings and routes.
message BgpV6Peer {

  // IPv6 address of the BGP peer for the session
  // required = true
  optional string peer_address = 1;

  // Description missing in models
  BgpV6SegmentRouting segment_routing = 2;

  // This contains the list of Ethernet Virtual Private Network (EVPN) Ethernet Segments
  // (ES) Per BGP Peer for IPv6 Address Family Identifier (AFI).
  // 
  // Each Ethernet Segment contains a list of EVPN Instances (EVIs) .
  // Each EVI contains a list of Broadcast Domains.
  // Each Broadcast Domain contains a list of MAC/IP Ranges.
  // 
  // <Ethernet Segment, EVI, Broadcast Domain> is responsible for advertising Ethernet
  // Auto-discovery Route Per EVI (Type 1).
  // 
  // <Ethernet Segment, EVI> is responsible for advertising Ethernet Auto-discovery Route
  // Per Ethernet Segment (Type 1).
  // 
  // <Ethernet Segment, EVI, Broadcast Domain, MAC/IP> is responsible for advertising
  // MAC/IP Advertisement Route (Type 2).
  // 
  // <Ethernet Segment, EVI, Broadcast Domain> is responsible for advertising Inclusive
  // Multicast Ethernet Tag Route (Type 3).
  // 
  // Ethernet Segment is responsible for advertising Ethernet Segment Route (Type 4).
  repeated BgpV6EthernetSegment evpn_ethernet_segments = 3;

  message AsType {
    enum Enum {
      unspecified = 0;
      ibgp = 1;
      ebgp = 2;
    }
  }
  // The type of BGP autonomous system. External BGP is used for BGP links between two
  // or more autonomous systems (ebgp). Internal BGP is used within a single autonomous
  // system (ibgp). BGP property defaults are aligned with this object defined as an internal
  // BGP peer. If the as_type is specified as 'ebgp' then other properties will need to
  // be specified as per an external BGP peer. Specifically, for 'ebgp',  'as_set_mode'
  // attribute in 'as_path' field  in any Route Range should be changed from default value
  // 'do_not_include_local_as' to any other value.
  // required = true
  optional AsType.Enum as_type = 4;

  // Autonomous System Number (AS number or ASN)
  // required = true
  optional uint32 as_number = 5;

  message AsNumberWidth {
    enum Enum {
      unspecified = 0;
      two = 1;
      four = 2;
    }
  }
  // The width in bytes of the as_number values. Any as_number values that exceeds the
  // width MUST result in an error.
  // default = AsNumberWidth.Enum.four
  optional AsNumberWidth.Enum as_number_width = 6;

  // Description missing in models
  BgpAdvanced advanced = 7;

  // Description missing in models
  BgpCapability capability = 8;

  // Description missing in models
  BgpLearnedInformationFilter learned_information_filter = 9;

  // Emulated BGPv4 route ranges.
  repeated BgpV4RouteRange v4_routes = 10;

  // Emulated BGPv6 route ranges.
  repeated BgpV6RouteRange v6_routes = 11;

  // Segment Routing Traffic Engineering (SR TE) Policies for IPv4 Address Family Identifier
  // (AFI).
  repeated BgpSrteV4Policy v4_srte_policies = 12;

  // Segment Routing Traffic Engineering (SR TE) Policies for IPv6 Address Family Identifier
  // (AFI).
  repeated BgpSrteV6Policy v6_srte_policies = 13;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  optional string name = 14;

  // Description missing in models
  BgpGracefulRestart graceful_restart = 15;

  // BGP Updates to be sent to the peer as specified after the session is established.
  // 
  BgpUpdateReplay replay_updates = 16;
}

// Configuration for emulated BGPv6 peers and routes on a single IPv6 interface.
message BgpV6Interface {

  // The unique name of IPv6 Loopback IPv6 interface or DHCPv4 client used as the source
  // IP for this list of BGP peers.
  // 
  // x-constraint:
  // - /components/schemas/Device.Ipv6/properties/name
  // - /components/schemas/Device.Ipv6Loopback/properties/name
  // - /components/schemas/Device.Dhcpv6client/properties/name
  // 
  // required = true
  optional string ipv6_name = 1;

  // This contains the list of BGPv6 peers configured on this interface.
  repeated BgpV6Peer peers = 2;
}

// Configuration for BGPv6 segment routing settings.
message BgpV6SegmentRouting {

  // TBD
  // default = False
  optional bool ingress_supports_vpn = 1;

  // TBD
  // default = False
  optional bool reduced_encapsulation = 2;

  // TBD
  // default = False
  optional bool copy_time_to_live = 3;

  // TBD
  // default = 0
  optional uint32 time_to_live = 4;

  // TBD
  // default = 0
  optional uint32 max_sids_per_srh = 5;

  // TBD
  // default = False
  optional bool auto_generate_segment_left_value = 6;

  // TBD
  // default = 0
  optional uint32 segment_left_value = 7;

  // TBD
  // default = False
  optional bool advertise_sr_te_policy = 8;
}

// Configuration for BGP Ethernet Segment ranges. Advertises following routes -
// 
// Type 4 - Ethernet Segment Route
message BgpV6EthernetSegment {

  // Designated Forwarder (DF) election configuration.
  BgpEthernetSegmentDfElection df_election = 1;

  // This contains the list of EVIs.
  repeated BgpV6EvpnEvis evis = 2;

  // 10-octet Ethernet Segment Identifier (ESI) Example - For multi-home scenario nonZero
  // ESI is '10000000000000000000' .
  // default = 00000000000000000000
  optional string esi = 3;

  message ActiveMode {
    enum Enum {
      unspecified = 0;
      single_active = 1;
      all_active = 2;
    }
  }
  // Single Active or All Active mode Redundancy mode selection for Multi-home.
  // default = ActiveMode.Enum.all_active
  optional ActiveMode.Enum active_mode = 4;

  // The label value to be advertised as ESI Label in ESI Label Extended Community. This
  // is included in Ethernet Auto-discovery per ES Routes advertised by a router.
  // default = 0
  optional uint32 esi_label = 5;

  // Description missing in models
  BgpRouteAdvanced advanced = 6;

  // Optional community settings.
  repeated BgpCommunity communities = 7;

  // Optional Extended Community settings. The Extended Communities Attribute is a transitive
  // optional BGP attribute, with the Type Code 16. Community and Extended Communities
  // attributes are utilized to trigger routing decisions, such as acceptance, rejection,
  // preference, or redistribution. An extended community is an 8-Bytes value. It is
  // divided into two main parts. The first 2 Bytes of the community encode a type and
  // sub-type fields and the last 6 Bytes carry a unique set of data in a format defined
  // by the type and sub-type field. Extended communities provide a larger  range for
  // grouping or categorizing communities. When type is administrator_as_2octet or administrator_as_4octet,
  // the valid sub types are route target and origin. The valid value for  administrator_as_2octet
  // and administrator_as_4octet type is either two byte AS followed by four byte local
  // administrator id or four byte AS followed by two  byte local administrator id.  When
  // type is administrator_ipv4_address the valid sub types are route target and origin.
  // The valid value for  administrator_ipv4_address is a four byte IPv4 address followed
  // by a two byte local administrator id.  When type is opaque, valid sub types are color
  // and encapsulation. When sub type is color, first two bytes of the value field contain
  // flags and last four bytes  contains the value of the color. When sub type is encapsulation
  // the first four bytes of value field are reserved and last two bytes carries the tunnel
  // type from  IANA's ETHER TYPES registry e.g IPv4 (protocol type = 0x0800), IPv6 (protocol
  // type = 0x86dd), and MPLS (protocol type = 0x8847). When type is administrator_as_2octet_link_bandwidth
  // the valid sub type is extended_bandwidth. The first two bytes of the value field
  // contains the AS number and the last four bytes contains the bandwidth in IEEE floating
  // point format.  When type is evpn the valid subtype is mac_address. In the value field
  // the low-order bit of the first byte(Flags) is defined as the Sticky/static flag and
  // may be set to 1, indicating the MAC address is static and cannot move. The second
  // byte is reserved and the  last four bytes contain the sequence number which is used
  // to ensure that PEs retain the correct MAC/IP Advertisement route when multiple updates
  // occur for the same MAC address.
  repeated BgpExtCommunity ext_communities = 8;

  // Optional AS PATH settings.
  BgpAsPath as_path = 9;
}

// This contains a list of different flavors of EVPN.
// For example EVPN over VXLAN or EVPN over MPLS etc to be configured per Ethernet segment.
// 
// Need to instantiate correct type of EVPN instance as per requirement.
message BgpV6EvpnEvis {

  message Choice {
    enum Enum {
      unspecified = 0;
      evi_vxlan = 1;
    }
  }
  // Description missing in models
  // default = Choice.Enum.evi_vxlan
  optional Choice.Enum choice = 1;

  // EVPN VXLAN instance to be configured per Ethernet Segment.
  BgpV6EviVxlan evi_vxlan = 2;
}

// Configuration for BGP EVPN EVI. Advertises following routes -
// 
// Type 3 - Inclusive Multicast Ethernet Tag Route
// 
// Type 1 -  Ethernet Auto-discovery Route (Per EVI)
// 
// Type 1 -  Ethernet Auto-discovery Route (Per ES)
message BgpV6EviVxlan {

  // This contains the list of Broadcast Domains to be configured per EVI.
  repeated BgpV6EviVxlanBroadcastDomain broadcast_domains = 1;

  message ReplicationType {
    enum Enum {
      unspecified = 0;
      ingress_replication = 1;
    }
  }
  // This model only supports Ingress Replication
  // default = ReplicationType.Enum.ingress_replication
  optional ReplicationType.Enum replication_type = 2;

  // Downstream assigned VNI to be carried as Part of P-Multicast Service Interface Tunnel
  // attribute (PMSI Tunnel Attribute) in Type 3 Inclusive Multicast Ethernet Tag Route.
  // default = 16
  optional uint32 pmsi_label = 3;

  // The Auto-discovery Route label (AD label) value, which gets advertised in the Ethernet
  // Auto-discovery Route per <EVI, ESI>
  // default = 0
  optional uint32 ad_label = 4;

  // Colon separated Extended Community value of 6 Bytes - AS number: Value identifying
  // an EVI.            Example - for the as_2octet 60005:100.
  BgpRouteDistinguisher route_distinguisher = 5;

  // List of Layer 2 Virtual Network Identifier (L2VNI) export targets associated with
  // this EVI.
  repeated BgpRouteTarget route_target_export = 6;

  // List of L2VNI import targets associated with this EVI.
  repeated BgpRouteTarget route_target_import = 7;

  // List of Layer 3 Virtual Network Identifier (L3VNI) Export Route Targets.
  repeated BgpRouteTarget l3_route_target_export = 8;

  // List of L3VNI Import Route Targets.
  repeated BgpRouteTarget l3_route_target_import = 9;

  // Description missing in models
  BgpRouteAdvanced advanced = 10;

  // Optional community settings.
  repeated BgpCommunity communities = 11;

  // Optional Extended Community settings. The Extended Communities Attribute is a transitive
  // optional BGP attribute, with the Type Code 16. Community and Extended Communities
  // attributes are utilized to trigger routing decisions, such as acceptance, rejection,
  // preference, or redistribution. An extended community is an 8-Bytes value. It is
  // divided into two main parts. The first 2 Bytes of the community encode a type and
  // sub-type fields and the last 6 Bytes carry a unique set of data in a format defined
  // by the type and sub-type field. Extended communities provide a larger  range for
  // grouping or categorizing communities. When type is administrator_as_2octet or administrator_as_4octet,
  // the valid sub types are route target and origin. The valid value for  administrator_as_2octet
  // and administrator_as_4octet type is either two byte AS followed by four byte local
  // administrator id or four byte AS followed by two  byte local administrator id.  When
  // type is administrator_ipv4_address the valid sub types are route target and origin.
  // The valid value for  administrator_ipv4_address is a four byte IPv4 address followed
  // by a two byte local administrator id.  When type is opaque, valid sub types are color
  // and encapsulation. When sub type is color, first two bytes of the value field contain
  // flags and last four bytes  contains the value of the color. When sub type is encapsulation
  // the first four bytes of value field are reserved and last two bytes carries the tunnel
  // type from  IANA's ETHER TYPES registry e.g IPv4 (protocol type = 0x0800), IPv6 (protocol
  // type = 0x86dd), and MPLS (protocol type = 0x8847). When type is administrator_as_2octet_link_bandwidth
  // the valid sub type is extended_bandwidth. The first two bytes of the value field
  // contains the AS number and the last four bytes contains the bandwidth in IEEE floating
  // point format.  When type is evpn the valid subtype is mac_address. In the value field
  // the low-order bit of the first byte(Flags) is defined as the Sticky/static flag and
  // may be set to 1, indicating the MAC address is static and cannot move. The second
  // byte is reserved and the  last four bytes contain the sequence number which is used
  // to ensure that PEs retain the correct MAC/IP Advertisement route when multiple updates
  // occur for the same MAC address.
  repeated BgpExtCommunity ext_communities = 12;

  // Optional AS PATH settings.
  BgpAsPath as_path = 13;
}

// Configuration for Broadcast Domains per EVI.
message BgpV6EviVxlanBroadcastDomain {

  // This contains the list of Customer MAC/IP Ranges to be configured per Broadcast Domain.
  // 
  // 
  // Advertises following route -
  // Type 2 - MAC/IP Advertisement Route.
  repeated BgpCMacIpRange cmac_ip_range = 1;

  // The Ethernet Tag ID of the Broadcast Domain.
  // default = 0
  optional uint32 ethernet_tag_id = 2;

  // VLAN-Aware service to be enabled or disabled.
  // default = False
  optional bool vlan_aware_service = 3;
}

// Description missing in models
message DeviceVxlan {

  // IPv4 VXLAN Tunnels
  repeated VxlanV4Tunnel v4_tunnels = 1;

  // IPv6 VXLAN Tunnels
  repeated VxlanV6Tunnel v6_tunnels = 2;
}

// Configuration and operational state parameters relating to IPv4 VXLAN tunnel end-point
// interface.
message VxlanV4Tunnel {

  // Determines the source interface.
  // 
  // x-constraint:
  // - /components/schemas/Device.Ipv4/properties/name
  // - /components/schemas/Device.Ipv4Loopback/properties/name
  // 
  // required = true
  optional string source_interface = 1;

  // Description missing in models
  VxlanV4TunnelDestinationIPMode destination_ip_mode = 2;

  // VXLAN Network Identifier (VNI) to distinguish network instances on the wire
  // required = true
  optional uint32 vni = 3;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  optional string name = 4;
}

// Configuration and operational state parameters relating to IPv6 VXLAN tunnel end-point
// interface.
message VxlanV6Tunnel {

  // Determines the source interface.
  // 
  // x-constraint:
  // - /components/schemas/Device.Ipv6/properties/name
  // - /components/schemas/Device.Ipv6Loopback/properties/name
  // 
  // required = true
  optional string source_interface = 1;

  // Description missing in models
  VxlanV6TunnelDestinationIPMode destination_ip_mode = 2;

  // VXLAN Network Identifier (VNI) to distinguish network instances on the wire
  // required = true
  optional uint32 vni = 3;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  optional string name = 4;
}

// Communication mode between the VTEPs, either unicast or multicast.
message VxlanV4TunnelDestinationIPMode {

  message Choice {
    enum Enum {
      unspecified = 0;
      unicast = 1;
      multicast = 2;
    }
  }
  // unicast or multicast
  // default = Choice.Enum.multicast
  optional Choice.Enum choice = 1;

  // Description missing in models
  VxlanV4TunnelDestinationIPModeUnicast unicast = 2;

  // Description missing in models
  VxlanV4TunnelDestinationIPModeMulticast multicast = 3;
}

// Communication mode between the VTEPs, either unicast or multicast.
message VxlanV6TunnelDestinationIPMode {

  message Choice {
    enum Enum {
      unspecified = 0;
      unicast = 1;
      multicast = 2;
    }
  }
  // unicast or multicast
  // default = Choice.Enum.multicast
  optional Choice.Enum choice = 1;

  // Description missing in models
  VxlanV6TunnelDestinationIPModeUnicast unicast = 2;

  // Description missing in models
  VxlanV6TunnelDestinationIPModeMulticast multicast = 3;
}

// Description missing in models
message VxlanV4TunnelDestinationIPModeUnicast {

  // List of VTEPs for member VNI(VXLAN Network Identifier)
  repeated VxlanV4TunnelDestinationIPModeUnicastVtep vteps = 1;
}

// Description missing in models
message VxlanV6TunnelDestinationIPModeUnicast {

  // List of VTEPs for member VNI(VXLAN Network Identifier)
  repeated VxlanV6TunnelDestinationIPModeUnicastVtep vteps = 1;
}

// Each VTEP maintains an ARP suppression cache table for known IP hosts and their associated
// MAC addresses in the VNI segment.  When an end host in the VNI sends an ARP request
// for another end-host IP address,  its local VTEP intercepts the ARP request and checks
// for the ARP-resolved IP address in its ARP suppression cache table.  If it finds
// a match, the local VTEP sends an ARP response on behalf of the remote end host.
message VxlanTunnelDestinationIPModeUnicastArpSuppressionCache {

  // Remote VM MAC address bound to Remote VM IPv4 address
  optional string remote_vm_mac = 1;

  // Remote VM IPv4 address
  optional string remote_vm_ipv4 = 2;
}

// VTEP (VXLAN Tunnel End Point (VTEP)) parameters
message VxlanV4TunnelDestinationIPModeUnicastVtep {

  // Remote VXLAN Tunnel End Point address
  optional string remote_vtep_address = 1;

  // Each VTEP maintains an ARP suppression cache table for known IP hosts and their associated
  // MAC addresses in the VNI segment.  When an end host in the VNI sends an ARP request
  // for another end-host IP address,  its local VTEP intercepts the ARP request and checks
  // for the ARP-resolved IP address in its ARP suppression cache table.  If it finds
  // a match, the local VTEP sends an ARP response on behalf of the remote end host.
  repeated VxlanTunnelDestinationIPModeUnicastArpSuppressionCache arp_suppression_cache = 2;
}

// VTEP (VXLAN Tunnel End Point (VTEP)) parameters
message VxlanV6TunnelDestinationIPModeUnicastVtep {

  // Remote VXLAN Tunnel End Point address
  optional string remote_vtep_address = 1;

  // Each VTEP maintains an ARP suppression cache table for known IP hosts and their associated
  // MAC addresses in the VNI segment.  When an end host in the VNI sends an ARP request
  // for another end-host IP address,  its local VTEP intercepts the ARP request and checks
  // for the ARP-resolved IP address in its ARP suppression cache table.  If it finds
  // a match, the local VTEP sends an ARP response on behalf of the remote end host.
  repeated VxlanTunnelDestinationIPModeUnicastArpSuppressionCache arp_suppression_cache = 2;
}

// Multicast Group address for member VNI(VXLAN Network Identifier)
message VxlanV4TunnelDestinationIPModeMulticast {

  // IPv4 Multicast address
  optional string address = 1;
}

// Multicast Group address for member VNI(VXLAN Network Identifier)
message VxlanV6TunnelDestinationIPModeMulticast {

  // IPv6 Multicast address
  optional string address = 1;
}

// Configuration for one or more RSVP interfaces, ingress and egress LSPs. In this model,
// currently IPv4 RSVP and point-to-point LSPs are supported as per RFC3209 and related
// specifications.
message DeviceRsvp {

  // List of IPv4 RSVP connected interfaces. At least one interface should be present
  // for device connected to the DUT. For unconnected devices, this array must be empty.
  repeated RsvpIpv4Interface ipv4_interfaces = 1;

  // List of IPv4 Loopback or IPv4 connected interfaces acting as RSVP ingress and egress
  // endpoints.
  repeated RsvpLspIpv4Interface lsp_ipv4_interfaces = 2;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  optional string name = 3;
}

// Configuration for RSVP Interface.
message RsvpIpv4Interface {

  // The globally unique name of the IPv4 interface connected to the DUT. This name must
  // match the name field of the ipv4_addresses on top which this RSVP interface is configured.
  // 
  // 
  // x-constraint:
  // - /components/schemas/Device.Ipv4/properties/name
  // 
  // required = true
  optional string ipv4_name = 1;

  // IPv4 address of the RSVP neighbor on this interface.
  // required = true
  optional string neighbor_ip = 2;

  // The user-defined label space start value. The LSPs for which this router acts as
  // a egress are assigned labels from this label pool.Thelabel_space_start and label_space_end
  // together defines this label-pool.
  // default = 1000
  optional uint32 label_space_start = 3;

  // The user-defined label space end value.The last label value that can be assigned
  // to the LSPs for which this router acts as egress.
  // default = 100000
  optional uint32 label_space_end = 4;

  // Enables sending of Refresh Reduction as described in RFC2961.
  // default = False
  optional bool enable_refresh_reduction = 5;

  // The number of seconds between transmissions of successive Summary Refreshes. There
  // is no specification specified maximum value. For clarity, setting the maximum to
  // 1 hour.
  // default = 30
  optional uint32 summary_refresh_interval = 6;

  // Enables aggregration of different RSVP messages within a single PDU.
  // default = False
  optional bool send_bundle = 7;

  // The number of milliseconds to wait after which RSVP will bundle different RSVP messages
  // and transmit Bundle messages.
  // default = 50
  optional uint32 bundle_threshold = 8;

  // Enables sending of Hello Messages as per RFC3209.
  // default = False
  optional bool enable_hello = 9;

  // If enable_hello is set to 'true', this specifies the minimum hello interval in seconds
  // at which successive Hello Messages  are sent as per RFC3209. There is no specification
  // specified maximum value. For clarity, setting the maximum to 1 hour.
  // default = 9
  optional uint32 hello_interval = 10;

  // The number of missed hellos after which the node should consider RSVP Neighbor to
  // have timed out. There is no specification specified maximum value. Setting the maximum
  // allowed value to 10.
  // default = 3
  optional uint32 timeout_multiplier = 11;
}

// Configuration for RSVP LSP IPv4 Interface.
message RsvpLspIpv4Interface {

  // The globally unique name of the IPv4 or Loopback IPv4 interface acting as the RSVP
  // ingress and egress endpoint for  the LSPs configured on this interface. This must
  // match the name field of either ipv4_addresses or ipv4_loopbacks  on which this LSP
  // interface is configured.
  // 
  // x-constraint:
  // - /components/schemas/Device.Ipv4/properties/name
  // - /components/schemas/Device.Ipv4Loopback/properties/name
  // 
  // required = true
  optional string ipv4_name = 1;

  // Contains properties of Tail(Egress) LSPs.
  RsvpLspIpv4InterfaceP2PEgressIpv4Lsp p2p_egress_ipv4_lsps = 2;

  // Array of point-to-point RSVP-TE P2P LSPs originating from this interface.
  repeated RsvpLspIpv4InterfaceP2PIngressIpv4Lsp p2p_ingress_ipv4_lsps = 3;
}

// Configuration for RSVP Egress Point-to-Point(P2P) IPv4 LSPs.
message RsvpLspIpv4InterfaceP2PEgressIpv4Lsp {

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  optional string name = 1;

  // The time in seconds between successive transmissions of RESV Refreshes. The actual
  // refresh interval is jittered by upto 50%. There is no specification specified maximum
  // value. For clarity, setting the maximum to 1 hour.
  // default = 30
  optional uint32 refresh_interval = 2;

  // The number of missed PATH refreshes after which a recieving node should consider
  // the LSP state to have timed out. There is no specification specified maximum value.
  // Setting the maximum allowed value to 10.
  // default = 3
  optional uint32 timeout_multiplier = 3;

  message ReservationStyle {
    enum Enum {
      unspecified = 0;
      shared_explicit = 1;
      fixed_filter = 2;
      auto = 3;
    }
  }
  // It determines how RSVP-TE enabled network devices set up reservations along the path
  // between an end-to-end  QOS-enabled connection. If 'auto' is enabled, the style is
  // chosen based on whether the incoming Path has 'SE Desired' flag set. Otherwise, the
  // style is chosen based on the value selected for this attribute.
  // default = ReservationStyle.Enum.shared_explicit
  optional ReservationStyle.Enum reservation_style = 4;

  // If enabled, a specific fixed label will be advertised by the egress or tail end for
  // all Path messages received by this egress.  This can be leveraged to advertise Explicit
  // or Implicit null labels.
  // default = False
  optional bool enable_fixed_label = 5;

  // The fixed label value as advertised by egress in RESV message. Applicable only if
  // 'fixed_label' is set to 'true'. Special values are '0 - IPv4 Explicit NULL', '2 -
  // IPv6 Explicit NULL' and '3 - Implicit NULL'.   Outside of this, labels are expected
  // to have a minimum value of 16.
  // default = 0
  optional uint32 fixed_label_value = 6;
}

// Configuration for an RSVP Ingress point-to-point LSP.
message RsvpLspIpv4InterfaceP2PIngressIpv4Lsp {

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  optional string name = 1;

  // IPv4 address of the remote endpoint of the LSP.
  // required = true
  optional string remote_address = 2;

  // The Tunnel ID of the RSVP LSP. Carried in the SESSION object in Path Messages.
  // default = 1
  optional uint32 tunnel_id = 3;

  // The LSP ID of the RSVP LSP. Carried in the SENDER_TEMPLATE object in Path Messages.
  // default = 1
  optional uint32 lsp_id = 4;

  // The time in seconds between successive transmissions of PATH Refreshes.  The actual
  // refresh interval is jittered by upto 50%. There is no specification specified maximum
  // value. For clarity, setting the maximum to 1 hour.
  // default = 30
  optional uint32 refresh_interval = 5;

  // The number of missed RESV refreshes after which a recieving node should consider
  // the LSP state to have timed out. There is no specification specified maximum value.
  // Setting the maximum allowed value to 10.
  // default = 3
  optional uint32 timeout_multiplier = 6;

  // The LSP id that will be used when creating a Make-Before-Break LSP when the active
  // LSP is using lsp_id. If the active LSP on which Make-Before-Break is being done is
  // using the backup_lsp_id, the new LSP created will toggle to  use the lsp_id instead.
  // default = 2
  optional uint32 backup_lsp_id = 7;

  // The amount of delay in milliseconds that an implementation should wait for before
  // switching traffic to the new LSP created after  a Make-Before-Break is done on an
  // LSP. The default value is 0 which means to switch immediately. An implementation
  // should support a minimum delay value of at least 50ms . There is no specification
  // specified maximum value. Setting maximum allowed value to 1 minute.  If a delay value
  // is supplied which is lesser than the minimum delay value supported, a warning should
  // be provided indicating that the minimum value of LSP switchover delay is automatically
  // increased to the supported minimum value. This warning should be included in the
  // list of warnings in the 'Response.Warning' attribute sent in the SetConfig 'Success'
  // Response.
  // default = 0
  optional uint32 lsp_switchover_delay = 8;

  // This contains the values of the fields to be included in the SESSION_ATTRIBUTE object
  // in the Path Message sent for the LSP.
  RsvpSessionAttribute session_attribute = 9;

  // This contains the values of the fields to be included in the TSPEC object in the
  // Path Message sent for the LSP.
  RsvpTspec tspec = 10;

  // This contains the values of the fields to be included in the FAST_REROUTE object
  // in the Path Message sent for the LSP.
  // This is an optional object . If this attribute is not included , the FAST_REROUTE
  // object will not be included.
  RsvpFastReroute fast_reroute = 11;

  // This contains the values of the fields to be included in the ERO object in the Path
  // Message sent for the LSP.
  // This is an optional object . If this attribute is not included , the ERO object will
  // not be included.
  RsvpEro ero = 12;
}

// Configuration for RSVP-TE SESSION_ATTRIBUTE object included in Path Messages as defined
// in RFC3209. The bandwidth_protection_desired and node_protection_desired flags are
// defined in RFC4090 (Fast Reroute).
message RsvpSessionAttribute {

  // If this is enabled, an auto-generated Session Name is included in the SESSION_ATTRIBUTE
  // object in the Path Message for this LSP.
  // default = True
  optional bool auto_generate_session_name = 1;

  // If auto_generate_session_name is set to 'false', then the value of this field is
  // used to fill the Session Name field of the SESSION_ATTRIBUTE object in the Path Message
  // for this LSP. It is suggested to include the Local IP, Remote IP, Tunnel ID and LSP
  // ID in the auto-generated Session Name to ensure uniqueness of the name in the test.
  // The maximum length of session name is 254 bytes.
  optional string session_name = 2;

  // Specifies the value of the Setup Priority field. This controls whether the LSP should
  // pre-empt existing  LSP setup with certain Holding Priority if resource limitation
  // is encountered when setting up the LSP. (e.g. bandwidth availability). The value
  // 0 is the highest priority while 7 is the lowest.
  // default = 7
  optional uint32 setup_priority = 3;

  // Specifies the value of the Holding Priority field. This controls whether a new LSP
  // being created with certain Setup Priority should pre-empt this LSP if resource limitation
  // is encountered when setting up the LSP. (e.g. bandwidth availability). The value
  // 0 is the highest priority while 7 is the lowest.
  // default = 7
  optional uint32 holding_priority = 4;

  // This flag permits transit routers to use a local repair mechanism which may result
  // in violation of the explicit route object.  When a fault is detected on an adjacent
  // downstream link or node, a transit router can reroute traffic for fast service restoration.
  // default = False
  optional bool local_protection_desired = 5;

  // This flag indicates that label information should be included when doing a route
  // record.
  // default = False
  optional bool label_recording_desired = 6;

  // This flag indicates that the tunnel ingress node may choose to reroute this tunnel
  // without tearing it down. A tunnel egress node SHOULD use the Shared Explicit(SE)
  // Style when responding with a Resv message.
  // default = False
  optional bool se_style_desired = 7;

  // This flag in the SESSION_ATTRIBUTE object in the Path Message indicates to the PLRs
  // along the protected LSP path that a  backup path with a bandwidth guarantee is desired.
  // This bandwidth has to be guaranteed for the protected LSP, if no FAST_REROUTE object
  // is included in the PATH message. If a FAST_REROUTE object is present in the Path
  // message, then the bandwidth specified therein is to be guaranteed.
  // default = False
  optional bool bandwidth_protection_desired = 8;

  // This flag in the SESSION_ATTRIBUTE object in the Path Message indicates to the PLRs
  // along a protected LSP path that it is desired to have a backup path that bypasses
  // at least the next node of the protected LSP.
  // default = False
  optional bool node_protection_desired = 9;

  // This is an optional object. If included the extended SESSION_ATTRIBUTE object is
  // sent in the Path message containing
  // the additional fields included in this object. This contains a set of three bitmaps
  // using which further constraints can be
  // set on the path calculated for the LSP based on the Admin Group settings in the IGP
  // (e.g ISIS or OSPF interface).
  RsvpResourceAffinities resource_affinities = 10;
}

// This is an optional object. If included, the extended SESSION_ATTRIBUTE object is
// sent in the Path message containing
// the additional fields included in this object. This contains a set of three bitmaps
// using which further constraints can be
// set on the path calculated for the LSP based on the Admin Group settings in the IGP
// (e.g ISIS or OSPF interface).
message RsvpResourceAffinities {

  // A 32-bit vector representing a set of attribute filters associated with a tunnel
  // any of which renders a link unacceptable.  A null set (all bits set to zero) doesn't
  // render the link unacceptable.  The most significant byte in the hex-string is the
  // farthest  to the left in the byte sequence.  Leading zero bytes in the configured
  // value may be omitted for brevity.
  // default = 0
  optional string exclude_any = 1;

  // A 32-bit vector representing a set of attribute filters associated with a tunnel
  // any of which renders a link acceptable. A null set (all bits set to zero) automatically
  // passes. The most significant byte in the hex-string is the farthest  to the left
  // in the byte sequence.  Leading zero bytes in the configured value may be omitted
  // for brevity.
  // default = 0
  optional string include_any = 2;

  // A 32-bit vector representing a set of attribute filters associated with a tunnel
  // all of which must be present for a link to be acceptable. A null set (all bits set
  // to zero) automatically passes. The most significant byte in the hex-string is the
  // farthest  to the left in the byte sequence.  Leading zero bytes in the configured
  // value may be omitted for brevity.
  // default = 0
  optional string include_all = 3;
}

// Configuration for RSVP-TE TSPEC object included in Path Messages. The usage of these
// parameters is defined in RFC2215.
message RsvpTspec {

  // The rate of the traffic to be carried in this LSP in bytes per second. This is part
  // of the Token Bucket specification defined for a traffic flow defined in RFC2215.
  // default = 0
  optional float token_bucket_rate = 1;

  // The depth of the token bucket in bytes used to specify the Token Bucket characteristics
  // of the traffic to be carried in the LSP. This is part of the Token Bucket specification
  // defined for a traffic flow defined in RFC2215.
  // default = 0
  optional float token_bucket_size = 2;

  // The peak data rate of the traffic in bytes per second used to specify the Token Bucket
  // characteristics of the traffic  to be carried in the LSP. This is part of the Token
  // Bucket specification defined for a traffic flow defined in RFC2215.
  // default = 0
  optional float peak_data_rate = 3;

  // Specifies the minium length of packet frames that will be policed.
  // default = 0
  optional uint32 minimum_policed_unit = 4;

  // Specifies the maximum length of packet frames that will be policed.
  // default = 0
  optional uint32 maximum_policed_unit = 5;
}

// Configuration for the optional RSVP-TE FAST_REROUTE object included in Path Messages
// as defined in RFC4090.
message RsvpFastReroute {

  // Specifies the value of the Setup Priority field. This controls whether the backup
  // LSP should pre-empt existing LSP that is setup with certain Holding Priority. While
  // setting up a backup LSP, preemption of existing LSP can happen  if resource limitation
  // is encountered (e.g bandwidth availability).
  // default = 7
  optional uint32 setup_priority = 1;

  // Specifies the value of the Holding Priority field. This controls whether a new LSP
  // being created with certain Setup Priority should pre-empt this LSP set up with this
  // Holding Priority. While setting up a new LSP, preemption of existing LSP can happen
  // if resource limitation is encountered (e.g bandwidth availability).
  // default = 7
  optional uint32 holding_priority = 2;

  // Specifies the value of the Hop Limit field. This controls the maximum number of hops
  // the LSP should traverse to reach the  LSP end-point.
  // default = 3
  optional uint32 hop_limit = 3;

  // Specifies the value of the Bandwidth field as a 32-bit IEEE floating point integer,
  // in bytes per second, as desired for the LSP.
  // default = 0
  optional float bandwidth = 4;

  // A 32-bit vector representing a set of attribute filters associated with a tunnel
  // any of which renders a link unacceptable. A null set (all bits set to zero) doesn't
  // render the link unacceptable. The most significant byte in the hex-string is the
  // farthest  to the left in the byte sequence.  Leading zero bytes in the configured
  // value may be omitted for brevity.
  // default = 0
  optional string exclude_any = 5;

  // A 32-bit vector representing a set of attribute filters associated with a tunnel
  // any of which renders a link acceptable. A null set (all bits set to zero) automatically
  // passes. The most significant byte in the hex-string is the farthest  to the left
  // in the byte sequence.  Leading zero bytes in the configured value may be omitted
  // for brevity.
  // default = 0
  optional string include_any = 6;

  // A 32-bit vector representing a set of attribute filters associated with a tunnel
  // all of which must be present for a link to be acceptable. A null set (all bits set
  // to zero) automatically passes. The most significant byte in the hex-string is the
  // farthest  to the left in the byte sequence.  Leading zero bytes in the configured
  // value may be omitted for brevity.
  // default = 0
  optional string include_all = 7;

  // Requests protection via the one-to-one backup method.
  // default = False
  optional bool one_to_one_backup_desired = 8;

  // Requests protection via the facility backup method.
  // default = False
  optional bool facility_backup_desired = 9;
}

// Configuration for the optional RSVP-TE explicit route object(ERO) object included
// in Path Messages.
message RsvpEro {

  message PrependNeighborIp {
    enum Enum {
      unspecified = 0;
      dont_prepend = 1;
      prepend_loose = 2;
      prepend_strict = 3;
    }
  }
  // Determines whether the IP address of the RSVP neighbor should be added as an ERO
  // sub-object. If it is to be included, it can be included as a Loose hop or as a Strict
  // hop.
  // default = PrependNeighborIp.Enum.prepend_loose
  optional PrependNeighborIp.Enum prepend_neighbor_ip = 1;

  // If prepend_egress_ip is set to one of 'prepend_loose' or 'prepend_strict', then set
  // this value as the prefix length of the ERO sub-object containing egress IP address.
  // 
  // default = 32
  optional uint32 prefix_length = 2;

  // Array of sub-objects to be included in the ERO. These sub-objects contain the intermediate
  // hops to be traversed by the LSP while being forwarded towards the egress endpoint.
  // These sub-objects are included after the optional sub-object containing IP address
  // of egress endpoint of the LSP (when present).
  repeated RsvpEroSubobject subobjects = 3;
}

// Configuration for the ERO sub-object.
message RsvpEroSubobject {

  message Type {
    enum Enum {
      unspecified = 0;
      ipv4 = 1;
      as_number = 2;
    }
  }
  // The type of the ERO sub-object, one of IPv4 Address or AS Number.
  // default = Type.Enum.ipv4
  optional Type.Enum type = 1;

  // IPv4 address that this LSP should traverse through. This field is applicable only
  // if the value of 'type' is set to 'ipv4'.
  // default = 0.0.0.0
  optional string ipv4_address = 2;

  // Prefix length for the IPv4 address in the ERO sub-object. This field is applicable
  // only if the value of 'type' is set to 'ipv4'.
  // default = 32
  optional uint32 prefix_length = 3;

  // Autonomous System number to be set in the ERO sub-object that this LSP should traverse
  // through. This field is applicable only if the value of 'type' is set to 'as_number'.
  // Note that as per RFC3209, 4-byte AS encoding is not supported.
  // default = 0
  optional uint32 as_number = 4;

  message HopType {
    enum Enum {
      unspecified = 0;
      strict = 1;
      loose = 2;
    }
  }
  // The hop type of the ERO sub-object, one of Strict or Loose.
  // default = HopType.Enum.loose
  optional HopType.Enum hop_type = 5;
}

// Configuration for one or more IPv4 or IPv6 DHCP servers.
message DeviceDhcpServer {

  // This contains an array of references to IPv4 interfaces, each of which will contain
  // one DHCPv4 server.
  repeated DhcpServerV4 ipv4_interfaces = 2;

  // This contains an array of references to IPv6 interfaces, each of which will contain
  // one DHCPv6 server.
  repeated DhcpServerV6 ipv6_interfaces = 3;
}

// Configuration for emulated DHCPv4 Server.
message DhcpServerV4 {

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  optional string name = 1;

  // The unique name of the IPv4 on which DHCPv4 server will run.
  // 
  // x-constraint:
  // - /components/schemas/Device.Ipv4/properties/name
  // 
  // required = true
  optional string ipv4_name = 2;

  // List of DHCPv4 Server Lease parameters
  repeated DhcpServerV4Pool address_pools = 3;
}

// Configuration for DHCPv4 address pool for a lease.
message DhcpServerV4Pool {

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  optional string name = 1;

  // The duration of time in seconds that is assigned to a lease.
  // default = 86400
  optional uint32 lease_time = 2;

  // The IPv4 address of the first lease pool.
  // required = true
  optional string start_address = 3;

  // The IPv4 network prefix length to be applied to the address.
  // default = 24
  optional uint32 prefix_length = 4;

  // The total number of addresses in the pool.
  // default = 1
  optional uint32 count = 5;

  // The increment value for the lease address within the lease pool. The value is incremented
  // according to the prefix_length and step.
  // default = 1
  optional uint32 step = 6;

  // Optional configuration for DHCPv4 address pool for the lease.
  DhcpServerV4PoolOption options = 7;
}

// Optional configuration for DHCPv4 address pool for the lease.
message DhcpServerV4PoolOption {

  // The Router address advertised by the DHCPv4 server in Offer and Ack messages.
  // default = 0.0.0.0
  optional string router_address = 1;

  // The primary DNS server address that is offered to DHCP clients that request this
  // information through a TLV option.
  // default = 0.0.0.0
  optional string primary_dns_server = 2;

  // The primary DNS server address that is offered to DHCP clients that request this
  // information through a TLV option.
  // default = 0.0.0.0
  optional string secondary_dns_server = 3;

  // If selected, the DHCP server includes in its replies the TLV information for the
  // DHCPv4 Relay Agent Option 82 and the corresponding sub-TLVs that it receives from
  // a DHCP relay agent, otherwise it replies without including this TLV.
  // default = True
  optional bool echo_relay_with_tlv_82 = 4;
}

// Configuration for emulated DHCPv6 Server.
message DhcpServerV6 {

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  optional string name = 1;

  // The unique name of the IPv6 on which DHCPv6 server will run.
  // 
  // x-constraint:
  // - /components/schemas/Device.Ipv6/properties/name
  // 
  // required = true
  optional string ipv6_name = 2;

  // If Rapid Commit is set, server responds to client initiated Rapid Commit two-message
  // exchanges.
  // default = False
  optional bool rapid_commit = 3;

  // If the server does not have an address to which it can send the Reconfigure message
  // directly to the client, the  server uses a Relay-reply message to send the Reconfigure
  // message to a relay agent that will relay the message to the client.
  // default = False
  optional bool reconfigure_via_relay_agent = 4;

  // Array of DHCP pools configured on a server.
  repeated DhcpV6ServerLease leases = 5;

  // Optional DHCPv4 Server options that are sent in Dhcp server messages.
  Dhcpv6ServerOptions options = 6;
}

// DHCP server options, these configured options are sent in Dhcp server messages.
message Dhcpv6ServerOptions {

  // Additional DHCP server primary dns and other configuration options.
  DhcpV6ServerDns dns = 1;

  // This option is used by servers to exchange vendor-specific information with clients.
  Dhcpv6ServerOptionsVendorInfo vendor_info = 2;

  // The server sends this option to inform the client about a URL to a boot file which
  // client will use for
  // network boots.
  Dhcpv6ServerOptionsBootfileUrl bootfile_url = 3;
}

// One DHCP pool configuration on a server.
message DhcpV6ServerLease {

  // The Life Time length in seconds that is assigned to a lease if the requesting DHCP
  // client does not specify a specific expiration time.
  // default = 86400
  optional uint32 lease_time = 1;

  // Description missing in models
  // required = true
  Dhcpv6ServerIaType ia_type = 5;
}

// Description missing in models
message Dhcpv6ServerIaType {

  message Choice {
    enum Enum {
      unspecified = 0;
      iana = 1;
      iata = 2;
      iapd = 3;
      ianapd = 4;
    }
  }
  // Identity Association: a collection of leases assigned to a client. Each IA has an
  // associated IAID.  Each IA holds one type of lease, like an identity association for
  // temporary addresses (IA_TA) holds  temporary addresses, and an identity association
  // for prefix delegation (IA_PD).
  // default = Choice.Enum.iana
  optional Choice.Enum choice = 1;

  // Description missing in models
  Dhcpv6ServerPoolInfo iana = 2;

  // Description missing in models
  Dhcpv6ServerPoolInfo iata = 3;

  // Description missing in models
  Dhcpv6ServerIapdPoolInfo iapd = 4;

  // Description missing in models
  Dhcpv6ServerIanapdPoolInfo ianapd = 5;
}

// The container for pool configurations for IA types iana and iata.
message Dhcpv6ServerPoolInfo {

  // The first IP address of the lease pool.
  optional string start_address = 1;

  // The prefix_len ( in conjunction with the step) can be used to increment the IPv6
  // lease addresses  to be assigned to the requested clients when multiple addresses
  // are configured by using the size field  in the pool. The address is incremented using
  // the prefix_len and step.
  // default = 64
  optional uint32 prefix_len = 2;

  // The total number of addresses in the pool.
  // default = 1
  optional uint32 size = 3;

  // The increment value for the lease address within the lease pool where multiple addresses
  // are present.  The value of the advertised IPv6 prefixes are incremented according
  // to the prefix_len and step.
  // default = 1
  optional uint32 step = 4;
}

// The container for prefix pool configurations for IA type iapd.
message Dhcpv6ServerIapdPoolInfo {

  // The first IP address of the prefix pool.
  optional string start_prefix_address = 1;

  // The configured_prefix_len ( in conjunction with the prefix_step) can be used to increment
  // the IPv6 lease addresses  to be assigned to the requested clients when multiple addresses
  // are configured by using the size field in the pool.  e.g. This can be used to assign
  // multiple IPv6 host addresses within the same IPv6 subnet ( defined by advertised_prefix_len
  // )  to multiple requesting clients.
  // default = 128
  optional uint32 configured_prefix_len = 2;

  // The total number of addresses in the pool.
  // default = 10
  optional uint32 prefix_size = 3;

  // The increment value for the lease address within the lease pool where multiple addresses
  // are present.  The value of the advertised IPv6 prefixes are incremented according
  // to the configured_prefix_len and prefix_step.
  // default = 1
  optional uint32 prefix_step = 4;

  // The prefix length of the IPv6 prefix that the Dhcpv6 server offers to the Dhcpv6
  // client.
  // default = 64
  optional uint32 advertised_prefix_len = 5;
}

// The container for pool configurations for IA type ianapd.
message Dhcpv6ServerIanapdPoolInfo {

  // The pool configurations for IA types iana in ianapd.
  Dhcpv6ServerPoolInfo iana = 1;

  // The pool configurations for IA types iapd in ianapd.
  Dhcpv6ServerIapdPoolInfo iapd = 2;
}

// Optional Dns configuration for DHCPv6 server.
message DhcpV6ServerDns {

  // The primary DNS server address that is offered to DHCP clients that request this
  // information through a TLV option.
  // required = true
  optional string primary = 1;

  // DHCP server secondary dns configuration options. If included secondary DNS server
  // address will be offered to
  // DHCP clients that request this information through a TLV option.
  repeated DhcpV6ServerSecondaryDns secondary_dns = 2;
}

// Advanced Dns configuration for DHCPv6 server.
message DhcpV6ServerSecondaryDns {

  // The secondary DNS server address that is offered to DHCP clients that request this
  // information through a TLV option.
  optional string ip = 1;
}

// A container of properties for an OSPFv2 router and its interfaces & Route Ranges.
message DeviceOspfv2Router {

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  optional string name = 1;

  // OSPFv2 Router Id.
  Ospfv2RouterId router_id = 2;

  // The time in seconds for LSA retransmission.
  // default = 5
  optional uint32 lsa_retransmit_time = 3;

  // The time in seconds required for LSA refresh.
  // default = 1800
  optional uint32 lsa_refresh_time = 4;

  // The gap in miliseconds between each Flood Link State Update Burst
  // default = 33
  optional uint32 inter_burst_lsu_interval = 5;

  // The maximum number of Flood LSUpdates for each burst
  // default = 1
  optional uint32 max_flood_lsu_per_burst = 6;

  // Description missing in models
  Ospfv2GracefulRestart graceful_restart = 7;

  // Configuration for controlling storage of OSPFv2 learned LSAs received from the neighbors.
  // default = False
  optional bool store_lsa = 8;

  // A router indicates the optional capabilities that it supports in its OSPF Hello packets,
  // Database Description packets and in its LSAs.
  Ospfv2Options capabilities = 9;

  // List of OSPFv2 interfaces for this router.
  repeated Ospfv2Interface interfaces = 10;

  // Emulated OSPFv4 IPv4 routes.
  repeated Ospfv2V4RouteRange v4_routes = 11;
}

// Container for OSPFv2 Router ID configuration.
message Ospfv2RouterId {

  message Choice {
    enum Enum {
      unspecified = 0;
      interface_ip = 1;
      custom = 2;
    }
  }
  // IP address of Router ID for this emulated OSPFv2 router.
  // - interface_ip: When IPv4 interface address to be assigned as Router ID.
  // - custom: When, Router ID needs to be configured different from Interface IPv4 address.
  // default = Choice.Enum.interface_ip
  optional Choice.Enum choice = 1;

  // Router ID in IPv4 address format.
  optional string custom = 3;
}

// The OSPFv2 Options field is present Database Description packets and all LSAs.
// This enables OSPF routers to support (or not support) optional capabilities,
// and to communicate their capability level to other OSPF routers.
// When capabilities are exchanged in Database Description packets a
// router can choose not to forward certain LSAs to a neighbor because
// of its reduced functionality.
// Reference: A.2 The Options field: https://www.rfc-editor.org/rfc/rfc2328#page-46.
message Ospfv2Options {

  // Type of Service: 0th-bit: describes OSPFv2's TOS capability.
  // default = False
  optional bool t_bit = 1;

  // External Capability: 1st-bit: describes the way AS-external-LSAs are flooded.
  // default = False
  optional bool e_bit = 2;

  // Multicast Capability: 2nd-bit: describes whether IP multicast datagrams are forwarded
  // according to  the specifications in [Ref18], rfc2328.
  // default = False
  optional bool mc_bit = 3;

  // NSSA Capability: 3rd-bit: describes the handling of Type-7 LSAs, as specified in
  // [Ref19], rfc2328.
  // default = False
  optional bool np_bit = 4;

  // External Attribute: 4th-bit: describes the router's willingness to receive and forward
  // External-Attributes-LSAs,  as specified in [Ref20], rfc2328.
  // default = False
  optional bool ea_bit = 5;

  // Demand Circuit: 5th-bit: describes the router's handling of demand circuits, as specified
  // in [Ref21], rfc2328.
  // default = False
  optional bool dc_bit = 6;

  // Opaque LSA's Forwarded: 6th-bit: describes the router's willingness to receive and
  // forward Opaque-LSAs, rfc2370.
  // default = False
  optional bool o_bit = 7;

  // Opaque LSA's Forwarded: 7th-bit: unused bit.
  // default = False
  optional bool unused_bit = 8;

  // Set to indicate that the router acts as an Area Border Router.
  // default = False
  optional bool lsa_b_bit = 9;

  // Set to indicate that the router acts as an AS Boundary Router.
  // default = False
  optional bool lsa_e_bit = 10;
}

// Container of properties of OSPFv2 Graceful Retstart.
message Ospfv2GracefulRestart {

  // Support of Graceful Restart in Helper Mode.
  // default = False
  optional bool helper_mode = 1;
}

// Configuration for single OSPFv2 interface.
message Ospfv2Interface {

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  optional string name = 1;

  // The globally unique name of the IPv4 interface connected to the DUT.
  // 
  // x-constraint:
  // - /components/schemas/Device.Ipv4/properties/name
  // 
  // required = true
  optional string ipv4_name = 2;

  // The Area ID of the area to which the attached network belongs.
  // All routing protocol packets originating from the interface are
  // labelled with this Area ID.
  Ospfv2InterfaceArea area = 3;

  // The OSPF network link type.
  Ospfv2InterfaceNetworkType network_type = 4;

  // Contains a list of Traffic Engineering attributes.
  repeated LinkStateTE traffic_engineering = 5;

  // OSPFv2 authentication properties.
  // If the authentication is not configured, none OSPF packet exchange is authenticated.
  Ospfv2InterfaceAuthentication authentication = 6;

  // Optional container for advanced interface properties.
  Ospfv2InterfaceAdvanced advanced = 7;

  // Link protection on the OSPFv2 link between two interfaces.
  Ospfv2InterfaceLinkProtection link_protection = 8;

  // A Shared Risk Link Group (SRLG) is represented by a 32-bit number unique within an
  // IGP (OSPFv2 and IS-IS) domain.
  // An SRLG is a set of links sharing a common resource, which affects all links in the
  // set if the common resource fails.
  // Links share the same risk of failure and are therefore considered to belong to the
  // same SRLG.
  repeated uint32 srlg_values = 9;
}

// Container for OSPF Area ID identifies the routing area to which the host belongs..
// 
message Ospfv2InterfaceArea {

  message Choice {
    enum Enum {
      unspecified = 0;
      id = 1;
      ip = 2;
    }
  }
  // The OSPF Area ID identifies the routing area to which the host belongs. Area ID type
  // can be following format.
  // - id: A 32-bit number identifying the area.
  // - ip:     The Area ID in IPv4 address format.
  // default = Choice.Enum.id
  optional Choice.Enum choice = 1;

  // The Area ID.
  // default = 0
  optional uint32 id = 2;

  // The Area ID in IPv4 address format.
  optional string ip = 3;
}

// The OSPF network link type options.
// - Point to Point:
// - Broadcast:
// - Point to Multipoint: In this case, at least a neigbor to be configured.
message Ospfv2InterfaceNetworkType {

  message Choice {
    enum Enum {
      unspecified = 0;
      broadcast = 1;
      point_to_point = 2;
      point_to_multipoint = 3;
    }
  }
  // Description missing in models
  // default = Choice.Enum.broadcast
  optional Choice.Enum choice = 1;

  // List of Neigbhors.
  repeated Ospfv2InterfaceNeighbor point_to_multipoint = 2;
}

// Configuration of a neighbor.
message Ospfv2InterfaceNeighbor {

  // Description missing in models
  optional string neighbor_ip = 1;
}

// Contains OSPFv2 advanced properties.
message Ospfv2InterfaceAdvanced {

  // The time interval, in seconds, between the Hello packets that
  // the router sends on the interface. Advertised in Hello packets
  // sent out this interface.
  // default = 10
  optional uint32 hello_interval = 1;

  // The time interval in seconds before the router's neighbors will declare
  // it down, when they stop hearing the router's Hello Packets.
  // Advertised in Hello packets sent out this interface.
  // default = 40
  optional uint32 dead_interval = 2;

  // Routing metric associated with the interface..
  // default = 10
  optional uint32 routing_metric = 3;

  // The Priority for (Backup) Designated Router election.
  // This value is used in Hello packets for the Designated Router (DR) election process.
  // The default is 0, which indicates that the router will not participate in the DR
  // election process.
  // default = 0
  optional uint32 priority = 4;

  // If this is set to true, then the MTU received from the neighbor during Database (DB)
  // Exchange
  // will be validated, otherwise it will be ignored.
  // 
  // default = True
  optional bool validate_received_mtu = 5;
}

// The OSPF Options field is present in OSPF Hello packets, Database Description packets
// and all LSAs.
// The Options field enables OSPF routers to support (or not support) optional capabilities,
// and to
// communicate their capability level to other OSPF routers https://datatracker.ietf.org/doc/html/rfc2328#page-46.
// When used in Hello packets, the Options field allows a router to reject a neighbor
// because of a capability mismatch.
message Ospfv2InterfaceOptions {

  // Type of Service: 0th-bit: describes OSPFv2's TOS capability.
  // default = False
  optional bool t_bit = 1;

  // External Capability: This bit describes the way AS-external-LSAs are flooded.
  // default = False
  optional bool e_bit = 2;

  // Multicast Capability: This bit describes whether IP multicast datagrams are forwarded
  // according to  the specifications in [Ref18], rfc2328.
  // default = False
  optional bool mc_bit = 3;

  // NSSA Capability: This bit describes the handling of Type-7 LSAs, as specified in
  // [Ref19], rfc2328.
  // default = False
  optional bool np_bit = 4;

  // External Attribute: This bit describes the router's willingness to receive and forward
  // External-Attributes-LSAs,  as specified in [Ref20], rfc2328.
  // default = False
  optional bool ea_bit = 5;

  // Demand Circuit: This bit describes the router's handling of demand circuits, as specified
  // in [Ref21], rfc2328.
  // default = False
  optional bool dc_bit = 6;

  // Opaque LSA's Forwarded: This bit describes the router's willingness to receive and
  // forward Opaque-LSAs, rfc2370.
  // default = False
  optional bool o_bit = 7;

  // Opaque LSA's Forwarded: 7th-bit: unused bit.
  // default = False
  optional bool unused_bit = 8;
}

// This contains OSPFv2 authentication properties.
// Reference: https://www.rfc-editor.org/rfc/rfc2328#appendix-D
message Ospfv2InterfaceAuthentication {

  message Choice {
    enum Enum {
      unspecified = 0;
      md5s = 1;
      clear_text = 2;
    }
  }
  // The authentication method.
  // - md5 - Cryptographic authentication.
  // - clear_text - Simple password authentication. A 64-bit field is configured on a
  // per-network basis.
  // All packets sent on a particular network must have this configured value (in clear
  // text)
  // in their OSPF header 64-bit authentication field.
  // default = Choice.Enum.clear_text
  optional Choice.Enum choice = 1;

  // List of MD5 Key IDs and MD5 Keys.
  repeated Ospfv2AuthenticationMd5 md5s = 2;

  // The 8 Byte authentication field in the OSPF packet.
  // default = otg
  optional string clear_text = 4;
}

// Container of Cryptographic authentication.
// If the authentication type is of 'md5' then 'md5_key_id' and 'md5_key'
// both are to be configured. A shared secret key is configured in all routers attached
// to a common network/subnet.
// For each OSPF protocol packet, the key is used to generate/verify a message digest
// that is appended to the end
// of the OSPF packet.
message Ospfv2AuthenticationMd5 {

  // The unique MD5 Key Identifier per-interface.
  optional uint32 key_id = 1;

  // An alphanumeric secret used to generate the 16 byte MD5 hash value added
  // to the OSPFv2 PDU in the Authentication TLV.
  optional string key = 2;
}

// Optional container for the link protection sub TLV (type 20).
message Ospfv2InterfaceLinkProtection {

  // Enable this to protect other link or links. LSAs on a link of this type are lost
  // if any of the links fail.
  // default = False
  optional bool extra_traffic = 1;

  // Enabling this signifies that there is no other link protecting this
  // link. LSAs on a link of this type are lost if the link fails.
  // default = False
  optional bool unprotected = 2;

  // Enable this to share the Extra Traffic links between one or more
  // links of type Shared.There are one or more disjoint links of type
  // Extra Traffic that are protecting this link.
  // default = False
  optional bool shared = 3;

  // Enabling this signifies that there is one dedicated disjoint link
  // of type Extra Traffic that is protecting this link.
  // default = False
  optional bool dedicated_1_to_1 = 4;

  // Enabling this signifies that a dedicated disjoint link is protecting
  // this link. However, the protecting link is not advertised in the
  // link state database and is therefore not available for the routing
  // of LSAs.
  // default = False
  optional bool dedicated_1_plus_1 = 5;

  // Enabling this signifies that a protection scheme that is more
  // reliable than Dedicated 1+1.
  // default = False
  optional bool enhanced = 6;

  // This is a Protection Scheme with value 0x40.
  // default = False
  optional bool reserved_40 = 7;

  // This is a Protection Scheme with value 0x80.
  // default = False
  optional bool reserved_80 = 8;
}

// Emulated OSPFv2 IPv4 routes.
message Ospfv2V4RouteRange {

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  optional string name = 1;

  // A list of group of IPv4 route addresses.
  repeated V4RouteAddress addresses = 2;

  // The user-defined metric associated with this route range.
  // default = 0
  optional uint32 metric = 3;

  // The type of the OSPFv2 routes.
  Ospfv2V4RRRouteOrigin route_origin = 4;
}

// Container of type of the OSPFv2 types correspond directly to the OSPFv2 LSAs types
// as
// defined in the OSPFv2 Link State (LS) Type - http://www.iana.org/assignments/ospfv2-parameters.
// 
message Ospfv2V4RRRouteOrigin {

  message Choice {
    enum Enum {
      unspecified = 0;
      intra_area = 1;
      inter_area = 2;
      external_type_1 = 3;
      external_type_2 = 4;
      nssa_external = 5;
    }
  }
  // Supported types are: - intra_area: for Intra-Area. - inter_area: for Inter Area.
  // - external_type_1: for Autonomous System (AS) External with internal AS metric. -
  // external_type_2: for Autonomous System (AS) External with internal and external AS
  // metric. - nssa_external: for 7 Not-So-Stubby Area (NSSA) External.
  // default = Choice.Enum.inter_area
  optional Choice.Enum choice = 1;

  // Configuration for the Intra-Area.
  Ospfv2V4RRIntraArea intra_area = 2;

  // Configuration for the Intra-Area.
  Ospfv2V4RRInterArea inter_area = 3;

  // Configuration for the External Type 1.
  Ospfv2V4RRExternalType1 external_type_1 = 4;

  // Configuration for the External Type 2.
  Ospfv2V4RRExternalType2 external_type_2 = 5;

  // Configuration for the External Type 2.
  Ospfv2V4RRNssaExternal nssa_external = 6;
}

// Container for Intra-Area.
message Ospfv2V4RRIntraArea {

  // One-octet field contains flags applicable to the prefix.
  Ospfv2V4RRExtdPrefixFlags flags = 1;
}

// Container for Intra-Area.
message Ospfv2V4RRInterArea {

  // One-octet field contains flags applicable to the prefix.
  Ospfv2V4RRExtdPrefixFlags flags = 1;
}

// Container for Intra-Area.
message Ospfv2V4RRExternalType1 {

  // One-octet field contains flags applicable to the prefix.
  Ospfv2V4RRExtdPrefixFlags flags = 1;
}

// Container for Intra-Area.
message Ospfv2V4RRExternalType2 {

  // One-octet field contains flags applicable to the prefix.
  Ospfv2V4RRExtdPrefixFlags flags = 1;
}

// Container for Intra-Area.
message Ospfv2V4RRNssaExternal {

  // One-octet field contains flags applicable to the prefix.
  Ospfv2V4RRExtdPrefixFlags flags = 1;

  // The flag is set True if LSA will be propagated between Areas.
  // default = False
  optional bool propagation = 2;
}

// One-octet field contains flags applicable to the prefix. https://datatracker.ietf.org/doc/html/rfc7684.
message Ospfv2V4RRExtdPrefixFlags {

  // 0x80 - (Attach Flag): An Area Border Router (ABR)
  // generating an OSPFv2 Extended Prefix TLV for an inter-area
  // prefix that is locally connected or attached in another
  // connected area SHOULD set this flag.
  // default = False
  optional bool a_flag = 1;

  // N-Flag (Node Flag): Set when the prefix identifies the
  // advertising router, i.e., the prefix is a host prefix
  // advertising a globally reachable address typically associated
  // with a loopback address.
  // default = False
  optional bool n_flag = 2;
}

// A container of properties for a MACsec capable device. Reference https://1.ieee802.org/security/802-1ae/.
message DeviceMacsec {

  // Ethernet Interfaces
  repeated DeviceMacsecEthernetInterface ethernet_interfaces = 1;
}

// Configuration for single MACsec interface.
message DeviceMacsecEthernetInterface {

  // The unique name of the Ethernet interface on which MACsec is enabled.
  // 
  // x-constraint:
  // - /components/schemas/Device.Ethernet/properties/name
  // 
  // required = true
  optional string eth_name = 1;

  // This contains the properties of Secure Entity (SecY).
  // required = true
  SecureEntity secure_entity = 2;
}

// Configuration of a Secure Entity (SecY).
message SecureEntity {

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  optional string name = 1;

  // This contains the properties of key generation protocol of Secure Entity (SecY).
  // required = true
  SecureEntityKeyGenerationProtocol key_generation_protocol = 2;

  // This contains the properties of data plane of Secure Entity (SecY).
  SecureEntityDataPlane data_plane = 3;
}

// Container of Key generation protocol configuration.
message SecureEntityKeyGenerationProtocol {

  message Choice {
    enum Enum {
      unspecified = 0;
      mka = 1;
      static_key = 2;
    }
  }
  // Key generation protocol choices. Choose mka for dynamic key distribution using MACsec
  // key agreement(MKA) protocol. Choose static_key for static configuration of secure
  // association key(SAK).
  // default = Choice.Enum.mka
  optional Choice.Enum choice = 1;

  // This contains the properties of Key Agreement Entity (KaY) in MKA supplicant.
  Mka mka = 2;

  // Static key properties properties of SecY. Static key is used in absence MKA.
  SecureEntityStaticKey static_key = 3;
}

// A container of data plane properties.
message SecureEntityDataPlane {

  message Choice {
    enum Enum {
      unspecified = 0;
      encapsulation = 1;
      no_encapsulation = 2;
    }
  }
  // Choose encapsulation so that data packets are sent with MACsec encapsulation. Choose
  // no_encapsulation so that data packets are sent without MACsec encapsulation.
  // default = Choice.Enum.encapsulation
  optional Choice.Enum choice = 1;

  // A container of encapsulation properties for a secure entity(SecY).
  SecureEntityDataPlaneEncapsulation encapsulation = 2;
}

// A container of encapsulation properties for a secure entity(SecY).
message SecureEntityDataPlaneEncapsulation {

  // Tx properties of SecY.
  SecureEntityDataPlaneTx tx = 1;

  // Rx properties of SecY.
  SecureEntityDataPlaneRx rx = 2;

  // Crypto engine properties of SecY.
  // required = true
  SecureEntityCryptoEngine crypto_engine = 3;
}

// A container of Tx properties of SecY.
message SecureEntityDataPlaneTx {

  // End station on not.
  // default = False
  optional bool end_station = 1;

  // Include SCI on not.
  // default = False
  optional bool include_sci = 2;
}

// A container for Rx settings of SecY.
message SecureEntityDataPlaneRx {

  // Enable replay protection on not.
  // default = False
  optional bool replay_protection = 1;

  // Replay window size.
  // default = 1
  optional uint32 replay_window = 2;
}

// A container of crypto engine properties of a SecY.
message SecureEntityCryptoEngine {

  message Choice {
    enum Enum {
      unspecified = 0;
      encrypt_only = 1;
    }
  }
  // Engine type based on encryption and/ or decryption capability. Supported types: encrypt_only
  // - engine can only encrypt transmitted packets but it cannot decrypt packets upon
  // arrival. As the packets cannot be decrypted on arrival, such packets cannot be delivered
  // to the receiving device. Hence only stateless traffic can be sent.
  // default = Choice.Enum.encrypt_only
  optional Choice.Enum choice = 1;

  // Description missing in models
  SecureEntityCryptoEngineEncryptOnly encrypt_only = 2;
}

// The container for encrypt only engine configuration.
message SecureEntityCryptoEngineEncryptOnly {

  // Description missing in models
  repeated SecureEntityCryptoEngineEncryptOnlyTxSc secure_channels = 1;

  // Description missing in models
  SecureEntityCryptoEngineEncryptOnlyTrafficOptions traffic_options = 2;
}

// The container for Tx secure channel configuration.
message SecureEntityCryptoEngineEncryptOnlyTxSc {

  // Description missing in models
  SecureEntityCryptoEngineEncryptOnlyTxScTxPn tx_pn = 1;
}

// Tx packet number(PN) configuration.
message SecureEntityCryptoEngineEncryptOnlyTxScTxPn {

  message Choice {
    enum Enum {
      unspecified = 0;
      fixed_pn = 1;
      incrementing_pn = 2;
    }
  }
  // Types of Tx packet number(PN) series. Supported choices: 1) fixed PN - MACsec packets
  // will be sent out with the configured fixed PN or lower half of configured fixed XPN.
  // 2) incrementing PN - MACsec packets will be sent out by single device with an incrementing
  // PN or XPN.
  // default = Choice.Enum.fixed_pn
  optional Choice.Enum choice = 1;

  // Description missing in models
  SecureEntityCryptoEngineEncryptOnlyFixedPn fixed = 2;

  // Description missing in models
  SecureEntityCryptoEngineEncryptOnlyIncrementingPn incrementing = 3;
}

// Fixed packet number(PN) configuration.
message SecureEntityCryptoEngineEncryptOnlyFixedPn {

  // Fixed Tx packet number(PN). 4 bytes PN with which all packets will be sent out.
  // default = 6
  optional uint32 pn = 1;

  // Fixed Tx extended packet number(XPN). 8 bytes XPN with which all packets will be
  // sent out.
  // default = 0x06
  optional string xpn = 2;
}

// Incrementing packet number(PN) configuration.
message SecureEntityCryptoEngineEncryptOnlyIncrementingPn {

  // Count of packet numbers in series.
  // default = 100
  optional uint32 count = 1;

  // The starting packet number(PN).
  // default = 10000
  optional uint32 starting_pn = 2;

  // The starting extended packet number(XPN).
  // default = 0x010000
  optional string starting_xpn = 3;
}

// Encrypt only traffic options.
message SecureEntityCryptoEngineEncryptOnlyTrafficOptions {

  // Send gratuitous ARP or not.
  // default = True
  optional bool send_gratuitous_arp = 1;
}

// Configuration of a MKA Key Agreement Entity (KaY). Reference https://1.ieee802.org/security/802-1x/.
message Mka {

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  optional string name = 1;

  // This contains the basic properties of KaY.
  // required = true
  MkaBasic basic = 2;

  // Key server attributes.
  MkaKeyServer key_server = 3;

  // Tx Properties.
  // required = true
  MkaTx tx = 4;
}

// A container of basic properties for a KaY.
message MkaBasic {

  message KeyDerivationFunction {
    enum Enum {
      unspecified = 0;
      aes_cmac_128 = 1;
      aes_cmac_256 = 2;
    }
  }
  // Key Derivation Function.
  // default = KeyDerivationFunction.Enum.aes_cmac_128
  optional KeyDerivationFunction.Enum key_derivation_function = 1;

  // Key source.
  // required = true
  MkaBasicKeySource key_source = 2;

  // Actor priority.
  // default = 70
  optional string actor_priority = 3;

  // Determines whether MACsec is desired or not. It is advertised in periodic Hellos.
  // default = True
  optional bool macsec_desired = 4;

  message MacsecCapability {
    enum Enum {
      unspecified = 0;
      macsec_not_implemented = 1;
      macsec_integrity_without_confidentiality = 2;
      macsec_integrity_with_no_confidentiality_offset = 3;
      macsec_integrity_with_confidentiality_offset = 4;
    }
  }
  // MACSec Capability.
  // default = MacsecCapability.Enum.macsec_integrity_with_confidentiality_offset
  optional MacsecCapability.Enum macsec_capability = 5;

  // Supported Cipher Suites.
  MkaBasicSupportedCipherSuites supported_cipher_suites = 6;

  // EAPOL Ethernet type.
  // default = 888E
  optional string eapol_ethernet_type = 7;

  // MKA Version.
  // default = 3
  optional uint32 mka_version = 8;

  // MKA Hello Time (msec).
  // default = 2000
  optional uint32 mka_hello_time = 9;

  // MKA Life Time (sec).
  // default = 6
  optional uint32 mka_life_time = 10;

  // Send ICV Indicator in MKPDU.
  // default = True
  optional bool send_icv_indicatior_in_mkpdu = 11;

  // Delay Protect or not. When delay protect is enabled, it guards against delaying the
  // delivery of MACsec encrypted frames by an attacker to the recipient.
  // default = True
  optional bool delay_protect = 12;

  // Rekey Mode.
  MkaBasicRekeyMode rekey_mode = 13;

  // Description missing in models
  MkaBasicPskChainStartTime psk_chain_start_time = 14;
}

// The container for supported cipher suites.
message MkaBasicSupportedCipherSuites {

  // GCM-AES-128.
  // default = True
  optional bool gcm_aes_128 = 1;

  // GCM-AES-256.
  // default = True
  optional bool gcm_aes_256 = 2;

  // GCM-AES-XPN-128.
  // default = True
  optional bool gcm_aes_xpn_128 = 3;

  // GCM-AES-XPN-256.
  // default = True
  optional bool gcm_aes_xpn_256 = 4;
}

// The container for key source settings.
message MkaBasicKeySource {

  message Choice {
    enum Enum {
      unspecified = 0;
      psk = 1;
      msk = 2;
    }
  }
  // Key source. Choose one from PSK or MSK.
  // default = Choice.Enum.psk
  optional Choice.Enum choice = 1;

  // PSK chain.
  repeated MkaBasicKeySourcePsk psks = 2;
}

// The container for Pre-shared key(PSK).
message MkaBasicKeySourcePsk {

  // Connectivity association key(CAK) value. It can be 128 bits or 256 bits long depending
  // on the chosen MKA key derivation function.
  // default = F123456789ABCDEF0123456789ABCDEF
  optional string cak_value = 1;

  // Connectivity association key(CAK) name.
  // default = F123456789ABCDEF0123456789ABCDEFF123456789ABCDEF0123456789ABCDEF
  optional string cak_name = 2;

  // 
  MkaBasicStartOffsetTime start_offset_time = 3;

  // 
  MkaBasicEndOffsetTime end_offset_time = 4;
}

// Key start offset time in HH:MM. This is relative to key chain start time.
message MkaBasicStartOffsetTime {

  // Hours in HH format.
  // default = 0
  optional uint32 hh = 1;

  // Minutes in MM format.
  // default = 0
  optional uint32 mm = 2;
}

// Key end offset time in HH:MM. This is relative to key chain start time. A value of
// 00:00 makes the key valid for lifetime.
message MkaBasicEndOffsetTime {

  // Hours in HH format.
  // default = 0
  optional uint32 hh = 1;

  // Minutes in MM format.
  // default = 0
  optional uint32 mm = 2;
}

// Pre-shared key(PSK) chain start time in UTC time format DD-MM-YYYY HH:MM:SS. If this
// time is set, the key start time will be relative to this value. Otherwise if this
// value is not set, key start time will be relative to test start time.
message MkaBasicPskChainStartTime {

  message Choice {
    enum Enum {
      unspecified = 0;
      utc = 1;
    }
  }
  // Timezone choice. Currently only Coordinated Universal Time(UTC) is supported.
  // default = Choice.Enum.utc
  optional Choice.Enum choice = 1;

  // Coordinated Universal Time(UTC) time.
  MkaBasicTimeUtc utc = 2;
}

// Coordinated Universal Time(UTC).
message MkaBasicTimeUtc {

  // Day of the month in DD format.
  optional uint32 day = 1;

  // Month of the year in MM format.
  optional uint32 month = 2;

  // Year from the start of common era(CE) in YYYY format.
  optional uint32 year = 3;

  // Hour of the day in HH format.
  optional uint32 hour = 4;

  // Minute of the hour in MM format.
  optional uint32 minute = 5;

  // Second of the minute in SS format.
  optional uint32 second = 6;
}

// Rekey mode.
message MkaBasicRekeyMode {

  message Choice {
    enum Enum {
      unspecified = 0;
      dont_rekey = 1;
      timer_based = 2;
      pn_based = 3;
    }
  }
  // Mode choices.
  // default = Choice.Enum.dont_rekey
  optional Choice.Enum choice = 1;

  // Container for timer based periodic rekey properties.
  MkaBasicRekeyModeTimerBased timer_based = 2;
}

// Timer based periodic rekey properties.
message MkaBasicRekeyModeTimerBased {

  message Choice {
    enum Enum {
      unspecified = 0;
      continuous = 1;
      fixed_count = 2;
    }
  }
  // Periodic Rekey count.
  // default = Choice.Enum.continuous
  optional Choice.Enum choice = 1;

  // Fixed rekey attempts.
  // default = 10
  optional uint32 fixed_count = 2;

  // Periodic rekey interval (sec).
  // default = 300
  optional uint32 interval = 3;
}

// Key server attributes of a KaY.
message MkaKeyServer {

  message ConfidentialtyOffset {
    enum Enum {
      unspecified = 0;
      no_confidentiality = 1;
      no_confidentiality_offset = 2;
      confidentiality_offset_30_octets = 3;
      confidentiality_offset_50_octets = 4;
    }
  }
  // Confidentiality Offset.
  // default = ConfidentialtyOffset.Enum.no_confidentiality_offset
  optional ConfidentialtyOffset.Enum confidentialty_offset = 1;

  message CipherSuite {
    enum Enum {
      unspecified = 0;
      gcm_aes_128 = 1;
      gcm_aes_256 = 2;
      gcm_aes_xpn_128 = 3;
      gcm_aes_xpn_256 = 4;
    }
  }
  // The cipher suite. Choose one from GCM-AES-128 GCM-AES-256 GCM-AES-XPN-128 GCM-AES-XPN-256
  // default = CipherSuite.Enum.gcm_aes_128
  optional CipherSuite.Enum cipher_suite = 2;

  // Starting Key Number.
  // default = 1
  optional uint32 starting_key_number = 3;

  // Starting Distributed AN.
  // default = 0
  optional uint32 starting_distributed_an = 4;

  // Determines the PN rekey threshold.
  // default = C0000000
  optional string rekey_threshold_pn = 5;

  // Determines the XPN rekey threshold.
  // default = C000000000000000
  optional string rekey_threshold_xpn = 6;
}

// A container of Tx properties.
message MkaTx {

  // Tx secure channels.
  repeated MkaTxSc secure_channels = 1;
}

// Tx secure channel(SC) properties.
message MkaTxSc {

  // Tx SC name.
  // required = true
  optional string name = 1;

  // System ID.
  // required = true
  optional string system_id = 2;

  // Port ID.
  // default = 1
  optional uint32 port_id = 3;

  // Starting Message Number.
  // default = 1
  optional uint64 starting_message_number = 4;
}

// A container of static key properties for a secure entity(SecY). This configuration
// is applicable when no dynamic key management protocol i.e. MACsec key agreement(MKA)
// is configured. If MKA is configured, any static key configuration is not applicable.
message SecureEntityStaticKey {

  message CipherSuite {
    enum Enum {
      unspecified = 0;
      gcm_aes_128 = 1;
      gcm_aes_256 = 2;
      gcm_aes_xpn_128 = 3;
      gcm_aes_xpn_256 = 4;
    }
  }
  // The cipher suite. Choose one from GCM-AES-128 GCM-AES-128 GCM-AES-256 GCM-AES-XPN-128
  // GCM-AES-XPN-256
  // default = CipherSuite.Enum.gcm_aes_128
  optional CipherSuite.Enum cipher_suite = 1;

  // Encrypt or not.
  // default = True
  optional bool confidentiality = 2;

  message ConfidentialityOffset {
    enum Enum {
      unspecified = 0;
      zero = 1;
      thirty = 2;
      fifty = 3;
    }
  }
  // Confidentiality offset.
  // default = ConfidentialityOffset.Enum.zero
  optional ConfidentialityOffset.Enum confidentiality_offset = 3;

  // Tx properties of SecY.
  SecureEntityStaticKeyTx tx = 4;

  // Rx properties of SecY.
  SecureEntityStaticKeyRx rx = 5;
}

// Rekey mode.
message SecureEntityStaticKeyRekeyMode {

  message Choice {
    enum Enum {
      unspecified = 0;
      dont_rekey = 1;
      timer_based = 2;
      pn_based = 3;
    }
  }
  // Rekey mode choices.
  // default = Choice.Enum.dont_rekey
  optional Choice.Enum choice = 1;

  // Container for timer based periodic rekey properties.
  SecureEntityStaticKeyRekeyModeTimerBased timer_based = 2;
}

// Timer based periodic rekey properties.
message SecureEntityStaticKeyRekeyModeTimerBased {

  message Choice {
    enum Enum {
      unspecified = 0;
      continuous = 1;
      fixed_count = 2;
    }
  }
  // Periodic rekey attempt choices.
  // default = Choice.Enum.continuous
  optional Choice.Enum choice = 1;

  // Fixed rekey attempts.
  // default = 10
  optional uint32 fixed_count = 2;

  // Periodic rekey interval (sec).
  // default = 300
  optional uint32 interval = 3;
}

// The container for SAK.
message SecureEntityStaticKeySak {

  // Secure association key(SAK) bits as hex string. Either 128 bits or 256 bits depending
  // on the chosen cipher suite.
  // default = F123456789ABCDEF0123456789ABCDEF
  optional string sak = 1;

  // 4 bytes short SCI(SSCI) used in case of XPN cipher suites.
  // default = 00000001
  optional string ssci = 2;

  // 12 bytes salt used in case of XPN cipher suites.
  // default = 000000000000000000000001
  optional string salt = 3;
}

// A container of static key Tx properties.
message SecureEntityStaticKeyTx {

  // Tx secure channels.
  repeated SecureEntityStaticKeyTxSc secure_channels = 1;

  // Description missing in models
  SecureEntityStaticKeyRekeyMode rekey_mode = 2;
}

// Tx SC setting for static key.
message SecureEntityStaticKeyTxSc {

  // System ID.
  optional string system_id = 1;

  // Port ID.
  // default = 1
  optional uint32 port_id = 2;

  // Tx SAK pool.
  repeated SecureEntityStaticKeySak saks = 3;
}

// A container of static key Rx properties.
message SecureEntityStaticKeyRx {

  // Rx secure channels.
  repeated SecureEntityStaticKeyRxSc secure_channels = 1;
}

// Rx SC settings.
message SecureEntityStaticKeyRxSc {

  // System ID in DUT SCI.
  optional string dut_sci_system_id = 1;

  // Port ID in DUT SCI.
  // default = 1
  optional uint32 dut_sci_port_id = 2;

  // DUT MSB of XPN. The 32 most significant bits of the XPN that DUT will be using to
  // construct the 64 bits XPN value when test starts.
  // default = 0
  optional uint32 dut_msb_xpn = 3;

  // Rx SAK pool.
  repeated SecureEntityStaticKeySak saks = 4;
}

// A container of properties for an OSPFv3 router.
message DeviceOspfv3Router {

  // OSPFv3 Router Id.
  Ospfv3RouterId router_id = 1;

  // List of OSPFv3 router instances for this router.
  repeated Ospfv3RouterInstance instances = 2;
}

// A container of properties for an OSPFv3 router instance and its interfaces and route
// ranges.
message Ospfv3RouterInstance {

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  optional string name = 1;

  // The time in seconds for LSA retransmission.
  // default = 5
  optional uint32 lsa_retransmit_time = 2;

  // The time in seconds required for LSA refresh.
  // default = 1800
  optional uint32 lsa_refresh_time = 3;

  // The gap in miliseconds between each Flood Link State Update burst.
  // default = 1000
  optional uint32 inter_burst_lsu_interval = 4;

  // Description missing in models
  Ospfv3GracefulRestart graceful_restart = 5;

  // Configuration for controlling storage of OSPFv3 learned LSAs received from the neighbors.
  // default = False
  optional bool store_lsa = 6;

  // Optional container for OSPFv3 router capabilities.
  Ospfv3Capabilities capabilities = 7;

  // List of OSPFv3 interfaces for this router.
  repeated Ospfv3Interface interfaces = 8;

  // Emulated OSPFv4 IPv6 routes.
  repeated Ospfv3V6RouteRange v6_routes = 9;
}

// Container for OSPFv3 Router ID configuration.
message Ospfv3RouterId {

  message Choice {
    enum Enum {
      unspecified = 0;
      auto = 1;
      custom = 2;
    }
  }
  // IP address of Router ID for this emulated OSPFv3 router.
  // - auto: When first IPv4 address on the router is attempted to be assigned as Router
  // ID.
  // If none are available for use, implementation should return an error.
  // - custom: When, Router ID needs to be configured different from first IPv4 address
  // of the router.
  // default = Choice.Enum.auto
  optional Choice.Enum choice = 1;

  // Router ID in IPv4 address format.
  optional string custom = 2;
}

// The OSPFv3 router optional attributes.
message Ospfv3Capabilities {

  // Set to indicate that the router acts as an Area Border Router.
  // default = False
  optional bool lsa_b_bit = 1;

  // Set to indicate that the router acts as an AS Boundary Router.
  // default = False
  optional bool lsa_e_bit = 2;
}

// Container of properties of OSPFv3 Graceful Retstart.
message Ospfv3GracefulRestart {

  // Support of Graceful Restart in Helper Mode.
  // default = False
  optional bool helper_mode = 1;
}

// Configuration for single OSPFv3 interface.
message Ospfv3Interface {

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  optional string name = 1;

  // The globally unique name of the IPv6 interface connected to the DUT.
  // 
  // x-constraint:
  // - /components/schemas/Device.Ipv6/properties/name
  // 
  // required = true
  optional string ipv6_name = 2;

  // The Area ID of the area to which the attached network belongs.
  // All routing protocol packets originating from the interface are
  // labelled with this Area ID.
  Ospfv3InterfaceArea area = 3;

  // The OSPF network link type.
  Ospfv3InterfaceNetworkType network_type = 4;

  // Optional container for advanced interface properties.
  Ospfv3InterfaceAdvanced advanced = 5;

  // Container for OSPFv3 optional interface properties.
  Ospfv3InterfaceOptions options = 6;

  // Enables multiple instances of OSPF to be run over a single link.
  // Each protocol instance should be assigned a separate Instance ID;
  // the Instance ID has link-local significance only.
  // default = 0
  optional uint32 instance_id = 7;
}

// Container for OSPFv3 Area ID identifies the routing area to which the host belongs.
// 
message Ospfv3InterfaceArea {

  message Choice {
    enum Enum {
      unspecified = 0;
      id = 1;
      ip = 2;
    }
  }
  // The OSPFv3 Area ID identifies the routing area to which the host belongs. Area ID
  // type can be following format.
  // - id: A 32-bit number identifying the area.
  // - ip: The Area ID in IPv4 address format.
  // default = Choice.Enum.id
  optional Choice.Enum choice = 1;

  // The Area ID.
  // default = 0
  optional uint32 id = 2;

  // The Area ID in IPv4 address format.
  optional string ip = 3;
}

// The OSPFv3 network link type options.
// - Broadcast
// - Point to Point
message Ospfv3InterfaceNetworkType {

  message Choice {
    enum Enum {
      unspecified = 0;
      broadcast = 1;
      point_to_point = 2;
    }
  }
  // Description missing in models
  // default = Choice.Enum.broadcast
  optional Choice.Enum choice = 1;

  // Capabilities associated with network type broadcast.
  Ospfv3InterfaceBroadcast broadcast = 2;
}

// Contains OSPFv3 advanced properties.
message Ospfv3InterfaceAdvanced {

  // The time interval, in seconds, between the Hello packets that
  // the router sends on the interface. Advertised in Hello packets
  // sent out this interface.
  // default = 10
  optional uint32 hello_interval = 1;

  // The time interval in seconds before the router's neighbors will declare
  // it down, when they stop hearing the router's Hello Packets.
  // Advertised in Hello packets sent out this interface.
  // default = 40
  optional uint32 dead_interval = 2;

  // The cost of transmitting data on this link.
  // default = 10
  optional uint32 link_metric = 3;

  // If this is set to true, then the MTU received from the neighbor during Database (DB)
  // Exchange
  // will be validated, otherwise it will be ignored.
  // 
  // default = True
  optional bool validate_received_mtu = 4;
}

// The Options field is present in OSPFv3 Hello packets, Database Description packets
// and all LSAs.
// The Options field enables OSPF routers to support (or not support) optional capabilities,
// and to
// communicate their capability level to other OSPF routers (https://datatracker.ietf.org/doc/html/rfc2740#appendix-A.2).
// When used in Hello packets, the Options field allows a router to reject a neighbor
// because of a capability mismatch.
message Ospfv3InterfaceOptions {

  // Demand Circuit: This bit describes the router's handling of demand circuits, as specified
  // in [Ref10], rfc2740.
  // default = False
  optional bool dc_bit = 1;

  // Router: This bit indicates if the originator is an active router.
  // default = True
  optional bool r_bit = 2;

  // NSSA Capability: This bit describes the handling of Type-7 LSAs, as specified in
  // [Ref8], rfc2740.
  // default = False
  optional bool n_bit = 3;

  // External Capability: This bit describes the router's willingness to receive and forward
  // External-Attributes-LSAs,  as specified in [Ref1], rfc2740.
  // default = True
  optional bool e_bit = 4;

  // V6: If set, the router/link should be included in IPv6 routing calculations.
  // default = True
  optional bool v6_bit = 5;
}

// Container for capabilities associated with network type broadcast.
message Ospfv3InterfaceBroadcast {

  // The Priority for (Backup) Designated Router election.
  // This value is used in Hello packets for the Designated Router (DR) election process.
  // The default is 0, which indicates that the router will not participate in the DR
  // election process.
  // default = 0
  optional uint32 priority = 1;
}

// Emulated OSPFv3 IPv6 routes.
message Ospfv3V6RouteRange {

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  optional string name = 1;

  // A list of group of IPv6 route addresses.
  repeated V6RouteAddress addresses = 2;

  // The user-defined metric associated with this route range.
  // default = 0
  optional uint32 metric = 3;

  // The type of the OSPFv3 routes.
  Ospfv3V6RRRouteOrigin route_origin = 4;
}

// Container of type of the OSPFv3 types correspond directly to the OSPFv3 LSAs types.
// 
message Ospfv3V6RRRouteOrigin {

  message Choice {
    enum Enum {
      unspecified = 0;
      intra_area = 1;
      inter_area = 2;
      external_type_1 = 3;
      external_type_2 = 4;
      nssa_external = 5;
    }
  }
  // Supported types are: - intra_area: for Intra-Area. - inter_area: for Inter Area.
  // - external_type_1: for Autonomous System (AS) External with internal AS metric. -
  // external_type_2: for Autonomous System (AS) External with internal and external AS
  // metric. - nssa_external: for type 7 Not-So-Stubby Area (NSSA) External.
  // default = Choice.Enum.inter_area
  optional Choice.Enum choice = 1;

  // Configuration for the type 7 Not-So-Stubby Area (NSSA) External.
  Ospfv3V6RRNssaExternal nssa_external = 2;
}

// Container for the forwarding address of NSSA External route origin configuration.
message Ospfv3V6RRNssaExternal {

  // Configuration for capabilities associated with route origin.
  Ospfv3V6RRCapabilities capabilities = 1;
}

// Container for the capabilities associated with route origin.
message Ospfv3V6RRCapabilities {

  // If set, LSAs will be propagated between Areas.
  // default = False
  optional bool propagation = 1;

  // Configuration for forwarding address of NSSA External route origin.
  Ospfv3V6RRForwardingAddress forwarding_address = 2;
}

// Container for the forwarding address of NSSA External route origin configuration.
message Ospfv3V6RRForwardingAddress {

  message Choice {
    enum Enum {
      unspecified = 0;
      interface_ip = 1;
      custom = 2;
    }
  }
  // IPv6 forwarding address of Type 7 LSA Not-So-Stubby Area (NSSA) External.
  // - interface_ip: if set, forwarding address is set with Interface IPv6 address.
  // - custom: if set, forwarding address is set with a custom IPv6 address.
  // default = Choice.Enum.interface_ip
  optional Choice.Enum choice = 1;

  // Forwarding address in IPv6 format.
  optional string custom = 2;
}

// Configuration for one or more IPv4 or IPv6 RoCEv2 Peers.
message DeviceRocev2Peer {

  // This contains an array of references to IPv4 interfaces, each having a list of IPv4
  // peers to various destinations.
  repeated Rocev2V4Interface ipv4_interfaces = 1;

  // This contains an array references to IPv6 interfaces, each with a list of IPv6 peers
  // for various destinations.
  repeated Rocev2V6Interface ipv6_interfaces = 2;
}

// This contains an array of references to IPv4 interfaces, each having a list of IPv4
// peers to various destinations.
message Rocev2V4Interface {

  // The unique name of the IPv4 interface, used as the source IP for this list of RoCEv2
  // peers.
  // 
  // x-constraint:
  // - /components/schemas/Device.Ipv4/properties/name
  // 
  // required = true
  optional string ipv4_name = 1;

  // The InfiniBand protocol defines several fixed sizes for the Maximum Transmission
  // Unit (IB MTU): 256, 512, 1024, 2048, or 4096 bytes. RDMA messages will have a payload
  // size that corresponds to the configured IB MTU. Additionally, it is possible to configure
  // a custom size.
  // default = 1024
  optional uint32 ib_mtu = 2;

  // This contains the list of RoCEv2 peers configured on this interface.
  repeated Rocev2V4Peer peers = 3;
}

// Configuration for RoCEv2 IPv4 peers.
message Rocev2V4Peer {

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  optional string name = 1;

  // Specify the destination ip address.
  // required = true
  optional string destination_ip_address = 2;

  // This allows the user to set  multiple QPs and its properties between a pair of source
  // and destination RoCEv2 devices.
  repeated Rocev2QPs qps = 3;
}

// This allows the user to set QP properties between a particular source and destination.
message Rocev2QPs {

  // Name of each QP.
  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  optional string qp_name = 1;

  // Description missing in models
  Rocev2ConnectionType connection_type = 2;
}

// Specifies the connection type for the QP, determining what and how the QP transfers
// data.
message Rocev2ConnectionType {

  message Choice {
    enum Enum {
      unspecified = 0;
      reliable_connection = 1;
    }
  }
  // Description missing in models
  // default = Choice.Enum.reliable_connection
  optional Choice.Enum choice = 1;

  // Description missing in models
  Rocev2QPParameters reliable_connection = 2;
}

// Defines the parameters for configuring a RoCEv2 QP.
message Rocev2QPParameters {

  // Configure Source QP number which initiates the RDMA operation.
  // default = 2
  optional uint32 source_qp_number = 1;

  // DSCP value for the RDMA data packets.
  // default = 24
  optional uint32 dscp = 2;

  message Ecn {
    enum Enum {
      unspecified = 0;
      non_ect = 1;
      ect_1 = 2;
      ect_0 = 3;
      ce = 4;
    }
  }
  // This field allows to configure bits of the Traffic Class field in the IPv4 or IPv6
  // header to encode four different code points. Those are non_ect, ect_1, ect_0 and
  // ce. non_ect quivalent is 00, ect_1 represent 01, ect_0 represent 10 and ce means
  // 11.
  // default = Ecn.Enum.ect_1
  optional Ecn.Enum ecn = 3;

  // UDP source port number for this QP.
  // default = 49152
  optional uint32 udp_source_port = 4;

  // Initial packet sequence number of the data transfer packet generated for this QP.
  // default = 0
  optional uint64 initial_psn = 5;

  // Virtual Address where the data transfer from the remote QP will write to.
  // default = 0000000000000000
  optional string virtual_address = 6;

  // Remote Key linked to the QP's virtual address.
  // default = 00000000
  optional string remote_key = 7;
}

// This contains an array of references to IPv6 interfaces, each having a list of IPv6
// peers to various destinations.
message Rocev2V6Interface {

  // The unique name of IPv6 used as the source IP for this list of RoCEv2 peers.
  // 
  // x-constraint:
  // - /components/schemas/Device.Ipv6/properties/name
  // 
  // required = true
  optional string ipv6_name = 1;

  // The InfiniBand protocol defines several fixed sizes for the Maximum Transmission
  // Unit (IB MTU): 256, 512, 1024, 2048, or 4096 bytes. RDMA messages will have a payload
  // size that corresponds to the configured IB MTU. Additionally, it is possible to configure
  // a custom size.
  // default = 1024
  optional uint32 ib_mtu = 2;

  // This contains the list of RoCEv2 IPv6 peers configured on this interface.
  repeated Rocev2V6Peer peers = 3;
}

// Configuration for RoCEv2 IPv6 peer settings.
message Rocev2V6Peer {

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  optional string name = 1;

  // Specify the destination ip address.
  // required = true
  optional string destination_ip_address = 2;

  // This allows the user to set  multiple QPs and its properties between a pair of source
  // and destination RoCEv2 devices.
  repeated Rocev2QPs qps = 3;
}

// Top-level container for BGP Monitoring Protocol (BMP) configuration. BMP, as defined
// in RFC 7854, provides a mechanism to monitor BGP sessions. This configuration pertains
// to the device when acting as a BMP Monitor /server, listening for connections from
// BGP speakers (routers) acting as BMP clients. BMP is unidirectional, meaning the
// monitoring station only receives information; it doesn't send commands to or control
// the monitored router.
message DeviceBmp {

  // This contains an array of references to IPv4 interfaces, each of which will have
  // one or more BMP Servers configured, each BMP Server will have a connection to a different
  // monitored router.
  repeated DeviceBmpV4Interface ipv4_interfaces = 1;

  // This contains an array of references to IPv6 interfaces, each of which will have
  // one or more BMP Servers configured, each BMP Server will have a connection to a different
  // monitored router.
  repeated DeviceBmpV6Interface ipv6_interfaces = 2;
}

// Configuration for BMP Servers on a single IPv4 interface.
message DeviceBmpV4Interface {

  // The unique name of the IPv4 interface used as the source IP for the BMP Server.
  // 
  // x-constraint:
  // - /components/schemas/Device.Ipv4/properties/name
  // 
  // required = true
  optional string ipv4_name = 1;

  // This contains the configuration of BMP Servers configured on this IPv4 interface.
  repeated DeviceBmpServerV4 servers = 2;
}

// Configuration for BMP Servers on a single IPv6 interface.
message DeviceBmpV6Interface {

  // The unique name of the IPv6 interface used as the source IP for BMP Server.
  // 
  // x-constraint:
  // - /components/schemas/Device.Ipv6/properties/name
  // 
  // required = true
  optional string ipv6_name = 1;

  // This contains the configuration of BMP Servers configured on this IPv6 interface.
  repeated DeviceBmpServerV6 servers = 2;
}

// Configuration for a BMP Server for a specific IPv4 BMP client.
message DeviceBmpServerV4 {

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  optional string name = 1;

  // The IPv4 address of the BMP client from which connections will be accepted from or
  // initiated with by this BMP Server.
  // required = true
  optional string client_ip = 2;

  // Optional object containing information about whether the BMP Server should operate
  // in passive or active mode and corresponding information depending on the mode.
  // 
  DeviceBmpServerConnection connection = 3;

  // Optional object containing information about whether IPv4 and IPv6 unicast prefixes
  // learned from the BMP client should be stored or not for future retrieval using get_states
  // and  exceptions to the configured choice for the same.  If the object is not included,
  // by default IPv4 and IPv6 unicast prefixes are not stored by the BMP server and only
  // received metrics are incremented on receipt of IPv4 / IPv6 unicast prefixes within
  // BMP Monitor messages.
  DeviceBmpServerPrefixStorage prefix_storage = 4;
}

// Configuration for a BMP Server connected to a specific IPv6 BMP client.
message DeviceBmpServerV6 {

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  optional string name = 1;

  // The IPv6 address of the BMP client from which connections will be accepted from or
  // initiated with by this BMP Server.
  // required = true
  optional string client_ip = 2;

  // Optional object containing information about whether the BMP Server should operate
  // in passive or active mode and corresponding information depending on the mode.
  // 
  DeviceBmpServerConnection connection = 3;

  // Optional object containing information about whether IPv4 and IPv6 unicast prefixes
  // learned from the BMP client should be stored or not for future retrieval using get_states
  // and  exceptions to the configured choice for the same.  If the object is not included,
  // by default IPv4 and IPv6 unicast prefixes are not stored by the BMP server and only
  // received metrics are incremented on receipt of IPv4 / IPv6 unicast prefixes within
  // BMP Monitor messages.
  DeviceBmpServerPrefixStorage prefix_storage = 4;
}

// Container of information about whether the BMP Server should operate in passive or
// active mode and corresponding information depending on the mode.
message DeviceBmpServerConnection {

  message Choice {
    enum Enum {
      unspecified = 0;
      passive = 1;
      active = 2;
    }
  }
  // Description missing in models
  // default = Choice.Enum.passive
  optional Choice.Enum choice = 1;

  // Description missing in models
  DeviceBmpServerPassiveConnection passive = 2;

  // Description missing in models
  DeviceBmpServerActiveConnection active = 3;
}

// Container of information when BMP Server is configured in passive mode. This means
// that BMP Server will not initiate the TCP connection but wait for the BMP client
// it is configured to accept connection from  to initiate the connection.  Note that
// in this case it is required to configure the BMP client in active mode otherwise
// BMP connection will not be intiated by either end.
message DeviceBmpServerPassiveConnection {

  // The TCP port number on which to listen for TCP connections from the remote BMP client
  // router.
  // default = 11019
  optional uint32 listen_port = 1;
}

// Container of information when BMP Server is configured in active mode. This means
// that BMP Server will initiate the TCP connection to the remote BMP client .
// Note that in this case it is required to configure the BMP client in passive mode
// for the BMP session to not be rejected from both ends.
message DeviceBmpServerActiveConnection {

  // The TCP port number on which to initiate BMP connection to the remote BMP client
  // router.
  // default = 11019
  optional uint32 remote_port = 1;
}

// Optional object containing information about whether IPv4 and IPv6 unicast prefixes
// learned from the BMP client should be stored or not for future retrieval using get_states
// and  exceptions to the configured choice for the same. If the object is not included,
// by default IPv4 and IPv6 Unicast Prefixes are not stored by the BMP server and only
// received metrics  are incremented on receipt of IPv4 / IPv6 Unicast routes via BMP
// Monitor messages.
message DeviceBmpServerPrefixStorage {

  // Optional object containing information about whether IPv4 unicast prefixes learned
  // from the BMP client should be stored or not for future retrieval using get_states
  // and  exceptions to the configured choice for the same. If the object is not included,
  // by default IPv4 unicast prefixes are not stored by the BMP server.
  DeviceBmpServerIpv4UnicastPrefixStorage ipv4_unicast = 1;

  // Optional object containing information about whether IPv6 unicast prefixes learned
  // from the BMP client should be stored or not for future retrieval using get_states
  // and  exceptions to the configured choice for the same. If the object is not included,
  // by default IPv6 unicast prefixes are not stored by the BMP server.
  DeviceBmpServerIpv6UnicastPrefixStorage ipv6_unicast = 2;
}

// Optional object containing information about whether IPv4 unicast prefixes learned
// from the BMP client should be stored or not for future retrieval using get_states
// and  exceptions to the configured choice for the same. If the object is not included,
// by default IPv4 unicast prefixes are not stored by the BMP server.
message DeviceBmpServerIpv4UnicastPrefixStorage {

  message Choice {
    enum Enum {
      unspecified = 0;
      discard = 1;
      store = 2;
    }
  }
  // Description missing in models
  // default = Choice.Enum.discard
  optional Choice.Enum choice = 1;

  // If this option is chosen, IPv4 unicast prefixes learned from the BMP client will
  // not be stored by the BMP server. Exception list can be used to create exceptions
  // to allow only some subset of the learned Ipv4 unicast prefixes to be stored while
  // the remaining learned prefixes are discarded. This can be useful when only some prefixes
  // need to be verified amongst a large number of learned prefixes.
  DeviceBmpServerIpv4UnicastPrefixDiscard discard = 2;

  // If this option is chosen, IPv4 unicast prefixes learned from the BMP client will
  // be stored by the BMP server. Exception list can be used to create exceptions to store
  // all the learned Ipv4 unicast prefixes except some subset of the learned IPv4 unicast
  // prefixes. This can be useful when only some prefixes need to be verified amongst
  // a large number of learned prefixes.
  DeviceBmpServerIpv4UnicastPrefixStore store = 3;
}

// The exception list can be used to specify exceptions to the specification to discard
// all IPv4 unicast prefixes. It is expected that when required, there would normally
// be a limited number of exceptions.
message DeviceBmpServerIpv4UnicastPrefixDiscard {

  // This contains an array of exceptions to the discard IPv4 unicast prefixes specification
  // i.e. prefixes matching the exceptions would be stored instead. One exception to the
  // specification is specified by a combination of an IPv4 prefix and a prefix length.
  // If the received prefix masked upto the exception's prefix length matches the prefix
  // specified in the exception, the received prefix is deemed as having matched the specified
  // exception e.g. received prefix 172.16.1.0/24 and 172.16.2.0/24 would match specified
  // exception of 172.16.0.0/16 but 172.0.0.0/8 or 192.16.2.0/24 would not.
  repeated DeviceBmpServerIpv4UnicastPrefixException exceptions = 1;
}

// The exception list can be used to specify exceptions to the specification to store
// all IPv4 unicast prefixes. It is expected that when required, there would normally
// be a limited number of exceptions.
message DeviceBmpServerIpv4UnicastPrefixStore {

  // This contains an array of exceptions to the store IPv4 unicast prefixes specification
  // i.e. prefixes matching the exceptions would be discarded instead. One exception to
  // the specification is specified by a combination of an IPv4 prefix and a prefix length.
  // If the received prefix masked upto the exception's prefix length matches the prefix
  // specified in the exception, the received prefix is deemed as having matched the specified
  // exception e.g. received prefix 172.16.1.0/24 and 172.16.2.0/24 would match specified
  // exception of 172.16.0.0/16 but 172.0.0.0/8 or 192.16.2.0/24 would not.
  repeated DeviceBmpServerIpv4UnicastPrefixException exceptions = 1;
}

// One exception to the specification is specified by a combination of an IPv4 prefix
// and a prefix length.  If the received prefix masked upto the exception's prefix length
// matches the prefix specified in the exception, the received prefix is deemed as having
// matched the specified exception e.g. received prefix 172.16.1.0/24 and 172.16.2.0/24
// would match specified exception of 172.16.0.0/16 but 172.0.0.0/8 or 192.16.2.0/24
// would not.
message DeviceBmpServerIpv4UnicastPrefixException {

  // The IPv4 prefix which, combined with the prefix_length, is used to determine if received
  // IPv4 unicast prefix matches this exception or not.
  // default = 0.0.0.0
  optional string ipv4_prefix = 1;

  // The prefix length which, combined with the ipv4_prefix, is used to determine if received
  // IPv4 unicast prefix matches this exception or not.
  // default = 16
  optional uint32 prefix_length = 2;
}

// Optional object containing information about whether IPv6 unicast prefixes learned
// from the BMP client should be stored or not for future retrieval using get_states
// and  exceptions to the configured choice for the same. If the object is not included,
// by default IPv6 unicast prefixes are not stored by the BMP server.
message DeviceBmpServerIpv6UnicastPrefixStorage {

  message Choice {
    enum Enum {
      unspecified = 0;
      discard = 1;
      store = 2;
    }
  }
  // Description missing in models
  // default = Choice.Enum.discard
  optional Choice.Enum choice = 1;

  // If this option is chosen, IPv6 unicast prefixes learned from the BMP client will
  // not be stored by the BMP server. Exception list can be used to create exceptions
  // to allow only some subset of the learned IPv6 unicast prefixes to be stored while
  // the remaining learned prefixes are discarded. This can be useful when only some prefixes
  // need to be verified amongst a large number of learned prefixes.
  DeviceBmpServerIpv6UnicastPrefixDiscard discard = 2;

  // If this option is chosen, IPv6 unicast prefixes learned from the BMP client will
  // be stored by the BMP server. Exception list can be used to create exceptions to store
  // all the learned Ipv6 unicast prefixes except some subset of the learned IPv6 unicast
  // prefixes. This can be useful when only some prefixes need to be verified amongst
  // a large number of learned prefixes.
  DeviceBmpServerIpv6UnicastPrefixStore store = 3;
}

// The exception list can be used to specify exceptions to the specification to discard
// all IPv6 unicast prefixes. It is expected that when required, there would normally
// be a limited number of exceptions.
message DeviceBmpServerIpv6UnicastPrefixDiscard {

  // This contains an array of exceptions to the discard IPv6 unicast prefixes specification
  // i.e. prefixes matching the exceptions would be stored instead. One exception to the
  // specification is specified by a combination of an IPv6 prefix and a prefix length.
  // If the received prefix masked upto the exception's prefix length matches the prefix
  // specified in the exception, the received prefix is deemed as having matched the specified
  // exception e.g. received prefix 1:1:1:1::/64  and 1:1:1:2::/64 would match specified
  // exception of 1:1:1::/48 but 1:1::/16 or 2:2:2:2::/64 would not.
  repeated DeviceBmpServerIpv6UnicastPrefixException exceptions = 1;
}

// The exception list can be used to specify exceptions to the specification to store
// all IPv6 unicast prefixes. It is expected that when required, there would normally
// be a limited number of exceptions.
message DeviceBmpServerIpv6UnicastPrefixStore {

  // This contains an array of exceptions to the store IPv6 unicast prefixes specification
  // i.e. prefixes matching the exceptions would be discarded instead. One exception to
  // the specification is specified by a combination of an IPv6 prefix and a prefix length.
  // If the received prefix masked upto the exception's prefix length matches the prefix
  // specified in the exception, the received prefix is deemed as having matched the specified
  // exception e.g. received prefix 1:1:1:1::/64  and 1:1:1:2::/64 would match specified
  // exception of 1:1:1::/48 but 1:1::/16 or 2:2:2:2::/64 would not.
  repeated DeviceBmpServerIpv6UnicastPrefixException exceptions = 1;
}

// One exception to the specification is specified by a combination of an IPv6 prefix
// and a prefix length.  If the received prefix masked upto the exception's prefix length
// matches the prefix specified in the exception, the received prefix is deemed as having
// matched the specified exception e.g. received prefix 1:1:1:1::/64  and 1:1:1:2::/64
// would match specified exception of 1:1:1::/48 but 1:1::/16 or 2:2:2:2::/64 would
// not.
message DeviceBmpServerIpv6UnicastPrefixException {

  // The IPv6 prefix which, combined with the prefix_length, is used to determine if received
  // IPv6 unicast prefix matches this exception or not.
  // default = ::
  optional string ipv6_prefix = 1;

  // The prefix length which, combined with the ipv6_prefix, is used to determine if received
  // IPv6 unicast prefix matches this exception or not.
  // default = 48
  optional uint32 prefix_length = 2;
}

// A high level data plane traffic flow.
message Flow {

  // The transmit and receive endpoints.
  // required = true
  FlowTxRx tx_rx = 1;

  // The list of protocol headers defining the shape of all
  // intended packets in corresponding flow as it is transmitted
  // by traffic-generator port.
  // 
  // The order of protocol headers assigned to the list is the
  // order they will appear on the wire.
  // 
  // In the case of an empty list the keyword/value of minItems: 1
  // indicates that an implementation MUST provide at least one
  // Flow.Header object.
  // 
  // The default value for the Flow.Header choice property is ethernet
  // which will result in an implementation by default providing at least
  // one ethernet packet header.
  repeated FlowHeader packet = 2;

  // Under Review: The packet header schema for egress tracking currently exposes unwanted
  // fields. The query structure for tagged metrics inside flows metrics requires documenting
  // expected response format.
  // 
  // The list of protocol headers defining the shape of all
  // intended packets in corresponding flow as it is received
  // by traffic-generator port.
  // 
  // For all protocol headers, only the `metric_tags` property is configurable.
  repeated FlowHeader egress_packet = 9;

  // The size of the packets.
  FlowSize size = 3;

  // The transmit rate of the packets.
  FlowRate rate = 4;

  // The transmit duration of the packets.
  FlowDuration duration = 5;

  // Flow metrics.
  FlowMetrics metrics = 6;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  optional string name = 7;

  // The pattern of the bytes in the transmitted frames for the flow after the protocol
  // headers.
  FlowPayload payload = 8;
}

// A container for different types of transmit and receive
// endpoint containers.
message FlowTxRx {

  message Choice {
    enum Enum {
      unspecified = 0;
      port = 1;
      device = 2;
    }
  }
  // The type of transmit and receive container used by the flow.
  // default = Choice.Enum.port
  optional Choice.Enum choice = 1;

  // Description missing in models
  FlowPort port = 2;

  // Description missing in models
  FlowRouter device = 3;
}

// A container for a transmit port and 0..n intended receive ports.
// When assigning this container to a flow the flows's
// packet headers will not be populated with any address resolution
// information such as source and/or destination addresses.
// For example Flow.Ethernet dst mac address values will be defaulted to 0.
// For full control over the Flow.properties.packet header contents use this
// container.
message FlowPort {

  // The unique name of a port that is the transmit port.
  // 
  // x-constraint:
  // - /components/schemas/Port/properties/name
  // - /components/schemas/Lag/properties/name
  // 
  // required = true
  optional string tx_name = 1;

  // Deprecated: This property is deprecated in favor of property rx_names
  // 
  // The unique name of a port that is the intended receive port.
  // 
  // x-constraint:
  // - /components/schemas/Port/properties/name
  // - /components/schemas/Lag/properties/name
  // 
  optional string rx_name = 2;

  // Unique name of ports or lags that are intended receive endpoints.
  // 
  // x-constraint:
  // - /components/schemas/Port/properties/name
  // - /components/schemas/Lag/properties/name
  // 
  repeated string rx_names = 3;
}

// A container for declaring a map of 1..n transmit devices to 1..n receive devices.
// This allows for a single flow to have  different tx to rx device flows such as a
// single one to one map or a  many to many map.
message FlowRouter {

  message Mode {
    enum Enum {
      unspecified = 0;
      mesh = 1;
      one_to_one = 2;
    }
  }
  // Determines the intent of creating traffic sub-flow(s) between the device
  // endpoints, from the entities of <b>tx_names</b> to the entities of <b>rx_names</b>
  // 
  // to derive how <b>auto</b> packet fields can be populated with
  // the actual value(s) by the implementation.
  // 
  // The <b>one_to_one</b> mode creates traffic sub-flow(s) between each device endpoint
  // pair in
  // tx_names to rx_names by index.
  // The length of tx_names and rx_names MUST be the same.
  // The same device name can be repeated multiple times in tx_names or rx_names, in any
  // order to create desired meshing between device(s).
  // For 2 values in tx_names and 2 values in rx_names, 2 device endpoint pairs would
  // be generated (each pair representing a traffic sub-flow).
  // 
  // The <b>mesh</b> mode creates traffic sub-flow(s) between each value in tx_names to
  // every value in rx_names, forming the device endpoint pair(s).
  // For 2 values in tx_names and 3 values in rx_names, generated device endpoint pairs
  // would be 2x3=6.
  // 
  // A generated device endpoint pair with same device endpoint name for both transmit
  // & receive device endpoint MUST raise an error.
  // 
  // Packet fields of type <b>auto</b> would be populated with one value for each device
  // endpoint pair (representing the traffic sub-flow).
  // The value would be determined considering transmit & receive device of the sub-flow.
  // And the sequence of the populated value(s)
  // would be in the order of generated device endpoint pair(s).
  // If 2 device endpoint pairs are generated (based on mode, tx_names and rx_names),
  // say (d1 to d3) and (d2 to d3), and ethernet.dst is set as <b>auto</b>, then
  // the auto field would be <b>replaced</b> by the implementation with a sequence of
  // 2 values, [v1,v2] where
  // v1 is determined using context (d1,d3) and v2 using context (d2,d3).
  // The final outcome is that packets generated on the wire will contain the values v1,v2,v1,...
  // for ethernet.dst field. Any non-auto packet fields
  // should be configured accordingly. For example, non-auto packet field ethernet.src
  // can be configured with values [u1, u2], where
  // u1 & u2 are source MAC of the connected interface of device d1 and d2 respectively.
  // Then packets on the wire will contain correct value pairs
  // (u1,v1),(u2,v2),(u1,v1),... for (ethernet.src,ethernet.dst) fields.
  // default = Mode.Enum.mesh
  optional Mode.Enum mode = 1;

  // TBD
  // 
  // x-constraint:
  // - /components/schemas/Device.Ethernet/properties/name
  // - /components/schemas/Device.Ipv4/properties/name
  // - /components/schemas/Device.Ipv6/properties/name
  // - /components/schemas/Bgp.V4RouteRange/properties/name
  // - /components/schemas/Bgp.V6RouteRange/properties/name
  // - /components/schemas/Bgp.CMacIpRange/properties/name
  // - /components/schemas/Rsvp.LspIpv4Interface.P2PIngressIpv4Lsp/properties/name
  // - /components/schemas/Isis.V4RouteRange/properties/name
  // - /components/schemas/Isis.V6RouteRange/properties/name
  // - /components/schemas/Ospfv2.V4RouteRange/properties/name
  // - /components/schemas/Ospfv3.V6RouteRange/properties/name
  // - /components/schemas/Device.Dhcpv4client/properties/name
  // - /components/schemas/Device.Dhcpv6client/properties/name
  // 
  repeated string tx_names = 2;

  // TBD
  // 
  // x-constraint:
  // - /components/schemas/Device.Ethernet/properties/name
  // - /components/schemas/Device.Ipv4/properties/name
  // - /components/schemas/Device.Ipv6/properties/name
  // - /components/schemas/Bgp.V4RouteRange/properties/name
  // - /components/schemas/Bgp.V6RouteRange/properties/name
  // - /components/schemas/Bgp.CMacIpRange/properties/name
  // - /components/schemas/Rsvp.LspIpv4Interface.P2PEgressIpv4Lsp/properties/name
  // - /components/schemas/Isis.V4RouteRange/properties/name
  // - /components/schemas/Isis.V6RouteRange/properties/name
  // - /components/schemas/Device.Dhcpv4client/properties/name
  // - /components/schemas/Ospfv2.V4RouteRange/properties/name
  // - /components/schemas/Ospfv3.V6RouteRange/properties/name
  // - /components/schemas/Device.Dhcpv6client/properties/name
  // 
  repeated string rx_names = 3;
}

// Configuration for all traffic packet headers
message FlowHeader {

  message Choice {
    enum Enum {
      unspecified = 0;
      custom = 1;
      ethernet = 2;
      vlan = 3;
      vxlan = 4;
      ipv4 = 5;
      ipv6 = 6;
      pfcpause = 7;
      ethernetpause = 8;
      tcp = 9;
      udp = 10;
      gre = 11;
      gtpv1 = 12;
      gtpv2 = 13;
      arp = 14;
      icmp = 15;
      icmpv6 = 16;
      ppp = 17;
      igmpv1 = 18;
      mpls = 19;
      snmpv2c = 20;
      rsvp = 21;
      macsec = 22;
      lacp = 23;
      ipv6_extension_header = 24;
    }
  }
  // The available types of flow headers. If one is not provided the
  // default ethernet packet header MUST be provided.
  // default = Choice.Enum.ethernet
  optional Choice.Enum choice = 1;

  // Description missing in models
  FlowCustom custom = 2;

  // Description missing in models
  FlowEthernet ethernet = 3;

  // Description missing in models
  FlowVlan vlan = 4;

  // Description missing in models
  FlowVxlan vxlan = 5;

  // Description missing in models
  FlowIpv4 ipv4 = 6;

  // Description missing in models
  FlowIpv6 ipv6 = 7;

  // Description missing in models
  FlowPfcPause pfcpause = 8;

  // Description missing in models
  FlowEthernetPause ethernetpause = 9;

  // Description missing in models
  FlowTcp tcp = 10;

  // Description missing in models
  FlowUdp udp = 11;

  // Description missing in models
  FlowGre gre = 12;

  // Description missing in models
  FlowGtpv1 gtpv1 = 13;

  // Description missing in models
  FlowGtpv2 gtpv2 = 14;

  // Description missing in models
  FlowArp arp = 15;

  // Description missing in models
  FlowIcmp icmp = 16;

  // Description missing in models
  FlowIcmpv6 icmpv6 = 17;

  // Description missing in models
  FlowPpp ppp = 18;

  // Description missing in models
  FlowIgmpv1 igmpv1 = 19;

  // Description missing in models
  FlowMpls mpls = 20;

  // Description missing in models
  FlowSnmpv2c snmpv2c = 21;

  // Description missing in models
  FlowRsvp rsvp = 22;

  // Description missing in models
  FlowMacsec macsec = 23;

  // Description missing in models
  FlowLacp lacp = 24;

  // Description missing in models
  FlowIpv6ExtHeader ipv6_extension_header = 25;
}

// Custom packet header
message FlowCustom {

  // A custom packet header defined as a string of hex bytes. The string MUST contain
  // sequence of valid hex bytes. Spaces or colons can be part of the bytes but will be
  // discarded. This packet header can be used in multiple places in the packet.
  // required = true
  optional string bytes = 1;

  // One or more metric tags can be used to enable tracking portion of or all bits
  // in a corresponding header field for metrics per each applicable value.
  // These would appear as tagged metrics in corresponding flow metrics.
  repeated FlowCustomMetricTag metric_tags = 2;
}

// Metric Tag can be used to enable tracking portion of or all bits
// in a corresponding header field for metrics per each applicable value.
// These would appear as tagged metrics in corresponding flow metrics.
message FlowCustomMetricTag {

  // Name used to identify the metrics associated with the values applicable
  // for configured offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset
  // of corresponding header field
  // default = 1
  optional uint32 length = 3;
}

// Ethernet packet header
message FlowEthernet {

  // Description missing in models
  PatternFlowEthernetDst dst = 1;

  // Description missing in models
  PatternFlowEthernetSrc src = 2;

  // Description missing in models
  PatternFlowEthernetEtherType ether_type = 3;

  // Description missing in models
  PatternFlowEthernetPfcQueue pfc_queue = 4;
}

// VLAN packet header
message FlowVlan {

  // Description missing in models
  PatternFlowVlanPriority priority = 1;

  // Description missing in models
  PatternFlowVlanCfi cfi = 2;

  // Description missing in models
  PatternFlowVlanId id = 3;

  // Description missing in models
  PatternFlowVlanTpid tpid = 4;
}

// VXLAN packet header
message FlowVxlan {

  // Description missing in models
  PatternFlowVxlanFlags flags = 1;

  // Description missing in models
  PatternFlowVxlanReserved0 reserved0 = 2;

  // Description missing in models
  PatternFlowVxlanVni vni = 3;

  // Description missing in models
  PatternFlowVxlanReserved1 reserved1 = 4;
}

// IPv4 packet header
message FlowIpv4 {

  // Description missing in models
  PatternFlowIpv4Version version = 1;

  // Description missing in models
  PatternFlowIpv4HeaderLength header_length = 2;

  // Description missing in models
  FlowIpv4Priority priority = 3;

  // Description missing in models
  PatternFlowIpv4TotalLength total_length = 4;

  // Description missing in models
  PatternFlowIpv4Identification identification = 5;

  // Description missing in models
  PatternFlowIpv4Reserved reserved = 6;

  // Description missing in models
  PatternFlowIpv4DontFragment dont_fragment = 7;

  // Description missing in models
  PatternFlowIpv4MoreFragments more_fragments = 8;

  // Description missing in models
  PatternFlowIpv4FragmentOffset fragment_offset = 9;

  // Description missing in models
  PatternFlowIpv4TimeToLive time_to_live = 10;

  // Description missing in models
  PatternFlowIpv4Protocol protocol = 11;

  // Description missing in models
  PatternFlowIpv4HeaderChecksum header_checksum = 12;

  // Description missing in models
  PatternFlowIpv4Src src = 13;

  // Description missing in models
  PatternFlowIpv4Dst dst = 14;

  // Description missing in models
  repeated FlowIpv4Options options = 15;
}

// IPv4 options are optional extensions for the IPv4 header that can be utilised to
// provide additional information about the IPv4 datagram.  It is encoded as a series
// of type, length and value attributes.  The IP header length MUST be increased to
// accommodate the extra bytes needed to encode the IP options. The length of the all
// options included to a IPv4 header should not exceed 40 bytes since IPv4 Header length
// (4 bits) can at max specify 15 4-word octets for a total of 60 bytes which includes
// 20 bytes needed for mandatory attributes of the IPv4 header. If the user adds multiples
// IPv4 options that exceeds 40 bytes and specify header length as auto, implementation
// should throw error. Currently IP options supported are: 1. router_alert option allows
// devices to intercept packets not addressed to them directly as defined in RFC2113.
// 2. custom option is provided to configure user defined IP options as needed.
message FlowIpv4Options {

  message Choice {
    enum Enum {
      unspecified = 0;
      router_alert = 1;
      custom = 2;
    }
  }
  // Description missing in models
  // default = Choice.Enum.router_alert
  optional Choice.Enum choice = 1;

  // Description missing in models
  FlowIpv4OptionsCustom custom = 2;
}

// User defined IP options to be appended to the IPv4 header.
message FlowIpv4OptionsCustom {

  // Description missing in models
  FlowIpv4OptionsCustomType type = 1;

  // Description missing in models
  FlowIpv4OptionsCustomLength length = 2;

  // Value of the option field should not excced 38 bytes since maximum 40 bytes can be
  // added as options in IPv4 header. For type and length requires 2 bytes, hence maximum
  // of 38 bytes are expected. Maximum length of this attribute is 76 (38 * 2 hex character
  // per byte).
  // default = 0000
  optional string value = 3;
}

// Type options for custom options.
message FlowIpv4OptionsCustomType {

  // Description missing in models
  PatternFlowIpv4OptionsCustomTypeCopiedFlag copied_flag = 1;

  // Description missing in models
  PatternFlowIpv4OptionsCustomTypeOptionClass option_class = 2;

  // Description missing in models
  PatternFlowIpv4OptionsCustomTypeOptionNumber option_number = 3;
}

// Length for custom options.
message FlowIpv4OptionsCustomLength {

  message Choice {
    enum Enum {
      unspecified = 0;
      auto = 1;
      value = 2;
    }
  }
  // auto or configured value.
  // default = Choice.Enum.auto
  optional Choice.Enum choice = 1;

  // The OTG implementation can provide a system generated value for this property. If
  // the OTG is unable to generate a value the default value must be used.
  // default = 0
  optional uint32 auto = 2;

  // Description missing in models
  // default = 0
  optional uint32 value = 3;
}

// A container for ipv4 raw, tos, dscp ip priorities.
message FlowIpv4Priority {

  message Choice {
    enum Enum {
      unspecified = 0;
      raw = 1;
      tos = 2;
      dscp = 3;
    }
  }
  // Description missing in models
  // default = Choice.Enum.dscp
  optional Choice.Enum choice = 1;

  // Description missing in models
  PatternFlowIpv4PriorityRaw raw = 2;

  // Description missing in models
  FlowIpv4Tos tos = 3;

  // Description missing in models
  FlowIpv4Dscp dscp = 4;
}

// Differentiated services code point (DSCP) packet field.
message FlowIpv4Dscp {

  // Description missing in models
  PatternFlowIpv4DscpPhb phb = 1;

  // Description missing in models
  PatternFlowIpv4DscpEcn ecn = 2;
}

// Type of service (TOS) packet field.
message FlowIpv4Tos {

  // Description missing in models
  PatternFlowIpv4TosPrecedence precedence = 1;

  // Description missing in models
  PatternFlowIpv4TosDelay delay = 2;

  // Description missing in models
  PatternFlowIpv4TosThroughput throughput = 3;

  // Description missing in models
  PatternFlowIpv4TosReliability reliability = 4;

  // Description missing in models
  PatternFlowIpv4TosMonetary monetary = 5;

  // Description missing in models
  PatternFlowIpv4TosUnused unused = 6;
}

// The OTG implementation can provide a system generated, value for this property.
message FlowIpv4Auto {

  message Choice {
    enum Enum {
      unspecified = 0;
      dhcp = 1;
    }
  }
  // The method to be used to provide the system generated value.
  // 
  // The dhcp option populates the field based on the dynamic IPv4 address that has been
  // assigned to the DHCPv4 client by a DHCPv4 server.
  // required = true
  optional Choice.Enum choice = 1;
}

// IPv6 packet header
message FlowIpv6 {

  // Description missing in models
  PatternFlowIpv6Version version = 1;

  // Description missing in models
  PatternFlowIpv6TrafficClass traffic_class = 2;

  // Description missing in models
  PatternFlowIpv6FlowLabel flow_label = 3;

  // Description missing in models
  PatternFlowIpv6PayloadLength payload_length = 4;

  // Description missing in models
  PatternFlowIpv6NextHeader next_header = 5;

  // Description missing in models
  PatternFlowIpv6HopLimit hop_limit = 6;

  // Description missing in models
  PatternFlowIpv6Src src = 7;

  // Description missing in models
  PatternFlowIpv6Dst dst = 8;
}

// The OTG implementation can provide a system generated, value for this property.
message FlowIpv6Auto {

  message Choice {
    enum Enum {
      unspecified = 0;
      dhcp = 1;
    }
  }
  // The method to be used to provide the system generated value.
  // The dhcp option populates the field based on the dynamic IPv6 address that has been
  // assigned to the DHCPv6 client
  // by a DHCPv6 server.
  // required = true
  optional Choice.Enum choice = 1;
}

// IEEE 802.1Qbb PFC Pause packet header.
message FlowPfcPause {

  // Description missing in models
  PatternFlowPfcPauseDst dst = 1;

  // Description missing in models
  PatternFlowPfcPauseSrc src = 2;

  // Description missing in models
  PatternFlowPfcPauseEtherType ether_type = 3;

  // Description missing in models
  PatternFlowPfcPauseControlOpCode control_op_code = 4;

  // Description missing in models
  PatternFlowPfcPauseClassEnableVector class_enable_vector = 5;

  // Description missing in models
  PatternFlowPfcPausePauseClass0 pause_class_0 = 6;

  // Description missing in models
  PatternFlowPfcPausePauseClass1 pause_class_1 = 7;

  // Description missing in models
  PatternFlowPfcPausePauseClass2 pause_class_2 = 8;

  // Description missing in models
  PatternFlowPfcPausePauseClass3 pause_class_3 = 9;

  // Description missing in models
  PatternFlowPfcPausePauseClass4 pause_class_4 = 10;

  // Description missing in models
  PatternFlowPfcPausePauseClass5 pause_class_5 = 11;

  // Description missing in models
  PatternFlowPfcPausePauseClass6 pause_class_6 = 12;

  // Description missing in models
  PatternFlowPfcPausePauseClass7 pause_class_7 = 13;
}

// IEEE 802.3x global ethernet pause packet header
message FlowEthernetPause {

  // Description missing in models
  PatternFlowEthernetPauseDst dst = 1;

  // Description missing in models
  PatternFlowEthernetPauseSrc src = 2;

  // Description missing in models
  PatternFlowEthernetPauseEtherType ether_type = 3;

  // Description missing in models
  PatternFlowEthernetPauseControlOpCode control_op_code = 4;

  // Description missing in models
  PatternFlowEthernetPauseTime time = 5;
}

// TCP packet header
message FlowTcp {

  // Description missing in models
  PatternFlowTcpSrcPort src_port = 1;

  // Description missing in models
  PatternFlowTcpDstPort dst_port = 2;

  // Description missing in models
  PatternFlowTcpSeqNum seq_num = 3;

  // Description missing in models
  PatternFlowTcpAckNum ack_num = 4;

  // Description missing in models
  PatternFlowTcpDataOffset data_offset = 5;

  // Description missing in models
  PatternFlowTcpEcnNs ecn_ns = 6;

  // Description missing in models
  PatternFlowTcpEcnCwr ecn_cwr = 7;

  // Description missing in models
  PatternFlowTcpEcnEcho ecn_echo = 8;

  // Description missing in models
  PatternFlowTcpCtlUrg ctl_urg = 9;

  // Description missing in models
  PatternFlowTcpCtlAck ctl_ack = 10;

  // Description missing in models
  PatternFlowTcpCtlPsh ctl_psh = 11;

  // Description missing in models
  PatternFlowTcpCtlRst ctl_rst = 12;

  // Description missing in models
  PatternFlowTcpCtlSyn ctl_syn = 13;

  // Description missing in models
  PatternFlowTcpCtlFin ctl_fin = 14;

  // Description missing in models
  PatternFlowTcpWindow window = 15;

  // Description missing in models
  PatternFlowTcpChecksum checksum = 16;
}

// UDP packet header
message FlowUdp {

  // Description missing in models
  PatternFlowUdpSrcPort src_port = 1;

  // Description missing in models
  PatternFlowUdpDstPort dst_port = 2;

  // Description missing in models
  PatternFlowUdpLength length = 3;

  // Description missing in models
  PatternFlowUdpChecksum checksum = 4;
}

// Standard GRE packet header (RFC2784)
message FlowGre {

  // Description missing in models
  PatternFlowGreChecksumPresent checksum_present = 1;

  // Description missing in models
  PatternFlowGreReserved0 reserved0 = 2;

  // Description missing in models
  PatternFlowGreVersion version = 3;

  // Description missing in models
  PatternFlowGreProtocol protocol = 4;

  // Description missing in models
  PatternFlowGreChecksum checksum = 5;

  // Description missing in models
  PatternFlowGreReserved1 reserved1 = 6;
}

// GTPv1 packet header
message FlowGtpv1 {

  // Description missing in models
  PatternFlowGtpv1Version version = 1;

  // Description missing in models
  PatternFlowGtpv1ProtocolType protocol_type = 2;

  // Description missing in models
  PatternFlowGtpv1Reserved reserved = 3;

  // Description missing in models
  PatternFlowGtpv1EFlag e_flag = 4;

  // Description missing in models
  PatternFlowGtpv1SFlag s_flag = 5;

  // Description missing in models
  PatternFlowGtpv1PnFlag pn_flag = 6;

  // Description missing in models
  PatternFlowGtpv1MessageType message_type = 7;

  // Description missing in models
  PatternFlowGtpv1MessageLength message_length = 8;

  // Description missing in models
  PatternFlowGtpv1Teid teid = 9;

  // Description missing in models
  PatternFlowGtpv1SquenceNumber squence_number = 10;

  // Description missing in models
  PatternFlowGtpv1NPduNumber n_pdu_number = 11;

  // Description missing in models
  PatternFlowGtpv1NextExtensionHeaderType next_extension_header_type = 12;

  // A list of optional extension headers.
  repeated FlowGtpExtension extension_headers = 13;
}

// Description missing in models
message FlowGtpExtension {

  // Description missing in models
  PatternFlowGtpExtensionExtensionLength extension_length = 1;

  // Description missing in models
  PatternFlowGtpExtensionContents contents = 2;

  // Description missing in models
  PatternFlowGtpExtensionNextExtensionHeader next_extension_header = 3;
}

// GTPv2 packet header
message FlowGtpv2 {

  // Description missing in models
  PatternFlowGtpv2Version version = 1;

  // Description missing in models
  PatternFlowGtpv2PiggybackingFlag piggybacking_flag = 2;

  // Description missing in models
  PatternFlowGtpv2TeidFlag teid_flag = 3;

  // Description missing in models
  PatternFlowGtpv2Spare1 spare1 = 4;

  // Description missing in models
  PatternFlowGtpv2MessageType message_type = 5;

  // Description missing in models
  PatternFlowGtpv2MessageLength message_length = 6;

  // Description missing in models
  PatternFlowGtpv2Teid teid = 7;

  // Description missing in models
  PatternFlowGtpv2SequenceNumber sequence_number = 8;

  // Description missing in models
  PatternFlowGtpv2Spare2 spare2 = 9;
}

// ARP packet header
message FlowArp {

  // Description missing in models
  PatternFlowArpHardwareType hardware_type = 1;

  // Description missing in models
  PatternFlowArpProtocolType protocol_type = 2;

  // Description missing in models
  PatternFlowArpHardwareLength hardware_length = 3;

  // Description missing in models
  PatternFlowArpProtocolLength protocol_length = 4;

  // Description missing in models
  PatternFlowArpOperation operation = 5;

  // Description missing in models
  PatternFlowArpSenderHardwareAddr sender_hardware_addr = 6;

  // Description missing in models
  PatternFlowArpSenderProtocolAddr sender_protocol_addr = 7;

  // Description missing in models
  PatternFlowArpTargetHardwareAddr target_hardware_addr = 8;

  // Description missing in models
  PatternFlowArpTargetProtocolAddr target_protocol_addr = 9;
}

// ICMP packet header
message FlowIcmp {

  message Choice {
    enum Enum {
      unspecified = 0;
      echo = 1;
    }
  }
  // Description missing in models
  // default = Choice.Enum.echo
  optional Choice.Enum choice = 1;

  // Description missing in models
  FlowIcmpEcho echo = 2;
}

// Packet Header for ICMP echo request
message FlowIcmpEcho {

  // Description missing in models
  PatternFlowIcmpEchoType type = 1;

  // Description missing in models
  PatternFlowIcmpEchoCode code = 2;

  // Description missing in models
  PatternFlowIcmpEchoChecksum checksum = 3;

  // Description missing in models
  PatternFlowIcmpEchoIdentifier identifier = 4;

  // Description missing in models
  PatternFlowIcmpEchoSequenceNumber sequence_number = 5;
}

// ICMPv6 packet header
message FlowIcmpv6 {

  message Choice {
    enum Enum {
      unspecified = 0;
      echo = 1;
    }
  }
  // Description missing in models
  // default = Choice.Enum.echo
  optional Choice.Enum choice = 1;

  // Description missing in models
  FlowIcmpv6Echo echo = 2;
}

// Packet Header for ICMPv6 Echo
message FlowIcmpv6Echo {

  // Description missing in models
  PatternFlowIcmpv6EchoType type = 1;

  // Description missing in models
  PatternFlowIcmpv6EchoCode code = 2;

  // Description missing in models
  PatternFlowIcmpv6EchoIdentifier identifier = 3;

  // Description missing in models
  PatternFlowIcmpv6EchoSequenceNumber sequence_number = 4;

  // Description missing in models
  PatternFlowIcmpv6EchoChecksum checksum = 5;
}

// PPP packet header
message FlowPpp {

  // Description missing in models
  PatternFlowPppAddress address = 1;

  // Description missing in models
  PatternFlowPppControl control = 2;

  // Description missing in models
  PatternFlowPppProtocolType protocol_type = 3;
}

// IGMPv1 packet header
message FlowIgmpv1 {

  // Description missing in models
  PatternFlowIgmpv1Version version = 1;

  // Description missing in models
  PatternFlowIgmpv1Type type = 2;

  // Description missing in models
  PatternFlowIgmpv1Unused unused = 3;

  // Description missing in models
  PatternFlowIgmpv1Checksum checksum = 4;

  // Description missing in models
  PatternFlowIgmpv1GroupAddress group_address = 5;
}

// MPLS packet header; When configuring multiple such headers, the count shall not exceed
// 20.
message FlowMpls {

  // Description missing in models
  PatternFlowMplsLabel label = 1;

  // Description missing in models
  PatternFlowMplsTrafficClass traffic_class = 2;

  // Description missing in models
  PatternFlowMplsBottomOfStack bottom_of_stack = 3;

  // Description missing in models
  PatternFlowMplsTimeToLive time_to_live = 4;
}

// SNMPv2C packet header as defined in RFC1901 and RFC3416.
message FlowSnmpv2c {

  // Description missing in models
  PatternFlowSnmpv2cVersion version = 1;

  // It is an ASCII based octet string which identifies the SNMP community in which the
  // sender and recipient of this message are located. It should match the read-only or
  // read-write community string configured on the recipient for the PDU to be accepted.
  // default = community
  optional string community = 2;

  // Description missing in models
  // required = true
  FlowSnmpv2cData data = 3;
}

// This contains the body of the SNMPv2C message.
// 
// - Encoding of subsequent fields follow ASN.1 specification.
// Refer: http://www.itu.int/ITU-T/asn1/
message FlowSnmpv2cData {

  message Choice {
    enum Enum {
      unspecified = 0;
      get_request = 1;
      get_next_request = 2;
      response = 3;
      set_request = 4;
      get_bulk_request = 5;
      inform_request = 6;
      snmpv2_trap = 7;
      report = 8;
    }
  }
  // Description missing in models
  // required = true
  optional Choice.Enum choice = 1;

  // Description missing in models
  FlowSnmpv2cPDU get_request = 2;

  // Description missing in models
  FlowSnmpv2cPDU get_next_request = 3;

  // Description missing in models
  FlowSnmpv2cPDU response = 4;

  // Description missing in models
  FlowSnmpv2cPDU set_request = 5;

  // Description missing in models
  FlowSnmpv2cBulkPDU get_bulk_request = 6;

  // Description missing in models
  FlowSnmpv2cPDU inform_request = 7;

  // Description missing in models
  FlowSnmpv2cPDU snmpv2_trap = 8;

  // Description missing in models
  FlowSnmpv2cPDU report = 9;
}

// This contains the body of the SNMPv2C PDU.
message FlowSnmpv2cPDU {

  // Description missing in models
  PatternFlowSnmpv2cPDURequestId request_id = 1;

  message ErrorStatus {
    enum Enum {
      unspecified = 0;
      no_error = 1;
      too_big = 2;
      no_such_name = 3;
      bad_value = 4;
      read_only = 5;
      gen_err = 6;
      no_access = 7;
      wrong_type = 8;
      wrong_length = 9;
      wrong_encoding = 10;
      wrong_value = 11;
      no_creation = 12;
      inconsistent_value = 13;
      resource_unavailable = 14;
      commit_failed = 15;
      undo_failed = 16;
      authorization_error = 17;
      not_writable = 18;
      inconsistent_name = 19;
    }
  }
  // The SNMP agent places an error code in this field in the response message if an error
  // occurred processing the request.
  // default = ErrorStatus.Enum.no_error
  optional ErrorStatus.Enum error_status = 2;

  // Description missing in models
  PatternFlowSnmpv2cPDUErrorIndex error_index = 3;

  // A Sequence of variable_bindings.
  repeated FlowSnmpv2cVariableBinding variable_bindings = 4;
}

// The purpose of the GetBulkRequest-PDU is to request the transfer of a potentially
// large amount of data, including, but not limited to, the efficient and rapid retrieval
// of large tables.
message FlowSnmpv2cBulkPDU {

  // Description missing in models
  PatternFlowSnmpv2cBulkPDURequestId request_id = 1;

  // Description missing in models
  PatternFlowSnmpv2cBulkPDUNonRepeaters non_repeaters = 2;

  // Description missing in models
  PatternFlowSnmpv2cBulkPDUMaxRepetitions max_repetitions = 3;

  // A Sequence of variable_bindings.
  repeated FlowSnmpv2cVariableBinding variable_bindings = 4;
}

// A Sequence of two fields, an object_identifier and the value for/from that object_identifier.
message FlowSnmpv2cVariableBinding {

  // The Object Identifier points to a particular parameter in the SNMP agent.
  // - Encoding of this field follows RFC2578(section 3.5) and ASN.1 X.690(section 8.1.3.6)
  // specification.
  // Refer: http://www.itu.int/ITU-T/asn1/
  // - According to BER, the first two numbers of any OID (x.y) are encoded as one value
  // using the formula (40*x)+y.
  // Example, the first two numbers of an SNMP OID 1.3... are encoded as 43 or 0x2B,
  // because (40*1)+3 = 43.
  // - After the first two numbers are encoded, the subsequent numbers in the OID are
  // each encoded as a byte.
  // - However, a special rule is required for large numbers because one byte can only
  // represent a number from 0-127.
  // - The rule for large numbers states that only the lower 7 bits in the byte are used
  // for holding the value (0-127).
  // - The highest order bit(8th) is used as a flag to indicate that this number spans
  // more than one byte. Therefore, any number over 127 must be encoded using more than
  // one byte.
  // - Example, the number 2680 in the OID '1.3.6.1.4.1.2680.1.2.7.3.2.0' cannot be
  // encoded using a single byte.
  // According to this rule, the number 2680 must be encoded as 0x94 0x78.
  // Since the most significant bit is set in the first byte (0x94), it indicates
  // that number spans to the next byte.
  // Since the most significant bit is not set in the next byte (0x78), it indicates
  // that the number ends at the second byte.
  // The value is derived by appending 7 bits from each of the concatenated bytes
  // i.e (0x14 *128^1) + (0x78 * 128^0) = 2680.
  // default = 0.1
  optional string object_identifier = 1;

  // Description missing in models
  FlowSnmpv2cVariableBindingValue value = 2;
}

// The value for the object_identifier as per RFC2578.
message FlowSnmpv2cVariableBindingValue {

  message Choice {
    enum Enum {
      unspecified = 0;
      no_value = 1;
      integer_value = 2;
      string_value = 3;
      object_identifier_value = 4;
      ip_address_value = 5;
      counter_value = 6;
      timeticks_value = 7;
      arbitrary_value = 8;
      big_counter_value = 9;
      unsigned_integer_value = 10;
    }
  }
  // Description missing in models
  // default = Choice.Enum.no_value
  optional Choice.Enum choice = 1;

  // Description missing in models
  PatternFlowSnmpv2cVariableBindingValueIntegerValue integer_value = 2;

  // Description missing in models
  FlowSnmpv2cVariableBindingStringValue string_value = 3;

  // The Object Identifier points to a particular parameter in the SNMP agent.
  // - Encoding of this field follows RFC2578(section 3.5) and ASN.1 X.690(section 8.1.3.6)
  // specification.
  // Refer: http://www.itu.int/ITU-T/asn1/
  // - According to BER, the first two numbers of any OID (x.y) are encoded as one value
  // using the formula (40*x)+y.
  // Example, the first two numbers of an SNMP OID 1.3... are encoded as 43 or 0x2B,
  // because (40*1)+3 = 43.
  // - After the first two numbers are encoded, the subsequent numbers in the OID are
  // each encoded as a byte.
  // - However, a special rule is required for large numbers because one byte can only
  // represent a number from 0-127.
  // - The rule for large numbers states that only the lower 7 bits in the byte are used
  // for holding the value (0-127).
  // - The highest order bit(8th) is used as a flag to indicate that this number spans
  // more than one byte. Therefore, any number over 127 must be encoded using more than
  // one byte.
  // - Example, the number 2680 in the OID '1.3.6.1.4.1.2680.1.2.7.3.2.0' cannot be
  // encoded using a single byte.
  // According to this rule, the number 2680 must be encoded as 0x94 0x78.
  // Since the most significant bit is set in the first byte (0x94), it indicates
  // that number spans to the next byte.
  // Since the most significant bit is not set in the next byte (0x78), it indicates
  // that the number ends at the second byte.
  // The value is derived by appending 7 bits from each of the concatenated bytes
  // i.e (0x14 *128^1) + (0x78 * 128^0) = 2680.
  // default = 0.1
  optional string object_identifier_value = 4;

  // Description missing in models
  PatternFlowSnmpv2cVariableBindingValueIpAddressValue ip_address_value = 5;

  // Description missing in models
  PatternFlowSnmpv2cVariableBindingValueCounterValue counter_value = 6;

  // Description missing in models
  PatternFlowSnmpv2cVariableBindingValueTimeticksValue timeticks_value = 7;

  // It contains the hex bytes of the value to be sent.  As of now it is restricted to
  // 10000 bytes.
  // default = 00
  optional string arbitrary_value = 8;

  // Description missing in models
  PatternFlowSnmpv2cVariableBindingValueBigCounterValue big_counter_value = 9;

  // Description missing in models
  PatternFlowSnmpv2cVariableBindingValueUnsignedIntegerValue unsigned_integer_value = 10;
}

// It contains the raw/ascii string value to be sent.
message FlowSnmpv2cVariableBindingStringValue {

  message Choice {
    enum Enum {
      unspecified = 0;
      ascii = 1;
      raw = 2;
    }
  }
  // Description missing in models
  // default = Choice.Enum.ascii
  optional Choice.Enum choice = 1;

  // It contains the ASCII string to be sent.  As of now it is restricted to 10000 bytes.
  // default = ascii
  optional string ascii = 2;

  // It contains the hex string to be sent.  As of now it is restricted to 10000 bytes.
  // default = 00
  optional string raw = 3;
}

// RSVP packet header as defined in RFC2205 and RFC3209. Currently only supported message
// type is Path with mandatory objects and sub-objects.
message FlowRsvp {

  // RSVP Protocol Version.
  // default = 1
  optional uint32 version = 1;

  message Flag {
    enum Enum {
      unspecified = 0;
      not_refresh_reduction_capable = 1;
      refresh_reduction_capable = 2;
    }
  }
  // Flag, 0x01-0x08: Reserved.
  // default = Flag.Enum.not_refresh_reduction_capable
  optional Flag.Enum flag = 2;

  // Description missing in models
  PatternFlowRsvpRsvpChecksum rsvp_checksum = 3;

  // Description missing in models
  PatternFlowRsvpTimeToLive time_to_live = 4;

  // Description missing in models
  PatternFlowRsvpReserved reserved = 5;

  // The sum of the lengths of the common header and all objects included in the message.
  FlowRSVPLength rsvp_length = 6;

  // An 8-bit number that identifies the function of the RSVP message. There are aound
  // 20 message types defined in https://www.iana.org/assignments/rsvp-parameters/rsvp-parameters.xhtml#rsvp-parameters-2
  // . Among these presently supported is Path(value: 1) message type.
  FlowRSVPMessage message_type = 7;
}

// Description missing in models
message FlowRSVPLength {

  message Choice {
    enum Enum {
      unspecified = 0;
      auto = 1;
      value = 2;
    }
  }
  // auto or configured value.
  // default = Choice.Enum.auto
  optional Choice.Enum choice = 1;

  // The OTG implementation will provide a system generated value for this property.
  // If the OTG implementation is unable to generate a value the default value must be
  // used.
  // default = 0
  optional uint32 auto = 2;

  // Description missing in models
  // default = 0
  optional uint32 value = 3;
}

// Description missing in models
message FlowRSVPMessage {

  message Choice {
    enum Enum {
      unspecified = 0;
      path = 1;
    }
  }
  // Description missing in models
  // default = Choice.Enum.path
  optional Choice.Enum choice = 1;

  // Description missing in models
  FlowRSVPPathMessage path = 2;
}

// Path message requires the following list of objects in order as defined in https://www.rfc-editor.org/rfc/rfc3209.html#page-15:
// 1. SESSION 2. RSVP_HOP 3. TIME_VALUES 4. EXPLICIT_ROUTE [optional] 5. LABEL_REQUEST
// 6. SESSION_ATTRIBUTE [optional] 7. SENDER_TEMPLATE 8. SENDER_TSPEC 9. RECORD_ROUTE
// [optional]
message FlowRSVPPathMessage {

  // Path message requires atleast SESSION, RSVP_HOP, TIME_VALUES, LABEL_REQUEST, SENDER_TEMPLATE
  // and SENDER_TSPEC objects in order.
  repeated FlowRSVPPathObjects objects = 1;
}

// Every RSVP object encapsulated in an RSVP message consists of a 32-bit word header
// and the object's contents.
message FlowRSVPPathObjects {

  // Description missing in models
  FlowRSVPPathObjectsClass class_num = 1;
}

// Description missing in models
message FlowRSVPObjectLength {

  message Choice {
    enum Enum {
      unspecified = 0;
      auto = 1;
      value = 2;
    }
  }
  // auto or configured value.
  // default = Choice.Enum.auto
  optional Choice.Enum choice = 1;

  // The OTG implementation will provide a system generated value for this property.
  // If the OTG implementation is unable to generate a value the default value must be
  // used.
  // default = 4
  optional uint32 auto = 2;

  // Description missing in models
  // default = 4
  optional uint32 value = 3;
}

// The class number is used to identify the class of an object. Defined in https://www.iana.org/assignments/rsvp-parameters/rsvp-parameters.xhtml#rsvp-parameters-4
// . Curently supported class numbers are for Path message type. Path message: Supported
// Class numbers and it's value: SESSION: 1, RSVP_HOP: 3, TIME_VALUES: 5, EXPLICIT_ROUTE:
// 20, LABEL_REQUEST: 19, SESSION_ATTRIBUTE: 207, SENDER_TEMPLATE: 11, SENDER_TSPEC:
// 12, RECORD_ROUTE: 21, Custom: User defined bytes based on class and c-types not supported
// in above options.
message FlowRSVPPathObjectsClass {

  message Choice {
    enum Enum {
      unspecified = 0;
      session = 1;
      rsvp_hop = 2;
      time_values = 3;
      explicit_route = 4;
      label_request = 5;
      session_attribute = 6;
      sender_template = 7;
      sender_tspec = 8;
      record_route = 9;
      custom = 10;
    }
  }
  // Description missing in models
  // required = true
  optional Choice.Enum choice = 1;

  // Description missing in models
  FlowRSVPPathObjectsClassSession session = 2;

  // Description missing in models
  FlowRSVPPathObjectsClassRsvpHop rsvp_hop = 3;

  // Description missing in models
  FlowRSVPPathObjectsClassTimeValues time_values = 4;

  // Description missing in models
  FlowRSVPPathObjectsClassExplicitRoute explicit_route = 5;

  // Description missing in models
  FlowRSVPPathObjectsClassLabelRequest label_request = 6;

  // Description missing in models
  FlowRSVPPathObjectsClassSessionAttribute session_attribute = 7;

  // Description missing in models
  FlowRSVPPathObjectsClassSenderTemplate sender_template = 8;

  // Description missing in models
  FlowRSVPPathObjectsClassSenderTspec sender_tspec = 9;

  // Description missing in models
  FlowRSVPPathObjectsClassRecordRoute record_route = 10;

  // Description missing in models
  FlowRSVPPathObjectsCustom custom = 11;
}

// C-Type is specific to a class num.
message FlowRSVPPathObjectsClassSession {

  // A 16-bit field containing the total object length in bytes.  Must always be a multiple
  // of 4 or at least 4.
  FlowRSVPObjectLength length = 1;

  // Description missing in models
  FlowRSVPPathObjectsSessionCType c_type = 2;
}

// The body of an object corresponding to the class number and c-type. Currently supported
// c-type for SESSION object is LSP Tunnel IPv4 (7).
message FlowRSVPPathObjectsSessionCType {

  message Choice {
    enum Enum {
      unspecified = 0;
      lsp_tunnel_ipv4 = 1;
    }
  }
  // Description missing in models
  // default = Choice.Enum.lsp_tunnel_ipv4
  optional Choice.Enum choice = 1;

  // Description missing in models
  FlowRSVPPathSessionLspTunnelIpv4 lsp_tunnel_ipv4 = 2;
}

// Class = SESSION, LSP_TUNNEL_IPv4 C-Type = 7.
message FlowRSVPPathSessionLspTunnelIpv4 {

  // Description missing in models
  PatternFlowRSVPPathSessionLspTunnelIpv4Ipv4TunnelEndPointAddress ipv4_tunnel_end_point_address = 1;

  // Description missing in models
  PatternFlowRSVPPathSessionLspTunnelIpv4Reserved reserved = 2;

  // Description missing in models
  PatternFlowRSVPPathSessionLspTunnelIpv4TunnelId tunnel_id = 3;

  // A 32-bit identifier used in the SESSION that remains constant over the life of the
  // tunnel. Normally set to all zeros. Ingress nodes that wish to narrow the scope of
  // a SESSION to the ingress-egress pair may place their IPv4 address here as a globally
  // unique identifier.
  FlowRSVPPathSessionExtTunnelId extended_tunnel_id = 4;
}

// Description missing in models
message FlowRSVPPathSessionExtTunnelId {

  message Choice {
    enum Enum {
      unspecified = 0;
      as_integer = 1;
      as_ipv4 = 2;
    }
  }
  // 32 bit integer or IPv4 address.
  // default = Choice.Enum.as_integer
  optional Choice.Enum choice = 1;

  // Description missing in models
  PatternFlowRSVPPathSessionExtTunnelIdAsInteger as_integer = 2;

  // Description missing in models
  PatternFlowRSVPPathSessionExtTunnelIdAsIpv4 as_ipv4 = 3;
}

// C-Type is specific to a class num.
message FlowRSVPPathObjectsClassRsvpHop {

  // A 16-bit field containing the total object length in bytes.  Must always be a multiple
  // of 4 or at least 4.
  FlowRSVPObjectLength length = 1;

  // Description missing in models
  FlowRSVPPathObjectsRsvpHopCType c_type = 2;
}

// Object for RSVP_HOP class. Currently supported c-type is IPv4 (1).
message FlowRSVPPathObjectsRsvpHopCType {

  message Choice {
    enum Enum {
      unspecified = 0;
      ipv4 = 1;
    }
  }
  // Description missing in models
  // default = Choice.Enum.ipv4
  optional Choice.Enum choice = 1;

  // Description missing in models
  FlowRSVPPathRsvpHopIpv4 ipv4 = 2;
}

// IPv4 RSVP_HOP object: Class = 3, C-Type = 1
message FlowRSVPPathRsvpHopIpv4 {

  // Description missing in models
  PatternFlowRSVPPathRsvpHopIpv4Ipv4Address ipv4_address = 1;

  // Description missing in models
  PatternFlowRSVPPathRsvpHopIpv4LogicalInterfaceHandle logical_interface_handle = 2;
}

// C-Type is specific to a class num.
message FlowRSVPPathObjectsClassTimeValues {

  // A 16-bit field containing the total object length in bytes.  Must always be a multiple
  // of 4 or at least 4.
  FlowRSVPObjectLength length = 1;

  // Description missing in models
  FlowRSVPPathObjectsTimeValuesCType c_type = 2;
}

// Object for TIME_VALUES class. Currently supported c-type is Type 1 Time Value (1).
message FlowRSVPPathObjectsTimeValuesCType {

  message Choice {
    enum Enum {
      unspecified = 0;
      type_1 = 1;
    }
  }
  // Description missing in models
  // default = Choice.Enum.type_1
  optional Choice.Enum choice = 1;

  // Description missing in models
  FlowRSVPPathTimeValuesType1 type_1 = 2;
}

// TIME_VALUES Object: Class = 5, C-Type = 1
message FlowRSVPPathTimeValuesType1 {

  // Description missing in models
  PatternFlowRSVPPathTimeValuesType1RefreshPeriodR refresh_period_r = 1;
}

// C-Type is specific to a class num.
message FlowRSVPPathObjectsClassExplicitRoute {

  // A 16-bit field containing the total object length in bytes.  Must always be a multiple
  // of 4 or at least 4.
  FlowRSVPObjectLength length = 1;

  // Description missing in models
  FlowRSVPPathObjectsClassExplicitRouteCType c_type = 2;
}

// Object for EXPLICIT_ROUTE class and c-type is Type 1 Explicit Route (1).
message FlowRSVPPathObjectsClassExplicitRouteCType {

  message Choice {
    enum Enum {
      unspecified = 0;
      type_1 = 1;
    }
  }
  // Description missing in models
  // default = Choice.Enum.type_1
  optional Choice.Enum choice = 1;

  // Description missing in models
  FlowRSVPPathExplicitRouteType1 type_1 = 2;
}

// Type1 Explicit Route has subobjects. Currently supported subobjects are IPv4 prefix
// and Autonomous system number.
message FlowRSVPPathExplicitRouteType1 {

  // Description missing in models
  repeated FlowRSVPType1ExplicitRouteSubobjects subobjects = 1;
}

// Type is specific to a subobject.
message FlowRSVPType1ExplicitRouteSubobjects {

  // Description missing in models
  FlowRSVPType1ExplicitRouteSubobjectsType type = 1;
}

// Currently supported subobjects are IPv4 address(1) and Autonomous system number(32).
message FlowRSVPType1ExplicitRouteSubobjectsType {

  message Choice {
    enum Enum {
      unspecified = 0;
      ipv4_prefix = 1;
      as_number = 2;
    }
  }
  // Description missing in models
  // default = Choice.Enum.ipv4_prefix
  optional Choice.Enum choice = 1;

  // Description missing in models
  FlowRSVPPathExplicitRouteType1Ipv4Prefix ipv4_prefix = 2;

  // Description missing in models
  FlowRSVPPathExplicitRouteType1ASNumber as_number = 3;
}

// Class = EXPLICIT_ROUTE, Type1 ROUTE_RECORD C-Type = 1 Subobject: IPv4 Prefix, C-Type:
// 1
message FlowRSVPPathExplicitRouteType1Ipv4Prefix {

  // Description missing in models
  PatternFlowRSVPPathExplicitRouteType1Ipv4PrefixLBit l_bit = 1;

  // The Length contains the total length of the subobject in bytes,including L,Type and
  // Length fields.   The Length MUST be atleast 4, and MUST be a multiple of 4.
  FlowRSVPExplicitRouteLength length = 2;

  // Description missing in models
  PatternFlowRSVPPathExplicitRouteType1Ipv4PrefixIpv4Address ipv4_address = 3;

  // The prefix length of the IPv4 address.
  // default = 32
  optional uint32 prefix = 4;
}

// Class = EXPLICIT_ROUTE, Type1 ROUTE_RECORD C-Type = 1 Subobject: Autonomous system
// number, C-Type: 32
message FlowRSVPPathExplicitRouteType1ASNumber {

  // Description missing in models
  PatternFlowRSVPPathExplicitRouteType1ASNumberLBit l_bit = 1;

  // The Length contains the total length of the subobject in bytes,including L, Type
  // and Length fields.   The Length MUST be atleast 4, and MUST be a multiple of 4.
  FlowRSVPExplicitRouteASNumberLength length = 2;

  // Autonomous System number to be set in the ERO sub-object that this LSP should traverse
  // through. This field is applicable only if the value of 'type' is set to 'as_number'.
  // default = 0
  optional uint32 as_number = 3;
}

// Description missing in models
message FlowRSVPExplicitRouteLength {

  message Choice {
    enum Enum {
      unspecified = 0;
      auto = 1;
      value = 2;
    }
  }
  // auto or configured value.
  // default = Choice.Enum.auto
  optional Choice.Enum choice = 1;

  // The OTG implementation will provide a system generated value for this property.
  // If the OTG implementation is unable to generate a value the default value must be
  // used.
  // default = 8
  optional uint32 auto = 2;

  // Description missing in models
  // default = 8
  optional uint32 value = 3;
}

// Description missing in models
message FlowRSVPExplicitRouteASNumberLength {

  message Choice {
    enum Enum {
      unspecified = 0;
      auto = 1;
      value = 2;
    }
  }
  // auto or configured value.
  // default = Choice.Enum.auto
  optional Choice.Enum choice = 1;

  // The OTG implementation will provide a system generated value for this property.
  // If the OTG implementation is unable to generate a value the default value must be
  // used.
  // default = 4
  optional uint32 auto = 2;

  // Description missing in models
  // default = 4
  optional uint32 value = 3;
}

// C-Type is specific to a class num.
message FlowRSVPPathObjectsClassLabelRequest {

  // A 16-bit field containing the total object length in bytes.  Must always be a multiple
  // of 4 or at least 4.
  FlowRSVPObjectLength length = 1;

  // Description missing in models
  FlowRSVPPathObjectsLabelRequestCType c_type = 2;
}

// Object for LABEL_REQUEST class. Currently supported c-type is Without Label Range
// (1).
message FlowRSVPPathObjectsLabelRequestCType {

  message Choice {
    enum Enum {
      unspecified = 0;
      without_label_range = 1;
    }
  }
  // Description missing in models
  // default = Choice.Enum.without_label_range
  optional Choice.Enum choice = 1;

  // Description missing in models
  FlowRSVPPathLabelRequestWithoutLabelRange without_label_range = 2;
}

// Class = LABEL_REQUEST, Without Label Range C-Type = 1
message FlowRSVPPathLabelRequestWithoutLabelRange {

  // Description missing in models
  PatternFlowRSVPPathLabelRequestWithoutLabelRangeReserved reserved = 1;

  // Description missing in models
  PatternFlowRSVPPathLabelRequestWithoutLabelRangeL3pid l3pid = 2;
}

// C-Type is specific to a class num.
message FlowRSVPPathObjectsClassSessionAttribute {

  // A 16-bit field containing the total object length in bytes.  Must always be a multiple
  // of 4 or at least 4.
  FlowRSVPObjectLength length = 1;

  // Description missing in models
  FlowRSVPPathObjectsSessionAttributeCType c_type = 2;
}

// Object for SESSION_ATTRIBUTE class. Currently supported c-type is LSP_Tunnel_RA (1)
// and LSP_Tunnel (7).
message FlowRSVPPathObjectsSessionAttributeCType {

  message Choice {
    enum Enum {
      unspecified = 0;
      lsp_tunnel = 1;
      lsp_tunnel_ra = 2;
    }
  }
  // Description missing in models
  // default = Choice.Enum.lsp_tunnel
  optional Choice.Enum choice = 1;

  // Description missing in models
  FlowRSVPPathSessionAttributeLspTunnel lsp_tunnel = 2;

  // Description missing in models
  FlowRSVPPathSessionAttributeLspTunnelRa lsp_tunnel_ra = 3;
}

// SESSION_ATTRIBUTE class = 207, LSP_TUNNEL_RA C-Type = 7, resource affinity information.
message FlowRSVPPathSessionAttributeLspTunnel {

  // The priority of the session with respect to taking resources,in the range of 0 to
  // 7. The value 0 is the highest priority. The Setup Priority is used in deciding whether
  // this session can preempt another session.
  // default = 7
  optional uint32 setup_priority = 1;

  // The priority of the session with respect to holding resources,in the range of 0 to
  // 7. The value 0 is the highest priority. The Setup Priority is used in deciding whether
  // this session can preempt another session.
  // default = 7
  optional uint32 holding_priority = 2;

  // 0x01 Local protection desired, 0x02 Label recording desired, 0x04 SE Style desired
  FlowRSVPLspTunnelFlag flags = 3;

  // The length of the display string before padding, in bytes.
  FlowRSVPSessionAttributeNameLength name_length = 4;

  // A null padded string of characters.
  // default =
  optional string session_name = 5;
}

// SESSION_ATTRIBUTE class = 207, LSP_TUNNEL_RA C-Type = 1, it carries resource affinity
// information.
message FlowRSVPPathSessionAttributeLspTunnelRa {

  // A 32-bit vector representing a set of attribute filters associated with a tunnel
  // any of which renders a link unacceptable. A null set (all bits set to zero) doesn't
  // render the link unacceptable. The most significant byte in the hex-string is the
  // farthest  to the left in the byte sequence.  Leading zero bytes in the configured
  // value may be omitted for brevity.
  // default = 00
  optional string exclude_any = 1;

  // A 32-bit vector representing a set of attribute filters associated with a tunnel
  // any of which renders a link acceptable. A null set (all bits set to zero) automatically
  // passes. The most significant byte in the hex-string is the farthest  to the left
  // in the byte sequence.  Leading zero bytes in the configured value may be omitted
  // for brevity.
  // default = 00
  optional string include_any = 2;

  // A 32-bit vector representing a set of attribute filters associated with a tunnel
  // all of which must be present for a link to be acceptable. A null set (all bits set
  // to zero) automatically passes. The most significant byte in the hex-string is the
  // farthest to the left in the byte sequence.  Leading zero bytes in the configured
  // value may be omitted for brevity.
  // default = 00
  optional string include_all = 3;

  // The priority of the session with respect to taking resources,in the range of 0 to
  // 7. The value 0 is the highest priority. The Setup Priority is used in deciding whether
  // this session can preempt another session.
  // default = 7
  optional uint32 setup_priority = 4;

  // The priority of the session with respect to holding resources,in the range of 0 to
  // 7. The value 0 is the highest priority. The Setup Priority is used in deciding whether
  // this session can preempt another session.
  // default = 7
  optional uint32 holding_priority = 5;

  // 0x01 Local protection desired, 0x02 Label recording desired, 0x04 SE Style desired
  FlowRSVPLspTunnelFlag flags = 6;

  // The length of the display string before padding, in bytes.
  FlowRSVPSessionAttributeNameLength name_length = 7;

  // A null padded string of characters.
  // default =
  optional string session_name = 8;
}

// Description missing in models
message FlowRSVPLspTunnelFlag {

  message Choice {
    enum Enum {
      unspecified = 0;
      local_protection_desired = 1;
      label_recording_desired = 2;
      se_style_desired = 3;
    }
  }
  // Description missing in models
  // default = Choice.Enum.local_protection_desired
  optional Choice.Enum choice = 1;
}

// Description missing in models
message FlowRSVPSessionAttributeNameLength {

  message Choice {
    enum Enum {
      unspecified = 0;
      auto = 1;
      value = 2;
    }
  }
  // auto or configured value.
  // default = Choice.Enum.auto
  optional Choice.Enum choice = 1;

  // The OTG implementation will provide a system generated value for this property.
  // If the OTG implementation is unable to generate a value the default value must be
  // used.
  // default = 0
  optional uint32 auto = 2;

  // Description missing in models
  // default = 0
  optional uint32 value = 3;
}

// C-Type is specific to a class num.
message FlowRSVPPathObjectsClassSenderTemplate {

  // A 16-bit field containing the total object length in bytes.  Must always be a multiple
  // of 4 or at least 4.
  FlowRSVPObjectLength length = 1;

  // Description missing in models
  FlowRSVPPathObjectsSenderTemplateCType c_type = 2;
}

// Object for SENDER_TEMPLATE class. Currently supported c-type is LSP Tunnel IPv4 (7).
message FlowRSVPPathObjectsSenderTemplateCType {

  message Choice {
    enum Enum {
      unspecified = 0;
      lsp_tunnel_ipv4 = 1;
    }
  }
  // Description missing in models
  // default = Choice.Enum.lsp_tunnel_ipv4
  optional Choice.Enum choice = 1;

  // Description missing in models
  FlowRSVPPathSenderTemplateLspTunnelIpv4 lsp_tunnel_ipv4 = 2;
}

// Class = SENDER_TEMPLATE, LSP_TUNNEL_IPv4 C-Type = 7
message FlowRSVPPathSenderTemplateLspTunnelIpv4 {

  // Description missing in models
  PatternFlowRSVPPathSenderTemplateLspTunnelIpv4Ipv4TunnelSenderAddress ipv4_tunnel_sender_address = 1;

  // Description missing in models
  PatternFlowRSVPPathSenderTemplateLspTunnelIpv4Reserved reserved = 2;

  // Description missing in models
  PatternFlowRSVPPathSenderTemplateLspTunnelIpv4LspId lsp_id = 3;
}

// C-Type is specific to a class num.
message FlowRSVPPathObjectsClassSenderTspec {

  // A 16-bit field containing the total object length in bytes.  Must always be a multiple
  // of 4 or at least 4.
  FlowRSVPObjectLength length = 1;

  // Description missing in models
  FlowRSVPPathObjectsSenderTspecCType c_type = 2;
}

// Object for SENDER_TSPEC class. Currently supported c-type is int-serv (2).
message FlowRSVPPathObjectsSenderTspecCType {

  message Choice {
    enum Enum {
      unspecified = 0;
      int_serv = 1;
    }
  }
  // Description missing in models
  // default = Choice.Enum.int_serv
  optional Choice.Enum choice = 1;

  // Description missing in models
  FlowRSVPPathSenderTspecIntServ int_serv = 2;
}

// int-serv SENDER_TSPEC object: Class = 12, C-Type = 2
message FlowRSVPPathSenderTspecIntServ {

  // Description missing in models
  PatternFlowRSVPPathSenderTspecIntServVersion version = 1;

  // Description missing in models
  PatternFlowRSVPPathSenderTspecIntServReserved1 reserved1 = 2;

  // Description missing in models
  PatternFlowRSVPPathSenderTspecIntServOverallLength overall_length = 3;

  // Description missing in models
  PatternFlowRSVPPathSenderTspecIntServServiceHeader service_header = 4;

  // Description missing in models
  PatternFlowRSVPPathSenderTspecIntServZeroBit zero_bit = 5;

  // Description missing in models
  PatternFlowRSVPPathSenderTspecIntServReserved2 reserved2 = 6;

  // Description missing in models
  PatternFlowRSVPPathSenderTspecIntServLengthOfServiceData length_of_service_data = 7;

  // Description missing in models
  PatternFlowRSVPPathSenderTspecIntServParameterIdTokenBucketTspec parameter_id_token_bucket_tspec = 8;

  // Description missing in models
  PatternFlowRSVPPathSenderTspecIntServParameter127Flag parameter_127_flag = 9;

  // Description missing in models
  PatternFlowRSVPPathSenderTspecIntServParameter127Length parameter_127_length = 10;

  // Token bucket rate is set to sender's view of its generated traffic.
  // default = 0
  optional float token_bucket_rate = 11;

  // Token bucket size is set to sender's view of its generated traffic.
  // default = 0
  optional float token_bucket_size = 12;

  // The peak rate may be set to the sender's peak traffic generation rate (if known and
  // controlled), the physical interface line rate (if known), or positive infinity (if
  // no better value is available).
  // default = 0
  optional float peak_data_rate = 13;

  // Description missing in models
  PatternFlowRSVPPathSenderTspecIntServMinimumPolicedUnit minimum_policed_unit = 14;

  // Description missing in models
  PatternFlowRSVPPathSenderTspecIntServMaximumPacketSize maximum_packet_size = 15;
}

// C-Type is specific to a class num.
message FlowRSVPPathObjectsClassRecordRoute {

  // A 16-bit field containing the total object length in bytes.  Must always be a multiple
  // of 4 or at least 4.
  FlowRSVPObjectLength length = 1;

  // Description missing in models
  FlowRSVPPathObjectsRecordRouteCType c_type = 2;
}

// Object for RECORD_ROUTE class. c-type is Type 1 Route Record (1).
message FlowRSVPPathObjectsRecordRouteCType {

  message Choice {
    enum Enum {
      unspecified = 0;
      type_1 = 1;
    }
  }
  // Description missing in models
  // default = Choice.Enum.type_1
  optional Choice.Enum choice = 1;

  // Description missing in models
  FlowRSVPPathRecordRouteType1 type_1 = 2;
}

// Type1 record route has list of subobjects. Currently supported subobjects are IPv4
// address(1) and Label(3).
message FlowRSVPPathRecordRouteType1 {

  // Description missing in models
  repeated FlowRSVPType1RecordRouteSubobjects subobjects = 1;
}

// Type is specific to a subobject.
message FlowRSVPType1RecordRouteSubobjects {

  // Description missing in models
  FlowRSVPPathObjectsRecordRouteSubObjectType type = 1;
}

// Currently supported subobjects are IPv4 address(1) and Label(3).
message FlowRSVPPathObjectsRecordRouteSubObjectType {

  message Choice {
    enum Enum {
      unspecified = 0;
      ipv4_address = 1;
      label = 2;
    }
  }
  // Description missing in models
  // default = Choice.Enum.ipv4_address
  optional Choice.Enum choice = 1;

  // Description missing in models
  FlowRSVPPathRecordRouteType1Ipv4Address ipv4_address = 2;

  // Description missing in models
  FlowRSVPPathRecordRouteType1Label label = 3;
}

// Class = RECORD_ROUTE, Type1 ROUTE_RECORD C-Type = 1 Subobject: IPv4 Address, C-Type:
// 1
message FlowRSVPPathRecordRouteType1Ipv4Address {

  // The Length contains the total length of the subobject in bytes, including the Type
  // and Length fields.   The Length MUST be atleast 4, and MUST be a multiple of 4.
  FlowRSVPRouteRecordLength length = 1;

  // Description missing in models
  PatternFlowRSVPPathRecordRouteType1Ipv4AddressIpv4Address ipv4_address = 2;

  // Description missing in models
  PatternFlowRSVPPathRecordRouteType1Ipv4AddressPrefixLength prefix_length = 3;

  // 0x01  local_protection_available, 0x02  local_protection_in_use
  FlowRSVPRecordRouteIPv4Flag flags = 4;
}

// Description missing in models
message FlowRSVPRecordRouteIPv4Flag {

  message Choice {
    enum Enum {
      unspecified = 0;
      local_protection_available = 1;
      local_protection_in_use = 2;
    }
  }
  // Description missing in models
  // default = Choice.Enum.local_protection_available
  optional Choice.Enum choice = 1;
}

// Class = RECORD_ROUTE, Type1 ROUTE_RECORD C-Type = 1 Subobject: Label, C-Type: 3
message FlowRSVPPathRecordRouteType1Label {

  // The Length contains the total length of the subobject in bytes, including the Type
  // and Length fields.   The Length MUST be atleast 4, and MUST be a multiple of 4.
  FlowRSVPRouteRecordLength length = 1;

  // Description missing in models
  PatternFlowRSVPPathRecordRouteType1LabelFlags flags = 2;

  // Description missing in models
  PatternFlowRSVPPathRecordRouteType1LabelCType c_type = 3;

  // The contents of the Label Object. Copied from the Label Object.
  FlowRSVPPathRecordRouteLabel label = 4;
}

// Description missing in models
message FlowRSVPPathRecordRouteLabel {

  message Choice {
    enum Enum {
      unspecified = 0;
      as_integer = 1;
      as_hex = 2;
    }
  }
  // 32 bit integer or hex value.
  // default = Choice.Enum.as_integer
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 16
  optional uint32 as_integer = 2;

  // Value of the this field should not excced 4 bytes. Maximum length of this attribute
  // is 8 (4 * 2 hex character per byte).
  // default = 10
  optional string as_hex = 3;
}

// Description missing in models
message FlowRSVPRouteRecordLength {

  message Choice {
    enum Enum {
      unspecified = 0;
      auto = 1;
      value = 2;
    }
  }
  // auto or configured value.
  // default = Choice.Enum.auto
  optional Choice.Enum choice = 1;

  // The OTG implementation will provide a system generated value for this property.
  // If the OTG implementation is unable to generate a value the default value must be
  // used.
  // default = 8
  optional uint32 auto = 2;

  // Description missing in models
  // default = 8
  optional uint32 value = 3;
}

// Custom packet header
message FlowRSVPPathObjectsCustom {

  // Description missing in models
  PatternFlowRSVPPathObjectsCustomType type = 1;

  // Description missing in models
  FlowRSVPObjectLength length = 2;

  // A custom packet header defined as a string of hex bytes. The string MUST contain
  // sequence of valid hex bytes. Spaces or colons can be part of the bytes but will be
  // discarded. Value of the this field should not excced 65525 bytes since maximum 65528
  // bytes can be added as object-contents in RSVP header. For type and length requires
  // 3 bytes, hence maximum of 65524 bytes are expected. Maximum length of this attribute
  // is 131050 (65525 * 2 hex character per byte).
  // default = 0000
  optional string bytes = 3;
}

// MACsec packet header.
message FlowMacsec {

  message Choice {
    enum Enum {
      unspecified = 0;
      auto = 1;
    }
  }
  // Currently only auto choice is allowed. If choice is auto, MACsec header is autogenerated.
  // If auto choice is selected, MACsec protocol must be configured in device; flow.tx_rx.choice
  // must be of type 'device' and flow.tx_rx.device.tx_names[0] must be chosen to be an
  // endpoint that is on or behind a MACSec enabled ethernet to be able to correctly auto-fill
  // the fields of the MACsec header. If one of the conditions is not true, the implementation
  // should return an error specifying the issue. A custom choice can be added in future
  // to allow user to set specific MACsec header fields and/ or to generate flow.tx_rx.port
  // type of traffic with MACSec header fields explicitly specified by the user.
  // default = Choice.Enum.auto
  optional Choice.Enum choice = 1;
}

// Defines the fields of a Link Aggregation Control Protocol (LACP) Data Unit (PDU)
// as specified by IEEE 802.3ad. The ethernet ether type, if set to auto, will be updated
// to '0x8809' and the destination address, if set to auto, will be updated to 01:80:C2:00:00:02
// for LACP. Flows[i].metrics.enable should be set to false to avoid insertion of additional
// instrumentation bytes in the generated packets.
message FlowLacp {

  message Choice {
    enum Enum {
      unspecified = 0;
      lacpdu = 1;
    }
  }
  // Description missing in models
  // default = Choice.Enum.lacpdu
  optional Choice.Enum choice = 1;

  // Description missing in models
  PatternFlowLacpVersion version = 2;

  // Description missing in models
  FlowLacpLacpdu lacpdu = 3;
}

// Defines the TLV fields of a Link Aggregation Control Protocol (LACP)
// Data Unit (PDU) as specified by IEEE 802.3ad.
message FlowLacpLacpdu {

  // Description missing in models
  FlowLacpduActor actor = 1;

  // Description missing in models
  FlowLacpduPartner partner = 2;

  // Description missing in models
  FlowLacpduCollector collector = 3;

  // Description missing in models
  FlowLacpduTerminator terminator = 4;
}

// Information about the local (actor) system.
message FlowLacpduActor {

  // Description missing in models
  PatternFlowLacpduActorType type = 1;

  // Description missing in models
  PatternFlowLacpduActorLength length = 2;

  // Description missing in models
  PatternFlowLacpduActorSystemPriority system_priority = 3;

  // Description missing in models
  PatternFlowLacpduActorSystemId system_id = 4;

  // Description missing in models
  PatternFlowLacpduActorKey key = 5;

  // Description missing in models
  PatternFlowLacpduActorPortPriority port_priority = 6;

  // Description missing in models
  PatternFlowLacpduActorPortNumber port_number = 7;

  // Description missing in models
  FlowLacpduActorState actor_state = 8;

  // Description missing in models
  PatternFlowLacpduActorReserved reserved = 9;
}

// Information about the remote (partner) system.
message FlowLacpduPartner {

  // Description missing in models
  PatternFlowLacpduPartnerType type = 1;

  // Description missing in models
  PatternFlowLacpduPartnerLength length = 2;

  // Description missing in models
  PatternFlowLacpduPartnerSystemPriority system_priority = 3;

  // Description missing in models
  PatternFlowLacpduPartnerSystemId system_id = 4;

  // Description missing in models
  PatternFlowLacpduPartnerKey key = 5;

  // Description missing in models
  PatternFlowLacpduPartnerPortPriority port_priority = 6;

  // Description missing in models
  PatternFlowLacpduPartnerPortNumber port_number = 7;

  // Description missing in models
  FlowLacpduPartnerState partner_state = 8;

  // Description missing in models
  PatternFlowLacpduPartnerReserved reserved = 9;
}

// Information about frame collection parameters.
message FlowLacpduCollector {

  // Description missing in models
  PatternFlowLacpduCollectorType type = 1;

  // Description missing in models
  PatternFlowLacpduCollectorLength length = 2;

  // Description missing in models
  PatternFlowLacpduCollectorMaxDelay max_delay = 3;

  // Reserved field for future use in the Collector TLV. 12 bytes long and should be set
  // to all zeros.
  // default = 000000000000000000000000
  optional string reserved = 4;
}

// Marks the end of the LACPDU message.
message FlowLacpduTerminator {

  // Description missing in models
  PatternFlowLacpduTerminatorType type = 1;

  // Description missing in models
  PatternFlowLacpduTerminatorLength length = 2;

  // Final block of reserved bytes to pad the PDU. It is 50 bytes long.
  // default = 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
  optional string reserved = 3;
}

// This field indicates the Actor's state.
message FlowLacpduActorState {

  // Description missing in models
  PatternFlowLacpduActorStateActivity activity = 1;

  // Description missing in models
  PatternFlowLacpduActorStateTimeout timeout = 2;

  // Description missing in models
  PatternFlowLacpduActorStateAggregation aggregation = 3;

  // Description missing in models
  PatternFlowLacpduActorStateSynchronization synchronization = 4;

  // Description missing in models
  PatternFlowLacpduActorStateCollecting collecting = 5;

  // Description missing in models
  PatternFlowLacpduActorStateDistributing distributing = 6;

  // Description missing in models
  PatternFlowLacpduActorStateDefaulted defaulted = 7;

  // Description missing in models
  PatternFlowLacpduActorStateExpired expired = 8;
}

// This field indicates the Partner's state.
message FlowLacpduPartnerState {

  // Description missing in models
  PatternFlowLacpduPartnerStateActivity activity = 1;

  // Description missing in models
  PatternFlowLacpduPartnerStateTimeout timeout = 2;

  // Description missing in models
  PatternFlowLacpduPartnerStateAggregation aggregation = 3;

  // Description missing in models
  PatternFlowLacpduPartnerStateSynchronization synchronization = 4;

  // Description missing in models
  PatternFlowLacpduPartnerStateCollecting collecting = 5;

  // Description missing in models
  PatternFlowLacpduPartnerStateDistributing distributing = 6;

  // Description missing in models
  PatternFlowLacpduPartnerStateDefaulted defaulted = 7;

  // Description missing in models
  PatternFlowLacpduPartnerStateExpired expired = 8;
}

// IPv6 Extension header should be preceded either by IPv6 header or other IPv6 Extension
// headers and the next_header in that preceding header should be set to the correct
// value depending on the type of extension header configured. This will be automatically
// handled by implementation if next_header choice is set to auto. For Routing Extension
// header this value is 43.
message FlowIpv6ExtHeader {

  message Choice {
    enum Enum {
      unspecified = 0;
      routing = 1;
    }
  }
  // Description missing in models
  // default = Choice.Enum.routing
  optional Choice.Enum choice = 1;

  // Description missing in models
  PatternFlowIpv6ExtHeaderNextHeader next_header = 2;

  // Description missing in models
  PatternFlowIpv6ExtHeaderHdrExtLen hdr_ext_len = 3;

  // Description missing in models
  FlowIpv6Routing routing = 4;
}

// IPv6 routing packet headers.
message FlowIpv6Routing {

  message Choice {
    enum Enum {
      unspecified = 0;
      segment_routing = 1;
    }
  }
  // Description missing in models
  // default = Choice.Enum.segment_routing
  optional Choice.Enum choice = 1;

  // Description missing in models
  FlowIpv6SegmentRouting segment_routing = 2;
}

// Defines the structure of the IPv6 Segment Routing Header (SRH) with Routing Type
// 4. This header is an IPv6 Routing header used to specify a source-routed path for
// a packet, guiding it through a sequence of Segment IDs (SIDs), which are typically
// IPv6 addresses.
message FlowIpv6SegmentRouting {

  // Description missing in models
  PatternFlowIpv6SegmentRoutingSegmentsLeft segments_left = 1;

  // Description missing in models
  PatternFlowIpv6SegmentRoutingLastEntry last_entry = 2;

  // Description missing in models
  FlowIpv6SegmentRoutingFlags flags = 3;

  // Description missing in models
  PatternFlowIpv6SegmentRoutingTag tag = 4;

  // 128-bit IPv6 addresses representing the nth segment in the Segment List. The Segment
  // List is encoded starting from the last segment of the SR Policy. That is, the first
  // element of the Segment List (Segment List[0]) contains the last segment of the SR
  // Policy, the second element contains the penultimate segment of the SR Policy, and
  // so on.
  repeated FlowIpv6SegmentRoutingSegment segment_list = 5;
}

// Description missing in models
message FlowIpv6SegmentRoutingSegment {

  // Description missing in models
  PatternFlowIpv6SegmentRoutingSegmentSegment segment = 1;
}

// An 8-bit field containing flags. While RFC 8754 reserves all bits as unused, earlier
// drafts defined specific flags for behavior such as OAM, HMAC, and FRR protection.
message FlowIpv6SegmentRoutingFlags {

  // Description missing in models
  PatternFlowIpv6SegmentRoutingFlagsProtected protected = 1;

  // Description missing in models
  PatternFlowIpv6SegmentRoutingFlagsOam oam = 2;

  // Description missing in models
  PatternFlowIpv6SegmentRoutingFlagsAlert alert = 3;
}

// The frame size which overrides the total length of the packet
message FlowSize {

  message Choice {
    enum Enum {
      unspecified = 0;
      fixed = 1;
      increment = 2;
      random = 3;
      weight_pairs = 4;
    }
  }
  // Description missing in models
  // default = Choice.Enum.fixed
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 64
  optional uint32 fixed = 2;

  // Description missing in models
  FlowSizeIncrement increment = 3;

  // Description missing in models
  FlowSizeRandom random = 4;

  // Description missing in models
  FlowSizeWeightPairs weight_pairs = 5;
}

// Frame size that increments from a starting size to
// an ending size incrementing by a step size.
message FlowSizeIncrement {

  // Starting frame size in bytes
  // default = 64
  optional uint32 start = 1;

  // Ending frame size in bytes
  // default = 1518
  optional uint32 end = 2;

  // Step frame size in bytes
  // default = 1
  optional uint32 step = 3;
}

// Random frame size from a min value to a max value.
message FlowSizeRandom {

  // Description missing in models
  // default = 64
  optional uint32 min = 1;

  // Description missing in models
  // default = 1518
  optional uint32 max = 2;
}

// Frame size distribution, defined as <size, weight> pairs (including IMIX distribution).
// Frames are randomly generated such that the proportion of each frame size out of
// the total number of frames
// are matching with the weight value of the <size, weight> pair. However, as with any
// other probability
// distribution, the sample distribution is close to theoretical value only if the size
// of the sample is reasonably large.
// When the number of frames is very low the transmitted frames may not come close to
// the ratio described in the weight.
message FlowSizeWeightPairs {

  message Choice {
    enum Enum {
      unspecified = 0;
      predefined = 1;
      custom = 2;
    }
  }
  // Description missing in models
  // default = Choice.Enum.predefined
  optional Choice.Enum choice = 1;

  message Predefined {
    enum Enum {
      unspecified = 0;
      imix = 1;
      ipsec_imix = 2;
      ipv6_imix = 3;
      standard_imix = 4;
      tcp_imix = 5;
    }
  }
  // Specify predefined frame size distribution <size, weight> pairs (including IMIX distribution).
  // 
  // The available predefined distribution pairs are:
  // - IMIX (64:7, 570:4, and 1518:1)
  // - IPSec IMIX (90:58.67, 92:2, 594:23.66 and 1418:15.67)
  // - IPv6 IMIX (60:58.67, 496:2, 594:23.66 and 1518:15.67)
  // - Standard IMIX (58:58.67, 62:2, 594:23.66 and 1518:15.67)
  // - TCP IMIX (90:58.67, 92:2, 594:23.66 and 1518:15.67)
  // default = Predefined.Enum.imix
  optional Predefined.Enum predefined = 2;

  // Description missing in models
  repeated FlowSizeWeightPairsCustom custom = 3;
}

// Custom frame size distribution <size, weight> pair.
message FlowSizeWeightPairsCustom {

  // The size of the frame (in bytes) for this weight pair.
  // default = 64
  optional uint32 size = 1;

  // Weight assigned to the corresponding frame size in this weight pair.
  // Higher weight means more packets.
  // default = 1
  optional float weight = 2;
}

// The rate of packet transmission
message FlowRate {

  message Choice {
    enum Enum {
      unspecified = 0;
      pps = 1;
      bps = 2;
      kbps = 3;
      mbps = 4;
      gbps = 5;
      percentage = 6;
    }
  }
  // The available types of flow rate.
  // default = Choice.Enum.pps
  optional Choice.Enum choice = 1;

  // Packets per second.
  // default = 1000
  optional uint64 pps = 2;

  // Bits per second.
  // default = 1000000000
  optional uint64 bps = 3;

  // Kilobits per second.
  // default = 1000000
  optional uint64 kbps = 4;

  // Megabits per second.
  // default = 1000
  optional uint64 mbps = 5;

  // Gigabits per second.
  // default = 1
  optional uint32 gbps = 6;

  // The percentage of a port location's available bandwidth.
  // default = 100
  optional float percentage = 7;
}

// A container for different transmit durations.
message FlowDuration {

  message Choice {
    enum Enum {
      unspecified = 0;
      fixed_packets = 1;
      fixed_seconds = 2;
      burst = 3;
      continuous = 4;
    }
  }
  // A choice used to determine the type of duration.
  // default = Choice.Enum.continuous
  optional Choice.Enum choice = 1;

  // Description missing in models
  FlowFixedPackets fixed_packets = 2;

  // Description missing in models
  FlowFixedSeconds fixed_seconds = 3;

  // Description missing in models
  FlowBurst burst = 4;

  // Description missing in models
  FlowContinuous continuous = 5;
}

// Transmit will be continuous and will not stop automatically.
message FlowContinuous {

  // The minimum gap between packets expressed as bytes.
  // default = 12
  optional uint32 gap = 1;

  // Description missing in models
  FlowDelay delay = 2;
}

// The optional container to specify the delay before starting
// transmission of packets.
message FlowDelay {

  message Choice {
    enum Enum {
      unspecified = 0;
      bytes = 1;
      nanoseconds = 2;
      microseconds = 3;
    }
  }
  // Description missing in models
  // default = Choice.Enum.bytes
  optional Choice.Enum choice = 1;

  // The delay before starting transmission of packets.
  // A value of 0 indicates no delay.
  // default = 0
  optional float bytes = 2;

  // The delay before starting transmission of packets.
  // A value of 0 indicates no delay.
  // default = 0
  optional float nanoseconds = 3;

  // The delay before starting transmission of packets.
  // A value of 0 indicates no delay.
  // default = 0
  optional float microseconds = 4;
}

// Transmit a fixed number of packets after which the flow will stop.
message FlowFixedPackets {

  // Stop transmit of the flow after this number of packets.
  // default = 1
  optional uint32 packets = 1;

  // The minimum gap between packets expressed as bytes.
  // default = 12
  optional uint32 gap = 2;

  // Description missing in models
  FlowDelay delay = 3;
}

// Transmit for a fixed number of seconds after which the flow will stop.
message FlowFixedSeconds {

  // Stop transmit of the flow after this number of seconds.
  // default = 1
  optional float seconds = 1;

  // The minimum gap between packets expressed as bytes.
  // default = 12
  optional uint32 gap = 2;

  // Description missing in models
  FlowDelay delay = 3;
}

// Transmits continuous or fixed burst of packets.
// For continuous burst of packets, it will not automatically stop.
// For fixed burst of packets, it will stop after transmitting fixed number of bursts.
// 
message FlowBurst {

  // The number of packet bursts transmitted per flow.
  // A value of 0 implies continuous burst of packets.
  // default = 0
  optional uint32 bursts = 1;

  // The number of packets transmitted per burst.
  // default = 1
  optional uint32 packets = 2;

  // The minimum gap between packets expressed as bytes.
  // default = 12
  optional uint32 gap = 3;

  // Description missing in models
  FlowDurationInterBurstGap inter_burst_gap = 4;
}

// The optional container for specifying a gap between bursts.
message FlowDurationInterBurstGap {

  message Choice {
    enum Enum {
      unspecified = 0;
      bytes = 1;
      nanoseconds = 2;
      microseconds = 3;
    }
  }
  // The type of inter burst gap units.
  // default = Choice.Enum.bytes
  optional Choice.Enum choice = 1;

  // The amount of time between bursts expressed in bytes.
  // A value of 0 indicates no gap between bursts.
  // default = 12
  optional double bytes = 2;

  // The amount of time between bursts expressed in nanoseconds.
  // A value of 0 indicates no gap between bursts.
  // default = 96
  optional double nanoseconds = 3;

  // The amount of time between bursts expressed in microseconds.
  // A value of 0 indicates no gap between bursts.
  // default = 0.096
  optional double microseconds = 4;
}

// The optional container for configuring flow metrics.
message FlowMetrics {

  // Enables flow metrics.
  // Enabling this option may affect the resultant packet payload due to
  // additional instrumentation data.
  // default = False
  optional bool enable = 1;

  // Enables additional flow metric loss calculation.
  // default = False
  optional bool loss = 2;

  // Rx Tx ratio.
  FlowRxTxRatio rx_tx_ratio = 6;

  // Enables additional flow metric first and last timestamps.
  // default = False
  optional bool timestamps = 3;

  // Latency metrics.
  FlowLatencyMetrics latency = 4;

  // Predefined metric tags
  FlowPredefinedTags predefined_metric_tags = 5;
}

// The optional container for per flow latency metric configuration.
message FlowLatencyMetrics {

  // True to enable latency metrics using timestamps.
  // 
  // Enabling this option may affect the resultant packet payload due to
  // additional instrumentation data.
  // default = False
  optional bool enable = 1;

  message Mode {
    enum Enum {
      unspecified = 0;
      store_forward = 1;
      cut_through = 2;
    }
  }
  // Select the type of latency measurement. The different types of
  // latency measurements are:
  // 
  // 
  // store_forward:
  // The time interval starting when the last bit of the frame leaves the
  // sending port and ending when the first bit of the frame is seen on
  // the receiving port (LIFO).  This is based on the RFC 1242 standard.
  // 
  // 
  // cut_through:
  // The time interval starting when the first bit of the frame leaves
  // the sending port and ending when the first bit of the frame is seen
  // on the receiving port (FIFO).  This is based on the RFC 1242
  // standard.
  // default = Mode.Enum.store_forward
  optional Mode.Enum mode = 2;
}

// List of predefined flow tracking options, outside packet fields, that can be enabled.
message FlowPredefinedTags {

  // Enables Rx port or lag level disaggregation with predefined metrics tag name set
  // as rx_name.
  // The Rx port / lag names can be found under tagged_metrics tag names in flow metrics
  // response.
  // default = False
  optional bool rx_name = 1;
}

// Rx Tx ratio is the ratio of expected number of Rx packets across all Rx ports to
// the Tx packets
// for the configured flow. It is a factor by which the Tx packet count is multiplied
// to calculate
// the sum of expected Rx packet count, across all Rx ports. This will be used to calculate
// loss
// percentage of flow at aggregate level.
message FlowRxTxRatio {

  message Choice {
    enum Enum {
      unspecified = 0;
      rx_count = 1;
      value = 2;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  FlowRxTxRatioRxCount rx_count = 2;

  // Should be a positive, non-zero value. The default value of 1, is when the Rx packet
  // count across
  // all ports is expected to match the Tx packet count. A custom integer value (>1) can
  // be specified for
  // loss calculation for cases when there are multiple destination addresses configured
  // within one flow,
  // but DUT is configured to replicate only to a subset of Rx ports. For cases when Tx
  // side generates two
  // packets from each source in 1:1 protection mode but only one of the two packets are
  // received by the
  // Rx port, we may need to specify a fractional value instead.
  // default = 1.0
  optional float value = 3;
}

// This is for cases where one copy of Tx packet is received on all Rx ports and so
// the sum total of Rx packets
// received across all Rx ports is a multiple of Rx port count and Tx packets.
message FlowRxTxRatioRxCount {
}

// A container for different types of payload, which is the data in the frame after
// protocol headers.
// Some part of the payload could be overwritten with instrumentation data, contents
// and placement of  which is implementation specific.
message FlowPayload {

  message Choice {
    enum Enum {
      unspecified = 0;
      fixed = 1;
      increment_byte = 2;
      decrement_byte = 3;
      increment_word = 4;
      decrement_word = 5;
    }
  }
  // A choice used to determine the pattern of the bytes in the payload following the
  // protocol headers.
  // Example of expected behaviour of each choice is as mentioned below,
  // - fixed: this would insert user defined pattern in the payload bytes.
  // - increment_byte: this would set the first byte as 00, second as 01 and so on, upto
  // ff and then the pattern would be repeated.
  // - decrement_byte: this would set the first byte as ff, second as fe and so on, upto
  // 00 and then the pattern would be repeated.
  // - increment_word: this would set the first 2 bytes as 00 00, second as 00 01 and
  // so on, upto ff ff and then the pattern would be repeated.
  // - decrement_word: this would set the first 2 bytes as ff ff, second as ff fe and
  // so on, upto 00 00 and then the pattern would be repeated.
  // default = Choice.Enum.fixed
  optional Choice.Enum choice = 1;

  // Description missing in models
  FlowPayloadFixed fixed = 2;
}

// Payload with user defined pattern.
message FlowPayloadFixed {

  // Description missing in models
  // default = 00
  optional string pattern = 1;

  // - If enabled, the given pattern would repeat till end of payload.
  // - If disabled, after the pattern, rest of the payload will be zero-padded.
  // default = True
  optional bool repeat = 2;
}

// The optional container for event configuration.
// Both cp_events.enable and dp_events.enable must be explicitly set to true to get
// 
// control_plane_data_plane_convergence_us metric values for convergence metrics.
message Event {

  // Container for control plane(cp) event configuration.
  EventCPEvents cp_events = 1;

  // Container for data plane(dp) event configuration.
  // Enabling this option may affect the resultant packet payload due to
  // additional instrumentation data.
  EventDPEvents dp_events = 2;
}

// The optional container for control plane event configuration.
message EventCPEvents {

  // Setting to true enables start and end time for control_plane events
  // associated with started flows to be recorded.
  // default = False
  optional bool enable = 1;
}

// The optional container for data plane event configuration.
message EventDPEvents {

  // Setting to true enables flow_rx_rate_above_threshold and flow_rx_rate_below_threshold
  // 
  // timestamps to be recorded when data packets switch between multiple rx_ports on the
  // receive ports for affected flows.
  // default = False
  optional bool enable = 1;

  // Setting to true enables timestamps to be recorded when the rx rate of a flow goes
  // above
  // or below the threshold value.
  // default = 95
  optional float rx_rate_threshold = 2;
}

// Description missing in models
message EventRequest {

  message Type {
    enum Enum {
      unspecified = 0;
      link_down = 1;
      link_up = 2;
      route_withdraw = 3;
      route_advertise = 4;
      flow_rx_rate_above_threshold = 5;
      flow_rx_rate_below_threshold = 6;
    }
  }
  // Constrain the events being returned by specifying event types.
  // If the list is empty then all event types will be returned.
  repeated Type.Enum type = 1;

  // Constrain the events being returned by specifying event sources.
  // If the list is empty then all event sources will be returned.
  // 
  // x-constraint:
  // - /components/schemas/Port/properties/name
  // - /components/schemas/Bgp.V4RouteRange/name
  // - /components/schemas/Bgp.V6RouteRange/name
  // 
  repeated string source = 2;
}

// A container that describes what events a system should provide and
// optionally where to publish them.
message EventSubscription {

  // Description missing in models
  EventRequest events = 1;

  // Indicates where a client wants to be notified of the events set in
  // the events property.
  // If this property is empty or null then no event notifications will
  // be forwarded.
  optional string callback_url = 2;
}

// Configuration of LLDP protocol IEEE Ref: https://www.ieee802.org/1/files/public/docs2002/lldp-protocol-00.pdf
message Lldp {

  // The unique name of the object on which LLDP is running.
  // required = true
  LldpConnection connection = 1;

  // The Chassis ID is a mandatory TLV which identifies the chassis component of the endpoint
  // identifier associated  with the transmitting LLDP agent. If mac address is specified
  // it should be in colon seperated mac address format.
  LldpChassisId chassis_id = 2;

  // The Port ID is a mandatory TLV which identifies the port component of the endpoint
  // identifier associated with  the transmitting LLDP agent. If the specified port is
  // an IEEE 802.3 Repeater port, then this TLV is optional.
  LldpPortId port_id = 3;

  // The system name field shall contain an alpha-numeric string that indicates the system's
  // administratively assigned  name. The system name should be the system's fully qualified
  // domain name. If implementations support IETF RFC  3418, the sysName object should
  // be used for this field.
  LldpSystemName system_name = 4;

  // Specifies the amount of time in seconds a receiving device should maintain LLDP information
  // sent  by the device before discarding it.
  // default = 120
  optional uint32 hold_time = 5;

  // Set the transmission frequency of LLDP updates in seconds.
  // default = 30
  optional uint32 advertisement_interval = 6;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  optional string name = 7;

  // The Organization Information is used to define the organization specific TLVs. The
  // organization specific TLV is defined in IEEE 802.1AB-2016 specification. This category
  // is provided to allow different organizations, such as  IEEE 802.1, IEEE 802.3, IETF,
  // as well as individual software and equipment vendors, to define TLVs that advertise
  // information to remote entities attached to the same media.
  repeated LldpOrgInfo org_infos = 8;
}

// LLDP connection to a test port. In future if more connection options arise  LLDP
// connection object will be enhanced.
message LldpConnection {

  message Choice {
    enum Enum {
      unspecified = 0;
      port_name = 1;
    }
  }
  // The name of the test port or other connection objects on which LLDP is configured.
  optional Choice.Enum choice = 1;

  // Name of the test port on which LLDP is configured on.
  // 
  // x-constraint:
  // - /components/schemas/Port/properties/name
  // 
  optional string port_name = 2;
}

// The Chassis ID is a mandatory TLV which identifies the chassis component of the endpoint
// identifier associated  with the transmitting LLDP agent. This field identifies the
// format and source of the chassis identifier string.  It is based on the enumerator
// defined by the LldpChassisIdSubtype object from IEEE 802.1AB MIB.
message LldpChassisId {

  message Choice {
    enum Enum {
      unspecified = 0;
      mac_address_subtype = 1;
      interface_name_subtype = 2;
      local_subtype = 3;
    }
  }
  // Chassis ID subtype to be used in Chassis ID TLV.
  // default = Choice.Enum.mac_address_subtype
  optional Choice.Enum choice = 1;

  // Description missing in models
  LldpChassisMacSubType mac_address_subtype = 2;

  // Name of an interface of the chassis that uniquely identifies the chassis.
  optional string interface_name_subtype = 3;

  // Locally assigned name of the chassis.
  optional string local_subtype = 4;
}

// The Port ID is a mandatory TLV which identifies the port component of the endpoint
// identifier associated with  the transmitting LLDP agent.This field identifies the
// format and source of the port identifier string. It is  based on the enumerator defined
// by the PtopoPortIdType object from RFC2922.
message LldpPortId {

  message Choice {
    enum Enum {
      unspecified = 0;
      mac_address_subtype = 1;
      interface_name_subtype = 2;
      local_subtype = 3;
    }
  }
  // Port ID subtype to be used in Port ID TLV.
  // default = Choice.Enum.interface_name_subtype
  optional Choice.Enum choice = 1;

  // The MAC Address configured in the Port ID TLV.
  optional string mac_address_subtype = 2;

  // Description missing in models
  LldpPortInterfaceNameSubType interface_name_subtype = 3;

  // The Locally assigned name configured in the Port ID TLV.
  optional string local_subtype = 4;
}

// The MAC address configured in the Chassis ID TLV.
message LldpChassisMacSubType {

  message Choice {
    enum Enum {
      unspecified = 0;
      auto = 1;
      value = 2;
    }
  }
  // In auto mode the system generated value is set for this property, while if the choice
  // is selected as value,  a user configured value will be used for this property.
  // default = Choice.Enum.auto
  optional Choice.Enum choice = 1;

  // The OTG implementation must provide a system generated value for this property.
  optional string auto = 2;

  // User must specify a value if mode is not auto.
  optional string value = 3;
}

// The interface name configured in the Port ID TLV.
message LldpPortInterfaceNameSubType {

  message Choice {
    enum Enum {
      unspecified = 0;
      auto = 1;
      value = 2;
    }
  }
  // In auto mode the system generated value is set for this property, while if the choice
  // is selected as value,  a user configured value will be used for this property.
  // default = Choice.Enum.auto
  optional Choice.Enum choice = 1;

  // The OTG implementation must provide a system generated value for this property.
  optional string auto = 2;

  // User must specify a value if mode is not auto.
  optional string value = 3;
}

// The system Name configured in the System Name TLV.
message LldpSystemName {

  message Choice {
    enum Enum {
      unspecified = 0;
      auto = 1;
      value = 2;
    }
  }
  // In auto mode the system generated value is set for this property, while if the choice
  // is selected as value,  a user configured value will be used for this property.
  // default = Choice.Enum.auto
  optional Choice.Enum choice = 1;

  // The OTG implementation must provide a system generated value for this property.
  optional string auto = 2;

  // User must specify a value if mode is not auto.
  optional string value = 3;
}

// The organization specific information configured in the Organization Specific TLV.
// 
message LldpOrgInfo {

  // The organizationally unique identifier field shall contain the organization's OUI
  // as defined in Clause 9 of IEEE  Std 802. It is a 24 bit number that uniquely identifies
  // a vendor, manufacturer, or other organizations.
  // default = 0080C2
  optional string oui = 1;

  // The organizationally defined subtype field shall contain a unique subtype value assigned
  // by the defining organization.
  // default = 1
  optional uint32 subtype = 2;

  // Contains the organizationally defined information. The actual format of the organizationally
  // defined information string  field is organizationally specific and can contain either
  // binary or alpha-numeric information that is instance specific  for the particular
  // TLV type and subtype. Alpha-numeric information are encoded in UTF-8 (as specified
  // in IETF RFC 3629).  Or include one or more information fields with their associated
  // field-type identifiers, designators similar to those in  the Management Address TLV.
  LldpOrgInfoType information = 3;
}

// Contains either the Alpha-numeric information encoded in UTF-8 (as specified in IETF
// RFC 3629) or include one or more information fields with  their associated field-type
// identifiers designators, similar to those in the Management Address TLV. Currently
// only one choice as info is given in future if required it can be extended to define
// sub tlvs.
message LldpOrgInfoType {

  message Choice {
    enum Enum {
      unspecified = 0;
      info = 1;
    }
  }
  // In info mode the organizationally defined information contain either binary or alpha-numeric
  // information encoded in UTF-8  (as specified in IETF RFC 3629).
  // default = Choice.Enum.info
  optional Choice.Enum choice = 1;

  // The organizationally defined information encoded in UTF-8 (as specified in IETF RFC
  // 3629). This byte stream can be of any  length from 1 to 507 bytes. In the info byte
  // stream, one byte is represented as string of 2 characters, for example 2  character
  // string (0x)AB represents value of a single byte. So the maximum length of this attribute
  // is 1014 (507 * 2 hex  characters per byte).
  optional string info = 2;
}

// Conversational traffic where the responding side can be responded back with control
// messages, eg incase of rocev2 responding side can send ack, nak.
message StatefulFlow {

  message Choice {
    enum Enum {
      unspecified = 0;
      rocev2 = 1;
    }
  }
  // Stateful traffic flow configuration.
  optional Choice.Enum choice = 1;

  // RoCEv2 Flow Groups.
  repeated Rocev2Flows rocev2 = 2;
}

// RoCEv2 traffic flow configuration.
message Rocev2Flows {

  // Specifies the list of transmit (TX) ports used for sending RoCEv2 traffic.
  repeated Rocev2TxPorts tx_ports = 1;
}

// Defines the transmit (TX) port settings for RoCEv2 traffic, including the port name
// and transmission type configuration.
message Rocev2TxPorts {

  // The name of port for which this settings will be applied to.
  // 
  // x-constraint:
  // - /components/schemas/Port/properties/name
  // 
  optional string port_name = 1;

  // Description missing in models
  Rocev2TransmitType transmit_type = 2;
}

// RoCEv2 flows can be configured to run in continuous mode or fixed iteration.
message Rocev2TransmitType {

  message Choice {
    enum Enum {
      unspecified = 0;
      target_line_rate = 1;
    }
  }
  // Description missing in models
  // default = Choice.Enum.target_line_rate
  optional Choice.Enum choice = 1;

  // Description missing in models
  Rocev2TargetLineRate target_line_rate = 2;
}

// Configure target line rate of traffic rate on this port as percentage of link speed.
message Rocev2TargetLineRate {

  // Target Line Rate as percentage of max line rate.
  // default = 98
  optional uint64 value = 1;

  // Description missing in models
  repeated Rocev2Flow flows = 2;
}

// Configure properties for a specific RoCE flow on the Tx port.
message Rocev2Flow {

  // The unique name of an emulated device that will be transmitting the flows.
  // 
  // x-constraint:
  // - /components/schemas/Rocev2.QPs/properties/qp_name
  // 
  // required = true
  optional string tx_endpoint = 1;

  // The unique name of remote QP or port which be receiving the packets for the flow.
  // 
  // x-constraint:
  // - /components/schemas/Port/properties/name
  // - /components/schemas/Rocev2.QPs/properties/qp_name
  // 
  optional string rx_endpoint = 2;

  // Globally unique name of an object. It also serves as the primary key for arrays of
  // objects.
  // required = true
  optional string name = 3;

  // Description missing in models
  Rocev2Verb rocev2_verb = 4;

  // Length of Message that needs to be transmitted to the remote end-point.
  // default = 1
  optional uint32 message_size = 5;

  message MessageSizeUnit {
    enum Enum {
      unspecified = 0;
      bytes = 1;
      kb = 2;
      mb = 3;
      gb = 4;
    }
  }
  // Unit of the transfer message size. Available options are Bytes, KiloBtyes (KB), NegaBytes
  // (MB) and GigaBytes (GB).
  // default = MessageSizeUnit.Enum.mb
  optional MessageSizeUnit.Enum message_size_unit = 6;
}

// RoCEv2 Verb. Available options are: WRITE, WRITE_With_Immediate, SEND, SEND_With_Immediate
// and READ.
message Rocev2Verb {

  message Choice {
    enum Enum {
      unspecified = 0;
      write = 1;
      write_with_immediate = 2;
      send = 3;
      send_with_immediate = 4;
      read = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.write
  optional Choice.Enum choice = 1;

  // Description missing in models
  Rocev2ImmediateData write_with_immediate = 2;

  // Description missing in models
  Rocev2ImmediateData send_with_immediate = 3;
}

// Four bytes of immediate Data for SEND/WRITE with immediate.
message Rocev2ImmediateData {

  // Four bytes of immediate Data for SEND/WRITE with immediate.
  // default = 00000000
  optional string immediate_data = 1;
}

// Egress tracking specification for a specified port.
// An application which supports a single or limited number of egress tracking specifications
// for a single port
// should return an error if the number of egress tracking specifications for a specific
// port or in total exceeds its capabilities.
message EgressOnlyTracking {

  // Name of the received port this egress tracking rule/specification has to be applied.
  // 
  // x-constraint:
  // - /components/schemas/Port/properties/name
  // 
  // required = true
  optional string port_name = 1;

  // One or more metric tags can be used to enable tracking portion of or all bits
  // in a corresponding header field for metrics per each applicable value.
  // These would appear as tagged metrics in corresponding egress_only_tracking metrics.
  repeated EgressOnlyTrackingMetricTags metric_tags = 2;

  // Enables additional metric first and last timestamps.
  // default = False
  optional bool enable_timestamps = 3;

  // Specifies a rule which will be used to first filter received packets on this port
  // 
  // before applying the egress tracking metric_tags on them.
  // If multiple filters are provided, then an incoming packet MUST pass all the filters.
  // 
  // If the packet does not pass any filter, it is not considered for egress tracking.
  repeated EgressOnlyTrackingFilter filters = 4;
}

// Metric Tag can be used to enable tracking portion of or all bits
// in a corresponding header field for metrics per each applicable value.
// These would appear as tagged metrics in corresponding egress_only_tracking metrics.
message EgressOnlyTrackingMetricTags {

  // The name used to identify the metric tracked at configured Rx offset and of configured
  // length.
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of the received packet on the receiving port.
  // required = true
  optional uint32 rx_offset = 2;

  // Offset in bits relative to start of the transmitted packet from the transmitting
  // port.
  EgressOnlyTrackingTxOffset tx_offset = 3;

  // Number of bits to track for metrics starting from configured offset
  // from start of the packet.
  // default = 1
  optional uint32 length = 4;
}

// A container of Tx offset properties. Tx offset configuration is optional. It is relevant
// only when optional Tx statistics in egress only tracking are supported and when fetching
// egress only stats with tx_metric also enabled in get_metrics/egress_only_tracking/tagged_metric/metric_names.
message EgressOnlyTrackingTxOffset {

  message Choice {
    enum Enum {
      unspecified = 0;
      auto = 1;
      custom = 2;
    }
  }
  // Choose auto when both offsets of tracked field in Tx/ Rx packets are the same. Otherwise
  // choose custom.
  // default = Choice.Enum.auto
  optional Choice.Enum choice = 1;

  // 
  EgressOnlyTrackingTxOffsetCustom custom = 2;
}

// A container of custom Tx offset properties. Choose custom when the Tx and Rx offsets
// are different due to DUT adding/ modifying or deleting encapsulation protocol header
// e.g. when the egress-only tracked packets are MACsec encapulated and the Tx and Rx
// side have different configuration such that the MACSec header is added/modified or
// removed.
message EgressOnlyTrackingTxOffsetCustom {

  // Offset in bits relative to start of the transmitted packet from the transmitting
  // port.
  optional uint32 value = 1;
}

// Description missing in models
message EgressOnlyTrackingFilter {

  message Choice {
    enum Enum {
      unspecified = 0;
      none = 1;
      auto_macsec = 2;
    }
  }
  // If a packet does not match the filter it will not be considered for egress tracking.
  // Currently two options are provided: none: All packets will be considered for egress
  // only tracking. auto_macsec: This requires that MACsec enabled Ethernet interface
  // should be configured on this port.  This filter will ensure that only packets with
  // Ethernet Type set to MACsec (0x88E5) and  destined to traffic Rx device(s) will be
  // considered for egress only tracking
  // default = Choice.Enum.none
  optional Choice.Enum choice = 1;
}

// Port specific configurations.
message PerPortOptions {

  // The name of port for which this settings will be applied to.
  // 
  // x-constraint:
  // - /components/schemas/Port/properties/name
  // 
  optional string port_name = 1;

  // Description missing in models
  repeated PortProtocol protocols = 2;
}

// Supprted protocols.
message PortProtocol {

  message Choice {
    enum Enum {
      unspecified = 0;
      rocev2 = 1;
    }
  }
  // list of protocols that have per port settings
  // default = Choice.Enum.rocev2
  optional Choice.Enum choice = 1;

  // Description missing in models
  Rocev2PerPortSettings rocev2 = 2;
}

// Data plane traffic flow configuration for a test port.
message Rocev2PerPortSettings {

  // Description missing in models
  Rocev2CNP cnp = 1;

  // Description missing in models
  Rocev2QPConnectionType connection_type = 2;

  // Description missing in models
  Rocev2DCQCN dcqcn_settings = 3;
}

// CNP parameters.
message Rocev2CNP {

  message Choice {
    enum Enum {
      unspecified = 0;
      ip_dscp = 1;
    }
  }
  // Description missing in models
  // default = Choice.Enum.ip_dscp
  optional Choice.Enum choice = 1;

  // IP DSCP value for the CNP packets.
  Rocev2PriorityValue ip_dscp = 2;

  message EcnValue {
    enum Enum {
      unspecified = 0;
      non_ect = 1;
      ect_1 = 2;
      ect_0 = 3;
      ce = 4;
    }
  }
  // CNP ECN Value.
  // default = EcnValue.Enum.ect_1
  optional EcnValue.Enum ecn_value = 3;

  // The interval duration between the generation of successive CNP packets should be
  // specified in microseconds.
  // default = 55
  optional uint32 cnp_delay_timer = 4;
}

// Specifies the connection type for the QP, determining what and how the QP transfers
// data.
message Rocev2QPConnectionType {

  message Choice {
    enum Enum {
      unspecified = 0;
      reliable_connection = 1;
    }
  }
  // Description missing in models
  // default = Choice.Enum.reliable_connection
  optional Choice.Enum choice = 1;

  // Description missing in models
  Rocev2AckAndNak reliable_connection = 2;
}

// Defines the ACK and NAK settings for RoCEv2. This configuration ensures reliable
// data delivery by controlling how the system responds to successful and failed packet
// transmissions.
message Rocev2AckAndNak {

  // Description missing in models
  Rocev2ACK ack = 1;

  // Description missing in models
  Rocev2NAK nak = 2;

  // Enable Retransmission on ACK Timeout.
  // default = True
  optional bool enable_retransmission_timeout = 3;

  // The duration to wait before retrying transmission upon not receiving an acknowledgment
  // (ACK) or negative acknowledgment (NAK) is specified in milliseconds.
  // default = 1
  optional uint32 retransmission_timeout_value = 4;

  // Number of retransmission attempts before stopping due to missing ACK/NAK.
  // default = 3
  optional uint32 retransmission_retry_count = 5;
}

// ACK parameters.
message Rocev2ACK {

  message Choice {
    enum Enum {
      unspecified = 0;
      ip_dscp = 1;
    }
  }
  // Description missing in models
  // default = Choice.Enum.ip_dscp
  optional Choice.Enum choice = 1;

  // IP DSCP value for the ACK packets.
  Rocev2PriorityValue ip_dscp = 2;

  message EcnValue {
    enum Enum {
      unspecified = 0;
      non_ect = 1;
      ect_1 = 2;
      ect_0 = 3;
      ce = 4;
    }
  }
  // ACK ECN Value.
  // default = EcnValue.Enum.ect_1
  optional EcnValue.Enum ecn_value = 3;
}

// NAK parameters.
message Rocev2NAK {

  message Choice {
    enum Enum {
      unspecified = 0;
      ip_dscp = 1;
    }
  }
  // Description missing in models
  // default = Choice.Enum.ip_dscp
  optional Choice.Enum choice = 1;

  // IP DSCP value for the NAK packets.
  Rocev2PriorityValue ip_dscp = 2;

  message EcnValue {
    enum Enum {
      unspecified = 0;
      non_ect = 1;
      ect_1 = 2;
      ect_0 = 3;
      ce = 4;
    }
  }
  // ECN Code point to add in NAK packets.
  // default = EcnValue.Enum.ect_1
  optional EcnValue.Enum ecn_value = 3;
}

// Priority value for CNP, ACK or NAK packets.
message Rocev2PriorityValue {

  // Description missing in models
  // default = 48
  optional uint32 value = 1;
}

// RoCEv2 DCQCN Settings.
message Rocev2DCQCN {

  // Enable DCQCN port settigns.
  // default = True
  optional bool enable_dcqcn = 1;

  // Controls the increment / decrement of the alpha parameter in DCQCN algorithm.
  // default = 1019
  optional uint64 alpha_g = 2;

  // Value of the alpha at the time when the first CNP is received.
  // default = 1023
  optional uint64 initial_alpha = 3;

  // timer after which the alpha parameter will update according to the algorithm. Unit
  // is microseconds.
  // default = 21
  optional uint64 alpha_update_period = 4;

  // timer after which the algorithm will check if CNP is there or not and if CNP is present
  // it will reduce the rate.
  // Unit is microseconds.
  // default = 21
  optional uint64 rate_reduction_time_period = 5;

  // This is the percentage of rate user wants to set on receiving the first CNP.
  // default = 0.002
  optional float initial_rate_after_first_cnp = 6;

  // This is the minimum line rate which user wants to restrict. Below this the algorithm
  // cannot set the rate.
  // default = 0.002
  optional float minimum_rate_limmit = 7;

  // This is the maximum that line rate can be decreased on triggering a rate reduce algorithm.
  // default = 10
  optional uint32 maximum_rate_decrement_at_time = 8;

  // Is used to reduce the target rate by remembering the current rate.
  // If it is not set, then only the target rate will be reduced for the
  // first CNP after each rate increment otherwise if its set then the target
  // rate will be reduced for each rate reduce.
  // default = False
  optional bool clamp_target_rate = 9;

  // After the expiry of this timer, the rate recovery algorithms will be triggered. Unit
  // is microseconds.
  // default = 250
  optional uint64 rate_increment_time = 10;

  // This is the bytes counter.
  // After the expiry of this bytes also counter the rate recovery algorithms will be
  // triggered, and the rate will be recovered.
  // default = 32767
  optional uint64 rate_increment_byte_counter = 11;

  // This is the threshold value which will ensure how many times, each rate recovery
  // algorithms will execute before moving to the next value.
  // default = 25
  optional uint32 rate_increment_threshold = 12;

  // This is the rate at which the target rates will increase when the DCQCN will be in
  // the additive increase rate recovery mode.
  // default = 0.001
  optional float additive_increment_rate = 13;

  // This is the rate at which the target rates will increase when the DCQCN will be in
  // the hyper increment rate recovery mode.
  // default = 0.001
  optional float hyper_increment_rate = 14;
}

// Error response generated while serving API request.
message Error {

  // Numeric status code based on the underlying transport being used.
  // The API server MUST set this code explicitly based on following references:
  // - HTTP 4xx errors: https://datatracker.ietf.org/doc/html/rfc9110#section-15.5
  // - HTTP 5xx errors: https://datatracker.ietf.org/doc/html/rfc9110#section-15.6
  // - gRPC errors: https://grpc.github.io/grpc/core/md_doc_statuscodes.html
  // required = true
  optional int32 code = 1;

  message Kind {
    enum Enum {
      unspecified = 0;
      validation = 1;
      internal = 2;
    }
  }
  // Classification of error originating from within API server that may not be mapped
  // to the value in `code`.
  // Absence of this field may indicate that the error did not originate from within API
  // server.
  optional Kind.Enum kind = 2;

  // List of error messages generated while executing the request.
  repeated string errors = 3;
}

// A list of warnings that have occurred while executing the request.
message Warning {

  // A list of any system specific warnings that have occurred while
  // executing the request.
  repeated string warnings = 1;
}

// Request for updating specific attributes of resources in traffic generator
message ConfigUpdate {

  message Choice {
    enum Enum {
      unspecified = 0;
      flows = 1;
    }
  }
  // Description missing in models
  optional Choice.Enum choice = 1;

  // Description missing in models
  FlowsUpdate flows = 2;
}

// A container of flows with associated properties to be updated without affecting the
// flows current transmit state.
message FlowsUpdate {

  message PropertyNames {
    enum Enum {
      unspecified = 0;
      rate = 1;
      size = 2;
    }
  }
  // Flow properties to be updated without affecting the transmit state.
  repeated PropertyNames.Enum property_names = 1;

  // The list of configured flows for which given property will be updated.
  repeated Flow flows = 2;
}

// A container for all configuration resources of various types to be appended.
message ConfigAppend {

  // Description missing in models
  repeated ConfigAppendResources config_append_list = 1;
}

// A container for an existing resource to be appended.
message ConfigAppendResources {

  message Choice {
    enum Enum {
      unspecified = 0;
      flows = 1;
    }
  }
  // Description missing in models
  // required = true
  optional Choice.Enum choice = 1;

  // The flows that will be added to existing configuration on the traffic generator.
  // The flow name must not already be used in existing configuration.
  repeated Flow flows = 2;
}

// A container for all configuration resources of various types to be deleted.
message ConfigDelete {

  // Description missing in models
  repeated ConfigDeleteResources config_delete_list = 1;
}

// A container for an existing resource to be deleted.
message ConfigDeleteResources {

  message Choice {
    enum Enum {
      unspecified = 0;
      flows = 1;
    }
  }
  // Description missing in models
  // required = true
  optional Choice.Enum choice = 1;

  // List of flows that will be deleted from existing configuration on the traffic generator.
  // 
  // x-constraint:
  // - /components/schemas/Flow/properties/name
  // 
  repeated string flows = 2;
}

// Request for setting operational state of configured resources.
message ControlState {

  message Choice {
    enum Enum {
      unspecified = 0;
      port = 1;
      protocol = 2;
      traffic = 3;
    }
  }
  // Description missing in models
  // required = true
  optional Choice.Enum choice = 1;

  // Description missing in models
  StatePort port = 2;

  // Description missing in models
  StateProtocol protocol = 3;

  // Description missing in models
  StateTraffic traffic = 4;
}

// States associated with configured ports.
message StatePort {

  message Choice {
    enum Enum {
      unspecified = 0;
      link = 1;
      capture = 2;
    }
  }
  // Description missing in models
  // required = true
  optional Choice.Enum choice = 1;

  // Description missing in models
  StatePortLink link = 2;

  // Description missing in models
  StatePortCapture capture = 3;
}

// States associated with configured flows
message StateTraffic {

  message Choice {
    enum Enum {
      unspecified = 0;
      flow_transmit = 1;
    }
  }
  // Description missing in models
  // required = true
  optional Choice.Enum choice = 1;

  // Description missing in models
  StateTrafficFlowTransmit flow_transmit = 2;
}

// States associated with protocols on configured resources.
message StateProtocol {

  message Choice {
    enum Enum {
      unspecified = 0;
      all = 1;
      route = 2;
      lacp = 3;
      bgp = 4;
      isis = 5;
      ospfv2 = 6;
      ospfv3 = 7;
    }
  }
  // Description missing in models
  // required = true
  optional Choice.Enum choice = 1;

  // Description missing in models
  StateProtocolAll all = 2;

  // Description missing in models
  StateProtocolRoute route = 3;

  // Description missing in models
  StateProtocolLacp lacp = 4;

  // Description missing in models
  StateProtocolBgp bgp = 5;

  // Description missing in models
  StateProtocolIsis isis = 6;

  // Description missing in models
  StateProtocolOspfv2 ospfv2 = 7;

  // Description missing in models
  StateProtocolOspfv3 ospfv3 = 8;

  // Description missing in models
  StateProtocolRocev2 rocev2 = 9;
}

// Sets the link of configured ports.
message StatePortLink {

  // The names of target ports. An empty or null list will target all ports.
  // 
  // x-constraint:
  // - /components/schemas/Port/properties/name
  // 
  repeated string port_names = 1;

  message State {
    enum Enum {
      unspecified = 0;
      up = 1;
      down = 2;
    }
  }
  // The link state.
  // required = true
  optional State.Enum state = 2;
}

// Sets the capture state of configured ports
message StatePortCapture {

  // The names of ports to which the capture state will be applied to. If the list of
  // port_names is empty or null the state will be applied to all configured ports.
  // If the list is not empty any port that is not included in the list of port_names
  // MUST be ignored and not included in the state change.
  // 
  // x-constraint:
  // - /components/schemas/Port/properties/name
  // 
  repeated string port_names = 1;

  message State {
    enum Enum {
      unspecified = 0;
      start = 1;
      stop = 2;
    }
  }
  // The capture state.
  // required = true
  optional State.Enum state = 2;
}

// Resets the configured ports to initialized state.
message ActionPortReboot {

  // The names of target ports. An empty or null list will target all ports.
  // 
  // x-constraint:
  // - /components/schemas/Port/properties/name
  // 
  repeated string port_names = 1;
}

// Provides state control of flow transmission.
message StateTrafficFlowTransmit {

  // The names of flows to which the transmit state will be applied to. If the list of
  // flow_names is empty or null the state will be applied to all configured flows.
  // If the list is not empty any flow that is not included in the list of flow_names
  // MUST be ignored and not included in the state change.
  // 
  // x-constraint:
  // - /components/schemas/Flow/properties/name
  // 
  repeated string flow_names = 1;

  message State {
    enum Enum {
      unspecified = 0;
      start = 1;
      stop = 2;
      pause = 3;
      resume = 4;
    }
  }
  // The transmit state.
  // If the value of the state property is 'start' then all flows defined by the 'flow_names'
  // property will be started and the metric counters MUST be cleared prior to starting
  // the flow(s).
  // If the value of the state property is 'stop' then all flows defined by the 'flow_names'
  // property will be stopped and the metric counters MUST NOT be cleared.
  // If the value of the state property is 'pause' then all flows defined by the 'flow_names'
  // property will be paused and the metric counters MUST NOT be cleared.
  // If the value of the state property is 'resume' then any paused flows defined by the
  // 'flow_names' property will start transmit at the point at which they were paused.
  // Any flow that is stopped will start transmit at the beginning of the flow. The flow(s)
  // MUST NOT have their metric counters cleared.
  // required = true
  optional State.Enum state = 2;
}

// Sets all configured protocols to `start` or `stop` state.
// Setting protocol state to `start` shall be a no-op if preceding `set_config` API
// call was made with `config.options.protocol_options.auto_start_all` set to `true`
// or if all the configured protocols are already started.
message StateProtocolAll {

  message State {
    enum Enum {
      unspecified = 0;
      start = 1;
      stop = 2;
    }
  }
  // Protocol states
  // required = true
  optional State.Enum state = 1;
}

// Sets the state of configured routes
message StateProtocolRoute {

  // The names of device route objects to control. If no names are specified then all
  // route objects that match the x-constraint will be affected.
  // 
  // x-constraint:
  // - /components/schemas/Bgp.V4RouteRange/properties/name
  // - /components/schemas/Bgp.V6RouteRange/properties/name
  // - /components/schemas/Isis.V4RouteRange/properties/name
  // - /components/schemas/Isis.V6RouteRange/properties/name
  // - /components/schemas/Ospfv2.V4RouteRange/properties/name
  // - /components/schemas/Ospfv3.V6RouteRange/properties/name
  // 
  repeated string names = 1;

  message State {
    enum Enum {
      unspecified = 0;
      withdraw = 1;
      advertise = 2;
    }
  }
  // Route states
  // required = true
  optional State.Enum state = 2;
}

// Sets state of configured LACP
message StateProtocolLacp {

  message Choice {
    enum Enum {
      unspecified = 0;
      admin = 1;
      member_ports = 2;
    }
  }
  // Description missing in models
  // required = true
  optional Choice.Enum choice = 1;

  // Description missing in models
  StateProtocolLacpAdmin admin = 2;

  // Description missing in models
  StateProtocolLacpMemberPorts member_ports = 3;
}

// Sets admin state of LACP configured on LAG members
message StateProtocolLacpAdmin {

  // The names of LAG members (ports) for which the state has to be applied. An empty
  // or null list will control all LAG members.
  // 
  // x-constraint:
  // - /components/schemas/Port/properties/name
  // 
  repeated string lag_member_names = 1;

  message State {
    enum Enum {
      unspecified = 0;
      up = 1;
      down = 2;
    }
  }
  // The LACP Member admin state. 'up' will send LACPDUs with 'sync' flag set on selected
  // member ports. 'down' will send LACPDUs with 'sync' flag unset on selected member
  // ports.
  // required = true
  optional State.Enum state = 2;
}

// Sets state of LACP member ports configured on LAG.
message StateProtocolLacpMemberPorts {

  // The names of LAG members (ports) for which the state has to be applied. An empty
  // or null list will control all LAG members.
  // 
  // x-constraint:
  // - /components/schemas/Port/properties/name
  // 
  repeated string lag_member_names = 1;

  message State {
    enum Enum {
      unspecified = 0;
      up = 1;
      down = 2;
    }
  }
  // The desired LACP member port state.
  // required = true
  optional State.Enum state = 2;
}

// Sets state of configured BGP peers.
message StateProtocolBgp {

  message Choice {
    enum Enum {
      unspecified = 0;
      peers = 1;
    }
  }
  // Description missing in models
  // required = true
  optional Choice.Enum choice = 1;

  // Description missing in models
  StateProtocolBgpPeers peers = 2;
}

// Sets state of configured BGP peers.
message StateProtocolBgpPeers {

  // The names of BGP peers for which the state has to be applied. An empty or null list
  // will control all BGP peers.
  // 
  // x-constraint:
  // - /components/schemas/Bgp.V4Peer/properties/name
  // - /components/schemas/Bgp.V6Peer/properties/name
  // 
  repeated string peer_names = 1;

  message State {
    enum Enum {
      unspecified = 0;
      up = 1;
      down = 2;
    }
  }
  // The desired state of BGP peer. If the desired state is 'up', underlying IP interface(s)
  // would be brought up automatically (if not already up), would attempt to bring up
  // the BGP session(s) and advertise route(s), if configured. If the desired state is
  // 'down', BGP session(s) would be brought down.
  // required = true
  optional State.Enum state = 2;
}

// Sets state of configured ISIS routers.
message StateProtocolIsis {

  message Choice {
    enum Enum {
      unspecified = 0;
      routers = 1;
    }
  }
  // Description missing in models
  // required = true
  optional Choice.Enum choice = 1;

  // Description missing in models
  StateProtocolIsisRouters routers = 2;
}

// Sets state of configured ISIS routers.
message StateProtocolIsisRouters {

  // The names of ISIS routers for which the state has to be applied. An empty or null
  // list will control all ISIS routers.
  // 
  // x-constraint:
  // - /components/schemas/Device.IsisRouter/properties/name
  // 
  repeated string router_names = 1;

  message State {
    enum Enum {
      unspecified = 0;
      up = 1;
      down = 2;
    }
  }
  // The desired state of ISIS router. If the desired state is 'up', would attempt to
  // bring up the ISIS session(s) with respective peer(s) and advertise route(s), if configured.
  // If the desired state is 'down', would bring down ISIS session(s) with respective
  // peer(s).
  // required = true
  optional State.Enum state = 2;
}

// Sets state of configured OSPFv2 routers.
message StateProtocolOspfv2 {

  message Choice {
    enum Enum {
      unspecified = 0;
      routers = 1;
    }
  }
  // Description missing in models
  // required = true
  optional Choice.Enum choice = 1;

  // Description missing in models
  StateProtocolOspfv2Routers routers = 2;
}

// Sets state of configured OSPFv2 routers.
message StateProtocolOspfv2Routers {

  // The names of OSPFv2 routers for which the state has to be applied. An empty or null
  // list will control all OSPFv2 routers.
  // 
  // x-constraint:
  // - /components/schemas/Device.Ospfv2/properties/name
  // 
  repeated string router_names = 1;

  message State {
    enum Enum {
      unspecified = 0;
      up = 1;
      down = 2;
    }
  }
  // The desired state of OSPFv2 router. If the desired state is 'up', would attempt to
  // bring up the OSPFv2 session(s) with respective peer(s) and advertise route(s), if
  // configured. If the desired state is 'down', would bring down OSPFv2 session(s) with
  // respective peer(s).
  // required = true
  optional State.Enum state = 2;
}

// Sets state of configured OSPFv3 routers.
message StateProtocolOspfv3 {

  message Choice {
    enum Enum {
      unspecified = 0;
      routers = 1;
    }
  }
  // Description missing in models
  // required = true
  optional Choice.Enum choice = 1;

  // Description missing in models
  StateProtocolOspfv3Routers routers = 2;
}

// Sets state of configured OSPFv3 routers.
message StateProtocolOspfv3Routers {

  // The names of OSPFv3 routers for which the state has to be applied. An empty or null
  // list will control all OSPFv3 routers.
  // 
  // x-constraint:
  // - /components/schemas/Ospfv3.RouterInstance/properties/name
  // 
  repeated string router_names = 1;

  message State {
    enum Enum {
      unspecified = 0;
      up = 1;
      down = 2;
    }
  }
  // The desired state of OSPFv3 router. If the desired state is 'up', would attempt to
  // bring up the OSPFv3 session(s) with respective peer(s) and advertise route(s), if
  // configured. If the desired state is 'down', would bring down OSPFv3 session(s) with
  // respective peer(s).
  // required = true
  optional State.Enum state = 2;
}

// Sets state of configured RoCEv2 peers.
message StateProtocolRocev2 {

  message Choice {
    enum Enum {
      unspecified = 0;
      peers = 1;
    }
  }
  // Description missing in models
  // required = true
  optional Choice.Enum choice = 1;

  // Description missing in models
  StateProtocolRocev2Peers peers = 2;
}

// Sets state of configured RoCEv2 peers.
message StateProtocolRocev2Peers {

  // The names of RoCEv2 peers for which the state has to be applied. An empty or null
  // list will control all RoCEv2 peers.
  // 
  // x-constraint:
  // - /components/schemas/Rocev2.V4Peer/properties/name
  // - /components/schemas/Rocev2.V6Peer/properties/name
  // 
  repeated string peer_names = 1;

  message State {
    enum Enum {
      unspecified = 0;
      up = 1;
      down = 2;
    }
  }
  // The desired state of RoCEv2 peer. If the desired state is 'up', underlying IP interface(s)
  // would be brought up automatically (if not already up),
  // would attempt to bring up the RoCEv2 session(s).
  // If the desired state is 'down', RoCEv2 session(s) would be brought down.
  // required = true
  optional State.Enum state = 2;
}

// Request for triggering action against configured resources.
message ControlAction {

  message Choice {
    enum Enum {
      unspecified = 0;
      protocol = 1;
      port = 2;
    }
  }
  // Description missing in models
  // required = true
  optional Choice.Enum choice = 1;

  // Description missing in models
  ActionProtocol protocol = 2;

  // Description missing in models
  ActionPort port = 3;
}

// Response for action triggered against configured resources along with warnings.
message ControlActionResponse {

  // List of warnings generated while triggering specified action
  repeated string warnings = 1;

  // Description missing in models
  ActionResponse response = 2;
}

// Response for action triggered against configured resources.
message ActionResponse {

  message Choice {
    enum Enum {
      unspecified = 0;
      protocol = 1;
    }
  }
  // Description missing in models
  // required = true
  optional Choice.Enum choice = 1;

  // Description missing in models
  ActionResponseProtocol protocol = 2;
}

// Actions associated with protocols on configured resources.
message ActionProtocol {

  message Choice {
    enum Enum {
      unspecified = 0;
      ipv4 = 1;
      ipv6 = 2;
      bgp = 3;
      isis = 4;
    }
  }
  // Description missing in models
  // required = true
  optional Choice.Enum choice = 1;

  // Description missing in models
  ActionProtocolIpv4 ipv4 = 2;

  // Description missing in models
  ActionProtocolIpv6 ipv6 = 3;

  // Description missing in models
  ActionProtocolBgp bgp = 4;

  // Description missing in models
  ActionProtocolIsis isis = 5;
}

// Response for actions associated with protocols on configured resources.
message ActionResponseProtocol {

  message Choice {
    enum Enum {
      unspecified = 0;
      ipv4 = 1;
      ipv6 = 2;
    }
  }
  // Description missing in models
  // required = true
  optional Choice.Enum choice = 1;

  // Description missing in models
  ActionResponseProtocolIpv4 ipv4 = 2;

  // Description missing in models
  ActionResponseProtocolIpv6 ipv6 = 3;
}

// Actions associated with ports on configured resources.
message ActionPort {

  message Choice {
    enum Enum {
      unspecified = 0;
      reboot = 1;
    }
  }
  // Description missing in models
  // required = true
  optional Choice.Enum choice = 1;

  // Description missing in models
  ActionPortReboot reboot = 2;
}

// Actions associated with IPv4 on configured resources.
message ActionProtocolIpv4 {

  message Choice {
    enum Enum {
      unspecified = 0;
      ping = 1;
    }
  }
  // Description missing in models
  // required = true
  optional Choice.Enum choice = 1;

  // Description missing in models
  ActionProtocolIpv4Ping ping = 2;
}

// Response for actions associated with IPv4 on configured resources.
message ActionResponseProtocolIpv4 {

  message Choice {
    enum Enum {
      unspecified = 0;
      ping = 1;
    }
  }
  // Description missing in models
  // required = true
  optional Choice.Enum choice = 1;

  // Description missing in models
  ActionResponseProtocolIpv4Ping ping = 2;
}

// Request for initiating ping between multiple source and destination pairs.
message ActionProtocolIpv4Ping {

  // List of IPv4 ping requests.
  repeated ActionProtocolIpv4PingRequest requests = 1;
}

// Request for initiating ping between a single source and destination pair.
// For ping request, 1 IPv4 ICMP Echo Request shall be sent and wait for ping response
// to either succeed or time out. The API wait timeout for each request shall be 300ms.
message ActionProtocolIpv4PingRequest {

  // Name of source IPv4 interface to be used.
  // 
  // x-constraint:
  // - /components/schemas/Device.Ipv4/properties/name
  // - /components/schemas/Device.Ipv4Loopback/properties/name
  // 
  optional string src_name = 1;

  // Destination IPv4 address to ping.
  optional string dst_ip = 2;
}

// Response for ping initiated between multiple source and destination pairs.
message ActionResponseProtocolIpv4Ping {

  // List of responses for IPv4 ping responses.
  repeated ActionResponseProtocolIpv4PingResponse responses = 1;
}

// Response for ping initiated between a single source and destination pair.
message ActionResponseProtocolIpv4PingResponse {

  // Name of source IPv4 interface used for ping.
  // 
  // x-constraint:
  // - /components/schemas/Device.Ipv4/properties/name
  // - /components/schemas/Device.Ipv4Loopback/properties/name
  // 
  // required = true
  optional string src_name = 1;

  // Destination IPv4 address used for ping.
  // required = true
  optional string dst_ip = 2;

  message Result {
    enum Enum {
      unspecified = 0;
      succeeded = 1;
      failed = 2;
    }
  }
  // Result of the ping request.
  // required = true
  optional Result.Enum result = 3;
}

// Actions associated with IPv6 on configured resources.
message ActionProtocolIpv6 {

  message Choice {
    enum Enum {
      unspecified = 0;
      ping = 1;
    }
  }
  // Description missing in models
  // required = true
  optional Choice.Enum choice = 1;

  // Description missing in models
  ActionProtocolIpv6Ping ping = 2;
}

// Response for actions associated with IPv6 on configured resources.
message ActionResponseProtocolIpv6 {

  message Choice {
    enum Enum {
      unspecified = 0;
      ping = 1;
    }
  }
  // Description missing in models
  // required = true
  optional Choice.Enum choice = 1;

  // Description missing in models
  ActionResponseProtocolIpv6Ping ping = 2;
}

// Request for initiating ping between multiple source and destination pairs.
message ActionProtocolIpv6Ping {

  // List of IPv6 ping requests.
  repeated ActionProtocolIpv6PingRequest requests = 1;
}

// Request for initiating ping between a single source and destination pair.
// For ping request, 1 IPv6 ICMP Echo Request shall be sent and wait for ping response
// to either succeed or time out. The API wait timeout for each request shall be 300ms.
message ActionProtocolIpv6PingRequest {

  // Name of source IPv6 interface to be used.
  // 
  // x-constraint:
  // - /components/schemas/Device.Ipv6/properties/name
  // - /components/schemas/Device.Ipv6Loopback/properties/name
  // 
  optional string src_name = 1;

  // Destination IPv6 address to ping.
  optional string dst_ip = 2;
}

// Response for ping initiated between multiple source and destination pairs.
message ActionResponseProtocolIpv6Ping {

  // List of responses for IPv6 ping responses.
  repeated ActionResponseProtocolIpv6PingResponse responses = 1;
}

// Response for ping initiated between a single source and destination pair.
message ActionResponseProtocolIpv6PingResponse {

  // Name of source IPv6 interface used for ping.
  // 
  // x-constraint:
  // - /components/schemas/Device.Ipv6/properties/name
  // - /components/schemas/Device.Ipv6Loopback/properties/name
  // 
  // required = true
  optional string src_name = 1;

  // Destination IPv6 address used for ping.
  // required = true
  optional string dst_ip = 2;

  message Result {
    enum Enum {
      unspecified = 0;
      succeeded = 1;
      failed = 2;
    }
  }
  // Result of the ping request.
  // required = true
  optional Result.Enum result = 3;
}

// Actions associated with BGP on configured resources.
message ActionProtocolBgp {

  message Choice {
    enum Enum {
      unspecified = 0;
      notification = 1;
      initiate_graceful_restart = 2;
    }
  }
  // Description missing in models
  // required = true
  optional Choice.Enum choice = 1;

  // Description missing in models
  ActionProtocolBgpNotification notification = 2;

  // Description missing in models
  ActionProtocolBgpInitiateGracefulRestart initiate_graceful_restart = 3;
}

// A NOTIFICATION message is sent when an error is detected with the BGP session, such
// as hold timer expiring, misconfigured AS number  or a BGP session reset is requested.
// This causes the BGP connection to close. Send explicit NOTIFICATIONs for list of
// specified  BGP peers. If a user wants to send custom Error Code and Error Subcode
// the custom object should be configured. A user can send IANA defined BGP NOTIFICATIONs
// according to https://www.iana.org/assignments/bgp-parameters/bgp-parameters.xhtml.
// 
message ActionProtocolBgpNotification {

  // The names of BGP Peers to send NOTIFICATION to. If no name is specified then NOTIFICATION
  // will be sent to all configured BGP peers.
  // 
  // x-constraint:
  // - /components/schemas/Bgp.V4Peer/properties/name
  // - /components/schemas/Bgp.V6Peer/properties/name
  // 
  repeated string names = 1;

  message Choice {
    enum Enum {
      unspecified = 0;
      cease = 1;
      message_header_error = 2;
      open_message_error = 3;
      update_message_error = 4;
      hold_timer_expired = 5;
      finite_state_machine_error = 6;
      custom = 7;
    }
  }
  // Each BGP NOTIFICATION message includes an Error Code field indicating what type of
  // problem occurred. For certain Error Codes, an Error  Subcode field provides additional
  // details about the specific nature of the problem.  The choice value will provide
  // the Error Code used in NOTIFICATION message.  The Subcode can be set for each of
  // the corresponding errors except for Hold Timer Expired error and BGP Finite State
  // Machine error.  In both of these cases Subcode 0 will be sent. If a user wants to
  // use non zero Sub Code then custom choice can be used.
  // default = Choice.Enum.cease
  optional Choice.Enum choice = 2;

  // Description missing in models
  DeviceBgpCeaseError cease = 3;

  // Description missing in models
  DeviceBgpMessageHeaderError message_header_error = 4;

  // Description missing in models
  DeviceBgpOpenMessageError open_message_error = 5;

  // Description missing in models
  DeviceBgpUpdateMessageError update_message_error = 6;

  // Description missing in models
  DeviceBgpHoldTimerExpired hold_timer_expired = 7;

  // Description missing in models
  DeviceBgpFiniteStateMachineError finite_state_machine_error = 8;

  // Description missing in models
  DeviceBgpCustomError custom = 9;
}

// Initiates BGP Graceful Restart process for the selected BGP peers. If no name is
// specified then Graceful Restart will be sent to all configured BGP peers. To emulate
// scenarios where a peer sends a Notification and stops the session, an optional Notification
// object is included. If the remote peer and the local peer are both configured to
// perform Graceful Restart for Notification triggered session , this will result in
// Graceful Restart scenario to be triggered as per RFC8538.
message ActionProtocolBgpInitiateGracefulRestart {

  // The names of device BGP peers objects to control.
  // 
  // x-constraint:
  // - /components/schemas/Bgp.V4Peer/properties/name
  // - /components/schemas/Bgp.V6Peer/properties/name
  // 
  repeated string peer_names = 1;

  // Duration (in seconds) after which selected BGP peers will initiate
  // Graceful restart by sending the Open Message with Restart State bit set in the Graceful
  // Restart capability.
  // default = 30
  optional uint32 restart_delay = 2;

  // Send a Notification to the peer as per configured parameters when initially bringing
  // down a session as per
  // configured parameters.
  ActionProtocolBgpGracefulRestartNotification notification = 3;
}

// Defines the explicit contents of the NOTIFICATION message to be sent when executing
// InitiateGracefulRestart trigger.  This causes the BGP connection to close.If a user
// wants to send custom Error Code and Error Subcode the custom object should be configured.
// A user can send IANA defined BGP NOTIFICATIONs according to https://www.iana.org/assignments/bgp-parameters/bgp-parameters.xhtml.
// 
message ActionProtocolBgpGracefulRestartNotification {

  message Choice {
    enum Enum {
      unspecified = 0;
      cease = 1;
      message_header_error = 2;
      open_message_error = 3;
      update_message_error = 4;
      hold_timer_expired = 5;
      finite_state_machine_error = 6;
      custom = 7;
    }
  }
  // Each BGP NOTIFICATION message includes an Error Code field indicating what type of
  // problem occurred. For certain Error Codes, an Error  Subcode field provides additional
  // details about the specific nature of the problem.  The choice value will provide
  // the Error Code used in NOTIFICATION message.  The Subcode can be set for each of
  // the corresponding errors except for Hold Timer Expired error and BGP Finite State
  // Machine error.  In both of these cases Subcode 0 will be sent. If a user wants to
  // use non zero Sub Code then custom choice can be used.
  // default = Choice.Enum.cease
  optional Choice.Enum choice = 2;

  // Description missing in models
  DeviceBgpCeaseError cease = 3;

  // Description missing in models
  DeviceBgpMessageHeaderError message_header_error = 4;

  // Description missing in models
  DeviceBgpOpenMessageError open_message_error = 5;

  // Description missing in models
  DeviceBgpUpdateMessageError update_message_error = 6;

  // Description missing in models
  DeviceBgpHoldTimerExpired hold_timer_expired = 7;

  // Description missing in models
  DeviceBgpFiniteStateMachineError finite_state_machine_error = 8;

  // Description missing in models
  DeviceBgpCustomError custom = 9;
}

// Actions associated with IS-IS on configured resources.
message ActionProtocolIsis {

  message Choice {
    enum Enum {
      unspecified = 0;
      initiate_graceful_restart = 1;
    }
  }
  // Description missing in models
  // required = true
  optional Choice.Enum choice = 1;

  // Configuration for the initiation of the IS-IS Graceful Restart.
  ActionProtocolIsisInitiateRestart initiate_graceful_restart = 2;
}

// Timers T1 and T2 are used both by a restarting router and a starting router. Timer
// T3 is used only by a restarting router.
// - Timer T1 is maintained per interface and indicates the time after which an unacknowledged
// (re)start attempt will be repeated. Its value is 3 seconds.
// - Timer T2 is maintained for each LSP database (LSDB) for Level 1 and Level 2. Default
// value is 90 seconds.
// When the timer T2 expires or is canceled, indicating that synchronization of that
// level is complete and SPF for that level is run.
// - Timer T3 is maintained for the entire system after which the router will declare
// that it has failed to achieve database synchronization
// (by setting the overload bit in its own LSP). Its initial value is 65535 seconds
// and is set to minimum of the remaining times of received IIHs
// containing a Restart TLV with the RA set.
message ActionProtocolIsisInitiateRestart {

  // The names of device objects to control.
  // 
  // x-constraint:
  // - /components/schemas/Device.IsisRouter/properties/name
  // 
  repeated string router_names = 1;

  message Choice {
    enum Enum {
      unspecified = 0;
      unplanned = 1;
      planned = 2;
    }
  }
  // Description missing in models
  // default = Choice.Enum.unplanned
  optional Choice.Enum choice = 2;

  // Description missing in models
  ActionProtocolIsisUnplannedRestart unplanned = 3;

  // Description missing in models
  ActionProtocolIsisPlannedRestart planned = 4;
}

// Initiates IS-IS Unplanned Graceful Restart process for the selected IS-IS routers.
// If no name is specified then Graceful Restart will be sent to all configured IS-IS
// routers. When an emulated IS-IS router is in the unplanned Restarting mode, it sends
// an IIH PDU containing a Restart TLV with the RR (Restart Request) bit set and holding_time
// updated to as specified by user to indicate the maximum time within which this router
// or routers will complete the graceful restart.  It waits for RA (Restart Acknowledge)
// in an IIH PDU from Neigbhor(s).  The timer T1 is maintained per interface and indicates
// the time after which an unacknowledged (re)start attempt will be repeated.
message ActionProtocolIsisUnplannedRestart {

  // This is the estimated duration (in seconds) it will take for the IS-IS session to
  // be re-established after a restart. The hold-timer in the IIH PDU is updated with
  // this time.
  // default = 30
  optional uint32 holding_time = 1;

  // Once it receives Restarting TLV having RA bit set in a IIH PDU and CSNP PDU, time
  // (in seconds), after which IIH PDU, having Restart Tlv with RR bit unset, will be
  // sent. This should result in IIH to be transmitted indicating restart is Completed,
  // not started i.e. RR bit is cleared and hold_timer is reset to normal.
  // default = 10
  optional uint32 restart_after = 2;
}

// Initiates IS-IS Planned Graceful Restart process for the selected IS-IS routers.
// If no name is specified then Graceful Restart will be sent to all configured IS-IS
// routers. When an emulated IS-IS router is in the planned Restarting mode, it sends
// an IIH PDU containing a Restart TLV with the PR (Planned Restart Request) bit set
// and sets the Remaining Time with the restart_time greater than the expected control-plane
// restart time that is the maximum time within which this router or routers will complete
// the graceful restart. It waits for PA (Planned Restart Acknowledge) in an IIH PDU
// from Neighbor(s). The use of the PR bit provides a means to safely support restart
// periods that are significantly longer than standard Holding Times. The PR bit SHOULD
// remain set in IIHs until the restart is initiated. Reference: https://datatracker.ietf.org/doc/html/rfc8706#section-3.2.3.
// Once the Restarting Router receives the Restart Tlv with PA bit is set, it intiates
// the Restart Request with the RR bit is set. The holding_time is set as the Remaining
// Time as received in Restart Tlv or by the remaining time of restart_time that was
// sent in the Planned Restart Request Tlv. This is left to the choice of the implementation.
message ActionProtocolIsisPlannedRestart {

  // This is the estimated duration (in seconds) it will take for the IS-IS session to
  // be re-established after a Planned Restart Request. The Remaining Time is set with
  // the restart_time in the Restarting Tlv.
  // default = 30
  optional uint32 restart_time = 1;

  // Once it receives Restarting TLV having PA bit set in a IIH PDU from a neighbor, the
  // time (in seconds), after which IIH PDU, having Restart Tlv with RA & RR bits unset,
  // will be sent. This should result in IIH to be transmitted indicating restart is Completed,
  // and hold_timer is reset to normal.
  // default = 10
  optional uint32 restart_after = 3;
}

// Request to traffic generator for metrics of choice.
message MetricsRequest {

  message Choice {
    enum Enum {
      unspecified = 0;
      port = 1;
      flow = 2;
      bgpv4 = 3;
      bgpv6 = 4;
      isis = 5;
      lag = 6;
      lacp = 7;
      lldp = 8;
      rsvp = 9;
      dhcpv4_client = 10;
      dhcpv4_server = 11;
      dhcpv6_client = 12;
      dhcpv6_server = 13;
      ospfv2 = 14;
      convergence = 15;
      macsec = 16;
      mka = 17;
      ospfv3 = 18;
      rocev2_ipv4 = 19;
      rocev2_ipv6 = 20;
      rocev2_flow = 21;
      egress_only_tracking = 22;
      bmp_server = 23;
    }
  }
  // Description missing in models
  // default = Choice.Enum.port
  optional Choice.Enum choice = 1;

  // Description missing in models
  PortMetricsRequest port = 2;

  // Description missing in models
  FlowMetricsRequest flow = 3;

  // Description missing in models
  Bgpv4MetricsRequest bgpv4 = 4;

  // Description missing in models
  Bgpv6MetricsRequest bgpv6 = 5;

  // Description missing in models
  IsisMetricsRequest isis = 6;

  // Description missing in models
  LagMetricsRequest lag = 7;

  // Description missing in models
  LacpMetricsRequest lacp = 8;

  // Description missing in models
  LldpMetricsRequest lldp = 9;

  // Description missing in models
  RsvpMetricsRequest rsvp = 10;

  // Description missing in models
  Dhcpv4ClientMetricsRequest dhcpv4_client = 11;

  // Description missing in models
  Dhcpv4ServerMetricsRequest dhcpv4_server = 12;

  // Description missing in models
  Dhcpv6ClientMetricsRequest dhcpv6_client = 13;

  // Description missing in models
  Dhcpv6ServerMetricsRequest dhcpv6_server = 14;

  // Description missing in models
  Ospfv2MetricsRequest ospfv2 = 15;

  // Description missing in models
  ConvergenceRequest convergence = 16;

  // Description missing in models
  MacsecMetricsRequest macsec = 17;

  // Description missing in models
  MkaMetricsRequest mka = 18;

  // Description missing in models
  Ospfv3MetricsRequest ospfv3 = 19;

  // Description missing in models
  Rocev2IPv4MetricsRequest rocev2_ipv4 = 20;

  // Description missing in models
  Rocev2IPv6MetricsRequest rocev2_ipv6 = 21;

  // Description missing in models
  Rocev2FlowMetricsRequest rocev2_flow = 22;

  // Description missing in models
  EgressOnlyTrackingMetricsRequest egress_only_tracking = 23;

  // Description missing in models
  BmpServerMetricsRequest bmp_server = 24;
}

// Response containing chosen traffic generator metrics.
message MetricsResponse {

  message Choice {
    enum Enum {
      unspecified = 0;
      flow_metrics = 1;
      port_metrics = 2;
      bgpv4_metrics = 3;
      bgpv6_metrics = 4;
      isis_metrics = 5;
      lag_metrics = 6;
      lacp_metrics = 7;
      lldp_metrics = 8;
      rsvp_metrics = 9;
      dhcpv4_client = 10;
      dhcpv4_server = 11;
      dhcpv6_client = 12;
      dhcpv6_server = 13;
      ospfv2_metrics = 14;
      convergence_metrics = 15;
      macsec_metrics = 16;
      mka_metrics = 17;
      ospfv3_metrics = 18;
      rocev2_ipv4_per_peer_metrics = 19;
      rocev2_ipv6_per_peer_metrics = 20;
      rocev2_flow_per_qp_metrics = 21;
      egress_only_tracking_metrics = 22;
      bmp_server_metrics = 23;
    }
  }
  // Description missing in models
  // default = Choice.Enum.port_metrics
  optional Choice.Enum choice = 1;

  // Description missing in models
  repeated PortMetric port_metrics = 2;

  // Description missing in models
  repeated FlowMetric flow_metrics = 3;

  // Description missing in models
  repeated Bgpv4Metric bgpv4_metrics = 4;

  // Description missing in models
  repeated Bgpv6Metric bgpv6_metrics = 5;

  // Description missing in models
  repeated IsisMetric isis_metrics = 6;

  // Description missing in models
  repeated LagMetric lag_metrics = 7;

  // Description missing in models
  repeated LacpMetric lacp_metrics = 8;

  // Description missing in models
  repeated LldpMetric lldp_metrics = 9;

  // Description missing in models
  repeated RsvpMetric rsvp_metrics = 10;

  // Description missing in models
  repeated Dhcpv4ClientMetric dhcpv4client_metrics = 11;

  // Description missing in models
  repeated Dhcpv4ServerMetric dhcpv4server_metrics = 12;

  // Description missing in models
  repeated Dhcpv6ClientMetric dhcpv6client_metrics = 13;

  // Description missing in models
  repeated Dhcpv6ServerMetric dhcpv6server_metrics = 14;

  // Description missing in models
  repeated Ospfv2Metric ospfv2_metrics = 15;

  // Description missing in models
  repeated ConvergenceMetric convergence_metrics = 16;

  // Description missing in models
  repeated MacsecMetric macsec_metrics = 17;

  // Description missing in models
  repeated MkaMetric mka_metrics = 18;

  // Description missing in models
  repeated Ospfv3Metric ospfv3_metrics = 19;

  // Description missing in models
  repeated Rocev2IPv4MetricPerPeer rocev2_ipv4_per_peer_metrics = 20;

  // Description missing in models
  repeated Rocev2IPv6MetricPerPeer rocev2_ipv6_per_peer_metrics = 21;

  // Description missing in models
  repeated Rocev2FlowMetricPerQP rocev2_flow_per_qp_metrics = 22;

  // Description missing in models
  repeated EgressOnlyTrackingMetric egress_only_tracking_metrics = 23;

  // Description missing in models
  repeated BmpServerMetric bmp_server_metrics = 24;
}

// The port result request to the traffic generator
message PortMetricsRequest {

  // The names of objects to return results for. An empty list will return all port row
  // results.
  // 
  // x-constraint:
  // - /components/schemas/Port/properties/name
  // 
  repeated string port_names = 1;

  message ColumnNames {
    enum Enum {
      unspecified = 0;
      transmit = 1;
      location = 2;
      link = 3;
      capture = 4;
      frames_tx = 5;
      frames_rx = 6;
      bytes_tx = 7;
      bytes_rx = 8;
      frames_tx_rate = 9;
      frames_rx_rate = 10;
      bytes_tx_rate = 11;
      bytes_rx_rate = 12;
      last_change = 13;
    }
  }
  // The list of column names that the returned result set will contain. If the list is
  // empty then all columns will be returned. The name of the port cannot be excluded.
  repeated ColumnNames.Enum column_names = 2;
}

// Description missing in models
message PortMetric {

  // The name of a configured port
  // 
  // x-constraint:
  // - /components/schemas/Port/properties/name
  // 
  optional string name = 1;

  // The state of the connection to the test port location. The format should be the configured
  // port location along with  any custom connection state message.
  optional string location = 2;

  message Link {
    enum Enum {
      unspecified = 0;
      up = 1;
      down = 2;
    }
  }
  // The state of the test port link The string can be up, down or a custom error message.
  optional Link.Enum link = 3;

  message Capture {
    enum Enum {
      unspecified = 0;
      started = 1;
      stopped = 2;
    }
  }
  // The state of the test port capture infrastructure. The string can be started, stopped
  // or a custom error message.
  optional Capture.Enum capture = 4;

  // The current total number of frames transmitted
  optional uint64 frames_tx = 5;

  // The current total number of valid frames received
  optional uint64 frames_rx = 6;

  // The current total number of bytes transmitted
  optional uint64 bytes_tx = 7;

  // The current total number of valid bytes received
  optional uint64 bytes_rx = 8;

  // The current rate of frames transmitted
  optional float frames_tx_rate = 9;

  // The current rate of valid frames received
  optional float frames_rx_rate = 10;

  // The current rate of bytes transmitted
  optional float bytes_tx_rate = 11;

  // The current rate of bytes received
  optional float bytes_rx_rate = 12;

  message Transmit {
    enum Enum {
      unspecified = 0;
      started = 1;
      stopped = 2;
    }
  }
  // The transmit state of the flow.
  optional Transmit.Enum transmit = 13;

  // The timestamp indicates the absolute time of the last
  // link state change of the test port (e.g., up-to-down transition).
  // 
  // The value is the timestamp in nanoseconds relative to
  // the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
  optional uint64 last_change = 14;

  // Description missing in models
  MetricDataIntegrity data_integrity = 15;
}

// The container for data integrity metrics. The container will be empty if
// options.port_options.data_integrity has not been enabled during set_config.
message MetricDataIntegrity {

  // The total number of data integrity enabled frames received
  optional uint64 total_frames_rx = 1;

  // The total number of data integrity enabled frames received with payload modified
  optional uint64 error_frames_rx = 2;
}

// The container for a flow metric request.
message FlowMetricsRequest {

  // Flow metrics will be retrieved for these flow names.
  // If no flow names are specified then all flows will be returned.
  // 
  // x-constraint:
  // - /components/schemas/Flow/properties/name
  // 
  repeated string flow_names = 1;

  message MetricNames {
    enum Enum {
      unspecified = 0;
      transmit = 1;
      frames_tx = 2;
      frames_rx = 3;
      bytes_tx = 4;
      bytes_rx = 5;
      frames_tx_rate = 6;
      frames_rx_rate = 7;
      tx_l1_rate_bps = 8;
      rx_l1_rate_bps = 9;
      tx_rate_bytes = 10;
      rx_rate_bytes = 11;
      tx_rate_bps = 12;
      rx_rate_bps = 13;
      tx_rate_kbps = 14;
      rx_rate_kbps = 15;
      tx_rate_mbps = 16;
      rx_rate_mbps = 17;
    }
  }
  // The list of metric names that the returned result set will contain. If the list is
  // empty then all metrics will be returned.
  repeated MetricNames.Enum metric_names = 3;

  // Description missing in models
  FlowTaggedMetricsFilter tagged_metrics = 4;
}

// Filter for tagged metrics
message FlowTaggedMetricsFilter {

  // Controls inclusion/exclusion of tagged metrics when fetching flow metrics.
  // default = True
  optional bool include = 1;

  // Controls inclusion/exclusion of tagged metrics where each underlying attributes has
  // zero value or absent value.
  // default = False
  optional bool include_empty_metrics = 2;

  message MetricNames {
    enum Enum {
      unspecified = 0;
      frames_tx = 1;
      frames_rx = 2;
      bytes_tx = 3;
      bytes_rx = 4;
      frames_tx_rate = 5;
      frames_rx_rate = 6;
      tx_l1_rate_bps = 7;
      rx_l1_rate_bps = 8;
      tx_rate_bytes = 9;
      rx_rate_bytes = 10;
      tx_rate_bps = 11;
      rx_rate_bps = 12;
      tx_rate_kbps = 13;
      rx_rate_kbps = 14;
      tx_rate_mbps = 15;
      rx_rate_mbps = 16;
    }
  }
  // The list of metric names that the returned result set will contain. If the list is
  // empty then all metrics will be returned.
  repeated MetricNames.Enum metric_names = 3;

  // List of filters to selectively fetch tagged metrics with certain tag and corresponding
  // value.
  repeated FlowMetricTagFilter filters = 4;
}

// A container for filtering ingress and/or egress metric tags.
// The Tx stats may not be applicable in both the request and response filter.
message FlowMetricTagFilter {

  // A metric tag name that MUST exist in a flow packet or
  // flow egress_packet configuration
  optional string name = 1;

  // A list of filters that can be applied to the metric tag name.
  // By default all values will be included in the flow metric results.
  repeated string values = 2;
}

// A container for flow metrics.
// The container is keyed by the name, port_tx and port_rx.
message FlowMetric {

  // The name of the flow
  optional string name = 1;

  // The name of the transmit port
  optional string port_tx = 2;

  // The name of the receive port
  optional string port_rx = 3;

  message Transmit {
    enum Enum {
      unspecified = 0;
      started = 1;
      stopped = 2;
      paused = 3;
    }
  }
  // The transmit state of the flow.
  optional Transmit.Enum transmit = 5;

  // The current total number of frames transmitted
  optional uint64 frames_tx = 6;

  // The current total number of valid frames received
  optional uint64 frames_rx = 7;

  // The current total number of bytes transmitted
  optional uint64 bytes_tx = 8;

  // The current total number of bytes received
  optional uint64 bytes_rx = 9;

  // The current rate of frames transmitted
  optional float frames_tx_rate = 10;

  // The current rate of valid frames received
  optional float frames_rx_rate = 11;

  // The percentage of lost frames
  optional float loss = 12;

  // Description missing in models
  MetricTimestamp timestamps = 13;

  // Description missing in models
  MetricLatency latency = 14;

  // List of metrics corresponding to a set of values applicable
  // for configured metric tags in ingress or egress packet header fields of corresponding
  // flow.
  // The container is keyed by list of tag-value pairs.
  repeated FlowTaggedMetric tagged_metrics = 15;

  // The Layer 1 transmission rate in bits per second.
  optional float tx_l1_rate_bps = 16;

  // The Layer 1 receive rate in bits per second.
  optional float rx_l1_rate_bps = 17;

  // The transmission rate in bytes per second.
  optional float tx_rate_bytes = 18;

  // The receive rate in bytes per second.
  optional float rx_rate_bytes = 19;

  // The transmission rate in bits per second.
  optional float tx_rate_bps = 20;

  // The receive rate in bits per second.
  optional float rx_rate_bps = 21;

  // The transmission rate in Kilobits per second.
  optional float tx_rate_kbps = 22;

  // The receive rate in Kilobits per second.
  optional float rx_rate_kbps = 23;

  // The transmission rate in Megabits per second.
  optional float tx_rate_mbps = 24;

  // The receive rate in Megabits per second.
  optional float rx_rate_mbps = 25;
}

// Metrics for each set of values applicable for configured
// metric tags in ingress or egress packet header fields of corresponding flow.
// The container is keyed by list of tag-value pairs.
message FlowTaggedMetric {

  // List of tag and value pairs
  repeated FlowMetricTag tags = 1;

  // The current total number of frames transmitted
  optional uint64 frames_tx = 2;

  // The current total number of valid frames received
  optional uint64 frames_rx = 3;

  // The current total number of bytes transmitted
  optional uint64 bytes_tx = 4;

  // The current total number of bytes received
  optional uint64 bytes_rx = 5;

  // The current rate of frames transmitted
  optional float frames_tx_rate = 6;

  // The current rate of valid frames received
  optional float frames_rx_rate = 7;

  // The percentage of lost frames
  optional float loss = 8;

  // Description missing in models
  MetricTimestamp timestamps = 9;

  // Description missing in models
  MetricLatency latency = 10;

  // The Layer 1 transmission rate in bits per second.
  optional float tx_l1_rate_bps = 11;

  // The Layer 1 receive rate in bits per second.
  optional float rx_l1_rate_bps = 12;

  // The transmission rate in bytes per second.
  optional float tx_rate_bytes = 13;

  // The receive rate in bytes per second.
  optional float rx_rate_bytes = 14;

  // The transmission rate in bits per second.
  optional float tx_rate_bps = 15;

  // The receive rate in bits per second.
  optional float rx_rate_bps = 16;

  // The transmission rate in Kilobits per second.
  optional float tx_rate_kbps = 17;

  // The receive rate in Kilobits per second.
  optional float rx_rate_kbps = 18;

  // The transmission rate in Megabits per second.
  optional float tx_rate_mbps = 19;

  // The receive rate in Megabits per second.
  optional float rx_rate_mbps = 20;
}

// Description missing in models
message FlowMetricTag {

  // Name of packet field metric tag
  optional string name = 1;

  // Description missing in models
  FlowMetricTagValue value = 2;
}

// A container for metric tag value
message FlowMetricTagValue {

  message Choice {
    enum Enum {
      unspecified = 0;
      hex = 1;
      str = 2;
    }
  }
  // Available formats for metric tag value
  // default = Choice.Enum.hex
  optional Choice.Enum choice = 1;

  // Value represented in hexadecimal format
  optional string hex = 2;

  // Value represented in string format
  optional string str = 3;
}

// The container for timestamp metrics.
// The container will be empty if the timestamp has not been configured for
// the flow.
message MetricTimestamp {

  // First timestamp in nanoseconds
  optional double first_timestamp_ns = 1;

  // Last timestamp in nanoseconds
  optional double last_timestamp_ns = 2;
}

// The container for latency metrics.
// The min/max/avg values are dependent on the type of latency measurement
// mode that is configured.
// The container will be empty if the latency has not been configured for
// the flow.
message MetricLatency {

  // Minimum latency in nanoseconds
  optional double minimum_ns = 1;

  // Maximum latency in nanoseconds
  optional double maximum_ns = 2;

  // Average latency in nanoseconds
  optional double average_ns = 3;
}

// The request to retrieve BGPv4 per peer metrics/statistics.
message Bgpv4MetricsRequest {

  // The names of BGPv4 peers to return results for. An empty list will return results
  // for all BGPv4 peers.
  // 
  // x-constraint:
  // - /components/schemas/Bgp.V4peer/properties/name
  // 
  repeated string peer_names = 1;

  message ColumnNames {
    enum Enum {
      unspecified = 0;
      session_state = 1;
      session_flap_count = 2;
      routes_advertised = 3;
      routes_received = 4;
      route_withdraws_sent = 5;
      route_withdraws_received = 6;
      updates_sent = 7;
      updates_received = 8;
      opens_sent = 9;
      opens_received = 10;
      keepalives_sent = 11;
      keepalives_received = 12;
      notifications_sent = 13;
      notifications_received = 14;
      fsm_state = 15;
      end_of_rib_received = 16;
    }
  }
  // The list of column names that the returned result set will contain. If the list is
  // empty then all columns will be returned except for any result_groups. The name of
  // the BGPv4 peer cannot be excluded.
  repeated ColumnNames.Enum column_names = 2;
}

// BGPv4 per peer statistics information.
message Bgpv4Metric {

  // The name of a configured BGPv4 peer.
  optional string name = 1;

  message SessionState {
    enum Enum {
      unspecified = 0;
      up = 1;
      down = 2;
    }
  }
  // Session state as up or down. Up refers to an Established state and Down refers to
  // any other state.
  optional SessionState.Enum session_state = 2;

  // Number of times the session went from Up to Down state.
  optional uint64 session_flap_count = 3;

  // Number of routes advertised.
  optional uint64 routes_advertised = 4;

  // Number of routes received.
  optional uint64 routes_received = 5;

  // Number of route withdraws sent.
  optional uint64 route_withdraws_sent = 6;

  // Number of route withdraws received.
  optional uint64 route_withdraws_received = 7;

  // Number of Update messages sent.
  optional uint64 updates_sent = 8;

  // Number of Update messages received.
  optional uint64 updates_received = 9;

  // Number of Open messages sent.
  optional uint64 opens_sent = 10;

  // Number of Open messages received.
  optional uint64 opens_received = 11;

  // Number of Keepalive messages sent.
  optional uint64 keepalives_sent = 12;

  // Number of Keepalive messages received.
  optional uint64 keepalives_received = 13;

  // Number of Notification messages sent.
  optional uint64 notifications_sent = 14;

  // Number of Notification messages received.
  optional uint64 notifications_received = 15;

  message FsmState {
    enum Enum {
      unspecified = 0;
      idle = 1;
      connect = 2;
      active = 3;
      opensent = 4;
      openconfirm = 5;
      established = 6;
    }
  }
  // BGP peer FSM (Finite State Machine) state as Idle, Connect, Active, OpenSent, OpenConfirm
  // and Established. In all the states except Established the BGP session is down. Idle
  // refers to the Idle state of the FSM. Connect refers to the state where the session
  // is waiting for the underlying transport session to be established. Active refers
  // to the state where the session is awaiting for a connection from the remote peer.
  // OpenSent refers to the state where the session is in the process of being established.
  // The local system has sent an OPEN message. OpenConfirm refers to the state where
  // the session is in the process of being established. The local system has sent and
  // received an OPEN message and is awaiting a NOTIFICATION or KEEPALIVE message from
  // remote peer. Established refers to the state where the BGP session with the peer
  // is established.
  optional FsmState.Enum fsm_state = 16;

  // Number of End-of-RIB markers received indicating the completion of the initial routing
  // update for a  particular <AFI, SAFI> address family after the session is established.
  // For the IPv4 unicast address family, the End-of-RIB marker is an UPDATE message with
  // the minimum length. For any other address family, it is an UPDATE message that contains
  // only the MP_UNREACH_NLRI attribute with  no withdrawn routes for that <AFI, SAFI>.
  optional uint64 end_of_rib_received = 17;
}

// The request to retrieve BGPv6 per peer metrics/statistics.
message Bgpv6MetricsRequest {

  // The names of BGPv6 peers to return results for. An empty list will return results
  // for all BGPv6 peers.
  // 
  // x-constraint:
  // - /components/schemas/Bgp.V6peer/properties/name
  // 
  repeated string peer_names = 1;

  message ColumnNames {
    enum Enum {
      unspecified = 0;
      session_state = 1;
      session_flap_count = 2;
      routes_advertised = 3;
      routes_received = 4;
      route_withdraws_sent = 5;
      route_withdraws_received = 6;
      updates_sent = 7;
      updates_received = 8;
      opens_sent = 9;
      opens_received = 10;
      keepalives_sent = 11;
      keepalives_received = 12;
      notifications_sent = 13;
      notifications_received = 14;
      fsm_state = 15;
      end_of_rib_received = 16;
    }
  }
  // The list of column names that the returned result set will contain. If the list is
  // empty then all columns will be returned except for any result_groups. The name of
  // the BGPv6 peer cannot be excluded.
  repeated ColumnNames.Enum column_names = 2;
}

// BGPv6 per peer statistics information.
message Bgpv6Metric {

  // The name of a configured BGPv6 peer.
  optional string name = 1;

  message SessionState {
    enum Enum {
      unspecified = 0;
      up = 1;
      down = 2;
    }
  }
  // Session state as up or down. Up refers to an Established state and Down refers to
  // any other state.
  optional SessionState.Enum session_state = 2;

  // Number of times the session went from Up to Down state.
  optional uint64 session_flap_count = 3;

  // Number of routes advertised.
  optional uint64 routes_advertised = 4;

  // Number of routes received.
  optional uint64 routes_received = 5;

  // Number of route withdraws sent.
  optional uint64 route_withdraws_sent = 6;

  // Number of route withdraws received.
  optional uint64 route_withdraws_received = 7;

  // Number of Update messages sent.
  optional uint64 updates_sent = 8;

  // Number of Update messages received.
  optional uint64 updates_received = 9;

  // Number of Open messages sent.
  optional uint64 opens_sent = 10;

  // Number of Open messages received.
  optional uint64 opens_received = 11;

  // Number of Keepalive messages sent.
  optional uint64 keepalives_sent = 12;

  // Number of Keepalive messages received.
  optional uint64 keepalives_received = 13;

  // Number of Notification messages sent.
  optional uint64 notifications_sent = 14;

  // Number of Notification messages received.
  optional uint64 notifications_received = 15;

  message FsmState {
    enum Enum {
      unspecified = 0;
      idle = 1;
      connect = 2;
      active = 3;
      opensent = 4;
      openconfirm = 5;
      established = 6;
    }
  }
  // BGP peer FSM (Finite State Machine) state as Idle, Connect, Active, OpenSent, OpenConfirm
  // and Established. In all the states except Established the BGP session is down. Idle
  // refers to the Idle state of the FSM. Connect refers to the state where the session
  // is waiting for the underlying transport session to be established. Active refers
  // to the state where the session is awaiting for a connection from the remote peer.
  // OpenSent refers to the state where the session is in the process of being established.
  // The local system has sent an OPEN message. OpenConfirm refers to the state where
  // the session is in the process of being established. The local system has sent and
  // received an OPEN message and is awaiting a NOTIFICATION or KEEPALIVE message from
  // remote peer. Established refers to the state where the BGP session with the peer
  // is established.
  optional FsmState.Enum fsm_state = 16;

  // Number of End-of-RIB markers received indicating the completion of the initial routing
  // update for a  particular <AFI, SAFI> address family after the session is established.
  // For the IPv4 unicast address family, the End-of-RIB marker is an UPDATE message with
  // the minimum length. For any other address family, it is an UPDATE message that contains
  // only the MP_UNREACH_NLRI attribute with  no withdrawn routes for that <AFI, SAFI>.
  optional uint64 end_of_rib_received = 17;
}

// The request to retrieve ISIS per Router metrics/statistics.
message IsisMetricsRequest {

  // The names of ISIS Routers to return results for. An empty list will return results
  // for all ISIS router.
  // 
  // x-constraint:
  // - /components/schemas/Device.IsisRouter/properties/name
  // 
  repeated string router_names = 1;

  message ColumnNames {
    enum Enum {
      unspecified = 0;
      l1_sessions_up = 1;
      l1_session_flap = 2;
      l1_database_size = 3;
      l1_broadcast_hellos_sent = 4;
      l1_broadcast_hellos_received = 5;
      l1_point_to_point_hellos_sent = 6;
      l1_point_to_point_hellos_received = 7;
      l1_psnp_sent = 8;
      l1_psnp_received = 9;
      l1_csnp_sent = 10;
      l1_csnp_received = 11;
      l1_lsp_sent = 12;
      l1_lsp_received = 13;
      l2_sessions_up = 14;
      l2_session_flap = 15;
      l2_database_size = 16;
      l2_broadcast_hellos_sent = 17;
      l2_broadcast_hellos_received = 18;
      l2_point_to_point_hellos_sent = 19;
      l2_point_to_point_hellos_received = 20;
      l2_psnp_sent = 21;
      l2_psnp_received = 22;
      l2_csnp_sent = 23;
      l2_csnp_received = 24;
      l2_lsp_sent = 25;
      l2_lsp_received = 26;
      gr_initiated = 27;
      gr_succeeded = 28;
      neighbor_gr_initiated = 29;
      neighbor_gr_succeeded = 30;
    }
  }
  // The list of column names that the returned result set will contain. If the list is
  // empty then all columns will be returned except for any result_groups. The name of
  // the ISIS Router cannot be excluded.
  repeated ColumnNames.Enum column_names = 2;
}

// ISIS per router statistics information.
message IsisMetric {

  // The name of a configured ISIS router.
  optional string name = 1;

  // The number of Level 1 (L1) sessions that are fully up.
  optional uint32 l1_sessions_up = 2;

  // The number of Level 1 Sessions Flap.
  optional uint64 l1_session_flap = 3;

  // Number of Level 1 Hello messages sent.
  optional uint64 l1_broadcast_hellos_sent = 4;

  // Number of Level 1 Hello messages received.
  optional uint64 l1_broadcast_hellos_received = 5;

  // Number of Level 1 Point-to-Point(P2P) Hello messages sent.
  optional uint64 l1_point_to_point_hellos_sent = 6;

  // Number of Level 1 Point-to-Point(P2P) Hello messages received.
  optional uint64 l1_point_to_point_hellos_received = 7;

  // Number of Link State Updates (LSPs) in the Level 1 LSP Databases.
  optional uint64 l1_database_size = 8;

  // Number of Level 1 (L1) Partial Sequence Number Packet (PSNPs) sent.
  optional uint64 l1_psnp_sent = 9;

  // Number of Level 1 (L1) Complete Sequence Number Packet (PSNPs) received.
  optional uint64 l1_psnp_received = 10;

  // Number of Level 1 (L1) Complete Sequence Number Packet (CSNPs) sent.
  optional uint64 l1_csnp_sent = 11;

  // Number of Level 1 (L1) Complete Sequence Number Packet (CSNPs) received.
  optional uint64 l1_csnp_received = 12;

  // Number of Level 1 (L1) Link State Protocol Data Units (LSPs) sent.
  optional uint64 l1_lsp_sent = 13;

  // Number of Level 1 (L1) Link State Protocol Data Units (LSPs) received.
  optional uint64 l1_lsp_received = 14;

  // The number of Level 2 (L2) sessions that are fully up.
  optional uint32 l2_sessions_up = 15;

  // The number of Level 2 Sessions Flap.
  optional uint64 l2_session_flap = 16;

  // Number of Level 2 Hello messages sent.
  optional uint64 l2_broadcast_hellos_sent = 17;

  // Number of Level 2 Hello messages received.
  optional uint64 l2_broadcast_hellos_received = 18;

  // Number of Level 2 Point-to-Point(P2P) Hello messages sent.
  optional uint64 l2_point_to_point_hellos_sent = 19;

  // Number of Level 2 Point-to-Point(P2P) Hello messages received.
  optional uint64 l2_point_to_point_hellos_received = 20;

  // Number of Link State Updates (LSPs) in the Level 2 LSP Databases.
  optional uint64 l2_database_size = 21;

  // Number of Level 2 (L2) Partial Sequence Number Packet (PSNPs) sent.
  optional uint64 l2_psnp_sent = 22;

  // Number of Level 2 (L2) Complete Sequence Number Packet (PSNPs) received.
  optional uint64 l2_psnp_received = 23;

  // Number of Level 2 (L2) Complete Sequence Number Packet (CSNPs) sent.
  optional uint64 l2_csnp_sent = 24;

  // Number of Level 2 (L2) Complete Sequence Number Packet (CSNPs) received.
  optional uint64 l2_csnp_received = 25;

  // Number of Level 2 (L2) Link State Protocol Data Units (LSPs) sent.
  optional uint64 l2_lsp_sent = 26;

  // Number of Level 2 (L2) Link State Protocol Data Units (LSPs) received.
  optional uint64 l2_lsp_received = 27;

  // Number of Graceful Restarts that were initiated by this router.
  optional uint64 gr_initiated = 28;

  // Number of Graceful Restarts succeeded that were initiated by a this router. This
  // counter is incremented if the Graceful Restart completes succesfully before the T3
  // timer expires. Timer T3 is maintained for the entire system after which  the router
  // will declare that it has failed to achieve database synchronization.
  optional uint64 gr_succeeded = 29;

  // Number of Graceful Restarts that were initiated by a Neighbor. This counter is incremented
  // for Restart TLV having RR bit set in the received IIH PDU.
  optional uint64 neighbor_gr_initiated = 30;

  // Number of Graceful Restarts succeeded that were initiated by a Neighbor. This counter
  // is incremented when Restart TLV having RR bit unset in the received IIH PDU after
  // the Graceful Restart was initiated by a Neighbor.
  optional uint64 neighbor_gr_succeeded = 31;
}

// The request to retrieve per LAG metrics/statistics.
message LagMetricsRequest {

  // The names of LAGs to return results for. An empty list will return results for all
  // LAGs.
  // 
  // x-constraint:
  // - /components/schemas/Lag/properties/name
  // 
  repeated string lag_names = 1;

  message ColumnNames {
    enum Enum {
      unspecified = 0;
      oper_status = 1;
      member_ports_up = 2;
      frames_tx = 3;
      frames_rx = 4;
      bytes_tx = 5;
      bytes_rx = 6;
      frames_tx_rate = 7;
      frames_rx_rate = 8;
      bytes_tx_rate = 9;
      bytes_rx_rate = 10;
    }
  }
  // The list of column names that the returned result set will contain. If the list is
  // empty then all columns will be returned. The name of the LAG cannot be excluded.
  repeated ColumnNames.Enum column_names = 2;
}

// Description missing in models
message LagMetric {

  // The name of a configured LAG
  // 
  // x-constraint:
  // - /components/schemas/Lag/properties/name
  // 
  optional string name = 1;

  message OperStatus {
    enum Enum {
      unspecified = 0;
      up = 1;
      down = 2;
    }
  }
  // The current operational state of the LAG. The state can be up or down. State 'up'
  // indicates member_ports_up >= min_links.
  optional OperStatus.Enum oper_status = 2;

  // The number of LAG member ports up.
  optional uint32 member_ports_up = 3;

  // The current total number of frames transmitted.
  optional uint64 frames_tx = 4;

  // The current total number of valid frames received.
  optional uint64 frames_rx = 5;

  // The current total number of bytes transmitted.
  optional uint64 bytes_tx = 6;

  // The current total number of valid bytes received.
  optional uint64 bytes_rx = 7;

  // The current rate of frames transmitted.
  optional float frames_tx_rate = 8;

  // The current rate of valid frames received.
  optional float frames_rx_rate = 9;

  // The current rate of bytes transmitted.
  optional float bytes_tx_rate = 10;

  // The current rate of bytes received.
  optional float bytes_rx_rate = 11;
}

// The request to retrieve LACP per LAG member metrics/statistics.
message LacpMetricsRequest {

  // The names of LAG (ports group) for which LACP metrics to be returned. An empty list
  // will return metrics for all LAGs.
  // 
  // x-constraint:
  // - /components/schemas/Lag/properties/name
  // 
  repeated string lag_names = 1;

  // The names of LAG members (ports) for which LACP metrics to be returned. An empty
  // list will return metrics for all LAG members.
  // 
  // x-constraint:
  // - /components/schemas/Port/properties/name
  // 
  repeated string lag_member_port_names = 2;

  message ColumnNames {
    enum Enum {
      unspecified = 0;
      lacp_packets_rx = 1;
      lacp_packets_tx = 2;
      lacp_rx_errors = 3;
      activity = 4;
      timeout = 5;
      synchronization = 6;
      aggregatable = 7;
      collecting = 8;
      distributing = 9;
      system_id = 10;
      oper_key = 11;
      partner_id = 12;
      partner_key = 13;
      port_num = 14;
      partner_port_num = 15;
    }
  }
  // The list of column names that the returned result set will contain. If the list is
  // empty then all columns will be returned. The name of LAG and LAG member can not be
  // excluded.
  repeated ColumnNames.Enum column_names = 3;
}

// LACP metrics (statistics) per LAG member.
message LacpMetric {

  // The name of a LAG (ports group) configured with LACP.
  optional string lag_name = 1;

  // The name of a LAG member (port) configured with LACP.
  optional string lag_member_port_name = 2;

  // Number of LACPDUs received.
  optional uint64 lacp_packets_rx = 3;

  // Number of LACPDUs transmitted.
  optional uint64 lacp_packets_tx = 4;

  // Number of LACPDUs receive packet errors.
  optional uint64 lacp_rx_errors = 5;

  message Activity {
    enum Enum {
      unspecified = 0;
      active = 1;
      passive = 2;
    }
  }
  // Indicates participant is active or passive.
  optional Activity.Enum activity = 6;

  message Timeout {
    enum Enum {
      unspecified = 0;
      short = 1;
      long = 2;
    }
  }
  // The timeout type (short or long) used by the participant.
  optional Timeout.Enum timeout = 7;

  message Synchronization {
    enum Enum {
      unspecified = 0;
      in_sync = 1;
      out_sync = 2;
    }
  }
  // Indicates whether the participant is in-sync or out-of-sync.
  optional Synchronization.Enum synchronization = 8;

  // A true value indicates that the participant will allow the link to be used as part
  // of the aggregate. A false value indicates the link should be used as an  individual
  // link.
  optional bool aggregatable = 9;

  // If true, the participant is collecting incoming frames on the link, otherwise false.
  optional bool collecting = 10;

  // When true, the participant is distributing outgoing frames; when false, distribution
  // is disabled.
  optional bool distributing = 11;

  // MAC address that defines the local system ID for the aggregate interface.
  optional string system_id = 12;

  // Current operational value of the key for the aggregate interface.
  optional uint32 oper_key = 13;

  // MAC address representing the protocol partner's interface system ID.
  optional string partner_id = 14;

  // Operational value of the protocol partner's key.
  optional uint32 partner_key = 15;

  // Port number of the local (actor) aggregation member.
  optional uint32 port_num = 16;

  // Port number of the partner (remote) port for this member port.
  optional uint32 partner_port_num = 17;
}

// The request to retrieve LLDP per instance metrics/statistics.
message LldpMetricsRequest {

  // The names of LLDP instances to return results for. An empty list will return results
  // for all LLDP instances.
  // 
  // x-constraint:
  // - /components/schemas/Lldp/properties/name
  // 
  repeated string lldp_names = 1;

  message ColumnNames {
    enum Enum {
      unspecified = 0;
      frames_rx = 1;
      frames_tx = 2;
      frames_error_rx = 3;
      frames_discard = 4;
      tlvs_discard = 5;
      tlvs_unknown = 6;
    }
  }
  // The requested list of column names for the result set. If the list is empty then
  // metrics for all columns will be returned. The name of LLDP instance can not be excluded.
  repeated ColumnNames.Enum column_names = 2;
}

// LLDP per instance statistics information.
message LldpMetric {

  // The name of the configured LLDP instance.
  optional string name = 1;

  // Number of LLDP frames received.
  optional uint64 frames_rx = 2;

  // Number of LLDP frames transmitted.
  optional uint64 frames_tx = 3;

  // Number of LLDP frames received with packet errors. This stat should be incremented
  // based on statsFramesInErrorsTotal increment rule in section 10.3.2 of IEEE Std 802.1
  // AB-2005.
  optional uint64 frames_error_rx = 4;

  // Number of LLDP frames received that are discarded. This stat should be incremented
  // when one or more of the three mandatory  TLVs at the beginning of the LLDPDU is missing,
  // out of order or  contains an out of range information string length. This stat should
  // follow the validation rules in section 10.3.2 of IEEE  Std 802.1 AB-2005.
  optional uint64 frames_discard = 5;

  // Number of LLDP tlvs received that are discarded. If any TLV contains  an error condition
  // specific for that particular TLV or if any TLV  extends past the physical end of
  // the frame then these TLVs will be discarded.
  optional uint64 tlvs_discard = 6;

  // Number of LLDP unknown tlvs received. If the OUI of the organizationlly specific
  // TLV and/or organizationally defined subtype are not recognized,or if TLV type  value
  // is in the range of reserved TLV types then these TLVs will be considered as  unknown
  // TLVs.
  optional uint64 tlvs_unknown = 7;
}

// The request to retrieve RSVP-TE per Router metrics/statistics.
message RsvpMetricsRequest {

  // The names of RSVP-TE Routers to return results for. An empty list as input will return
  // results for all RSVP-TE routers.
  // 
  // x-constraint:
  // - /components/schemas/Device.Rsvp/properties/name
  // 
  repeated string router_names = 1;

  message ColumnNames {
    enum Enum {
      unspecified = 0;
      ingress_p2p_lsps_configured = 1;
      ingress_p2p_lsps_up = 2;
      egress_p2p_lsps_up = 3;
      lsp_flap_count = 4;
      paths_tx = 5;
      paths_rx = 6;
      resvs_tx = 7;
      resvs_rx = 8;
      path_tears_tx = 9;
      path_tears_rx = 10;
      resv_tears_tx = 11;
      resv_tears_rx = 12;
      path_errors_tx = 13;
      path_errors_rx = 14;
      resv_errors_tx = 15;
      resv_errors_rx = 16;
      resv_conf_tx = 17;
      resv_conf_rx = 18;
      hellos_tx = 19;
      hellos_rx = 20;
      acks_tx = 21;
      acks_rx = 22;
      nacks_tx = 23;
      nacks_rx = 24;
      srefresh_tx = 25;
      srefresh_rx = 26;
      bundle_tx = 27;
      bundle_rx = 28;
      path_reevaluation_request_tx = 29;
      path_reoptimizations = 30;
    }
  }
  // The list of column names that the returned result set will contain. If the input
  // list is empty then all columns will be returned except for any result_groups.
  // 
  repeated ColumnNames.Enum column_names = 2;
}

// RSVP-TE per router statistics information.
message RsvpMetric {

  // The name of a configured RSVP router.
  optional string name = 1;

  // The number of ingress point-to-point LSPs configured or transiting through the RSVP
  // router which have been initated from the test port.
  optional uint32 ingress_p2p_lsps_configured = 2;

  // The number of ingress point-to-point LSPs for which Resv has been received and is
  // currently up.
  optional uint32 ingress_p2p_lsps_up = 3;

  // The number of egress point-to-point LSPs for which Path requests were successfully
  // processed and is currently up.
  optional uint32 egress_p2p_lsps_up = 4;

  // The number of times an LSP went from up to down state either because it timed out
  // while waiting for Refreshes or  a PathTear or ResvTear message was received which
  // caused the LSP to flap.
  optional uint64 lsp_flap_count = 5;

  // The number of Path messages sent by this RSVP router.
  optional uint64 paths_tx = 6;

  // The number of Path messages received by this RSVP router.
  optional uint64 paths_rx = 7;

  // The number of Resv messages sent by this RSVP router.
  optional uint64 resvs_tx = 8;

  // The number of Resv messages received by this RSVP router.
  optional uint64 resvs_rx = 9;

  // The number of  Path Tear messages sent by this RSVP router.
  optional uint64 path_tears_tx = 10;

  // The number of Path Tear messages received by this RSVP router.
  optional uint64 path_tears_rx = 11;

  // The number of  Resv Tear messages sent by this RSVP router.
  optional uint64 resv_tears_tx = 12;

  // The number of Resv Tear messages received by this RSVP router.
  optional uint64 resv_tears_rx = 13;

  // The number of Path Error messages sent by this RSVP router.
  optional uint64 path_errors_tx = 14;

  // The number of Path Error messages received by this RSVP router.
  optional uint64 path_errors_rx = 15;

  // The number of Resv Error messages sent by this RSVP router.
  optional uint64 resv_errors_tx = 16;

  // The number of Resv Error messages received by this RSVP router.
  optional uint64 resv_errors_rx = 17;

  // The number of ResvConf messages sent by this RSVP router.
  optional uint64 resv_conf_tx = 18;

  // The number of ResvConf messages received by this RSVP router.
  optional uint64 resv_conf_rx = 19;

  // The number of Hello messages sent by this RSVP router.
  optional uint64 hellos_tx = 20;

  // The number of Hello messages received by this RSVP router.
  optional uint64 hellos_rx = 21;

  // The number of Ack messages sent by this RSVP router.
  optional uint64 acks_tx = 22;

  // The number of Ack messages received by this RSVP router.
  optional uint64 acks_rx = 23;

  // The number of Nack messages sent by this RSVP router.
  optional uint64 nacks_tx = 24;

  // The number of Nack messages received by this RSVP router.
  optional uint64 nacks_rx = 25;

  // The number of SRefresh messages sent by this RSVP router.
  optional uint64 srefresh_tx = 26;

  // The number of SRefresh messages received by this RSVP router.
  optional uint64 srefresh_rx = 27;

  // The number of Bundle messages sent by this RSVP router.
  optional uint64 bundle_tx = 28;

  // The number of Bundle messages received by this RSVP router.
  optional uint64 bundle_rx = 29;

  // The number of Path messages with Path Re-evaluation Request enabled sent by this
  // RSVP router.
  optional uint64 path_reevaluation_request_tx = 30;

  // The number of successfully completed Make-Before-Break operations on LSPs on this
  // RSVP router.
  optional uint64 path_reoptimizations = 31;
}

// The request to retrieve DHCPv4 per client metrics/statistics.
message Dhcpv4ClientMetricsRequest {

  // The names of DHCPv4 clients to return results for. An empty list will return results
  // for all DHCPv4 client.
  // 
  // x-constraint:
  // - /components/schemas/Device.Dhcpv4client/properties/name
  // 
  repeated string client_names = 1;

  message ColumnNames {
    enum Enum {
      unspecified = 0;
      discovers_sent = 1;
      offers_received = 2;
      requests_sent = 3;
      acks_received = 4;
      nacks_received = 5;
      releases_sent = 6;
      declines_sent = 7;
    }
  }
  // The list of column names that the returned result set will contain. If the list is
  // empty then all columns will be returned.  The name of the DHCPv4 client cannot be
  // excluded.
  repeated ColumnNames.Enum column_names = 2;
}

// DHCPv4 per peer statistics information.
message Dhcpv4ClientMetric {

  // The name of a configured DHCPv4 client.
  optional string name = 1;

  // Number of DHCPDISCOVER messages sent.
  optional uint64 discovers_sent = 2;

  // Number of DHCPOFFER messages received.
  optional uint64 offers_received = 3;

  // Number of DHCPREQUEST messages sent.
  optional uint64 requests_sent = 4;

  // Number of lease DHCPACK messages received.
  optional uint64 acks_received = 5;

  // Number of negative lease DHCPNACK messages received.
  optional uint64 nacks_received = 6;

  // Number of DHCPRELEASE messages sent.
  optional uint64 releases_sent = 7;

  // Number of DHCPDECLINE messages sent.
  optional uint64 declines_sent = 8;
}

// The request to retrieve DHCPv4 per Server metrics/statistics.
message Dhcpv4ServerMetricsRequest {

  // The names of DHCPv4 Servers to return results for. An empty list will return results
  // for all DHCPv4 Server.
  // 
  // x-constraint:
  // - /components/schemas/Device.Dhcpv4Server/properties/name
  // 
  repeated string server_names = 1;

  message ColumnNames {
    enum Enum {
      unspecified = 0;
      discovers_received = 1;
      offers_sent = 2;
      requests_received = 3;
      acks_sent = 4;
      nacks_sent = 5;
      releases_received = 6;
      declines_received = 7;
    }
  }
  // The list of column names that the returned result set will contain. If the list is
  // empty then all columns will be returned.  The name of the DHCPv4 server cannot be
  // excluded.
  repeated ColumnNames.Enum column_names = 2;
}

// DHCPv4 per peer statistics information.
message Dhcpv4ServerMetric {

  // The name of a configured DHCPv4 Server.
  optional string name = 1;

  // Number of DHCPDISCOVER messages received.
  optional uint64 discovers_received = 2;

  // Number of DHCPOFFER messages sent.
  optional uint64 offers_sent = 3;

  // Number of DHCPOFFER messages received.
  optional uint64 requests_received = 4;

  // Number of lease DHCPACK messages sent.
  optional uint64 acks_sent = 5;

  // Number of negative lease DHCPNACK messages sent.
  optional uint64 nacks_sent = 6;

  // Number of DHCPRELEASE messages received.
  optional uint64 releases_received = 7;

  // Number of DHCPDECLINE messages received.
  optional uint64 declines_received = 8;
}

// The request to retrieve DHCPv6 per client metrics/statistics.
message Dhcpv6ClientMetricsRequest {

  // The names of DHCPv6 clients to return results for. An empty list will return results
  // for all DHCPv6 client.
  // 
  // x-constraint:
  // - /components/schemas/Device.Dhcpv6client/properties/name
  // 
  repeated string client_names = 1;

  message ColumnNames {
    enum Enum {
      unspecified = 0;
      solicits_sent = 1;
      advertisements_received = 2;
      advertisements_ignored = 3;
      requests_sent = 4;
      nacks_received = 5;
      replies_received = 6;
      information_requests_sent = 7;
      renews_sent = 8;
      rebinds_sent = 9;
      releases_sent = 10;
      reconfigures_received = 11;
      rapid_commit_solicits_sent = 12;
      rapid_commit_replies_received = 13;
    }
  }
  // The list of column names that the returned result set will contain. If the list is
  // empty then all columns will be returned except for any result_groups. The name of
  // the DHCPv6 client cannot be excluded.
  repeated ColumnNames.Enum column_names = 2;
}

// DHCPv6 per peer statistics information.
message Dhcpv6ClientMetric {

  // The name of a configured DHCPv6 client.
  optional string name = 1;

  // Number of DHCPSOLICIT messages sent.
  optional uint64 solicits_sent = 2;

  // Number of DHCPADVERTISE messages received.
  optional uint64 advertisements_received = 3;

  // Number of DHCPADVERTISE messages ignored.
  optional uint64 advertisements_ignored = 4;

  // Number of DHCPREQUEST messages sent.
  optional uint64 requests_sent = 5;

  // Number of negative lease DHCPNACK messages received.
  optional uint64 nacks_received = 6;

  // Number of DHCPOFFER messages received.
  optional uint64 replies_received = 7;

  // Number of DHCP Inform requests sent.
  optional uint64 information_requests_sent = 8;

  // Number of DHCP renew messages sent.
  optional uint64 renews_sent = 9;

  // Number of DHCP rebind messages sent.
  optional uint64 rebinds_sent = 10;

  // Number of DHCP Release messages sent.
  optional uint64 releases_sent = 11;

  // Number of DHCP Reconfigure messages received.
  optional uint64 reconfigures_received = 12;

  // Number of rapid commit DHCPSOLICIT messages sent.
  optional uint64 rapid_commit_solicits_sent = 13;

  // Number of rapid commit DHCP Reply messages received.
  optional uint64 rapid_commit_replies_received = 14;
}

// The request to retrieve DHCPv6 per Server metrics/statistics.
message Dhcpv6ServerMetricsRequest {

  // The names of DHCPv6 Servers to return results for. An empty list will return results
  // for all DHCPv6 Server.
  // 
  // x-constraint:
  // - /components/schemas/Device.Dhcpv6Server/properties/name
  // 
  repeated string server_names = 1;

  message ColumnNames {
    enum Enum {
      unspecified = 0;
      solicits_received = 1;
      solicits_ignored = 2;
      advertisements_sent = 3;
      requests_received = 4;
      nacks_sent = 5;
      confirms_received = 6;
      renewals_received = 7;
      rebinds_received = 8;
      replies_sent = 9;
      releases_received = 10;
      declines_received = 11;
      information_requests_received = 12;
      relay_forwards_received = 13;
      relay_replies_sent = 14;
      reconfigures_sent = 15;
    }
  }
  // The list of column names that the returned result set will contain. If the list is
  // empty then all columns will be returned except for any result_groups. The name of
  // the DHCPv6 server cannot be excluded.
  repeated ColumnNames.Enum column_names = 2;
}

// DHCPv6 per server statistics information.
message Dhcpv6ServerMetric {

  // The name of a configured DHCPv6 Server.
  optional string name = 1;

  // Number of DHCPSOLICIT messages received.
  optional uint64 solicits_received = 2;

  // Number of DHCPSOLICIT messages ignored.
  optional uint64 solicits_ignored = 3;

  // Number of DHCP Advertise messages sent.
  optional uint64 advertisements_sent = 4;

  // Number of DHCPREQUEST messages received.
  optional uint64 requests_received = 5;

  // Number of naks sent for DHCPREQUEST messages.
  optional uint64 nacks_sent = 6;

  // Number of DHCP Confirm messages received.
  optional uint64 confirms_received = 7;

  // Number of DHCP Renewal messages received.
  optional uint64 renewals_received = 8;

  // Number of DHCP Rebind messages received.
  optional uint64 rebinds_received = 9;

  // Number of DHCP Reply messages sent.
  optional uint64 replies_sent = 10;

  // Number of DHCP Release messages received.
  optional uint64 releases_received = 11;

  // Number of DHCP Decline messages received.
  optional uint64 declines_received = 12;

  // Number of DHCP Information Request messages received.
  optional uint64 information_requests_received = 13;

  // Number of DHCP Relay agent forward messages received.
  optional uint64 relay_forwards_received = 14;

  // Number of DHCP reply messages sent to Relay agent.
  optional uint64 relay_replies_sent = 15;

  // Number of DHCP Reconfigure messages sent.
  optional uint64 reconfigures_sent = 16;
}

// The request to retrieve OSPFv2 per Router metrics/statistics.
message Ospfv2MetricsRequest {

  // The names of OSPFv2 routers to return results for. An empty list will return results
  // for all OSPFv2 router.
  // 
  // x-constraint:
  // - /components/schemas/Device.Ospfv2/properties/name
  // 
  repeated string router_names = 1;

  message ColumnNames {
    enum Enum {
      unspecified = 0;
      full_state_count = 1;
      down_state_count = 2;
      sessions_flap = 3;
      hellos_sent = 4;
      hellos_received = 5;
      dbd_sent = 6;
      dbd_received = 7;
      ls_request_sent = 8;
      ls_request_received = 9;
      ls_update_sent = 10;
      ls_update_received = 11;
      ls_ack_sent = 12;
      ls_ack_received = 13;
      lsa_sent = 14;
      lsa_received = 15;
      lsa_ack_sent = 16;
      lsa_ack_received = 17;
      router_lsa_sent = 18;
      router_lsa_received = 19;
      network_lsa_sent = 20;
      network_lsa_received = 21;
      summary_lsa_sent = 22;
      summary_lsa_received = 23;
      external_lsa_sent = 24;
      external_lsa_received = 25;
      nssa_lsa_sent = 26;
      nssa_lsa_received = 27;
      opaque_local_sent = 28;
      opaque_local_received = 29;
      opaque_area_sent = 30;
      opaque_area_received = 31;
      opaque_domain_sent = 32;
      opaque_domain_received = 33;
    }
  }
  // The list of column names that the returned result set will contain.
  // If the list is empty then all columns will be returned except for
  // any result_groups.
  // The name of the OSPFv2 Router cannot be excluded.
  repeated ColumnNames.Enum column_names = 2;
}

// OSPFv2 per router statistics information.
message Ospfv2Metric {

  // The name of a configured OSPFv2 router.
  optional string name = 1;

  // The number of OSPFv2 sessions in up state.
  optional uint64 full_state_count = 2;

  // The number of OSPFv2 sessions in down state.
  optional uint64 down_state_count = 3;

  // The number of change of OSPFv2 sessions from up to down state.
  optional uint64 sessions_flap = 4;

  // The number of OSPFv2 Hello messages transmitted.
  optional uint64 hellos_sent = 5;

  // The number of OSPFv2 Hello messages received.
  optional uint64 hellos_received = 6;

  // The number of OSPFv2 Database Description (DBD) messages transmitted.
  optional uint64 dbd_sent = 7;

  // The number of OSPFv2 Database Description (DBD) messages received.
  optional uint64 dbd_received = 8;

  // The number of OSPFv2 LinkState (LS) Request messages transmitted.
  optional uint64 ls_request_sent = 9;

  // The number of OSPFv2 LinkState (LS) Request messages received.
  optional uint64 ls_request_received = 10;

  // The number of OSPFv2 LinkState (LS) Update messages transmitted.
  optional uint64 ls_update_sent = 11;

  // The number of OSPFv2 LinkState (LS) Update messages received.
  optional uint64 ls_update_received = 12;

  // The number of OSPFv2 LinkState (LS) Acknowledgement messages transmitted.
  optional uint64 ls_ack_sent = 13;

  // The number of OSPFv2 LinkState (LS) Acknowledgement messages received.
  optional uint64 ls_ack_received = 14;

  // The total number of OSPFv2 LinkState Advertisement (LSA) messages transmitted.
  optional uint64 lsa_sent = 15;

  // The total number of OSPFv2 LinkState Advertisement (LSA) messages received.
  optional uint64 lsa_received = 16;

  // The total number of OSPFv2 LinkState Advertisement (LSA) messages acknowledged.
  optional uint64 lsa_ack_sent = 17;

  // The total number of OSPFv2 LinkState Advertisement (LSA) acknowledge messages received
  // .
  optional uint64 lsa_ack_received = 18;

  // The number of OSPFv2 Router (Type 1) LSAs transmitted.
  optional uint64 router_lsa_sent = 19;

  // The number of OSPFv2 Router (Type 1) LSAs received.
  optional uint64 router_lsa_received = 20;

  // The number of OSPFv2 Network (Type 2) LSAs transmitted.
  optional uint64 network_lsa_sent = 21;

  // The number of OSPFv2 Network (Type 2) LSAs transmitted.
  optional uint64 network_lsa_received = 22;

  // The number of OSPFv2 Summary IP (Type 3) LSAs transmitted.
  optional uint64 summary_lsa_sent = 23;

  // The number of OSPFv2 Summary IP (Type 3) LSA received.
  optional uint64 summary_lsa_received = 24;

  // The number of OSPFv2 External (Type 5) LSAs transmitted.
  optional uint64 external_lsa_sent = 25;

  // The number of OSPFv2 External (Type 5) LSAs received.
  optional uint64 external_lsa_received = 26;

  // The number of OSPFv2 NSSA (Type 7) LSAs transmitted.
  optional uint64 nssa_lsa_sent = 27;

  // The number of OSPFv2 NSSA (Type 7) LSAs received.
  optional uint64 nssa_lsa_received = 28;

  // The number of OSPFv2 Opaque Local (Type 9) LSAs transmitted.
  optional uint64 opaque_local_sent = 29;

  // The number of OSPFv2 Opaque Local (Type 9) LSAs received.
  optional uint64 opaque_local_received = 30;

  // The number of OSPF Opaque Area (Type 10) LSAs transmitted.
  optional uint64 opaque_area_sent = 31;

  // The number of OSPFv2 Opaque Area (Type 10) LSAs received.
  optional uint64 opaque_area_received = 32;

  // The number of OSPFv2 Opaque Domain (Type 11) LSAs transmitted.
  optional uint64 opaque_domain_sent = 33;

  // The number of OSPFv2 Opaque Domain (Type 11) LSAs received.
  optional uint64 opaque_domain_received = 34;
}

// Container for requesting control-plane and data-plane convergence time metrics for
// flows.
message ConvergenceRequest {

  // Convergence metrics will be retrieved for these flow names.
  // If no flow names are specified then convergence metrics for all flows will be returned.
  // 
  // x-constraint:
  // - /components/schemas/Flow/properties/name
  // 
  repeated string flow_names = 1;
}

// The container for convergence metrics.
message ConvergenceMetric {

  // The name of a flow.
  optional string name = 1;

  // The convergence time(microseconds) measured from the data plane perspective only.
  // 
  // It measures the time w.r.t. last start of the traffic of the affected flow from Below
  // Threshold Timestamp,
  // when the rate on Test Port 2 crosses below the Rx Threshold until an acceptable amount
  // of traffic was
  // received at time Above Threshold Timestamp, when the rate crosses above the configured
  // 
  // rx_rate_threshold.
  optional double data_plane_convergence_us = 2;

  // The total convergence time(microseconds), between the event that caused the
  // switchover until an acceptable amount of traffic was
  // received at time Above Threshold Timestamp, when the rate crosses above the configured
  // 
  // rx_rate_threshold.
  optional double control_plane_data_plane_convergence_us = 3;

  // The events that were used to determine the convergence analytics.
  repeated ConvergenceEvent events = 4;
}

// A container for an event that has occurred in the system affecting the convergence
// time recorded for the flow.
message ConvergenceEvent {

  message Type {
    enum Enum {
      unspecified = 0;
      link_down = 1;
      link_up = 2;
      route_withdraw = 3;
      route_advertise = 4;
      flow_rx_rate_above_threshold = 5;
      flow_rx_rate_below_threshold = 6;
    }
  }
  // The type of control plane or data plane event that occurred.
  optional Type.Enum type = 1;

  // The source of the event.
  // The source MUST be the value of one of the x-constraint paths,
  // which means the source MUST be a unique name in the configuration.
  // 
  // x-constraint:
  // - /components/schemas/Port/properties/name
  // - /components/schemas/Flow/properties/name
  // - /components/schemas/Device.Bgpv4Route/properties/name
  // - /components/schemas/Device.Bgpv6Route/properties/name
  // 
  optional string source = 2;

  // The timestamp(nanoseconds) of the starting event that triggers convergence.
  optional double begin_timestamp_ns = 3;

  // The timestamp(nanoseconds) of the end event that triggers convergence.
  optional double end_timestamp_ns = 4;
}

// The request to retrieve MACsec per secure entity(secY) metrics/statistics.
message MacsecMetricsRequest {

  // The names of secure entities(secYs) to return results for. An empty list will return
  // results for all secYs.
  // 
  // x-constraint:
  // - /components/schemas/Macsec/properties/name
  // 
  repeated string secure_entity_names = 1;

  message ColumnNames {
    enum Enum {
      unspecified = 0;
      session_state = 1;
      session_flap_count = 2;
      out_pkts_protected = 3;
      out_pkts_encrypted = 4;
      in_pkts_ok = 5;
      in_pkts_bad = 6;
      in_pkts_bad_tag = 7;
      in_pkts_late = 8;
      in_pkts_no_sci = 9;
      in_pkts_not_using_sa = 10;
      in_pkts_not_valid = 11;
      in_pkts_unknown_sci = 12;
      in_pkts_unused_sa = 13;
      in_pkts_invalid = 14;
      in_pkts_untagged = 15;
      out_octets_protected = 16;
      out_octets_encrypted = 17;
      in_octets_validated = 18;
      in_octets_decrypted = 19;
    }
  }
  // The list of column names that the returned result set will contain. If the list is
  // empty then all columns will be returned except for any result_groups. The name of
  // the secure entity(secY) cannot be excluded.
  repeated ColumnNames.Enum column_names = 2;
}

// MACsec per secure entity(secY) statistics information.
message MacsecMetric {

  // The name of a configured MACsec secure entity(secY).
  optional string name = 1;

  message SessionState {
    enum Enum {
      unspecified = 0;
      up = 1;
      down = 2;
    }
  }
  // Session state as up or down. Up refers to an Established state and Down refers to
  // any other state.
  optional SessionState.Enum session_state = 2;

  // Number of times the session went from Up to Down state.
  optional uint64 session_flap_count = 3;

  // OutPktsProtected, the number of protected packets transmitted.
  optional uint64 out_pkts_protected = 4;

  // OutPktsEncrypted, the number of encrypted packets transmitted.
  optional uint64 out_pkts_encrypted = 5;

  // InPktsOk, the number of valid packets received.
  optional uint64 in_pkts_ok = 6;

  // The total number of received bad packets that failed atleast one validation check.
  optional uint64 in_pkts_bad = 7;

  // InPktsBadTag, the number of packets discarded due to bad tag/ICV.
  optional uint64 in_pkts_bad_tag = 8;

  // InPktsLate, the number of packets discarded out of window.
  optional uint64 in_pkts_late = 9;

  // InPktsNoSCI,the number of packets discarded due to unknown SCI.
  optional uint64 in_pkts_no_sci = 10;

  // InPktsNotUsingSA, the number of packets discarded due to unused SA.
  optional uint64 in_pkts_not_using_sa = 11;

  // InPktsNotValid, the number of packets discarded due to invalid ICV.
  optional uint64 in_pkts_not_valid = 12;

  // InPktsUnknownSCI, the number of packets received with unknown SCI.
  optional uint64 in_pkts_unknown_sci = 13;

  // InPktsUnusedSA, the number of packets received with unused SA.
  optional uint64 in_pkts_unused_sa = 14;

  // InPktsInvalid, the number of packets received with invalid ICV.
  optional uint64 in_pkts_invalid = 15;

  // InPktsUntagged, the number of non-MACsec packets received.
  optional uint64 in_pkts_untagged = 16;

  // OutOctetsProtected, the number of bytes transmitted as protected.
  optional uint64 out_octets_protected = 17;

  // OutOctetsEncrypted, the number of bytes transmitted as encrypted.
  optional uint64 out_octets_encrypted = 18;

  // InOctetsValidated, the number of received bytes validated.
  optional uint64 in_octets_validated = 19;

  // InOctetsDecrypted, the number of received bytes decrypted.
  optional uint64 in_octets_decrypted = 20;
}

// The request to retrieve MKA per peer metrics/statistics.
message MkaMetricsRequest {

  // The names of peers to return results for. An empty list will return results for all
  // peers.
  // 
  // x-constraint:
  // - /components/schemas/Mka/properties/name
  // 
  repeated string peer_names = 1;

  message ColumnNames {
    enum Enum {
      unspecified = 0;
      session_state = 1;
      session_flap_count = 2;
      mkpdu_tx = 3;
      mkpdu_rx = 4;
      live_peer_count = 5;
      potential_peer_count = 6;
      latest_key_tx_peer_count = 7;
      latest_key_rx_peer_count = 8;
      malformed_mkpdu = 9;
      icv_mismatch = 10;
    }
  }
  // The list of column names that the returned result set will contain. If the list is
  // empty then all columns will be returned except for any result_groups. The name of
  // the peer cannot be excluded.
  repeated ColumnNames.Enum column_names = 2;
}

// MKA per peer statistics information.
message MkaMetric {

  // The name of a configured MKA peer.
  optional string name = 1;

  message SessionState {
    enum Enum {
      unspecified = 0;
      up = 1;
      down = 2;
    }
  }
  // Session state as up or down. Up refers to an Established state and Down refers to
  // any other state.
  optional SessionState.Enum session_state = 2;

  // Number of times the session went from Up to Down state.
  optional uint64 session_flap_count = 3;

  // Number of MKA protocol data unit(MKPDU) frames Tx.
  optional uint64 mkpdu_tx = 4;

  // Number of MKA protocol data unit(MKPDU) frames Rx.
  optional uint64 mkpdu_rx = 5;

  // Number of MKA live peers.
  optional uint64 live_peer_count = 6;

  // Number of MKA potential peers.
  optional uint64 potential_peer_count = 7;

  // Number of MKA latest key Tx peers.
  optional uint64 latest_key_tx_peer_count = 8;

  // Number of MKA latest key Rx peers.
  optional uint64 latest_key_rx_peer_count = 9;

  // Number of malformed MKA Protocol Data Unit(MKPDU) frames Rx.
  optional uint64 malformed_mkpdu = 10;

  // Number of MKA Protocol Data Unit(MKPDU) frames with ICV mismatch Rx.
  optional uint64 icv_mismatch = 11;
}

// The request to retrieve OSPFv3 per router metrics/statistics.
message Ospfv3MetricsRequest {

  // The names of OSPFv3 routers to return results for. An empty list will return results
  // for all OSPFv3 routers.
  // 
  // x-constraint:
  // - /components/schemas/Ospfv3.RouterInstance/properties/name
  // 
  repeated string router_names = 1;

  message ColumnNames {
    enum Enum {
      unspecified = 0;
      full_state_count = 1;
      down_state_count = 2;
      sessions_flap = 3;
      hellos_sent = 4;
      hellos_received = 5;
      dbd_sent = 6;
      dbd_received = 7;
      ls_request_sent = 8;
      ls_request_received = 9;
      ls_update_sent = 10;
      ls_update_received = 11;
      ls_ack_sent = 12;
      ls_ack_received = 13;
      lsa_sent = 14;
      lsa_received = 15;
      router_lsa_sent = 16;
      router_lsa_received = 17;
      network_lsa_sent = 18;
      network_lsa_received = 19;
      inter_area_prefix_lsa_sent = 20;
      inter_area_prefix_lsa_received = 21;
      inter_area_router_lsa_sent = 22;
      inter_area_router_lsa_received = 23;
      external_lsa_sent = 24;
      external_lsa_received = 25;
      nssa_lsa_sent = 26;
      nssa_lsa_received = 27;
      link_lsa_sent = 28;
      link_lsa_received = 29;
      intra_area_prefix_lsa_sent = 30;
      intra_area_prefix_lsa_received = 31;
    }
  }
  // The list of column names that the returned result set will contain.
  // If the list is empty then all columns will be returned except for
  // any result_groups.
  // The name of the OSPFv3 Router cannot be excluded.
  repeated ColumnNames.Enum column_names = 2;
}

// OSPFv3 per router statistics information.
message Ospfv3Metric {

  // The name of a configured OSPFv3 router.
  optional string name = 1;

  // The number of OSPFv3 sessions in up state.
  optional uint64 full_state_count = 2;

  // The number of OSPFv3 sessions in down state.
  optional uint64 down_state_count = 3;

  // The number of change of OSPFv3 sessions from up to down state.
  optional uint64 sessions_flap = 4;

  // The number of OSPFv3 Hello messages transmitted.
  optional uint64 hellos_sent = 5;

  // The number of OSPFv3 Hello messages received.
  optional uint64 hellos_received = 6;

  // The number of OSPFv3 Database Description (DBD) messages transmitted.
  optional uint64 dbd_sent = 7;

  // The number of OSPFv3 Database Description (DBD) messages received.
  optional uint64 dbd_received = 8;

  // The number of OSPFv3 LinkState (LS) Request messages transmitted.
  optional uint64 ls_request_sent = 9;

  // The number of OSPFv3 LinkState (LS) Request messages received.
  optional uint64 ls_request_received = 10;

  // The number of OSPFv3 LinkState (LS) Update messages transmitted.
  optional uint64 ls_update_sent = 11;

  // The number of OSPFv3 LinkState (LS) Update messages received.
  optional uint64 ls_update_received = 12;

  // The number of OSPFv3 LinkState (LS) Acknowledgement messages transmitted.
  optional uint64 ls_ack_sent = 13;

  // The number of OSPFv3 LinkState (LS) Acknowledgement messages received.
  optional uint64 ls_ack_received = 14;

  // The total number of OSPFv3 LinkState Advertisement (LSA) messages transmitted.
  optional uint64 lsa_sent = 15;

  // The total number of OSPFv3 LinkState Advertisement (LSA) messages received.
  optional uint64 lsa_received = 16;

  // The number of OSPFv3 Router (Type 1) LSAs transmitted.
  optional uint64 router_lsa_sent = 17;

  // The number of OSPFv3 Router (Type 1) LSAs received.
  optional uint64 router_lsa_received = 18;

  // The number of OSPFv3 Network (Type 2) LSAs transmitted.
  optional uint64 network_lsa_sent = 19;

  // The number of OSPFv3 Network (Type 2) LSAs received.
  optional uint64 network_lsa_received = 20;

  // The number of OSPFv3 Inter-Area-Prefix (Type 3) LSAs transmitted.
  optional uint64 inter_area_prefix_lsa_sent = 21;

  // The number of OSPFv3 Inter-Area-Prefix (Type 3) LSAs received.
  optional uint64 inter_area_prefix_lsa_received = 22;

  // The number of OSPFv3 Inter-Area-Router (Type 4) LSAs transmitted.
  optional uint64 inter_area_router_lsa_sent = 23;

  // The number of OSPFv3 Inter-Area-Router (Type 4) LSAs received.
  optional uint64 inter_area_router_lsa_received = 24;

  // The number of OSPFv3 External (Type 5) LSAs transmitted.
  optional uint64 external_lsa_sent = 25;

  // The number of OSPFv3 External (Type 5) LSAs received.
  optional uint64 external_lsa_received = 26;

  // The number of OSPFv3 NSSA (Type 7) LSAs transmitted.
  optional uint64 nssa_lsa_sent = 27;

  // The number of OSPFv3 NSSA (Type 7) LSAs received.
  optional uint64 nssa_lsa_received = 28;

  // The number of OSPFv3 Link (Type 8) LSAs transmitted.
  optional uint64 link_lsa_sent = 29;

  // The number of OSPFv3 Link (Type 8) LSAs received.
  optional uint64 link_lsa_received = 30;

  // The number of OSPFv3 Intra-Area-Prefix (Type 9) LSAs transmitted.
  optional uint64 intra_area_prefix_lsa_sent = 31;

  // The number of OSPFv3 Intra-Area-Prefix (Type 9) LSAs received.
  optional uint64 intra_area_prefix_lsa_received = 32;
}

// Request to retrieve RoCEv2 over IPv4 per peer metrics/statistics.
message Rocev2IPv4MetricsRequest {

  message Choice {
    enum Enum {
      unspecified = 0;
      per_peer = 1;
    }
  }
  // Fetch stats per_peer
  // default = Choice.Enum.per_peer
  optional Choice.Enum choice = 1;

  // Description missing in models
  Rocev2IPv4ColumnNames per_peer = 2;
}

// The names of RoCEv2 over IPv4 peers to return results for. An empty list will return
// results for all RoCEv2 peers.
message Rocev2IPv4ColumnNames {

  // The names of RoCEv2 over IPv4 peers to return results for. An empty list will return
  // results for all RoCEv2 peers.
  // 
  // x-constraint:
  // - /components/schemas/Rocev2.V4peer/properties/name
  // 
  repeated string peer_names = 1;

  message ColumnNames {
    enum Enum {
      unspecified = 0;
      qp_configured = 1;
      qp_up = 2;
      qp_down = 3;
      connect_request_tx = 4;
      connect_request_rx = 5;
      connect_reply_tx = 6;
      connect_reply_rx = 7;
      ready_tx = 8;
      ready_rx = 9;
      disconnect_request_tx = 10;
      disconnect_request_rx = 11;
      disconnect_reply_tx = 12;
      disconnect_reply_rx = 13;
      reject_tx = 14;
      reject_rx = 15;
      unknown_msg_rx = 16;
    }
  }
  // The list of column names that the returned result set will contain. If the list is
  // empty then all columns will be returned except for any result_groups. The name of
  // the RoCEv2 peer cannot be excluded.
  repeated ColumnNames.Enum column_names = 2;
}

// RoCEv2 per peer statistics information.
message Rocev2IPv4MetricPerPeer {

  // The name of a configured RoCEv2 peer.
  optional string name = 1;

  // Number of QPs configured on this port.
  optional uint64 qp_configured = 2;

  // Number of QPs that are in UP state.
  optional uint64 qp_up = 3;

  // Number of QPs that have not come UP.
  optional uint64 qp_down = 4;

  // Number of REQ Message Transmitted.
  optional uint64 connect_request_tx = 5;

  // Number of REQ Message Received.
  optional uint64 connect_request_rx = 6;

  // Number of REP Message Transmitted.
  optional uint64 connect_reply_tx = 8;

  // Number of REP Message Received.
  optional uint64 connect_reply_rx = 9;

  // Number of RTU Message Transmitted.
  optional uint64 ready_tx = 10;

  // Number of RTU Message Received.
  optional uint64 ready_rx = 11;

  // Number of DREQ Message Transmitted.
  optional uint64 disconnect_request_tx = 12;

  // Number of DREQ Message Received.
  optional uint64 disconnect_request_rx = 13;

  // Number of DREP Message Transmitted.
  optional uint64 disconnect_reply_tx = 14;

  // Number of DREP Message Received.
  optional uint64 disconnect_reply_rx = 15;

  // Number of REJ Message Transmitted.
  optional uint64 reject_tx = 16;

  // Number of Unknown Message Received.
  optional uint64 unknown_msg_rx = 17;
}

// Request to retrieve RoCEv2 over IPv6 per peer metrics/statistics.
message Rocev2IPv6MetricsRequest {

  message Choice {
    enum Enum {
      unspecified = 0;
      per_peer = 1;
    }
  }
  // Fetch stats per_peer
  // default = Choice.Enum.per_peer
  optional Choice.Enum choice = 1;

  // Description missing in models
  Rocev2IPv6ColumnNames per_peer = 2;
}

// The names of RoCEv2 over IPv6 peers to return results for. An empty list will return
// results for all RoCEv2 peers.
message Rocev2IPv6ColumnNames {

  // The names of RoCEv2 over IPv6 peers to return results for. An empty list will return
  // results for all RoCEv2 peers.
  // 
  // x-constraint:
  // - /components/schemas/Rocev2.V6peer/properties/name
  // 
  repeated string peer_names = 1;

  message ColumnNames {
    enum Enum {
      unspecified = 0;
      qp_configured = 1;
      qp_up = 2;
      qp_down = 3;
      connect_request_tx = 4;
      connect_request_rx = 5;
      connect_reply_tx = 6;
      connect_reply_rx = 7;
      ready_tx = 8;
      ready_rx = 9;
      disconnect_request_tx = 10;
      disconnect_request_rx = 11;
      disconnect_reply_tx = 12;
      disconnect_reply_rx = 13;
      reject_tx = 14;
      reject_rx = 15;
      unknown_msg_rx = 16;
    }
  }
  // The list of column names that the returned result set will contain. If the list is
  // empty then all columns will be returned except for any result_groups. The name of
  // the RoCEv2 peer cannot be excluded.
  repeated ColumnNames.Enum column_names = 2;
}

// RoCEv2 per peer statistics information.
message Rocev2IPv6MetricPerPeer {

  // The name of a configured RoCEv2 peer.
  optional string name = 1;

  // Number of QPs configured on this port.
  optional uint64 qp_configured = 2;

  // Number of QPs that are in UP state.
  optional uint64 qp_up = 3;

  // Number of QPs that have not come UP.
  optional uint64 qp_down = 4;

  // Number of REQ Message Transmitted.
  optional uint64 connect_request_tx = 5;

  // Number of REQ Message Received.
  optional uint64 connect_request_rx = 6;

  // Number of REP Message Transmitted.
  optional uint64 connect_reply_tx = 8;

  // Number of REP Message Received.
  optional uint64 connect_reply_rx = 9;

  // Number of RTU Message Transmitted.
  optional uint64 ready_tx = 10;

  // Number of RTU Message Received.
  optional uint64 ready_rx = 11;

  // Number of DREQ Message Transmitted.
  optional uint64 disconnect_request_tx = 12;

  // Number of DREQ Message Received.
  optional uint64 disconnect_request_rx = 13;

  // Number of DREP Message Transmitted.
  optional uint64 disconnect_reply_tx = 14;

  // Number of DREP Message Received.
  optional uint64 disconnect_reply_rx = 15;

  // Number of REJ Message Transmitted.
  optional uint64 reject_tx = 16;

  // Number of Unknown Message Received.
  optional uint64 unknown_msg_rx = 17;
}

// Request to retrieve RoCEv2 FLow statistics.
message Rocev2FlowMetricsRequest {

  message Choice {
    enum Enum {
      unspecified = 0;
      per_qp = 1;
    }
  }
  // Fetch stats per QP
  // default = Choice.Enum.per_qp
  optional Choice.Enum choice = 1;

  // Description missing in models
  Rocev2FlowColumnNames per_qp = 2;
}

// The names of RoCEv2 flows. An empty list will return results for all RoCEv2 flows.
message Rocev2FlowColumnNames {

  message ColumnNames {
    enum Enum {
      unspecified = 0;
      flow_name = 1;
      port_tx = 2;
      port_rx = 3;
      src_qp = 4;
      dest_qp = 5;
      src_ipv4 = 6;
      dest_ipv4 = 7;
      data_frames_tx = 8;
      data_frames_rx = 9;
      frame_delta = 10;
      data_frames_retransmitted = 11;
      frame_sequence_error = 12;
      tx_bytes = 13;
      rx_bytes = 14;
      data_tx_rate = 15;
      data_rx_rate = 16;
      message_tx = 17;
      message_complete_rx = 18;
      message_fail = 19;
      flow_completion_time = 20;
      avg_latency = 21;
      min_latency = 22;
      max_latency = 23;
      ecn_ce_rx = 24;
      cnp_tx = 25;
      cnp_rx = 26;
      ack_tx = 27;
      ack_rx = 28;
      nak_tx = 29;
      nak_rx = 30;
      first_timestamp = 31;
      last_timestamp = 32;
    }
  }
  // The list of column names that the returned result set will contain. If the list is
  // empty then all columns will be returned except for any result_groups. The name of
  // the Flow cannot be excluded.
  repeated ColumnNames.Enum column_names = 1;
}

// RoCEv2 Flow statistics information.
message Rocev2FlowMetricPerQP {

  // Flow Name.
  optional string flow_name = 1;

  // The name of the transmit port
  optional string port_tx = 2;

  // The name of the receive port
  optional string port_rx = 3;

  // Current source QP number.
  optional uint64 src_qp = 4;

  // Current destination QP number.
  optional uint64 dest_qp = 5;

  // Current source address.
  optional string src_ipv4 = 6;

  // Current destination address.
  optional string dest_ipv4 = 7;

  // Current number of data frames transmitted.
  optional uint64 data_frames_tx = 8;

  // Current number of data frames received.
  optional uint64 data_frames_rx = 9;

  // Current differnece between tx and rx data frames
  optional uint64 frame_delta = 10;

  // Current number of data frames re-transmitted.
  optional uint64 data_frames_retransmitted = 11;

  // Current number of frame sequence errors.
  optional uint64 frame_sequence_error = 12;

  // Current number of bytes transmitted.
  optional uint64 tx_bytes = 13;

  // Current number of bytes received.
  optional uint64 rx_bytes = 14;

  // Current rate at which data is transmitted in Gbps.
  optional float data_tx_rate = 15;

  // Current rate at which data is received in Gbps.
  optional float data_rx_rate = 16;

  // Current number of Message transmitted.
  optional uint64 message_tx = 17;

  // Current number of Message Complete received.
  optional uint64 message_complete_rx = 18;

  // Current number of Message Fail count.
  optional uint64 message_fail = 19;

  // Current flow comletion time in ms.
  optional uint64 flow_completion_time = 20;

  // Current average latency measured in ns.
  optional uint64 avg_latency = 21;

  // Current minimum latency measured in ns.
  optional uint64 min_latency = 22;

  // Current maximum latency measured in ns.
  optional uint64 max_latency = 23;

  // Current number of ECN-CE Recevied.
  optional uint64 ecn_ce_rx = 24;

  // Current number of CNP transmitted.
  optional uint64 cnp_tx = 25;

  // Current number of CNP received.
  optional uint64 cnp_rx = 26;

  // Current number of ACK transmitted.
  optional uint64 ack_tx = 27;

  // Current number of ACK received.
  optional uint64 ack_rx = 28;

  // Current number of NAK transmitted.
  optional uint64 nak_tx = 29;

  // Current number of NAK received.
  optional uint64 nak_rx = 30;

  // First Timestamp.
  optional string first_timestamp = 31;

  // Last Timestamp.
  optional string last_timestamp = 32;
}

// The container for a egress only tracking metric request.
message EgressOnlyTrackingMetricsRequest {

  // Egress only tracking metrics will be retrieved for these port names.
  // If no port-names are provided, egress_only_tracking metrics will be returned for
  // all ports
  // which have one or more egress_only_tracking enabled.
  // 
  // x-constraint:
  // - /components/schemas/EgressOnlyTracking/properties/port_name
  // 
  repeated string port_names = 1;

  // Description missing in models
  EgressOnlyTrackingTaggedMetricsFilter tagged_metrics = 2;
}

// Filter for tagged metrics
message EgressOnlyTrackingTaggedMetricsFilter {

  // Controls inclusion/exclusion of tagged metrics where each underlying attribute has
  // zero value or absent value.
  // default = False
  optional bool include_empty_metrics = 1;

  message MetricNames {
    enum Enum {
      unspecified = 0;
      frames_rx = 1;
      bytes_rx = 2;
      frames_rx_rate = 3;
      rx_l1_rate_bps = 4;
      rx_rate_bytes = 5;
      rx_rate_bps = 6;
      rx_rate_kbps = 7;
      rx_rate_mbps = 8;
      tx_metrics = 9;
    }
  }
  // The list of metric names that the returned result set will contain. If the list is
  // empty then all metrics will be returned. Note: tx_metrics is optional, it is applicable
  // where implementation is able to retrieve transmitter information. In order to get
  // Tx metrics, tx_metric must be added in metric_names and all supported Tx metrics
  // will be returned as listed in metric response.
  repeated MetricNames.Enum metric_names = 2;
}

// A container for egress-only-tracking metrics.
// The container is keyed by the port_rx.
message EgressOnlyTrackingMetric {

  // The name of the receive port
  optional string port_rx = 1;

  // List of metrics corresponding to a set of values applicable
  // for configured metric tags in egress packet header fields.
  // The container is keyed by list of tag-value pairs.
  repeated EgressOnlyTrackingTaggedMetric tagged_metrics = 2;
}

// Metrics for each set of values applicable for configured
// metric tags in egress packet header fields.
// The container is keyed by list of tag-value pairs.
message EgressOnlyTrackingTaggedMetric {

  // List of tag and value pairs
  repeated EgressOnlyTrackingMetricTag tags = 1;

  // The current total number of valid frames received
  optional uint64 frames_rx = 2;

  // The current total number of bytes received
  optional uint64 bytes_rx = 3;

  // The current rate of valid frames received
  optional float frames_rx_rate = 4;

  // Description missing in models
  EgressOnlyTrackingTimestamp timestamps = 5;

  // The Layer 1 receive rate in bits per second.
  optional float rx_l1_rate_bps = 6;

  // The receive rate in bytes per second.
  optional float rx_rate_bytes = 7;

  // The receive rate in bits per second.
  optional float rx_rate_bps = 8;

  // The receive rate in Kilobits per second.
  optional float rx_rate_kbps = 9;

  // The receive rate in Megabits per second.
  optional float rx_rate_mbps = 10;

  // Description missing in models
  EgressOnlyTrackingTxMetrics tx_metrics = 11;
}

// Description missing in models
message EgressOnlyTrackingMetricTag {

  // Name of packet field metric tag
  optional string name = 1;

  // Value of packet field metric tag in hexadecimal format
  optional string value = 2;
}

// The container for timestamp metrics.
// The container will be empty if the timestamp has not been configured for the flow.
message EgressOnlyTrackingTimestamp {

  // First timestamp in nanoseconds
  optional double first_timestamp_ns = 1;

  // Last timestamp in nanoseconds
  optional double last_timestamp_ns = 2;
}

// The container for tx metrics.
// The container will be empty if the tx metrics has not been configured.
message EgressOnlyTrackingTxMetrics {

  // The name of the transmit port
  optional string port_tx = 1;

  // The current total number of frames transmitted
  optional uint64 frames_tx = 2;

  // The current total number of bytes transmitted
  optional uint64 bytes_tx = 3;

  // The current rate of frames transmitted
  optional float frames_tx_rate = 4;

  // The percentage of lost frames
  optional float loss = 5;

  // The Layer 1 transmission rate in bits per second.
  optional float tx_l1_rate_bps = 6;

  // The transmission rate in bytes per second.
  optional float tx_rate_bytes = 7;

  // The transmission rate in bits per second.
  optional float tx_rate_bps = 8;

  // The transmission rate in Kilobits per second.
  optional float tx_rate_kbps = 9;

  // The transmission rate in Megabits per second.
  optional float tx_rate_mbps = 10;
}

// The request to retrieve per BMP Server metrics/statistics.
message BmpServerMetricsRequest {

  // The names of BMP Servers to return results for. An empty list will return results
  // for all BMP Servers.
  // 
  // x-constraint:
  // - /components/schemas/Device.Bmp.ServerV4/properties/name
  // - /components/schemas/Device.Bmp.ServerV6/properties/name
  // 
  repeated string server_names = 1;

  message ColumnNames {
    enum Enum {
      unspecified = 0;
      session_state = 1;
      flap_count = 2;
      route_monitoring_messages_received = 3;
      statistics_messages_received = 4;
      peer_down_messages_received = 5;
      peer_up_messages_received = 6;
      initiation_messages_received = 7;
      route_mirroring_messages_received = 8;
      termination_messages_received = 9;
      pre_policy_ipv4_unicast_routes_received = 10;
      post_policy_ipv4_unicast_routes_received = 11;
      pre_policy_ipv6_unicast_routes_received = 12;
      post_policy_ipv6_unicast_routes_received = 13;
    }
  }
  // The list of column names that the returned result set will contain. If the list is
  // empty then all columns will be returned except for any result_groups. The name of
  // the BMP Server cannot be excluded.
  repeated ColumnNames.Enum column_names = 2;
}

// BMP Server statistics information.
message BmpServerMetric {

  // The name of the configured BMP server.
  optional string name = 1;

  message SessionState {
    enum Enum {
      unspecified = 0;
      up = 1;
      down = 2;
    }
  }
  // Session state as up or down. The session goes to 'up' state when a BMP monitored
  // client router sends a Initiation message to the BMP Server. The session goes to 'down'
  // state when a BMP monitored client router sends a Termination message to the BMP Server
  // or the TCP connection is lost. On initial start, the state as reported as 'down'.
  optional SessionState.Enum session_state = 2;

  // Number of times the BMP session with the BMP client went from Up to Down state.
  optional uint64 flap_count = 3;

  // Number of BMP Route Monitoring Messages received from the BMP client from the time
  // the BMP server was started.
  optional uint64 route_monitoring_messages_received = 4;

  // Number of BMP Route Statistics Messages received from the BMP client from the time
  // the BMP server was started.
  optional uint64 statistics_messages_received = 5;

  // Number of BMP Peer Down Messages received from the BMP client from the time the BMP
  // server was started.
  optional uint64 peer_down_messages_received = 6;

  // Number of BMP Peer Up Messages received from the BMP client from the time the BMP
  // server was started.
  optional uint64 peer_up_messages_received = 7;

  // Number of BMP Initiation Messages received from the BMP client from the time the
  // BMP server was started .
  optional uint64 initiation_messages_received = 8;

  // Number of BMP Route Mirroring Messages received from the BMP client from the time
  // the BMP server was started.
  optional uint64 route_mirroring_messages_received = 9;

  // Number of BMP Termination Messages received from the BMP client from the time the
  // BMP server was started.
  optional uint64 termination_messages_received = 10;

  // Number of IPv4 Unicast prefixes received within BMP Monitor messages with L flag
  // unset (indicating absence of application on in-bound policy on the advertised prefix)
  // from the BMP client from the time the BMP server was started.
  optional uint64 pre_policy_ipv4_unicast_routes_received = 11;

  // Number of IPv4 Unicast prefixes received within BMP Monitor messages with L flag
  // set (indicating application of in-bound policy on the advertised prefix)  from the
  // BMP client from the time the BMP server was started.
  optional uint64 post_policy_ipv4_unicast_routes_received = 12;

  // Number of IPv6 Unicast prefixes received within BMP Monitor messages with L flag
  // unset (indicating absence of application on in-bound policy on the advertised prefix)
  // from the BMP client from the time the BMP server was started.
  optional uint64 pre_policy_ipv6_unicast_routes_received = 13;

  // Number of IPv6 Unicast prefixes received within BMP Monitor messages with L flag
  // set (indicating application of in-bound policy on the advertised prefix)  from the
  // BMP client from the time the BMP server was started.
  optional uint64 post_policy_ipv6_unicast_routes_received = 14;
}

// Request to traffic generator for states of choice
message StatesRequest {

  message Choice {
    enum Enum {
      unspecified = 0;
      ipv4_neighbors = 1;
      ipv6_neighbors = 2;
      bgp_prefixes = 3;
      isis_lsps = 4;
      lldp_neighbors = 5;
      rsvp_lsps = 6;
      dhcpv4_interfaces = 7;
      dhcpv4_leases = 8;
      dhcpv6_interfaces = 9;
      dhcpv6_leases = 10;
      ospfv2_lsas = 11;
      ospfv3_lsas = 12;
      isis_adjacencies = 13;
      bmp_servers = 14;
    }
  }
  // Description missing in models
  // default = Choice.Enum.ipv4_neighbors
  optional Choice.Enum choice = 1;

  // Description missing in models
  Neighborsv4StatesRequest ipv4_neighbors = 2;

  // Description missing in models
  Neighborsv6StatesRequest ipv6_neighbors = 3;

  // Description missing in models
  BgpPrefixStateRequest bgp_prefixes = 4;

  // Description missing in models
  IsisLspsStateRequest isis_lsps = 5;

  // Description missing in models
  LldpNeighborsStateRequest lldp_neighbors = 6;

  // Description missing in models
  RsvpLspsStateRequest rsvp_lsps = 7;

  // Description missing in models
  Dhcpv4InterfaceStateRequest dhcpv4_interfaces = 8;

  // Description missing in models
  Dhcpv4LeaseStateRequest dhcpv4_leases = 9;

  // Description missing in models
  Dhcpv6InterfaceStateRequest dhcpv6_interfaces = 10;

  // Description missing in models
  Dhcpv6LeaseStateRequest dhcpv6_leases = 11;

  // Description missing in models
  Ospfv2LsasStateRequest ospfv2_lsas = 12;

  // Description missing in models
  Ospfv3LsasStateRequest ospfv3_lsas = 13;

  // Description missing in models
  IsisIIHsStateRequest isis_adjacencies = 14;

  // Description missing in models
  BmpServersStateRequest bmp_servers = 15;
}

// Response containing chosen traffic generator states
message StatesResponse {

  message Choice {
    enum Enum {
      unspecified = 0;
      ipv4_neighbors = 1;
      ipv6_neighbors = 2;
      bgp_prefixes = 3;
      isis_lsps = 4;
      lldp_neighbors = 5;
      rsvp_lsps = 6;
      dhcpv4_interfaces = 7;
      dhcpv4_leases = 8;
      dhcpv6_interfaces = 9;
      dhcpv6_leases = 10;
      ospfv2_lsas = 11;
      ospfv3_lsas = 12;
      isis_adjacencies = 13;
      bmp_servers = 14;
    }
  }
  // Description missing in models
  // default = Choice.Enum.ipv4_neighbors
  optional Choice.Enum choice = 1;

  // Description missing in models
  repeated Neighborsv4State ipv4_neighbors = 2;

  // Description missing in models
  repeated Neighborsv6State ipv6_neighbors = 3;

  // Description missing in models
  repeated BgpPrefixesState bgp_prefixes = 4;

  // Description missing in models
  repeated IsisLspsState isis_lsps = 5;

  // Description missing in models
  repeated LldpNeighborsState lldp_neighbors = 6;

  // Description missing in models
  repeated RsvpLspsState rsvp_lsps = 7;

  // Description missing in models
  repeated Dhcpv4InterfaceState dhcpv4_interfaces = 8;

  // Description missing in models
  repeated Dhcpv4LeasesState dhcpv4_leases = 9;

  // Description missing in models
  repeated Dhcpv6InterfaceState dhcpv6_interfaces = 10;

  // Description missing in models
  repeated Dhcpv6LeasesState dhcpv6_leases = 11;

  // Description missing in models
  repeated Ospfv2LsaState ospfv2_lsas = 12;

  // Description missing in models
  repeated Ospfv3LsaState ospfv3_lsas = 13;

  // Description missing in models
  repeated IsisIIHsState isis_adjacencies = 14;

  // Description missing in models
  repeated BmpServerState bmp_servers = 15;
}

// The request to retrieve IPv4 Neighbor state (ARP cache entries) of a network interface(s).
message Neighborsv4StatesRequest {

  // The names of Ethernet interfaces for which Neighbor state (ARP cache entries) will
  // be retrieved. If no names are specified then the results will contain Neighbor state
  // (ARP cache entries) for all available Ethernet interfaces.
  // 
  // x-constraint:
  // - /components/schemas/Device.Ethernet/properties/name
  // 
  repeated string ethernet_names = 1;
}

// IPv4 Neighbor state (ARP cache entry).
message Neighborsv4State {

  // The name of the Ethernet interface associated with the Neighbor state (ARP cache
  // entry).
  // required = true
  optional string ethernet_name = 1;

  // The IPv4 address of the neighbor.
  // required = true
  optional string ipv4_address = 2;

  // The link-layer address (MAC) of the neighbor.
  optional string link_layer_address = 3;
}

// The request to retrieve IPv6 Neighbor state (NDISC cache entries) of a network interface(s).
message Neighborsv6StatesRequest {

  // The names of Ethernet interfaces for which Neighbor state (NDISC cache entries) will
  // be retrieved. If no names are specified then the results will contain Neighbor state
  // (NDISC cache entries) for all available Ethernet interfaces.
  // 
  // x-constraint:
  // - /components/schemas/Device.Ethernet/properties/name
  // 
  repeated string ethernet_names = 1;
}

// IPv6 Neighbor state (NDISC cache entry).
message Neighborsv6State {

  // The name of the Ethernet interface associated with the Neighbor state (NDISC cache
  // entry).
  // required = true
  optional string ethernet_name = 1;

  // The IPv6 address of the neighbor.
  // required = true
  optional string ipv6_address = 2;

  // The link-layer address (MAC) of the neighbor.
  optional string link_layer_address = 3;
}

// The request to retrieve BGP peer prefix information.
message BgpPrefixStateRequest {

  // The names of BGP peers for which prefix information will be retrieved. If no names
  // are specified then the results will contain prefix information for all configured
  // BGP peers.
  // 
  // x-constraint:
  // - /components/schemas/Bgp.V4Peer/properties/name
  // - /components/schemas/Bgp.V6Peer/properties/name
  // 
  repeated string bgp_peer_names = 1;

  message PrefixFilters {
    enum Enum {
      unspecified = 0;
      ipv4_unicast = 1;
      ipv6_unicast = 2;
    }
  }
  // Specify which prefixes to return. If the list is empty or missing then all prefixes
  // will be returned.
  repeated PrefixFilters.Enum prefix_filters = 2;

  // The IPv4 unicast results can be filtered by specifying additional prefix search criteria.
  // If the ipv4_unicast_filters property is missing or empty then all IPv4 prefixes will
  // be returned.
  repeated BgpPrefixIpv4UnicastFilter ipv4_unicast_filters = 3;

  // The IPv6 unicast results can be filtered by specifying additional prefix search criteria.
  // If the ipv6_unicast_filters property is missing or empty then all IPv6 prefixes will
  // be returned.
  repeated BgpPrefixIpv6UnicastFilter ipv6_unicast_filters = 4;
}

// Description missing in models
message BgpPrefixIpv4UnicastFilter {

  // The addresses to match. If the addresses property is missing or empty then all addresses
  // will match.
  repeated string addresses = 1;

  // The prefix length to match. If the prefix length is missing then all prefix lengths
  // will match.
  optional uint32 prefix_length = 2;

  message Origin {
    enum Enum {
      unspecified = 0;
      igp = 1;
      egp = 2;
      incomplete = 3;
    }
  }
  // The origin to match. If the origin is missing then all origins will match.
  optional Origin.Enum origin = 3;

  // The path id to match. If the path id is missing then all path ids will match.
  optional uint32 path_id = 4;
}

// Description missing in models
message BgpPrefixIpv6UnicastFilter {

  // The addresses to match. If the addresses property is missing or empty then all addresses
  // will match.
  repeated string addresses = 1;

  // The prefix length to match. If the prefix length is missing then all prefix lengths
  // will match.
  optional uint32 prefix_length = 2;

  message Origin {
    enum Enum {
      unspecified = 0;
      igp = 1;
      egp = 2;
      incomplete = 3;
    }
  }
  // The origin to match. If the origin is missing then all origins will match.
  optional Origin.Enum origin = 3;

  // The path id to match. If the path id is missing then all path ids will match.
  optional uint32 path_id = 4;
}

// BGP peer prefixes.
message BgpPrefixesState {

  // The name of a BGP peer.
  optional string bgp_peer_name = 1;

  // Description missing in models
  repeated BgpPrefixIpv4UnicastState ipv4_unicast_prefixes = 2;

  // Description missing in models
  repeated BgpPrefixIpv6UnicastState ipv6_unicast_prefixes = 3;
}

// IPv4 unicast prefix.
message BgpPrefixIpv4UnicastState {

  // An IPv4 unicast address
  optional string ipv4_address = 1;

  // The length of the prefix.
  optional uint32 prefix_length = 2;

  message Origin {
    enum Enum {
      unspecified = 0;
      igp = 1;
      egp = 2;
      incomplete = 3;
    }
  }
  // The origin of the prefix.
  optional Origin.Enum origin = 3;

  // The path id.
  optional uint32 path_id = 4;

  // The IPv4 address of the egress interface.
  optional string ipv4_next_hop = 5;

  // The IPv6 address of the egress interface.
  optional string ipv6_next_hop = 6;

  // Optional community attributes.
  repeated ResultBgpCommunity communities = 7;

  // Optional received Extended Community attributes. Each received Extended Community
  // attribute is available for retrieval in two forms. Support of the 'raw' format in
  // which all 8 bytes (16 hex characters) is always present and available for use. In
  // addition, if supported by the implementation, the Extended Community attribute may
  // also be retrieved in the  'structured' format which is an optional field.
  repeated ResultExtendedCommunity extended_communities = 11;

  // Description missing in models
  ResultBgpAsPath as_path = 8;

  // The local preference is a well-known attribute and the value is used for route selection.
  // The route with the highest local preference value is preferred.
  optional uint32 local_preference = 9;

  // The multi exit discriminator (MED) is an optional non-transitive attribute and the
  // value is used for route selection. The route with the lowest MED value is preferred.
  optional uint32 multi_exit_discriminator = 10;
}

// IPv6 unicast prefix.
message BgpPrefixIpv6UnicastState {

  // An IPv6 unicast address
  optional string ipv6_address = 1;

  // The length of the prefix.
  optional uint32 prefix_length = 2;

  message Origin {
    enum Enum {
      unspecified = 0;
      igp = 1;
      egp = 2;
      incomplete = 3;
    }
  }
  // The origin of the prefix.
  optional Origin.Enum origin = 3;

  // The path id.
  optional uint32 path_id = 4;

  // The IPv4 address of the egress interface.
  optional string ipv4_next_hop = 5;

  // The IPv6 address of the egress interface.
  optional string ipv6_next_hop = 6;

  // Optional community attributes.
  repeated ResultBgpCommunity communities = 7;

  // Optional received Extended Community attributes. Each received Extended Community
  // attribute is available for retrieval in two forms. Support of the 'raw' format in
  // which all 8 bytes (16 hex characters) is always present and available for use. In
  // addition, if supported by the implementation, the Extended Community attribute may
  // also be retrieved in the  'structured' format which is an optional field.
  repeated ResultExtendedCommunity extended_communities = 11;

  // Description missing in models
  ResultBgpAsPath as_path = 8;

  // The local preference is a well-known attribute and the value is used for route selection.
  // The route with the highest local preference value is preferred.
  optional uint32 local_preference = 9;

  // The multi exit discriminator (MED) is an optional non-transitive attribute and the
  // value is used for route selection. The route with the lowest MED value is preferred.
  optional uint32 multi_exit_discriminator = 10;
}

// Each received Extended Community attribute is available for retrieval in two forms.
// Support of the 'raw' format in which all 8 bytes (16 hex characters) is always present
// and available for use. In addition, if supported by the implementation, the Extended
// Community attribute may also be retrieved in the 'structured' format which is an
// optional field.
message ResultExtendedCommunity {

  // The raw byte contents of the 8 bytes received in the Extended Community as 16 hex
  // characters.
  optional string raw = 1;

  // Description missing in models
  ResultExtendedCommunityStructured structured = 2;
}

// The Extended Communities Attribute is a optional BGP attribute,defined in RFC4360
// with the Type Code 16.
// Community and Extended Communities  attributes are utilized to trigger routing decisions,
// such as acceptance, rejection,  preference, or redistribution.
// An extended community is an 8-bytes value. It is divided into two main parts. The
// first 2 bytes of the community  encode a type and optonal sub-type field.
// The last 6 bytes (or 7 bytes for types without a sub-type) carry a unique set of
// data in a format defined by the type and optional sub-type field.
// Extended communities provide a larger  range for grouping or categorizing communities.
message ResultExtendedCommunityStructured {

  message Choice {
    enum Enum {
      unspecified = 0;
      transitive_2octet_as_type = 1;
      transitive_ipv4_address_type = 2;
      transitive_4octet_as_type = 3;
      transitive_opaque_type = 4;
      non_transitive_2octet_as_type = 5;
    }
  }
  // Description missing in models
  optional Choice.Enum choice = 1;

  // Description missing in models
  ResultExtendedCommunityTransitive2OctetAsType transitive_2octet_as_type = 2;

  // Description missing in models
  ResultExtendedCommunityTransitiveIpv4AddressType transitive_ipv4_address_type = 3;

  // Description missing in models
  ResultExtendedCommunityTransitive4OctetAsType transitive_4octet_as_type = 4;

  // Description missing in models
  ResultExtendedCommunityTransitiveOpaqueType transitive_opaque_type = 5;

  // Description missing in models
  ResultExtendedCommunityNonTransitive2OctetAsType non_transitive_2octet_as_type = 6;
}

// The Route Target Community identifies one or more routers that may receive a set
// of routes (that carry this Community) carried by BGP Update message.  It is sent
// with sub-type as 0x02.
message ResultExtendedCommunityTransitive2OctetAsTypeRouteTarget {

  // The two octet IANA assigned AS value assigned to the Autonomous System.
  optional uint32 global_2byte_as = 1;

  // The Local Administrator sub-field contains a number from a numbering space that is
  // administered by the organization to which the Autonomous System number carried in
  // the Global Administrator sub-field has been assigned by an appropriate authority.
  optional uint32 local_4byte_admin = 2;
}

// The Route Origin Community identifies one or more routers that inject a set of routes
// (that carry this Community) into BGP. It is sent with sub-type as 0x03 .
message ResultExtendedCommunityTransitive2OctetAsTypeRouteOrigin {

  // The two octet IANA assigned AS value assigned to the Autonomous System.
  optional uint32 global_2byte_as = 1;

  // The Local Administrator sub-field contains a number from a numbering space that is
  // administered by the organization to which the Autonomous System number carried in
  // the Global Administrator sub-field has been assigned by an appropriate authority.
  optional uint32 local_4byte_admin = 2;
}

// The Link Bandwidth Extended Community attribute is defined in draft-ietf-idr-link-bandwidth.
// (https://datatracker.ietf.org/doc/draft-ietf-idr-link-bandwidth) It is sent with
// sub-type as 0x04.
message ResultExtendedCommunityTransitive2OctetAsTypeLinkBandwidth {

  // The value of the Global Administrator subfield should represent the Autonomous System
  // of the router that attaches the Link Bandwidth Community. If four octet AS numbering
  // scheme is used, AS_TRANS (23456) should be used.
  optional uint32 global_2byte_as = 1;

  // Bandwidth of the link in bytes per second. ( 1 Kbps is 1000 bytes per second and
  // 1 Mbps is 1000 Kbps per second )
  optional float bandwidth = 2;
}

// The Transitive Two-Octet AS-Specific Extended Community is sent as type 0x00 .
// 
message ResultExtendedCommunityTransitive2OctetAsType {

  message Choice {
    enum Enum {
      unspecified = 0;
      route_target_subtype = 1;
      route_origin_subtype = 2;
      link_bandwidth_subtype = 3;
    }
  }
  // Description missing in models
  optional Choice.Enum choice = 1;

  // Description missing in models
  ResultExtendedCommunityTransitive2OctetAsTypeRouteTarget route_target_subtype = 2;

  // Description missing in models
  ResultExtendedCommunityTransitive2OctetAsTypeRouteOrigin route_origin_subtype = 3;

  // Description missing in models
  ResultExtendedCommunityTransitive2OctetAsTypeLinkBandwidth link_bandwidth_subtype = 4;
}

// The Route Origin Community identifies one or more routers that inject a set of routes
// (that carry this Community) into BGP It is sent with sub-type as 0x03.
message ResultExtendedCommunityTransitiveIpv4AddressTypeRouteOrigin {

  // An IPv4 unicast address assigned by one of the Internet registries.
  optional string global_ipv4_admin = 1;

  // The Local Administrator sub-field contains a number from a numbering space that is
  // administered by the organization to which  the IP address carried in the Global Administrator
  // sub-field has been assigned by an appropriate authority.
  optional uint32 local_2byte_admin = 2;
}

// The Route Target Community identifies one or more routers that may receive a set
// of routes (that carry this Community) carried by BGP.  It is sent with sub-type as
// 0x02.
message ResultExtendedCommunityTransitiveIpv4AddressTypeRouteTarget {

  // An IPv4 unicast address assigned by one of the Internet registries.
  optional string global_ipv4_admin = 1;

  // The Local Administrator sub-field contains a number from a numbering space that is
  // administered by the organization to which  the IP address carried in the Global Administrator
  // sub-field has been assigned by an appropriate authority.
  optional uint32 local_2byte_admin = 2;
}

// The Transitive IPv4 Address Specific Extended Community is sent as type 0x01.
message ResultExtendedCommunityTransitiveIpv4AddressType {

  message Choice {
    enum Enum {
      unspecified = 0;
      route_target_subtype = 1;
      route_origin_subtype = 2;
    }
  }
  // Description missing in models
  optional Choice.Enum choice = 1;

  // Description missing in models
  ResultExtendedCommunityTransitiveIpv4AddressTypeRouteTarget route_target_subtype = 2;

  // Description missing in models
  ResultExtendedCommunityTransitiveIpv4AddressTypeRouteOrigin route_origin_subtype = 3;
}

// The Route Target Community identifies one or more routers that may receive a set
// of routes (that carry this Community) carried by BGP.  It is sent with sub-type as
// 0x02
message ResultExtendedCommunityTransitive4OctetAsTypeRouteTarget {

  // The four octet IANA assigned AS value assigned to the Autonomous System.
  optional uint32 global_4byte_as = 1;

  // The Local Administrator sub-field contains a number from a numbering space that is
  // administered by the organization to which the Autonomous System number carried in
  // the Global Administrator sub-field has been assigned by an appropriate authority.
  optional uint32 local_2byte_admin = 2;
}

// The Route Origin Community identifies one or more routers that inject a set of routes
// (that carry this Community) into BGP. It is sent with sub-type as 0x03.
message ResultExtendedCommunityTransitive4OctetAsTypeRouteOrigin {

  // The four octet IANA assigned AS value assigned to the Autonomous System.
  optional uint32 global_4byte_as = 1;

  // The Local Administrator sub-field contains a number from a numbering space that is
  // administered by the organization to which the Autonomous System number carried in
  // the Global Administrator sub-field has been assigned by an appropriate authority.
  optional uint32 local_2byte_admin = 2;
}

// The Transitive Four-Octet AS-Specific Extended Community is sent as type 0x02. It
// is defined in RFC 5668.
message ResultExtendedCommunityTransitive4OctetAsType {

  message Choice {
    enum Enum {
      unspecified = 0;
      route_target_subtype = 1;
      route_origin_subtype = 2;
    }
  }
  // Description missing in models
  optional Choice.Enum choice = 1;

  // Description missing in models
  ResultExtendedCommunityTransitive4OctetAsTypeRouteTarget route_target_subtype = 2;

  // Description missing in models
  ResultExtendedCommunityTransitive4OctetAsTypeRouteOrigin route_origin_subtype = 3;
}

// The Color Community contains locally administrator defined 'color' value which is
// used in conjunction with Encapsulation  attribute to decide whether a data packet
// can be transmitted on a certain tunnel or not. It is defined in RFC9012 and sent
// with sub-type as 0x0b.
message ResultExtendedCommunityTransitiveOpaqueTypeColor {

  // Two octet flag values.
  optional uint32 flags = 1;

  // The color value is user defined and configured locally and used to determine whether
  // a data packet can be transmitted on a certain tunnel or not
  // in conjunction with the Encapsulation attribute. It is defined in RFC9012.
  // 
  optional uint32 color = 2;
}

// This identifies the type of tunneling technology being signalled. It is defined in
// RFC9012 and sent with sub-type as 0x0c.
message ResultExtendedCommunityTransitiveOpaqueTypeEncapsulation {

  // Four bytes of reserved values. Normally set to 0 on transmit and ignored on receive.
  // 
  optional uint32 reserved = 1;

  // Identifies the type of tunneling technology being signalled. Initially defined in
  // RFC5512 and extended in RFC9012.
  // Some of the important tunnel types include
  // - 1 L2TPv3 over IP	[RFC9012],
  // - 2	GRE	[RFC9012],
  // - 7	IP in IP	[RFC9012],
  // - 8	VXLAN Encapsulation	[RFC8365],
  // - 9	NVGRE Encapsulation	[RFC8365],
  // - 10	MPLS Encapsulation	[RFC8365],
  // - 15	SR TE Policy Type	[draft-ietf-idr-segment-routing-te-policy],
  // - 19	Geneve Encapsulation	[RFC8926]
  optional uint32 tunnel_type = 2;
}

// The Transitive Opaque Extended Community is sent as type 0x03.
message ResultExtendedCommunityTransitiveOpaqueType {

  message Choice {
    enum Enum {
      unspecified = 0;
      color_subtype = 1;
      encapsulation_subtype = 2;
    }
  }
  // Description missing in models
  optional Choice.Enum choice = 1;

  // Description missing in models
  ResultExtendedCommunityTransitiveOpaqueTypeColor color_subtype = 2;

  // Description missing in models
  ResultExtendedCommunityTransitiveOpaqueTypeEncapsulation encapsulation_subtype = 3;
}

// The Link Bandwidth Extended Community attribute is defined in draft-ietf-idr-link-bandwidth.
// It is sent with sub-type as 0x04.
message ResultExtendedCommunityNonTransitive2OctetAsTypeLinkBandwidth {

  // The value of the Global Administrator subfield should represent the Autonomous System
  // of the router that attaches the Link Bandwidth Community. If four octet AS numbering
  // scheme is used, AS_TRANS (23456) should be used.
  optional uint32 global_2byte_as = 1;

  // Bandwidth of the link in bytes per second. ( 1 Kbps is 1000 bytes per second and
  // 1 Mbps is 1000 Kbps per second )
  optional float bandwidth = 2;
}

// The Non-Transitive Two-Octet AS-Specific Extended Community is sent as type 0x40.
// 
message ResultExtendedCommunityNonTransitive2OctetAsType {

  message Choice {
    enum Enum {
      unspecified = 0;
      link_bandwidth_subtype = 1;
    }
  }
  // Description missing in models
  optional Choice.Enum choice = 1;

  // Description missing in models
  ResultExtendedCommunityNonTransitive2OctetAsTypeLinkBandwidth link_bandwidth_subtype = 2;
}

// BGP communities provide additional capability for tagging routes and  for modifying
// BGP routing policy on upstream and downstream routers. BGP community is a 32-bit
// number which is broken into 16-bit AS number and  a 16-bit custom value.
message ResultBgpCommunity {

  message Type {
    enum Enum {
      unspecified = 0;
      manual_as_number = 1;
      no_export = 2;
      no_advertised = 3;
      no_export_subconfed = 4;
      llgr_stale = 5;
      no_llgr = 6;
    }
  }
  // The type of community AS number. If community type is manual_as_number then as_number
  // and as_custom will be available.
  optional Type.Enum type = 1;

  // First two octets of 32 bit community AS number.
  optional uint32 as_number = 2;

  // Last two octets of the community value.
  optional uint32 as_custom = 3;
}

// This attribute identifies the autonomous systems through  which routing information
// carried in this UPDATE message has passed.
message ResultBgpAsPath {

  // AS Path segments present in the received AS Path attribute.
  repeated ResultBgpAsPathSegment segments = 1;
}

// Configuration for a single BGP AS path segment
message ResultBgpAsPathSegment {

  message Type {
    enum Enum {
      unspecified = 0;
      as_seq = 1;
      as_set = 2;
      as_confed_seq = 3;
      as_confed_set = 4;
    }
  }
  // AS sequence is the most common type of AS_PATH, it contains the  list of ASNs starting
  // with the most recent ASN being added read  from left to right.
  // The other three AS_PATH types are used for Confederations - AS_SET is the type of
  // AS_PATH attribute that summarizes routes using using the aggregate-address command,
  // allowing AS_PATHs to be  summarized in the update as well. - AS_CONFED_SEQ gives
  // the list of ASNs in the path starting with the  most recent ASN to be added reading
  // left to right - AS_CONFED_SET will allow summarization of multiple AS PATHs to be
  // sent in BGP Updates.
  optional Type.Enum type = 1;

  // The AS numbers in this AS path segment.
  repeated uint32 as_numbers = 2;
}

// The request to retrieve ISIS Link State PDU (LSP) information learned by the router.
message IsisLspsStateRequest {

  // The names of ISIS routers for which learned information is requested. An empty list
  // will return results for all ISIS routers.
  // 
  // x-constraint:
  // - /components/schemas/Device.IsisRouter/properties/name
  // 
  repeated string isis_router_names = 1;
}

// The result of ISIS LSP information that are retrieved.
message IsisLspsState {

  // The name of the ISIS Router.
  optional string isis_router_name = 1;

  // One or more LSPs that are learned by this ISIS router.
  repeated IsisLspState lsps = 2;
}

// ISIS LSP.
message IsisLspState {

  // LSP ID in the format, e.g. '640000000001-00-00'. LSP ID consists of the System ID
  // of a neighbor, the Pseudonode ID, and the LSP number. The last two bytes represent
  // Pseudonode ID and LSP number respectively. A pseudonode is a logical representation
  // of the LAN which is generated by a Designated Intermediate System (DIS) on a LAN
  // segment. If one LSP exceeds the maximum LSP size then it is sent in another LSP with
  // the LSP number incremented by one. A router's learned LSP gets refreshed by 'remaining_lifetime'.
  // Then the sequence number is incremented by 1.
  // required = true
  optional string lsp_id = 1;

  message PduType {
    enum Enum {
      unspecified = 0;
      level_1 = 1;
      level_2 = 2;
    }
  }
  // Link State PDU type.
  optional PduType.Enum pdu_type = 2;

  // Remaining lifetime in seconds before LSP expires.
  optional uint32 remaining_lifetime = 3;

  // Sequence number of the LSP.
  optional uint64 sequence_number = 4;

  // Total length of the LSP.
  optional uint32 pdu_length = 5;

  // LSP Type-Block flags.
  IsisLspFlags flags = 6;

  // IS Type - bits 1 and 2 indicate the type of Intermediate System.
  // 1 - ( i.e. bit 1 set) Level 1 Intermediate system.
  // 2 - Unused value.
  // 3 - (i.e. bits 1 and 2 set) Level 2 Intermediate system.
  optional uint32 is_type = 7;

  // It refers to Link State PDU State TLVs container.
  IsisLspTlvs tlvs = 8;
}

// This contains the list of TLVs present in one LSP.
message IsisLspTlvs {

  // Array of Hostname TLVs ( type 137) present in this LSP.
  repeated IsisLspHostname hostname_tlvs = 1;

  // Array of IS-Reachability TLVs (type 2) present in this LSP.
  repeated IsisLspIsReachabilityTlv is_reachability_tlvs = 2;

  // Array of Extended IS-Reachability TLVs (type 22) present in this LSP.
  repeated IsisLspExtendedIsReachabilityTlv extended_is_reachability_tlvs = 3;

  // Array of IPv4 Internal Reachability TLVs (type 128) present in this LSP.
  repeated IsisLspIpv4InternalReachabilityTlv ipv4_internal_reachability_tlvs = 4;

  // Array of IPv4 External Reachability TLVs (type 130) present in this LSP.
  repeated IsisLspIpv4ExternalReachabilityTlv ipv4_external_reachability_tlvs = 5;

  // Array of IPv4 Extended Reachability TLVs (type 135) present in this LSP.
  repeated IsisLspExtendedIpv4ReachabilityTlv extended_ipv4_reachability_tlvs = 6;

  // Array of IPv6 Reachability TLVs (type 236) present in this LSP.
  repeated IsisLspIpv6ReachabilityTlv ipv6_reachability_tlvs = 7;

  // IS-IS Router Capabilities: TLV 242.
  // This container defines Router Capabilities.
  repeated IsisLspCapability router_capabilities = 8;
}

// It contains Hostname for the TLV 137.
message IsisLspHostname {

  // Hostname for an ISIS router.
  optional string hostname = 1;
}

// LSP Type flags.
message IsisLspFlags {

  // When set, the originator supports partition repair.
  optional bool partition_repair = 1;

  // When set, the originator is attached to another area using the referred metric.
  optional bool attached_error = 2;

  // When set, the originator is attached to another
  // area using the referred metric.
  optional bool attached_expense = 3;

  // Delay Metric - when set, the originator is attached to another
  // area using the referred metric.
  optional bool attached_delay = 4;

  // Default Metric - when set, the originator is attached to another
  // area using the referred metric.
  optional bool attached_default = 5;

  // Overload bit - when set, the originator is overloaded, and must
  // be avoided in path calculation.
  optional bool overload = 6;
}

// This container describes list of ISIS neighbors and attributes in IS-Reachability
// TLV (type 2).
message IsisLspIsReachabilityTlv {

  // This container describes Intermediate System (IS) neighbors.
  repeated IsisLspneighbor neighbors = 1;
}

// This is list of ISIS neighbors and attributes in Extended-IS-Reachability TLV (type
// 22).
message IsisLspExtendedIsReachabilityTlv {

  // This container describes IS neighbors.
  repeated IsisLspExtendedNeighbor neighbors = 1;
}

// This contains IS neighbors.
message IsisLspneighbor {

  // The System ID for this emulated ISIS router, e.g. 640100010000.
  optional string system_id = 1;
}

// This contains IS neighbors.
message IsisLspExtendedNeighbor {

  // The System ID for this emulated ISIS router, e.g. 640100010000.
  optional string system_id = 1;

  // List of segment routing adjacency SIDs.
  repeated IsisLspAdjacencySid adjacency_sids = 2;
}

// This container defines list of IPv4 internal reachability information in one IPv4
// internal reachability TLV.
// This is advertised when the origin-type is set 'internal' in route range configurations.
message IsisLspIpv4InternalReachabilityTlv {

  // Describes list of IPv4 prefixes in this TLV.
  repeated IsisLspV4Prefix prefixes = 1;
}

// This container defines list of IPv4 external reachability information in one IPv4
// external reachability TLV.
// This is advertised when the origin-type is set 'external' in route range configurations.
message IsisLspIpv4ExternalReachabilityTlv {

  // Describes list of IPv4 prefixes in this TLV..
  repeated IsisLspV4Prefix prefixes = 1;
}

// This group defines attributes of an IPv4 standard prefix.
message IsisLspV4Prefix {

  // An IPv4 unicast prefix reachable via the originator of this LSP.
  optional string ipv4_address = 1;

  // The length of the IPv4 prefix.
  optional uint32 prefix_length = 2;

  message RedistributionType {
    enum Enum {
      unspecified = 0;
      up = 1;
      down = 2;
    }
  }
  // Up (0)-used when a prefix is initially advertised within the ISIS L3 hierarchy,
  // and for all other prefixes in L1 and L2 LSPs. (default)
  // Down (1)-used when an L1/L2 router advertises L2 prefixes in L1 LSPs.
  // The prefixes are being advertised from a higher level (L2) down to a lower level
  // (L1).
  optional RedistributionType.Enum redistribution_type = 3;

  // ISIS default metric value.
  optional uint32 default_metric = 4;

  message OriginType {
    enum Enum {
      unspecified = 0;
      internal = 1;
      external = 2;
    }
  }
  // The origin of the advertised route-internal or external to the ISIS area. Options
  // include the following:
  // Internal-for intra-area routes, through Level 1 LSPs.
  // External-for inter-area routes redistributed within L1, through Level
  // 1 LSPs.
  optional OriginType.Enum origin_type = 5;
}

// This container defines list of IPv4 extended reachability information in one Extended
// IPv4 External Reachability TLV.
// It is advertised when the 'wide metric' is enabled.
message IsisLspExtendedIpv4ReachabilityTlv {

  // IPv4 prefix contained within extended reachability TLVs.
  repeated IsisLspExtendedV4Prefix prefixes = 1;
}

// This group defines attributes of an IPv4 standard prefix.
message IsisLspExtendedV4Prefix {

  // An IPv4 unicast prefix reachable via the originator of this LSP.
  optional string ipv4_address = 1;

  // The length of the IPv4 prefix.
  optional uint32 prefix_length = 2;

  // ISIS wide metric.
  optional uint32 metric = 3;

  message RedistributionType {
    enum Enum {
      unspecified = 0;
      up = 1;
      down = 2;
    }
  }
  // Up (0)-used when a prefix is initially advertised within the ISIS L3 hierarchy,
  // and for all other prefixes in L1 and L2 LSPs. (default)
  // Down (1)-used when an L1/L2 router advertises L2 prefixes in L1 LSPs.
  // The prefixes are being advertised from a higher level (L2) down to a lower level
  // (L1).
  optional RedistributionType.Enum redistribution_type = 4;

  // Extended Prefix Attribute flags container sub-TLV is type 4.
  IsisLspPrefixAttributes prefix_attributes = 5;

  // Prefix Segment-ID list. IGP-Prefix Segment is an IGP segment attached to an IGP prefix.
  // An IGP-Prefix Segment is global
  // (unless explicitly advertised otherwise) within the SR/IGP domain.
  repeated IsisLspPrefixSid prefix_sids = 6;
}

// It defines list of IPv6 extended reachability information in one IPv6 Reachability
// TLV.
message IsisLspIpv6ReachabilityTlv {

  // IPv6 prefix contained within reachability TLVs.
  repeated IsisLspV6Prefix prefixes = 1;
}

// It defines attributes of an IPv6 standard prefix.
message IsisLspV6Prefix {

  // An IPv6 unicast prefix reachable via the originator of this LSP.
  optional string ipv6_address = 1;

  // The length of the IPv6 prefix.
  optional uint32 prefix_length = 2;

  // ISIS wide metric.
  optional uint32 metric = 3;

  message RedistributionType {
    enum Enum {
      unspecified = 0;
      up = 1;
      down = 2;
    }
  }
  // Up (0)-used when a prefix is initially advertised within the ISIS L3 hierarchy,
  // and for all other prefixes in L1 and L2 LSPs. (default)
  // Down (1)-used when an L1/L2 router advertises L2 prefixes in L1 LSPs.
  // The prefixes are being advertised from a higher level (L2) down to a lower level
  // (L1).
  optional RedistributionType.Enum redistribution_type = 4;

  message OriginType {
    enum Enum {
      unspecified = 0;
      internal = 1;
      external = 2;
    }
  }
  // The origin of the advertised route-internal or external to the ISIS area. Options
  // include the following:
  // Internal-for intra-area routes, through Level 1 LSPs.
  // External-for inter-area routes redistributed within L1, through Level
  // 1 LSPs.
  optional OriginType.Enum origin_type = 5;

  // Extended Prefix Attribute flags container sub-TLV is type 4.
  IsisLspPrefixAttributes prefix_attributes = 6;

  // Prefix Segment-ID list. IGP-Prefix Segment is an IGP segment attached to an IGP prefix.
  // An IGP-Prefix Segment is global
  // (unless explicitly advertised otherwise) within the SR/IGP domain.
  repeated IsisLspPrefixSid prefix_sids = 7;
}

// One bit value of ISIS Prefix attributes for the extended IPv4 and IPv6 reachability.
// https://www.rfc-editor.org/rfc/rfc7794.html.
message IsisLspPrefixAttributes {

  // External prefix flag (Bit 0). Set if the prefix has been
  // redistributed from another protocol. This includes
  // the case where multiple virtual routers are
  // supported and the source of the redistributed prefix
  // is another IS-IS instance.
  optional bool x_flag = 1;

  // Readvertisement flag (Bit 1). Set when the prefix has been
  // leaked from one level to another (upwards or
  // downwards).
  optional bool r_flag = 2;

  // Node Flag (Bit 2).
  // Set when the prefix identifies the
  // advertising router, i.e., the prefix is a host
  // prefix advertising  a globally reachable address
  // typically associated with a loopback address.
  optional bool n_flag = 3;
}

// This contains the properties of IS-IS Prefix-SID and its attributes for  the extended
// Ipv4 and Ipv6 reachability. Refernce: https://datatracker.ietf.org/doc/html/rfc8667#name-prefix-segment-identifier-p.
message IsisLspPrefixSid {

  // One or more SIDs/Indices are the SID/Label values associated  with the IGP Prefix
  // segment attached to the specific IPv4 or IPv6 prefix.
  repeated uint32 sids = 1;

  // Flags associated with Prefix Segment-ID.
  IsisLspPrefixSidFlags flags = 2;

  // The Isis may use various algorithms when calculating
  // reachability to other nodes or to prefixes attached to these
  // nodes.
  optional uint32 algorithm = 3;
}

// Container of IS-IS Router CAPABILITY TLV.
message IsisLspCapability {

  // Router CapabilityID in IPv4 address format.
  optional string router_cap_id = 1;

  message SBit {
    enum Enum {
      unspecified = 0;
      flood = 1;
      not_flood = 2;
    }
  }
  // S bit (0x01): If the S bit is set(1), the IS-IS Router CAPABILITY TLV
  // MUST be flooded across the entire routing domain.  If the S bit is
  // not set(0), the TLV MUST NOT be leaked between levels.  This bit MUST
  // NOT be altered during the TLV leaking.
  optional SBit.Enum s_bit = 2;

  message DBit {
    enum Enum {
      unspecified = 0;
      down = 1;
      not_down = 2;
    }
  }
  // D bit (0x02): When the IS-IS Router CAPABILITY TLV is leaked from
  // Level 2 (L2) to Level 1 (L1), the D bit MUST be set.  Otherwise, this
  // bit MUST be clear.  IS-IS Router CAPABILITY TLVs with the D bit set
  // MUST NOT be leaked from Level 1 to Level 2.  This is to prevent TLV looping.
  optional DBit.Enum d_bit = 3;

  // SR-Capabilities.
  IsisLspSRCapability sr_capability = 4;

  // This contains one or more SR-Algorithm.
  repeated uint32 algorithms = 5;

  // This contains the list of SR Local Block (SRLB)
  repeated IsisLspSrlb srlb_ranges = 6;
}

// Container of IS-IS SR-CAPABILITY Sub-Tlv.
message IsisLspSRCapability {

  // 1 octet of flags.
  IsisLspCapasFlags flags = 1;

  // This contains the list of SRGB.
  repeated IsisLspSrgb srgb_ranges = 2;
}

// Container for the configuration of IS-IS SR-CAPABILITY flags.
message IsisLspCapasFlags {

  // I-Flag for the MPLS IPv4 Flag. If set, then the router is capable of processing SR-MPLS-encapsulated
  // IPv4 packets on all interfaces.
  optional bool ipv4_mpls = 1;

  // V-Flag for the MPLS IPv6 Flag. If set, then the router is capable of processing SR-MPLS-encapsulated
  // IPv6 packets on all interfaces.
  optional bool ipv6_mpls = 2;
}

// This contains the propeties of SRGB range. Reference: https://datatracker.ietf.org/doc/html/rfc8667#section-3.1-7.1.1
message IsisLspSrgb {

  // The SID/Label sub-TLV contains the first value of the SRGB while the range contains
  // the number of SRGB elements.
  optional uint32 starting_sid = 1;

  // This represents the number of SID in a SRGB range.
  optional uint32 range = 2;
}

// This contains the propeties of SRLB. The SR Local Block (SRLB) sub-TLV contains the
// range of labels the node has reserved  for Local SIDs. Local SIDs are used, e.g.,
// for Adj-SIDs, and may also be allocated by components other than the IS-IS protocol
// Reference: https://datatracker.ietf.org/doc/html/rfc8667#name-sr-local-block-sub-tlv.
message IsisLspSrlb {

  // The SID/Label sub-TLV contains the first value of the SRGB while the range contains
  // the number of SRGB elements.
  optional uint32 starting_sid = 1;

  // This represents the number of SID in a SRGB range.
  optional uint32 range = 2;
}

// This container defines segment routing adjacency SIDs.
message IsisLspAdjacencySid {

  message Type {
    enum Enum {
      unspecified = 0;
      adj_sid = 1;
      lan_adj_sid = 2;
    }
  }
  // Adjacency-SID type: Adjacency SIDs(31) or LAN adjacency SID (32).
  optional Type.Enum type = 1;

  // One or more SID/Indices are the SID/Label values associated with the IGP adjacency
  // SID.
  repeated uint32 sids = 2;

  // Flags associated with Adjacency Segment-ID.
  IsisLspAdjSidFlags flags = 3;

  // The value represents the weight of the Adj-SID for the purpose of load balancing.
  // 
  optional uint32 weight = 4;
}

// Conatiner of 1-octet Flags associated with Prefix Segment-ID.
message IsisLspPrefixSidFlags {

  // Readvertisment flag. When set, the prefix to which this Prefix-SID is attached, has
  // been propagated by
  // the router either from another level or from redistribution.
  optional bool r_flag = 1;

  // Node flag. When set, the Prefix-SID refers to the router identified by the prefix.
  // Typically, the
  // N-Flag is set on Prefix-SIDs attached to a router loopback address.
  optional bool n_flag = 2;

  // Penultimate-Hop-Popping flag. When set, then the penultimate hop MUST NOT pop the
  // Prefix-SID before
  // delivering the packet to the node that advertised the Prefix-SID.
  optional bool p_flag = 3;

  // Explicit-Null flag. When set, any upstream neighbor of the Prefix-SID originator
  // MUST replace the
  // Prefix-SID with a Prefix-SID having an Explicit-NULL value (0 for IPv4 and 2 for
  // IPv6) before forwarding
  // the packet.
  optional bool e_flag = 4;

  // Value flag. When set, the Prefix-SID carries avalue (instead of an index).
  optional bool v_flag = 5;

  // Local flag. When set, the value/index carried by the Prefix-SID has local significance.
  optional bool l_flag = 6;
}

// Conatiner of 1-octet Flags associated with Adjacency Segment-ID.
message IsisLspAdjSidFlags {

  // The address family flag. If unset, then the Adj-SID refers
  // to an adjacency with outgoing IPv4 encapsulation.  If set then
  // the Adj-SID refers to an adjacency with outgoing IPv6
  // encapsulation.
  optional bool f_flag = 1;

  // The backup flag. If set, the Adj-SID is eligible for protection.
  optional bool b_flag = 2;

  // The value flag. If set, then the Adj-SID carries a value.
  optional bool v_flag = 3;

  // The local flag.  If set, then the value/index carried by
  // the Adj-SID has local significance.
  optional bool l_flag = 4;

  // The set flag. When set, the S-Flag indicates that the
  // Adj-SID refers to a set of adjacencies (and therefore MAY be
  // assigned to other adjacencies as well).
  optional bool s_flag = 5;

  // The persistent flag. When set, the P-Flag indicates that
  // the Adj-SID is persistently allocated, i.e., the Adj-SID value
  // remains consistent across router restart and/or interface flap.
  optional bool p_flag = 6;
}

// The request to retrieve LLDP neighbor information for a given instance.
message LldpNeighborsStateRequest {

  // The names of LLDP instances for which neighbor information will be retrieved. If
  // no names are specified then the results will contain neighbor information for all
  // configured LLDP instances.
  // 
  // x-constraint:
  // - /components/schemas/Lldp/properties/name
  // 
  repeated string lldp_names = 1;

  // Specify the neighbors for which information will be returned. If empty  or missing
  // then information for all neighbors will be returned.
  repeated string neighbor_id_filters = 2;
}

// LLDP neighbor information.
message LldpNeighborsState {

  // The name of the LLDP instance.
  optional string lldp_name = 1;

  // The system name field shall contain an alpha-numeric string that  indicates the system's
  // administratively assigned name. The system name  should be the system's fully qualified
  // domain name. If implementations  support IETF RFC 3418, the sysName object should
  // be used for this field.
  optional string system_name = 2;

  // The system description field shall contain an alpha-numeric string that  is the textual
  // description of the network entity. The system description  should include the full
  // name and version identification of the system's  hardware type, software operating
  // system, and networking software. If  implementations support IETF RFC 3418, the sysDescr
  // object should be used  for this field.
  optional string system_description = 3;

  // The Chassis ID is a mandatory TLV which identifies the chassis component of  the
  // endpoint identifier associated with the transmitting LLDP agent.
  optional string chassis_id = 4;

  message ChassisIdType {
    enum Enum {
      unspecified = 0;
      port_component = 1;
      network_address = 2;
      chassis_component = 3;
      mac_address = 4;
      interface_name = 5;
      local = 6;
      interface_alias = 7;
    }
  }
  // This field identifies the format and source of the chassis identifier string.  It
  // is an enumerator defined by the LldpChassisIdSubtype object from IEEE 802.1AB  MIB.
  optional ChassisIdType.Enum chassis_id_type = 5;

  // System generated identifier for the neighbor on the LLDP instance.
  optional string neighbor_id = 6;

  // Age since discovery in seconds.
  optional uint32 age = 7;

  // Seconds since last update received.
  optional uint32 last_update = 8;

  // The time-to-live (TTL) in seconds is a mandatory TLV which indicates how long information
  // from the neighbor  should be considered valid.
  optional uint32 ttl = 9;

  // The Port ID is a mandatory TLV which identifies the port component of the endpoint
  // identifier associated with  the transmitting LLDP agent. If the specified port is
  // an IEEE 802.3 Repeater port, then this TLV is optional.
  optional string port_id = 10;

  message PortIdType {
    enum Enum {
      unspecified = 0;
      port_component = 1;
      network_address = 2;
      agent_circuit_id = 3;
      mac_address = 4;
      interface_name = 5;
      local = 6;
      interface_alias = 7;
    }
  }
  // This field identifies the format and source of the port identifier string. It is
  // an enumerator defined by the PtopoPortIdType object from RFC2922.
  optional PortIdType.Enum port_id_type = 11;

  // The binary string containing the actual port identifier for the port which this LLDP
  // PDU was transmitted. The source  and format of this field is defined by PtopoPortId
  // from RFC2922.
  optional string port_description = 12;

  // The Management Address is a mandatory TLV which identifies a network address associated
  // with the local LLDP agent, which  can be used to reach the agent on the port identified
  // in the Port ID TLV.
  optional string management_address = 13;

  // The enumerated value for the network address type identified in this TLV. This enumeration
  // is defined in the 'Assigned Numbers'  RFC [RFC3232] and the ianaAddressFamilyNumbers
  // object.
  optional string management_address_type = 14;

  // Description missing in models
  repeated LldpCustomTLVState custom_tlvs = 15;

  // Description missing in models
  repeated LldpCapabilityState capabilities = 16;
}

// Custom TLV received from a neighbor.Custom TLVs are organization specific TLVs advertised
// with TLV type 127.
message LldpCustomTLVState {

  // The integer value identifying the type of information contained in the value field.
  optional uint32 custom_type = 1;

  // The organizationally unique identifier field shall contain the organization's OUI
  // as defined in Clause 9 of IEEE Std 802. The high-order octet is 0 and the low-order
  // 3 octets are the SMI Network Management Private Enterprise Code of the Vendor in
  // network byte order,  as defined in the 'Assigned Numbers' RFC [RFC3232].
  optional string oui = 2;

  // The organizationally defined subtype field shall contain a unique subtype value assigned
  // by the defining organization.
  optional uint32 oui_subtype = 3;

  // Contains information on the remaining bytes of the received Organization-Specific
  // TLV after the sub-type field. The value must be returned in lowercase hexadecimal
  // format.
  optional string information = 4;
}

// LLDP system capability advertised by the neighbor
message LldpCapabilityState {

  message CapabilityName {
    enum Enum {
      unspecified = 0;
      mac_bridge = 1;
      two_port_mac_relay = 2;
      repeater = 3;
      docsis_cable_device = 4;
      s_vlan = 5;
      telephone = 6;
      other = 7;
      router = 8;
      c_vlan = 9;
      station_only = 10;
      wlan_access_point = 11;
    }
  }
  // Name of the system capability advertised by the neighbor. Capabilities are represented
  // in a bitmap that defines the primary functions of the system.  The capabilities are
  // defined in IEEE 802.1AB.
  optional CapabilityName.Enum capability_name = 1;

  // Indicates whether the corresponding system capability is enabled on the neighbor.
  optional bool capability_enabled = 2;
}

// The request to retrieve RSVP Label Switched Path (LSP) information learned by the
// router.
message RsvpLspsStateRequest {

  // The names of RSVP-TE routers for which learned information is requested. An empty
  // list will return results for all RSVP=TE routers.
  // 
  // x-constraint:
  // - /components/schemas/Device.Rsvp/properties/name
  // 
  repeated string rsvp_router_names = 1;
}

// Discovered IPv4 Point-to-Point LSPs of a RSVP-TE router.
message RsvpLspsState {

  // The name of the RSVP-TE Router.
  optional string rsvp_router_name = 1;

  // IPv4 Point-to-Point RSVP-TE Discovered LSPs.
  repeated RsvpIPv4LspState ipv4_lsps = 2;
}

// IPv4 RSVP-TE Discovered LSPs.
message RsvpIPv4LspState {

  // The origin IPv4 address of RSVP session.
  optional string source_address = 1;

  // The IPv4 destination address of RSVP session.
  optional string destination_address = 2;

  // It refers to the RSVP LSP properties.
  RsvpLspState lsp = 3;

  // It refers to RSVP RRO objects container.
  repeated RsvpLspIpv4Rro rros = 4;

  // It refers to RSVP ERO objects container.
  repeated RsvpLspIpv4Ero eros = 5;
}

// IPv4 RSVP-TE Discovered LSPs.
message RsvpLspState {

  // The tunnel id of RSVP session which acts as an identifier that remains constant over
  // the life of the tunnel.
  optional uint32 tunnel_id = 1;

  // The lsp-id of RSVP session which acts as a differentiator for two lsps originating
  // from the same headend, commonly used to distinguish RSVP sessions during make before
  // break operations.
  optional uint32 lsp_id = 2;

  // The value of RSVP-TE Session Name field of the Session Attribute object.
  optional string session_name = 3;

  // The label received by RSVP-TE ingress.
  optional uint32 label_in = 4;

  // The label assigned by RSVP-TE egress.
  optional uint32 label_out = 5;

  message SessionStatus {
    enum Enum {
      unspecified = 0;
      up = 1;
      down = 2;
    }
  }
  // Operational state of the RSVP LSP.
  optional SessionStatus.Enum session_status = 6;

  message LastFlapReason {
    enum Enum {
      unspecified = 0;
      resv_tear = 1;
      path_tear = 2;
      path_timeout = 3;
    }
  }
  // The reason for the last flap of this RSVP session.
  optional LastFlapReason.Enum last_flap_reason = 7;

  // The tunnel UP time in milli seconds. If the tunnel is DOWN the UP time will be zero.
  optional uint64 up_time = 8;
}

// This contains the list of Record Route Object(RRO) objects associated with the traffic
// engineering tunnel. The  Record Route Object(RRO) is used in RSVP-TE to record the
// route traversed by the LSP. The RRO might be present in both   Path message and Resv
// message, the RRO stores the IP addresses of the routers that the traffic engineering
// tunnel  traversed and also the label generated and distributed by the routers. The
// RROs in the Resv message mirrors that of  the Path message, the only difference is
// that the RRO in a Resv message records the path information in the reverse  direction.
// 
message RsvpLspIpv4Rro {

  // The IPv4 addresses of the routers that the traffic engineering tunnel traversed.
  optional string address = 1;

  // Label reported for RRO hop. When the Label_Recording flag is set in the Session Attribute
  // object, nodes doing route recording should include the Label Record subobject containing
  // the reported label.
  optional uint32 reported_label = 2;
}

// This contains the list of sub-objects included in the Explicit Route Object(ERO)
// object send in the PATH message from the ingress. These sub-objects contain the intermediate
// hops to be traversed by the LSP while being forwarded  towards the egress endpoint.
message RsvpLspIpv4Ero {

  // The IPv4 prefix indicated by the ERO. Specified only when the ERO hop is an IPv4
  // prefix.
  optional string prefix = 1;

  // The autonomous system number indicated by the ERO. Specified only when the ERO hop
  // is an  2 or 4-byte AS number.
  optional uint32 asn = 2;

  message Type {
    enum Enum {
      unspecified = 0;
      ipv4 = 1;
      ipv6 = 2;
      asn = 3;
      asn4 = 4;
      label = 5;
      unnumbered_interface = 6;
    }
  }
  // The type indicated by the ERO.
  optional Type.Enum type = 3;
}

// The request for assigned IPv4 address information associated with DHCP Client sessions.
message Dhcpv4InterfaceStateRequest {

  // The names of DHCPv4 client to return results for. An empty list will return results
  // for all DHCPv4 Client address information.
  // 
  // x-constraint:
  // - /components/schemas/Device.Dhcpv4client/properties/name
  // 
  repeated string dhcp_client_names = 1;
}

// The IPv4 address associated with this DHCP Client session.
message Dhcpv4InterfaceState {

  // The name of a DHCPv4 Client.
  optional string dhcp_client_name = 1;

  // The IPv4 address associated with this DHCP Client session.
  optional string ipv4_address = 2;

  // The length of the prefix.
  optional uint32 prefix_length = 3;

  // The Gateway Ipv4 address associated with this DHCP Client session.
  optional string gateway_address = 4;

  // The duration of the IPv4 address lease, in seconds.
  optional uint32 lease_time = 5;

  // Time in seconds until the DHCPv4 client starts renewing the lease.
  optional uint32 renew_time = 6;

  // Time in seconds until the DHCPv4 client starts rebinding.
  optional uint32 rebind_time = 7;
}

// The request to retrieve DHCP Server host allocated status.
message Dhcpv4LeaseStateRequest {

  // The names of DHCPv4 server to return results for. An empty list will return results
  // for all DHCPv4 servers.
  // 
  // x-constraint:
  // - /components/schemas/Device.Dhcpv4server/properties/name
  // 
  repeated string dhcp_server_names = 1;
}

// Lease information of DHCP Server.
message Dhcpv4LeasesState {

  // The name of a DHCP Server.
  optional string dhcp_server_name = 1;

  // Description missing in models
  repeated Dhcpv4LeaseState leases = 2;
}

// IPv4 address lease state.
message Dhcpv4LeaseState {

  // The IPv4 address associated with this lease.
  optional string address = 1;

  // The time in seconds after which the IPv4 address lease will expire.
  optional uint32 valid_time = 2;

  // The elapsed time in seconds since the address has been renewed.
  optional uint32 preferred_time = 3;

  // Time in seconds until the DHCPv4 client starts renewing the lease.
  optional uint32 renew_time = 4;

  // Time in seconds until the DHCPv4 client starts rebinding.
  optional uint32 rebind_time = 5;

  // The ID of the DHCPv4 client holding this lease.
  optional string client_id = 6;

  // The Circuit ID option found in the last request message.
  optional string circuit_id = 7;

  // The Remote ID option found in the last request message.
  optional string remote_id = 8;
}

// The request for assigned IPv6 address information associated with DHCP Client sessions.
message Dhcpv6InterfaceStateRequest {

  // The names of DHCPv6 client to return results for. An empty list will return results
  // for all DHCPv6 Client address information.
  // 
  // x-constraint:
  // - /components/schemas/Device.Dhcpv6client/properties/name
  // 
  repeated string dhcp_client_names = 1;
}

// The IPv6 address associated with this DHCP Client session.
message Dhcpv6InterfaceState {

  // The name of a DHCPv6 Client.
  optional string dhcp_client_name = 1;

  // The IPv6 IAPD addresses and prefixes associated with this DHCP Client session.
  repeated Dhcpv6InterfaceIapd iapd_addresses = 2;

  // The IPv6 IATA/IANA addresses and gateways associated with this DHCP Client session.
  repeated Dhcpv6InterfaceIa ia_addresses = 3;
}

// The IPv6 IAPD address and prefix length associated with this DHCP Client session.
message Dhcpv6InterfaceIapd {

  // The IAPD address associated with this DHCPv6 Client session.
  optional string address = 1;

  // The prefix length of the IAPD address associated with this DHCPv6 Client session.
  optional uint32 prefix_length = 2;

  // The duration of the IPv6 address lease, in seconds.
  optional uint32 lease_time = 3;
}

// The IPv6 IATA/IANA address and gateway associated with this DHCP Client session.
message Dhcpv6InterfaceIa {

  // The address associated with this DHCPv6 Client session.
  optional string address = 1;

  // The Gateway address associated with this DHCPv6 Client session.
  optional string gateway = 2;

  // The duration of the IPv6 address lease, in seconds.
  optional uint32 lease_time = 3;
}

// The request to retrieve DHCP Server host allocated status.
message Dhcpv6LeaseStateRequest {

  // The names of DHCPv6 server to return results for. An empty list will return results
  // for all DHCPv6 servers.
  // 
  // x-constraint:
  // - /components/schemas/Device.Dhcpv6server/properties/name
  // 
  repeated string dhcp_server_names = 1;
}

// Lease information of DHCP Server.
message Dhcpv6LeasesState {

  // The name of a DHCP Server.
  optional string dhcp_server_name = 1;

  // Description missing in models
  repeated Dhcpv6ServerLeaseState leases = 2;
}

// IPv6 unicast prefix.
message Dhcpv6ServerLeaseState {

  // The IPv6 address associated with this lease.
  optional string address = 1;

  // The time in seconds, IP address lease will expire.
  optional uint32 valid_time = 2;

  // The time in seconds, elapsed time since address has been renewed.
  optional uint32 preferred_time = 3;

  // Time in seconds until the DHCPv6 client starts renewing the lease.
  optional uint32 renew_time = 4;

  // Time in seconds until the DHCPv6 client starts rebinding.
  optional uint32 rebind_time = 5;

  // The ID of the DHCPv6 client holding this lease.
  optional string client_id = 6;

  // The Remote ID option found in the last request message.
  optional string remote_id = 7;

  // The Interface ID option found in the last request message.
  optional string interface_id = 8;
}

// The request to retrieve OSPFv2 Link State Advertisements (LSA) information learned
// by the routers.
message Ospfv2LsasStateRequest {

  // The names of OSPFv2 routers for which learned information is requested. An empty
  // list will return results for all OSPFv2 routers.
  // 
  // x-constraint:
  // - /components/schemas/Device.Ospfv2Router/properties/name
  // 
  repeated string router_names = 1;
}

// The result of OSPFv2 LSA information that are retrieved.
message Ospfv2LsaState {

  // The name of the OSPFv2 Router that learned the LSA information.
  optional string router_name = 1;

  // One or more OSPFv2 Router-LSA - Type 1.
  repeated Ospfv2RouterLsa router_lsas = 2;

  // One or more OSPFv2 Network-LSA - Type 2.
  repeated Ospfv2NetworkLsa network_lsas = 3;

  // One or more OSPFv2 Network summary LSA - Type 3.
  repeated Ospfv2NetworkSummaryLsa network_summary_lsas = 4;

  // One or more OSPFv2 Autonomous System Boundary Router (ASBR) summary LSA - Type 4.
  repeated Ospfv2SummaryAsLsa summary_as_lsas = 5;

  // OSPFv2 AS-External-LSA - Type 5.
  repeated Ospfv2ExternalAsLsa external_as_lsas = 6;

  // One or more OSPFv2 NSSA-LSA - Type 7.
  repeated Ospfv2NssaLsa nssa_lsas = 7;

  // One or more OSPFv2 Link-Scope Opaque-LSA - Type 9.
  repeated Ospfv2OpaqueLsa opaque_lsas = 8;
}

// Contents of the router LSA.
message Ospfv2RouterLsa {

  // Contents of the LSA header.
  Ospfv2LsaHeader header = 1;

  // Links that are described within the LSA.
  repeated Ospfv2Link links = 2;
}

// Contents of the Network LSA.
message Ospfv2NetworkLsa {

  // Contents of the LSA header.
  Ospfv2LsaHeader header = 1;

  // The IPv4 address mask for the network.
  optional string network_mask = 2;

  // Neighbor router ids that are described within the LSA.
  repeated string neighbor_router_ids = 3;
}

// Contents of the Network Summary LSA - Type 3.
// The value of the IPv4 prefix that was received is present in header.lsa_id.
message Ospfv2NetworkSummaryLsa {

  // Contents of the LSA header.
  Ospfv2LsaHeader header = 1;

  // The IPv4 address mask for the network.
  optional string network_mask = 2;

  // The cost of the summary route TOS level 0 and all unspecified levels.
  optional uint32 metric = 3;
}

// Contents of OSPFv2 Autonomous System Boundary Router (ASBR) summary LSA - Type 4.
message Ospfv2SummaryAsLsa {

  // Contents of the LSA header.
  Ospfv2LsaHeader header = 1;

  // The IPv4 address mask for the network.
  optional string network_mask = 2;

  // The cost of the summary route TOS level 0 and all unspecified levels.
  optional uint32 metric = 3;
}

// Contents of OSPFv2 AS-External-LSA - Type 5.
// The value of the IPv4 prefix that was received is present in header.lsa_id.
message Ospfv2ExternalAsLsa {

  // Contents of the LSA header.
  Ospfv2LsaHeader header = 1;

  // The IPv4 address mask for the network.
  optional string network_mask = 2;

  // The cost of the summary route TOS level 0 and all unspecified levels.
  optional uint32 metric = 3;

  // The type of metric associated with the route range.
  optional uint32 metric_type = 4;
}

// Contents of OSPFv2 NSSA LSA - Type 7.
// The value of the IPv4 prefix that was received is present in header.lsa_id.
message Ospfv2NssaLsa {

  // Contents of the LSA header.
  Ospfv2LsaHeader header = 1;

  // The IPv4 address mask for the network.
  optional string network_mask = 2;

  // The cost of the summary route TOS level 0 and all unspecified levels.
  optional uint32 metric = 3;

  // The type of metric associated with the route range.
  optional uint32 metric_type = 4;

  // IPv4 Forwarding address.
  optional string forwarding_address = 5;
}

// Contents of OSPFv2 Opaque LSA - Type 7.
message Ospfv2OpaqueLsa {

  // Contents of the LSA header.
  Ospfv2LsaHeader header = 1;

  message Type {
    enum Enum {
      unspecified = 0;
      local = 1;
      area = 2;
      domain = 3;
    }
  }
  // The type of Opaque TE LSAs. The LSA type.
  optional Type.Enum type = 2;
}

// Attributes in LSA Header.
message Ospfv2LsaHeader {

  // LSA ID in the IPv4 format. The Link State ID for the specified LSA type.
  optional string lsa_id = 1;

  // The router ID (in the IPv4 format) of the router that originated the LSA.
  optional string advertising_router_id = 2;

  // Sequence number to detect old and duplicate LSAs. The greater the sequence number
  // the more recent the LSA.
  optional uint32 sequence_number = 3;

  // The time since the LSA's generation in seconds.
  optional uint32 age = 4;

  // The optional bits.
  optional uint32 option_bits = 5;
}

// Generic attributes used to identify links within OSPFv2.
message Ospfv2Link {

  message Type {
    enum Enum {
      unspecified = 0;
      point_to_point = 1;
      transit = 2;
      stub = 3;
      virtual = 4;
    }
  }
  // The data associated with the link type. The value is dependent upon the subtype of
  // the LSA. - point_to_point: The LSA represents a point-to-point connection to another
  // router. - transit: The LSA represents a connection to a transit network. - stub:
  // The LSA represents a connection to a stub network. - virtual: The LSA represents
  // a virtual link connection.
  optional Type.Enum type = 1;

  // The identifier for the link specified. The value of the link
  // identifier is dependent upon the type of the LSA.
  optional string id = 2;

  // The data associated with the link type. The value is
  // dependent upon the subtype of the LSA. When the connection is
  // to a stub network it represents the mask; for p2p connections
  // that are unnumbered it represents the ifIndex value of the
  // router's interface; for all other connections it represents
  // the local system's IP address.
  optional string data = 3;

  // The data associated with the link type. The value is
  // dependent upon the subtype of the LSA. When the connection is
  // to a stub network it represents the mask; for p2p connections
  // that are unnumbered it represents the ifIndex value of the
  // router's interface; for all other connections it represents
  // the local system's IP address.
  optional uint32 metric = 4;
}

// The request to retrieve OSPFv3 Link State Advertisements (LSA) information learned
// by the routers.
message Ospfv3LsasStateRequest {

  // The names of OSPFv3 routers for which learned information is requested. An empty
  // list will return results for all OSPFv3 routers.
  // 
  // x-constraint:
  // - /components/schemas/Ospfv3.RouterInstance/properties/name
  // 
  repeated string router_names = 1;
}

// The result of OSPFv3 LSA information that are retrieved.
message Ospfv3LsaState {

  // The name of the OSPFv3 Router that learned the LSA information.
  optional string router_name = 1;

  // One or more OSPFv3 Router LSA - Type 1.
  repeated Ospfv3RouterLsa router_lsas = 2;

  // One or more OSPFv3 Network LSA - Type 2.
  repeated Ospfv3NetworkLsa network_lsas = 3;

  // One or more OSPFv3 Inter-Area-Prefix LSA - Type 3.
  repeated Ospfv3InterAreaPrefixLsa inter_area_prefix_lsas = 4;

  // One or more OSPFv3 Inter-Area-Router LSA - Type 4.
  repeated Ospfv3InterAreaRouterLsa inter_area_router_lsas = 5;

  // OSPFv3 AS-External LSA - Type 5.
  repeated Ospfv3ExternalAsLsa external_as_lsas = 6;

  // One or more OSPFv3 NSSA LSA - Type 7.
  repeated Ospfv3NssaLsa nssa_lsas = 7;

  // One or more OSPFv3 Link LSA - Type 8.
  repeated Ospfv3LinkLsa link_lsas = 8;

  // One or more OSPFv3 Intra-Area-Prefix LSA - Type 9.
  repeated Ospfv3IntraAreaPrefixLsa intra_area_prefix_lsas = 9;
}

// Contents of the router LSA.
message Ospfv3RouterLsa {

  // Contents of the LSA header.
  Ospfv3LsaHeader header = 1;

  // Neighbor router id that is described within the LSA.
  optional string neighbor_router_id = 2;

  // Links that are described within the LSA.
  repeated Ospfv3Link links = 3;
}

// Contents of the Network LSA.
message Ospfv3NetworkLsa {

  // Contents of the LSA header.
  Ospfv3LsaHeader header = 1;

  // Attached router ids that are described within the LSA.
  repeated string attached_router_ids = 2;
}

// Contents of the Inter-Area-Prefix LSA - Type 3.
message Ospfv3InterAreaPrefixLsa {

  // Contents of the LSA header.
  Ospfv3LsaHeader header = 1;

  // The prefix for Inter Area Prefix LSA Address.
  optional string address_prefix = 2;

  // The prefix length for the IP address.
  optional uint32 prefix_length = 3;

  // The cost of the summary route TOS level 0 and all unspecified levels.
  optional uint32 metric = 4;
}

// Contents of OSPFv3 Inter-Area-Router LSA - Type 4.
message Ospfv3InterAreaRouterLsa {

  // Contents of the LSA header.
  Ospfv3LsaHeader header = 1;

  // The cost of the summary route TOS level 0 and all unspecified levels.
  optional uint32 metric = 2;

  // The id of the destination router of LSA.
  optional string destination_router_id = 3;
}

// Contents of OSPFv3 AS-External-LSA - Type 5.
message Ospfv3ExternalAsLsa {

  // Contents of the LSA header.
  Ospfv3LsaHeader header = 1;

  // The first IPv6 address prefix to be advertised in the LSA.
  optional string address_prefix = 2;

  // The length of the IPv6 address prefix, in bits.
  optional uint32 prefix_length = 3;

  // The cost metric value for the route to this destination router.
  optional uint32 metric = 4;

  // If non-zero, an LSA with this LS type is to be associated with this LSA.
  optional uint32 referenced_ls_type = 5;

  // The IPV6 address where traffic for the advertised destination is forwarded.
  optional string forwarding_address = 6;

  // The optional field may be used to communicate additional information between  AS
  // boundary routers.
  optional string route_tag = 7;
}

// Contents of OSPFv3 NSSA LSA - Type 7.
message Ospfv3NssaLsa {

  // Contents of the LSA header.
  Ospfv3LsaHeader header = 1;

  // The first IPv6 address prefix to be advertised in the LSA.
  optional string address_prefix = 2;

  // The length of the IPv6 address prefix, in bits.
  optional uint32 prefix_length = 3;

  // The cost metric value for the route to this destination router.
  optional uint32 metric = 4;

  // The IPV6 address where traffic for the advertised destination is forwarded.
  optional string forwarding_address = 5;

  // The optional field may be used to communicate additional information between  AS
  // boundary routers.
  optional string route_tag = 6;
}

// Contents of OSPFv3 Link LSA - Type 8.
message Ospfv3LinkLsa {

  // Contents of the LSA header.
  Ospfv3LsaHeader header = 1;

  // The first IPv6 address prefix to be advertised in the LSA.
  optional string address_prefix = 2;

  // The length of the IPv6 address prefix, in bits.
  optional uint32 prefix_length = 3;

  // The IPV6 Link Local address for the originating router's interface attached to this
  // link.
  optional string link_local_address = 4;
}

// Contents of OSPFv3 Intra-Area-Prefix LSA - Type 9.
message Ospfv3IntraAreaPrefixLsa {

  // Contents of the LSA header.
  Ospfv3LsaHeader header = 1;

  // The first IPv6 address prefix to be advertised in the LSA.
  optional string address_prefix = 2;

  // The length of the IPv6 address prefix, in bits.
  optional uint32 prefix_length = 3;

  // The cost metric value for the route to this destination router.
  optional uint32 metric = 4;
}

// Attributes in LSA Header.
message Ospfv3LsaHeader {

  // LSA ID in the IPv4 format. The Link State ID for the specified LSA type.
  optional string lsa_id = 1;

  // The router ID (in the IPv4 format) of the router that originated the LSA.
  optional string advertising_router_id = 2;

  // Sequence number to detect old and duplicate LSAs. The greater the sequence number
  // the more recent the LSA.
  optional uint32 sequence_number = 3;

  // The time since the LSA's generation in seconds.
  optional uint32 age = 4;
}

// Generic attributes used to identify links within OSPFv3.
message Ospfv3Link {

  message Type {
    enum Enum {
      unspecified = 0;
      point_to_point = 1;
      transit = 2;
      stub = 3;
      virtual = 4;
    }
  }
  // The data associated with the link type. The value is dependent upon the subtype of
  // the LSA. - point_to_point: The LSA represents a point-to-point connection to another
  // router. - transit: The LSA represents a connection to a transit network. - stub:
  // The LSA represents a connection to a stub network. - virtual: The LSA represents
  // a virtual link connection.
  optional Type.Enum type = 1;

  // The data associated with the link type. The value is
  // dependent upon the subtype of the LSA. When the connection is
  // to a stub network it represents the mask; for p2p connections
  // that are unnumbered it represents the ifIndex value of the
  // router's interface; for all other connections it represents
  // the local system's IP address.
  optional uint32 metric = 2;
}

// The request to retrieve ISIS IIH information exchanged by the ISIS routers.
message IsisIIHsStateRequest {

  // The names of ISIS routers for which learned information is requested. An empty list
  // will return results of IIH States for all ISIS routers.
  // 
  // x-constraint:
  // - /components/schemas/Device.IsisRouter/properties/name
  // 
  repeated string isis_router_names = 1;
}

// The result of ISIS IIH information that are exchanged.
message IsisIIHsState {

  // The name of the ISIS Router.
  optional string isis_router_name = 1;

  // Current state of adjacencies.
  repeated IsisLocalIIHAdjacencyStates adjacency_states = 2;
}

// Information for a local adjacency.
message IsisLocalIIHAdjacencyStates {

  // System ID of a neighbor in the hex format, e.g. '650000000001'.
  optional string neighbor_system_id = 1;

  // Interface name on which adjacency is created.
  optional string interface_name = 2;

  // Local adjacency state of this ISIS router.
  IsisLocalIIHState local_state = 3;

  // A IS-IS neighbor that are learned by this ISIS router.
  IsisNeighborIIHState neighbor_state = 4;
}

// Information for a local adjacency.
message IsisLocalIIHState {

  message LevelType {
    enum Enum {
      unspecified = 0;
      level_1 = 1;
      level_2 = 2;
      level_1_2 = 3;
    }
  }
  // This indicates whether this IS-IS router is participating in Level-1 (L1),
  // Level-2 (L2) or both L1 and L2 domains on this interface.
  optional LevelType.Enum level_type = 1;

  // Hold timer being sent in the IIH PDU.
  optional uint32 hold_timer = 2;

  // Reference to Restarting Information.
  IsisIIHLocalRestartStatus restarting_status = 3;
}

// Information for neighbor adjacency State.
message IsisNeighborIIHState {

  message LevelType {
    enum Enum {
      unspecified = 0;
      level_1 = 1;
      level_2 = 2;
      level_1_2 = 3;
    }
  }
  // This indicates whether Neighbor IS-IS router is participating in Level-1 (L1),
  // Level-2 (L2) or both L1 and L2 domains on this interface.
  optional LevelType.Enum level_type = 1;

  // Hold timer received in the IIH PDU sent by the neighbor..
  optional uint32 hold_timer = 2;

  // Reference to Restarting Information.
  IsisIIHNeighborRestartStatus restarting_status = 3;

  // It refers to IIH PDU TLVs container.
  IsisIIHNeighborTlvs tlvs = 4;
}

// This contains the Restarting/Starting/Running state of this router.
message IsisIIHLocalRestartStatus {

  message State {
    enum Enum {
      unspecified = 0;
      running = 1;
      starting = 2;
      restarting = 3;
    }
  }
  // Current State of this router.
  // - starting: Is in Starting state when Restarting Tlv has been sent with SA bit set.
  // - running: Is in Running state when Restarting Tlv is not present or Restarting Tlv
  // has been sent with SA or RR bits unset.
  // - restarting: Is in Restarting state when Restarting Tlv has been sent with RR bits
  // set.
  optional State.Enum state = 1;

  // This container holds the information of the last Graceful Restart initiated on this
  // router.
  IsisIIHLocalGRLastAttemptStatus last_attempt_status = 2;
}

// This contains the Restarting/Starting/Running state of a neighbor router.
message IsisIIHNeighborRestartStatus {

  message State {
    enum Enum {
      unspecified = 0;
      running = 1;
      starting = 2;
      restarting = 3;
    }
  }
  // Current State of Neighbor router.
  // - starting: Is in Starting state when Restarting Tlv has been received with SA bit
  // set.
  // - running: Is in Running state when Restarting Tlv is not present or Restarting Tlv
  // has been received with SA or RR bits unset.
  // - restarting: Is in Restarting state when Restarting Tlv has been received with RR
  // bits set.
  optional State.Enum state = 1;

  // This container holds the information of the last Graceful Restart initiated  by the
  // neighbor since the adjacency was established.
  IsisIIHNeighborGRLastAttemptStatus last_attempt_status = 2;
}

// This object contains the status of the last attempted Graceful Restart status of
// this router.
// - succeeded: Choice is set if the last Graceful Status is successful.
// - failed: The last Graceful Status is unsuccessful.
// - inprogress: The last Graceful Restart status is in progress.
// - unavailable: The last Graceful Restart status is not initiated.
message IsisIIHLocalGRLastAttemptStatus {

  message Choice {
    enum Enum {
      unspecified = 0;
      succeeded = 1;
      failed = 2;
      inprogress = 3;
      unavailable = 4;
    }
  }
  // Description missing in models
  optional Choice.Enum choice = 1;

  // Description missing in models
  IsisIIHLocalGRLastAttemptSucceeded succeeded = 2;

  // Description missing in models
  IsisIIHLocalGRLastAttemptFailed failed = 3;
}

// This container contains the failure status of the last Graceful Restart initiated
// by this router.
message IsisIIHLocalGRLastAttemptFailed {

  // Failure reason of last Graceful Restart.
  optional string reason = 1;
}

// This container contains details about the successful status of the last Graceful
// Restart initiated by this router.
message IsisIIHLocalGRLastAttemptSucceeded {

  // The time (in seconds) is taken to synchronize the L1 and L2 LSDB by this Restarting
  // router.
  // By this time, the CSNP list is cleared and all LSPs are collected by the neighbor(s).
  optional uint32 lsdb_syncup_time = 1;

  // The time (in seconds) is measured from when the Restart TLV with RR bit set is sent
  // 
  // in an IIH PDU upto the time when Restart TLV is sent with RR bit unset.
  optional uint32 adjacency_bring_up_time = 3;
}

// This object contains the status of the last attempted Graceful Restart status of
// an ISIS neighbor.
// - succeeded: Choice is set if the last Graceful was successful.
// - failed: The last Graceful attempt was unsuccessful.
// - inprogress: The last Graceful Restart is in progress.
// - unavailable: Graceful Restart has never been initiated by the neighbor.
message IsisIIHNeighborGRLastAttemptStatus {

  message Choice {
    enum Enum {
      unspecified = 0;
      succeeded = 1;
      failed = 2;
      inprogress = 3;
      unavailable = 4;
    }
  }
  // Description missing in models
  optional Choice.Enum choice = 1;

  // Description missing in models
  IsisIIHNeighborGRLastAttemptSucceeded succeeded = 2;

  // Description missing in models
  IsisIIHNeighborGRLastAttemptFailed failed = 3;
}

// This container contains the failure status of the last Graceful Restart initiated
// by this neighbor.
message IsisIIHNeighborGRLastAttemptFailed {

  // Failure reason of last Graceful Restart in readable string.
  optional string reason = 1;
}

// This object contains the result of a successful graceful restart status in the last
// attempted by a Neighbor.
message IsisIIHNeighborGRLastAttemptSucceeded {

  // The time (in second) is measured from when the Restart TLV with RR bit set in a IIH
  // PDU is received up to the time
  // when it receives the Restart TLV with RR bit and SA bit unset in a IIH PDU from the
  // Neighbor Router.
  optional uint32 adjacency_bring_up_time = 1;
}

// This contains the list of TLVs present in a IIH PDU received from a neighbor IS-IS
// router.
message IsisIIHNeighborTlvs {

  // Restart Tlv.
  IsisIIHRestartTlv restart_tlv = 1;
}

// Container of Restart TLV in IIH PDU. Reference: https://datatracker.ietf.org/doc/html/rfc8706#name-restart-tlv
message IsisIIHRestartTlv {

  // One octet Restart flags in the Restart TLV.
  IsisIIHRestartFlags flags = 1;

  // Remaining Holding Time (in seconds).
  optional uint32 remaining_time = 2;

  // Restarting Neighbor's System ID in hex format without 0x at the beginning. e.g. '640000000001'
  optional string restarting_neighbor_id = 3;
}

// Restarting flags in Restarting TLV in IIH PDU.
message IsisIIHRestartFlags {

  // Restart Request bit.
  optional bool rr_bit = 1;

  // Restart Acknowledgement.
  optional bool ra_bit = 2;

  // Suppress Adjacency Advertisement.
  optional bool sa_bit = 3;

  // Restart Planned.
  optional bool pr_bit = 4;

  // Planned Pestart Acknowledgement.
  optional bool pa_bit = 5;
}

// The request for BMP server information.
message BmpServersStateRequest {

  // The names of the BMP Servers  to return results for. An empty list will return results
  // for all BMP Servers.
  // 
  // x-constraint:
  // - /components/schemas/Device.Bmp.ServerV4/properties/name
  // - /components/schemas/Device.Bmp.ServerV6/properties/name
  // 
  repeated string bmp_server_names = 1;
}

// The information learned by a specific BMP Server. Note that each BMP Server is connected
// to a single BMP client, though multiple BMP Servers can be configured on the  same
// IPv4 or IPv6 interface , each connected to a different BMP client. Each BMP client
// can in turn report information about multiple BGP sessions on that router.
message BmpServerState {

  // The name of the BMP Server configured for which the information is being returned.
  optional string bmp_server_name = 1;

  // Description missing in models
  repeated BmpServerPeerState peers = 2;
}

// The information returned by a BMP client to the BMP Server related to a specific
// BGP session on the router.
message BmpServerPeerState {

  message SessionIpType {
    enum Enum {
      unspecified = 0;
      ipv4 = 1;
      ipv6 = 2;
    }
  }
  // Whether the peer is of type BGPv4 or BGPv6. If the type is ipv4 the session_ipv4_information
  // object should be included to convey the local and remote IPv4 address for the peer.
  // If the type is ipv6 the session_ipv6_information object should be included to convey
  // the local and remote IPv6 address for the peer.
  optional SessionIpType.Enum session_ip_type = 1;

  // This object is included if session_ip_type is of type ipv4.
  BmpServerPeerSessionIpv4Information session_ipv4_information = 2;

  // This object is included if session_ip_type is of type ipv6.
  BmpServerPeerSessionIpv6Information session_ipv6_information = 3;

  // The BGP Identifier of the peer.
  optional string peer_bgp_id = 4;

  message Status {
    enum Enum {
      unspecified = 0;
      up = 1;
      down = 2;
    }
  }
  // The current state of the BGP session.  Note that per peer stats and rib information
  // might be empty if the peer state is down.
  optional Status.Enum status = 5;

  // The last set of BMP stats sent by the BMP client for this peer as per the message
  // format defined in https://www.rfc-editor.org/rfc/rfc7854.html#section-4.8. It might
  // be absent if no BMP Statistics message have been received yet or peer is still in
  // down state. If the BMP client has sent a subset of the various statistic counters,
  // only those should be set when returning the result.
  BmpServerPeerStats stats = 6;

  // The set of routes received from this peer as reported using BMP Route Monitoring
  // messages by the BMP client  which are part of the Adj-RIB-In database *before* inbound
  // policies were applied. This is determined by checking that the L flag is not set
  // in the Per-Peer Header in the received Route Monitoring message. It should also be
  // ensured that the O flag as defined in RFC8671 is not set in the flags. (indicates
  // Adj-RIB-Out)  Note that routes which have been advertised initially and currently
  // in withdrawn state can be included in the returned set of routes by setting the status
  // of that specific route to 'withdrawn'. Routes which have been received from this
  // peer and part of current Pre-Policy In-Rib DB should have the status set to 'advertised'.
  // Note that if prefix_storage.ipv4_unicast.discard or/and prefix_storage.ipv6_unicast.discard
  // is configured or exceptions in the prefix_storage are specified such that all incoming
  // routes are filtered, the prefix database list will be empty.
  BmpServerPeerPrePolicyInRib pre_policy_in_rib = 7;

  // The set of routes received from this peer as reported using BMP Route Monitoring
  // messages by the BMP client  which are part of the Adj-RIB-In database *after* inbound
  // policies were applied. This is determined by checking that the L flag is set in the
  // Per-Peer Header in the received Route Monitoring message. It should also be ensured
  // that the O flag as defined in RFC8671 is not set in the flags. (indicates Adj-RIB-Out)
  // Note that routes which have been advertised initially and currently in withdrawn
  // state can be included in the returned set of routes by setting the status of that
  // specific route to 'withdrawn'. Routes which have been received from this peer and
  // part of current Post-Policy In-Rib DB should have the status set to 'advertised'.
  // Note that if prefix_storage.ipv4_unicast.discard or/and prefix_storage.ipv6_unicast.discard
  // is configured or exceptions in the prefix_storage are specified such that all incoming
  // routes are filtered, the prefix database list will be empty.
  BmpServerPeerPostPolicyInRib post_policy_in_rib = 8;
}

// This object is included if session_ip_type is of type ipv4.
message BmpServerPeerSessionIpv4Information {

  // The local IPv4 address associated with the BGPv4 peer.
  optional string local_address = 1;

  // The remote IPv4 address associated with the BGPv4 peer.
  optional string remote_address = 2;
}

// This object is included if session_ip_type is of type ipv6.
message BmpServerPeerSessionIpv6Information {

  // The local IPv6 address associated with the BGPv6 peer.
  optional string local_address = 1;

  // The remote IPv6 address associated with the BGPv6 peer.
  optional string remote_address = 2;
}

// The last set of BMP stats sent by the BMP client for this peer as per the message
// format defined in https://www.rfc-editor.org/rfc/rfc7854.html#section-4.8. It might
// be absent if no BMP Statistics message have been received yet or peer is still in
// down state. If the BMP client has sent a subset of the various statistic counters,
// only those should be set when returning the result.
message BmpServerPeerStats {

  // Number of prefixes rejected by inbound policy.
  optional uint32 rejected_prefixes = 1;

  // Number of (known) duplicate prefix advertisements.
  optional uint32 duplicate_prefixes = 2;

  // Number of (known) duplicate withdraws.
  optional uint32 duplicate_withdraws = 3;

  // Number of updates invalidated due to CLUSTER_LIST loop.
  optional uint32 cluster_list_invalidated_updates = 4;

  // Number of updates invalidated due to AS_PATH loop.
  optional uint32 as_path_invalidated_updates = 5;

  // Number of updates invalidated due to ORIGINATOR_ID.
  optional uint32 originator_id_invalidated_updates = 6;

  // Number of updates invalidated due to AS_CONFED loop.
  optional uint32 as_confed_invalidated_updates = 7;

  // Number of routes in Adj-RIBs-In.
  optional uint64 adj_rib_routes = 8;

  // Number of routes in Loc-RIB.
  optional uint64 local_rib_routes = 9;

  // Number of updates subjected to treat-as-withdraw treatment [RFC7606].
  optional uint32 withdraw_updates_received = 10;

  // Number of prefixes  subjected to treat-as-withdraw treatment [RFC7606].
  optional uint32 withdraw_prefixes_received = 11;

  // Number of duplicate update messages received.
  optional uint32 duplicate_updates = 12;
}

// The set of routes received from this peer as reported using BMP Route Monitoring
// messages by the BMP client  which are part of the Adj-RIB-In database *before* inbound
// policies were applied. This is determined by checking that the L flag is not set
// in the Per-Peer Header in the received Route Monitoring message. It should also be
// ensured that the O flag as defined in RFC8671 is not set in the flags. (indicates
// Adj-RIB-Out)  Note that routes which have been advertised initially and currently
// in withdrawn state can be included in the returned set of routes by setting the status
// of that specific route to 'withdrawn'. Routes which have been received from this
// peer and part of current Pre-Policy In-Rib DB should have the status set to 'advertised'.
// Note that if prefix_storage.ipv4_unicast.discard or/and prefix_storage.ipv6_unicast.discard
// is configured or exceptions in the prefix_storage are specified such that all incoming
// routes are filtered, the corresponding prefix database list will be empty.
message BmpServerPeerPrePolicyInRib {

  // Description missing in models
  repeated BmpPrefixIpv4UnicastState ipv4_unicast_prefixes = 1;

  // Description missing in models
  repeated BmpPrefixIpv6UnicastState ipv6_unicast_prefixes = 2;
}

// The set of routes received from this peer as reported using BMP Route Monitoring
// messages by the BMP client  which are part of the Adj-RIB-In database *after* inbound
// policies were applied. This is determined by checking that the L flag is set in the
// Per-Peer Header in the received Route Monitoring message. It should also be ensured
// that the O flag as defined in RFC8671 is not set in the flags. (indicates Adj-RIB-Out)
// Note that routes which have been advertised initially and currently in withdrawn
// state can be included in the returned set of routes by setting the status of that
// specific route to 'withdrawn'. Routes which have been received from this peer and
// part of current Post-Policy In-Rib DB should have the status set to 'advertised'.
// Note that if prefix_storage.ipv4_unicast.discard or/and prefix_storage.ipv6_unicast.discard
// is configured or exceptions in the prefix_storage are specified such that all incoming
// routes are filtered, the corresponding prefix database list will be empty. .
// 
message BmpServerPeerPostPolicyInRib {

  // Description missing in models
  repeated BmpPrefixIpv4UnicastState ipv4_unicast_prefixes = 1;

  // Description missing in models
  repeated BmpPrefixIpv6UnicastState ipv6_unicast_prefixes = 2;
}

// IPv4 unicast prefix.
message BmpPrefixIpv4UnicastState {

  // An IPv4 unicast address.
  optional string ipv4_address = 1;

  // The length of the IPv4 prefix.
  optional uint32 prefix_length = 2;

  message Origin {
    enum Enum {
      unspecified = 0;
      igp = 1;
      egp = 2;
      incomplete = 3;
    }
  }
  // The origin of the prefix.
  optional Origin.Enum origin = 3;

  // The path id.
  optional uint32 path_id = 4;

  message RouteState {
    enum Enum {
      unspecified = 0;
      advertised = 1;
      withdrawn = 2;
    }
  }
  // The state of the route , either advertised or withdrawn. If route is in withdrawn
  // state, only the prefix, prefix_length, origin and path_id (if applicable) may be
  // present.
  optional RouteState.Enum route_state = 5;

  message NextHopType {
    enum Enum {
      unspecified = 0;
      ipv4 = 1;
      ipv6 = 2;
    }
  }
  // The next hop type , ipv4 or ipv6 .  If type is ipv4, then the ipv4_next_hop should
  // be included. If type is ipv6, then the ipv6_next_hop should be included.
  // 
  optional NextHopType.Enum next_hop_type = 6;

  // The IPv4 address of the egress interface.
  optional string ipv4_next_hop = 7;

  // The IPv6 address of the egress interface.
  optional string ipv6_next_hop = 8;

  // Optional community attributes.
  repeated ResultBgpCommunity communities = 9;

  // Optional received Extended Community attributes. Each received Extended Community
  // attribute is available for retrieval in two forms. Support of the 'raw' format in
  // which all 8 bytes (16 hex characters) is always present and available for use. In
  // addition, if supported by the implementation, the Extended Community attribute may
  // also be retrieved in the  'structured' format which is an optional field.
  repeated ResultExtendedCommunity extended_communities = 10;

  // Description missing in models
  ResultBgpAsPath as_path = 11;

  // The local preference is a well-known attribute and the value is used for route selection.
  // The route with the highest local preference value is preferred.
  optional uint32 local_preference = 12;

  // The multi exit discriminator (MED) is an optional non-transitive attribute and the
  // value is used for route selection. The route with the lowest MED value is preferred.
  optional uint32 multi_exit_discriminator = 13;
}

// IPv6 unicast prefix.
message BmpPrefixIpv6UnicastState {

  // An IPv6 unicast address.
  optional string ipv6_address = 1;

  // The length of the IPv6 prefix.
  optional uint32 prefix_length = 2;

  message Origin {
    enum Enum {
      unspecified = 0;
      igp = 1;
      egp = 2;
      incomplete = 3;
    }
  }
  // The origin of the prefix.
  optional Origin.Enum origin = 3;

  // The path id.
  optional uint32 path_id = 4;

  message RouteState {
    enum Enum {
      unspecified = 0;
      advertised = 1;
      withdrawn = 2;
    }
  }
  // The state of the route , either advertised or withdrawn. If route is in withdrawn
  // state, only the prefix, prefix_length, origin and path_id (if applicable) may be
  // present.
  optional RouteState.Enum route_state = 5;

  message NextHopType {
    enum Enum {
      unspecified = 0;
      ipv4 = 1;
      ipv6 = 2;
    }
  }
  // The next hop type , ipv4 or ipv6 .  If type is ipv4, then the ipv4_next_hop should
  // be included. If type is ipv6, then the ipv6_next_hop should be included.
  // 
  optional NextHopType.Enum next_hop_type = 6;

  // The IPv4 address of the egress interface.
  optional string ipv4_next_hop = 7;

  // The IPv6 address of the egress interface.
  optional string ipv6_next_hop = 8;

  // Optional community attributes.
  repeated ResultBgpCommunity communities = 9;

  // Optional received Extended Community attributes. Each received Extended Community
  // attribute is available for retrieval in two forms. Support of the 'raw' format in
  // which all 8 bytes (16 hex characters) is always present and available for use. In
  // addition, if supported by the implementation, the Extended Community attribute may
  // also be retrieved in the  'structured' format which is an optional field.
  repeated ResultExtendedCommunity extended_communities = 10;

  // Description missing in models
  ResultBgpAsPath as_path = 11;

  // The local preference is a well-known attribute and the value is used for route selection.
  // The route with the highest local preference value is preferred.
  optional uint32 local_preference = 12;

  // The multi exit discriminator (MED) is an optional non-transitive attribute and the
  // value is used for route selection. The route with the lowest MED value is preferred.
  optional uint32 multi_exit_discriminator = 13;
}

// The capture result request to the traffic generator.
// Stops the port capture on the port_name and returns the capture.
message CaptureRequest {

  // The name of a port a capture is started on.
  // 
  // x-constraint:
  // - /components/schemas/Port/properties/name
  // 
  // required = true
  optional string port_name = 1;

  // Specification of the packets to be returned in the capture result from  the set of
  // captured packets as per capture configuration.
  CaptureRequestPackets packets = 2;
}

// Packets to be returned in the capture result from  the set of captured packets as
// per capture configuration.
message CaptureRequestPackets {

  message Choice {
    enum Enum {
      unspecified = 0;
      all = 1;
      slice = 2;
    }
  }
  // Description missing in models
  // default = Choice.Enum.all
  optional Choice.Enum choice = 1;

  // Description missing in models
  CaptureRequestCaptureSlice slice = 2;
}

// Packets to be returned as part of the capture result from the set of captured packets
// as per
// capture configuration and specification of capture slice.
// To be noted,
// - definition of capture slice works in conjunction with capture filter parameters
// in set_config.
// - if 'initial' set of packets is desired to be returned in the capture result, 'overwrite'
// attribute in 'captures'
// settings of set_config should be disabled.
message CaptureRequestCaptureSlice {

  message Choice {
    enum Enum {
      unspecified = 0;
      initial = 1;
    }
  }
  // Description missing in models
  // default = Choice.Enum.initial
  optional Choice.Enum choice = 1;

  // Description missing in models
  CaptureRequestCaptureSliceInitial initial = 2;
}

// Specification of capture slice to retrieve captured packets from begining of captured
// packet sequence.
message CaptureRequestCaptureSliceInitial {

  // Position of the packet (Nth) in the captured packet sequence starting from which
  // packets would be returned as part of the capture result.
  // default = 1
  optional uint64 start = 1;

  // Maximum number of packets to be returned as part of the capture result starting from
  // the position of 'start' packet.
  // default = 100
  optional uint64 count = 2;
}

// mac counter pattern
message PatternFlowEthernetDstCounter {

  // Description missing in models
  // default = 00:00:00:00:00:00
  optional string start = 1;

  // Description missing in models
  // default = 00:00:00:00:00:01
  optional string step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowEthernetDstMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 48
  optional uint32 length = 3;
}

// Destination MAC address
message PatternFlowEthernetDst {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      auto = 1;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.auto
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 00:00:00:00:00:00
  optional string value = 2;

  // Description missing in models
  // default = ['00:00:00:00:00:00']
  repeated string values = 3;

  // The OTG implementation can provide a system generated
  // value for this property. If the OTG is unable to generate a value
  // the default value must be used.
  // default = 00:00:00:00:00:00
  optional string auto = 4;

  // Description missing in models
  PatternFlowEthernetDstCounter increment = 6;

  // Description missing in models
  PatternFlowEthernetDstCounter decrement = 7;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowEthernetDstMetricTag metric_tags = 8;
}

// mac counter pattern
message PatternFlowEthernetSrcCounter {

  // Description missing in models
  // default = 00:00:00:00:00:00
  optional string start = 1;

  // Description missing in models
  // default = 00:00:00:00:00:01
  optional string step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowEthernetSrcMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 48
  optional uint32 length = 3;
}

// Source MAC address
message PatternFlowEthernetSrc {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 00:00:00:00:00:00
  optional string value = 2;

  // Description missing in models
  // default = ['00:00:00:00:00:00']
  repeated string values = 3;

  // Description missing in models
  PatternFlowEthernetSrcCounter increment = 5;

  // Description missing in models
  PatternFlowEthernetSrcCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowEthernetSrcMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowEthernetEtherTypeCounter {

  // Description missing in models
  // default = 65535
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowEthernetEtherTypeMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Ethernet type
message PatternFlowEthernetEtherType {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      auto = 1;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.auto
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 65535
  optional uint32 value = 2;

  // Description missing in models
  // default = [65535]
  repeated uint32 values = 3;

  // The OTG implementation can provide a system generated
  // value for this property. If the OTG is unable to generate a value
  // the default value must be used.
  // default = 65535
  optional uint32 auto = 4;

  // Description missing in models
  PatternFlowEthernetEtherTypeCounter increment = 6;

  // Description missing in models
  PatternFlowEthernetEtherTypeCounter decrement = 7;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowEthernetEtherTypeMetricTag metric_tags = 8;
}

// integer counter pattern
message PatternFlowEthernetPfcQueueCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowEthernetPfcQueueMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 3
  optional uint32 length = 3;
}

// Priority flow control queue
message PatternFlowEthernetPfcQueue {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowEthernetPfcQueueCounter increment = 5;

  // Description missing in models
  PatternFlowEthernetPfcQueueCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowEthernetPfcQueueMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowVlanPriorityCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowVlanPriorityMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 3
  optional uint32 length = 3;
}

// Priority code point
message PatternFlowVlanPriority {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowVlanPriorityCounter increment = 5;

  // Description missing in models
  PatternFlowVlanPriorityCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowVlanPriorityMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowVlanCfiCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowVlanCfiMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// Canonical format indicator or drop elegible indicator
message PatternFlowVlanCfi {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowVlanCfiCounter increment = 5;

  // Description missing in models
  PatternFlowVlanCfiCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowVlanCfiMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowVlanIdCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowVlanIdMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 12
  optional uint32 length = 3;
}

// Vlan identifier
message PatternFlowVlanId {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowVlanIdCounter increment = 5;

  // Description missing in models
  PatternFlowVlanIdCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowVlanIdMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowVlanTpidCounter {

  // Description missing in models
  // default = 65535
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowVlanTpidMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Protocol identifier
message PatternFlowVlanTpid {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 65535
  optional uint32 value = 2;

  // Description missing in models
  // default = [65535]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowVlanTpidCounter increment = 5;

  // Description missing in models
  PatternFlowVlanTpidCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowVlanTpidMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowVxlanFlagsCounter {

  // Description missing in models
  // default = 8
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowVxlanFlagsMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 8
  optional uint32 length = 3;
}

// Flags field with a bit format of RRRRIRRR. The I flag MUST be set to 1 for a valid
// vxlan network id (VNI).   The other 7 bits (designated R) are reserved fields and
// MUST be  set to zero on transmission and ignored on receipt.
message PatternFlowVxlanFlags {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 8
  optional uint32 value = 2;

  // Description missing in models
  // default = [8]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowVxlanFlagsCounter increment = 5;

  // Description missing in models
  PatternFlowVxlanFlagsCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowVxlanFlagsMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowVxlanReserved0Counter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowVxlanReserved0MetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 24
  optional uint32 length = 3;
}

// Reserved field
message PatternFlowVxlanReserved0 {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowVxlanReserved0Counter increment = 5;

  // Description missing in models
  PatternFlowVxlanReserved0Counter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowVxlanReserved0MetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowVxlanVniCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowVxlanVniMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 24
  optional uint32 length = 3;
}

// VXLAN network id
message PatternFlowVxlanVni {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      auto = 1;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.auto
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // The OTG implementation can provide a system generated
  // value for this property. If the OTG is unable to generate a value
  // the default value must be used.
  // default = 0
  optional uint32 auto = 4;

  // Description missing in models
  PatternFlowVxlanVniCounter increment = 6;

  // Description missing in models
  PatternFlowVxlanVniCounter decrement = 7;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowVxlanVniMetricTag metric_tags = 8;
}

// integer counter pattern
message PatternFlowVxlanReserved1Counter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowVxlanReserved1MetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 8
  optional uint32 length = 3;
}

// Reserved field
message PatternFlowVxlanReserved1 {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowVxlanReserved1Counter increment = 5;

  // Description missing in models
  PatternFlowVxlanReserved1Counter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowVxlanReserved1MetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIpv4VersionCounter {

  // Description missing in models
  // default = 4
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv4VersionMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 4
  optional uint32 length = 3;
}

// Version
message PatternFlowIpv4Version {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 4
  optional uint32 value = 2;

  // Description missing in models
  // default = [4]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowIpv4VersionCounter increment = 5;

  // Description missing in models
  PatternFlowIpv4VersionCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv4VersionMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIpv4HeaderLengthCounter {

  // Description missing in models
  // default = 5
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv4HeaderLengthMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 4
  optional uint32 length = 3;
}

// Header length
message PatternFlowIpv4HeaderLength {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      auto = 1;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.auto
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 5
  optional uint32 value = 2;

  // Description missing in models
  // default = [5]
  repeated uint32 values = 3;

  // The OTG implementation can provide a system generated
  // value for this property. If the OTG is unable to generate a value
  // the default value must be used.
  // default = 5
  optional uint32 auto = 4;

  // Description missing in models
  PatternFlowIpv4HeaderLengthCounter increment = 6;

  // Description missing in models
  PatternFlowIpv4HeaderLengthCounter decrement = 7;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv4HeaderLengthMetricTag metric_tags = 8;
}

// integer counter pattern
message PatternFlowIpv4TotalLengthCounter {

  // Description missing in models
  // default = 46
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv4TotalLengthMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Total length
message PatternFlowIpv4TotalLength {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      auto = 1;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.auto
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 46
  optional uint32 value = 2;

  // Description missing in models
  // default = [46]
  repeated uint32 values = 3;

  // The OTG implementation can provide a system generated
  // value for this property. If the OTG is unable to generate a value
  // the default value must be used.
  // default = 46
  optional uint32 auto = 4;

  // Description missing in models
  PatternFlowIpv4TotalLengthCounter increment = 6;

  // Description missing in models
  PatternFlowIpv4TotalLengthCounter decrement = 7;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv4TotalLengthMetricTag metric_tags = 8;
}

// integer counter pattern
message PatternFlowIpv4IdentificationCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv4IdentificationMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Identification
message PatternFlowIpv4Identification {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowIpv4IdentificationCounter increment = 5;

  // Description missing in models
  PatternFlowIpv4IdentificationCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv4IdentificationMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIpv4ReservedCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv4ReservedMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// Reserved flag.
message PatternFlowIpv4Reserved {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowIpv4ReservedCounter increment = 5;

  // Description missing in models
  PatternFlowIpv4ReservedCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv4ReservedMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIpv4DontFragmentCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv4DontFragmentMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// Dont fragment flag If the dont_fragment flag is set and fragmentation is required
// to route the packet then the packet is dropped.
message PatternFlowIpv4DontFragment {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowIpv4DontFragmentCounter increment = 5;

  // Description missing in models
  PatternFlowIpv4DontFragmentCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv4DontFragmentMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIpv4MoreFragmentsCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv4MoreFragmentsMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// More fragments flag
message PatternFlowIpv4MoreFragments {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowIpv4MoreFragmentsCounter increment = 5;

  // Description missing in models
  PatternFlowIpv4MoreFragmentsCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv4MoreFragmentsMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIpv4FragmentOffsetCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv4FragmentOffsetMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 5
  optional uint32 length = 3;
}

// Fragment offset
message PatternFlowIpv4FragmentOffset {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowIpv4FragmentOffsetCounter increment = 5;

  // Description missing in models
  PatternFlowIpv4FragmentOffsetCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv4FragmentOffsetMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIpv4TimeToLiveCounter {

  // Description missing in models
  // default = 64
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv4TimeToLiveMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 8
  optional uint32 length = 3;
}

// Time to live
message PatternFlowIpv4TimeToLive {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 64
  optional uint32 value = 2;

  // Description missing in models
  // default = [64]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowIpv4TimeToLiveCounter increment = 5;

  // Description missing in models
  PatternFlowIpv4TimeToLiveCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv4TimeToLiveMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIpv4ProtocolCounter {

  // Description missing in models
  // default = 61
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv4ProtocolMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 8
  optional uint32 length = 3;
}

// Protocol, default is 61 any host internal protocol
message PatternFlowIpv4Protocol {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      auto = 1;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.auto
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 61
  optional uint32 value = 2;

  // Description missing in models
  // default = [61]
  repeated uint32 values = 3;

  // The OTG implementation can provide a system generated
  // value for this property. If the OTG is unable to generate a value
  // the default value must be used.
  // default = 61
  optional uint32 auto = 4;

  // Description missing in models
  PatternFlowIpv4ProtocolCounter increment = 6;

  // Description missing in models
  PatternFlowIpv4ProtocolCounter decrement = 7;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv4ProtocolMetricTag metric_tags = 8;
}

// Header checksum
message PatternFlowIpv4HeaderChecksum {

  message Choice {
    enum Enum {
      unspecified = 0;
      generated = 1;
      custom = 2;
    }
  }
  // The type of checksum
  // default = Choice.Enum.generated
  optional Choice.Enum choice = 1;

  message Generated {
    enum Enum {
      unspecified = 0;
      good = 1;
      bad = 2;
    }
  }
  // A system generated checksum value
  // default = Generated.Enum.good
  optional Generated.Enum generated = 2;

  // A custom checksum value
  optional uint32 custom = 3;
}

// ipv4 counter pattern
message PatternFlowIpv4SrcCounter {

  // Description missing in models
  // default = 0.0.0.0
  optional string start = 1;

  // Description missing in models
  // default = 0.0.0.1
  optional string step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv4SrcMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 32
  optional uint32 length = 3;
}

// ipv4 random pattern
message PatternFlowIpv4SrcRandom {

  // The minimum possible value generated by the random value generator.
  // default = 0.0.0.0
  optional string min = 1;

  // The maximum possible value generated by the random value generator.
  // default = 255.255.255.255
  optional string max = 2;

  // The seed value is used to initialize the random number generator to a deterministic
  // state. If the user provides a seed value of 0, the implementation will generate a
  // sequence of non-deterministic random values. For any other seed value, the sequence
  // of random numbers will be generated in a deterministic manner (specific to the implementation).
  // default = 1
  optional uint32 seed = 3;

  // The total number of values to be generated by the random value generator.
  // default = 1
  optional uint32 count = 4;
}

// Source address
message PatternFlowIpv4Src {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
      auto = 1;
      random = 6;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0.0.0.0
  optional string value = 2;

  // Description missing in models
  // default = ['0.0.0.0']
  repeated string values = 3;

  // Description missing in models
  PatternFlowIpv4SrcCounter increment = 5;

  // Description missing in models
  PatternFlowIpv4SrcCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv4SrcMetricTag metric_tags = 7;

  // Description missing in models
  FlowIpv4Auto auto = 8;

  // Description missing in models
  PatternFlowIpv4SrcRandom random = 9;
}

// ipv4 counter pattern
message PatternFlowIpv4DstCounter {

  // Description missing in models
  // default = 0.0.0.0
  optional string start = 1;

  // Description missing in models
  // default = 0.0.0.1
  optional string step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv4DstMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 32
  optional uint32 length = 3;
}

// ipv4 random pattern
message PatternFlowIpv4DstRandom {

  // The minimum possible value generated by the random value generator.
  // default = 0.0.0.0
  optional string min = 1;

  // The maximum possible value generated by the random value generator.
  // default = 255.255.255.255
  optional string max = 2;

  // The seed value is used to initialize the random number generator to a deterministic
  // state. If the user provides a seed value of 0, the implementation will generate a
  // sequence of non-deterministic random values. For any other seed value, the sequence
  // of random numbers will be generated in a deterministic manner (specific to the implementation).
  // default = 1
  optional uint32 seed = 3;

  // The total number of values to be generated by the random value generator.
  // default = 1
  optional uint32 count = 4;
}

// Destination address
message PatternFlowIpv4Dst {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
      auto = 1;
      random = 6;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0.0.0.0
  optional string value = 2;

  // Description missing in models
  // default = ['0.0.0.0']
  repeated string values = 3;

  // Description missing in models
  PatternFlowIpv4DstCounter increment = 5;

  // Description missing in models
  PatternFlowIpv4DstCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv4DstMetricTag metric_tags = 7;

  // Description missing in models
  FlowIpv4Auto auto = 8;

  // Description missing in models
  PatternFlowIpv4DstRandom random = 9;
}

// integer counter pattern
message PatternFlowIpv4OptionsCustomTypeCopiedFlagCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// This flag indicates this option is copied to all fragments on fragmentations.
message PatternFlowIpv4OptionsCustomTypeCopiedFlag {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowIpv4OptionsCustomTypeCopiedFlagCounter increment = 5;

  // Description missing in models
  PatternFlowIpv4OptionsCustomTypeCopiedFlagCounter decrement = 6;
}

// integer counter pattern
message PatternFlowIpv4OptionsCustomTypeOptionClassCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Option class [Ref:https://www.iana.org/assignments/ip-parameters/ip-parameters.xhtml#ip-parameters-1].
message PatternFlowIpv4OptionsCustomTypeOptionClass {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowIpv4OptionsCustomTypeOptionClassCounter increment = 5;

  // Description missing in models
  PatternFlowIpv4OptionsCustomTypeOptionClassCounter decrement = 6;
}

// integer counter pattern
message PatternFlowIpv4OptionsCustomTypeOptionNumberCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Option Number [Ref:https://www.iana.org/assignments/ip-parameters/ip-parameters.xhtml#ip-parameters-1].
message PatternFlowIpv4OptionsCustomTypeOptionNumber {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowIpv4OptionsCustomTypeOptionNumberCounter increment = 5;

  // Description missing in models
  PatternFlowIpv4OptionsCustomTypeOptionNumberCounter decrement = 6;
}

// integer counter pattern
message PatternFlowIpv4PriorityRawCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv4PriorityRawMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 8
  optional uint32 length = 3;
}

// Raw priority
message PatternFlowIpv4PriorityRaw {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowIpv4PriorityRawCounter increment = 5;

  // Description missing in models
  PatternFlowIpv4PriorityRawCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv4PriorityRawMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIpv4DscpPhbCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv4DscpPhbMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 6
  optional uint32 length = 3;
}

// Per hop behavior
message PatternFlowIpv4DscpPhb {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowIpv4DscpPhbCounter increment = 5;

  // Description missing in models
  PatternFlowIpv4DscpPhbCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv4DscpPhbMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIpv4DscpEcnCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv4DscpEcnMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 2
  optional uint32 length = 3;
}

// Explicit congestion notification
message PatternFlowIpv4DscpEcn {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowIpv4DscpEcnCounter increment = 5;

  // Description missing in models
  PatternFlowIpv4DscpEcnCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv4DscpEcnMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIpv4TosPrecedenceCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv4TosPrecedenceMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 3
  optional uint32 length = 3;
}

// Precedence
message PatternFlowIpv4TosPrecedence {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowIpv4TosPrecedenceCounter increment = 5;

  // Description missing in models
  PatternFlowIpv4TosPrecedenceCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv4TosPrecedenceMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIpv4TosDelayCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv4TosDelayMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// Delay
message PatternFlowIpv4TosDelay {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowIpv4TosDelayCounter increment = 5;

  // Description missing in models
  PatternFlowIpv4TosDelayCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv4TosDelayMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIpv4TosThroughputCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv4TosThroughputMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// Throughput
message PatternFlowIpv4TosThroughput {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowIpv4TosThroughputCounter increment = 5;

  // Description missing in models
  PatternFlowIpv4TosThroughputCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv4TosThroughputMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIpv4TosReliabilityCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv4TosReliabilityMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// Reliability
message PatternFlowIpv4TosReliability {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowIpv4TosReliabilityCounter increment = 5;

  // Description missing in models
  PatternFlowIpv4TosReliabilityCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv4TosReliabilityMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIpv4TosMonetaryCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv4TosMonetaryMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// Monetary
message PatternFlowIpv4TosMonetary {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowIpv4TosMonetaryCounter increment = 5;

  // Description missing in models
  PatternFlowIpv4TosMonetaryCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv4TosMonetaryMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIpv4TosUnusedCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv4TosUnusedMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// Unused
message PatternFlowIpv4TosUnused {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowIpv4TosUnusedCounter increment = 5;

  // Description missing in models
  PatternFlowIpv4TosUnusedCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv4TosUnusedMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIpv6VersionCounter {

  // Description missing in models
  // default = 6
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv6VersionMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 4
  optional uint32 length = 3;
}

// Version number
message PatternFlowIpv6Version {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 6
  optional uint32 value = 2;

  // Description missing in models
  // default = [6]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowIpv6VersionCounter increment = 5;

  // Description missing in models
  PatternFlowIpv6VersionCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv6VersionMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIpv6TrafficClassCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv6TrafficClassMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 8
  optional uint32 length = 3;
}

// Traffic class
message PatternFlowIpv6TrafficClass {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowIpv6TrafficClassCounter increment = 5;

  // Description missing in models
  PatternFlowIpv6TrafficClassCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv6TrafficClassMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIpv6FlowLabelCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv6FlowLabelMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 20
  optional uint32 length = 3;
}

// integer random pattern
message PatternFlowIpv6FlowLabelRandom {

  // The minimum possible value generated by the random value generator.
  // default = 0
  optional uint32 min = 1;

  // The maximum possible value generated by the random value generator.
  // default = 1048575
  optional uint32 max = 2;

  // The seed value is used to initialize the random number generator to a deterministic
  // state. If the user provides a seed value of 0, the implementation will generate a
  // sequence of non-deterministic random values. For any other seed value, the sequence
  // of random numbers will be generated in a deterministic manner (specific to the implementation).
  // default = 1
  optional uint32 seed = 3;

  // The total number of values to be generated by the random value generator.
  // default = 1
  optional uint32 count = 4;
}

// Flow label
message PatternFlowIpv6FlowLabel {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
      random = 6;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowIpv6FlowLabelCounter increment = 5;

  // Description missing in models
  PatternFlowIpv6FlowLabelCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv6FlowLabelMetricTag metric_tags = 7;

  // Description missing in models
  PatternFlowIpv6FlowLabelRandom random = 8;
}

// integer counter pattern
message PatternFlowIpv6PayloadLengthCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv6PayloadLengthMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Payload length
message PatternFlowIpv6PayloadLength {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      auto = 1;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.auto
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // The OTG implementation can provide a system generated
  // value for this property. If the OTG is unable to generate a value
  // the default value must be used.
  // default = 0
  optional uint32 auto = 4;

  // Description missing in models
  PatternFlowIpv6PayloadLengthCounter increment = 6;

  // Description missing in models
  PatternFlowIpv6PayloadLengthCounter decrement = 7;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv6PayloadLengthMetricTag metric_tags = 8;
}

// integer counter pattern
message PatternFlowIpv6NextHeaderCounter {

  // Description missing in models
  // default = 59
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv6NextHeaderMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 8
  optional uint32 length = 3;
}

// Next header
message PatternFlowIpv6NextHeader {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      auto = 1;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.auto
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 59
  optional uint32 value = 2;

  // Description missing in models
  // default = [59]
  repeated uint32 values = 3;

  // The OTG implementation can provide a system generated
  // value for this property. If the OTG is unable to generate a value
  // the default value must be used.
  // default = 59
  optional uint32 auto = 4;

  // Description missing in models
  PatternFlowIpv6NextHeaderCounter increment = 6;

  // Description missing in models
  PatternFlowIpv6NextHeaderCounter decrement = 7;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv6NextHeaderMetricTag metric_tags = 8;
}

// integer counter pattern
message PatternFlowIpv6HopLimitCounter {

  // Description missing in models
  // default = 64
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv6HopLimitMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 8
  optional uint32 length = 3;
}

// Hop limit
message PatternFlowIpv6HopLimit {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 64
  optional uint32 value = 2;

  // Description missing in models
  // default = [64]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowIpv6HopLimitCounter increment = 5;

  // Description missing in models
  PatternFlowIpv6HopLimitCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv6HopLimitMetricTag metric_tags = 7;
}

// ipv6 counter pattern
message PatternFlowIpv6SrcCounter {

  // Description missing in models
  // default = ::0
  optional string start = 1;

  // Description missing in models
  // default = ::1
  optional string step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv6SrcMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 128
  optional uint32 length = 3;
}

// Source address
message PatternFlowIpv6Src {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
      auto = 1;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = ::0
  optional string value = 2;

  // Description missing in models
  // default = ['::0']
  repeated string values = 3;

  // Description missing in models
  PatternFlowIpv6SrcCounter increment = 5;

  // Description missing in models
  PatternFlowIpv6SrcCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv6SrcMetricTag metric_tags = 7;

  // Description missing in models
  FlowIpv6Auto auto = 8;
}

// ipv6 counter pattern
message PatternFlowIpv6DstCounter {

  // Description missing in models
  // default = ::0
  optional string start = 1;

  // Description missing in models
  // default = ::1
  optional string step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIpv6DstMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 128
  optional uint32 length = 3;
}

// Destination address
message PatternFlowIpv6Dst {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
      auto = 1;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = ::0
  optional string value = 2;

  // Description missing in models
  // default = ['::0']
  repeated string values = 3;

  // Description missing in models
  PatternFlowIpv6DstCounter increment = 5;

  // Description missing in models
  PatternFlowIpv6DstCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIpv6DstMetricTag metric_tags = 7;

  // Description missing in models
  FlowIpv6Auto auto = 8;
}

// mac counter pattern
message PatternFlowPfcPauseDstCounter {

  // Description missing in models
  // default = 01:80:c2:00:00:01
  optional string start = 1;

  // Description missing in models
  // default = 00:00:00:00:00:01
  optional string step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowPfcPauseDstMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 48
  optional uint32 length = 3;
}

// Destination MAC address
message PatternFlowPfcPauseDst {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 01:80:c2:00:00:01
  optional string value = 2;

  // Description missing in models
  // default = ['01:80:c2:00:00:01']
  repeated string values = 3;

  // Description missing in models
  PatternFlowPfcPauseDstCounter increment = 5;

  // Description missing in models
  PatternFlowPfcPauseDstCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowPfcPauseDstMetricTag metric_tags = 7;
}

// mac counter pattern
message PatternFlowPfcPauseSrcCounter {

  // Description missing in models
  // default = 00:00:00:00:00:00
  optional string start = 1;

  // Description missing in models
  // default = 00:00:00:00:00:01
  optional string step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowPfcPauseSrcMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 48
  optional uint32 length = 3;
}

// Source MAC address
message PatternFlowPfcPauseSrc {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 00:00:00:00:00:00
  optional string value = 2;

  // Description missing in models
  // default = ['00:00:00:00:00:00']
  repeated string values = 3;

  // Description missing in models
  PatternFlowPfcPauseSrcCounter increment = 5;

  // Description missing in models
  PatternFlowPfcPauseSrcCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowPfcPauseSrcMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowPfcPauseEtherTypeCounter {

  // Description missing in models
  // default = 34824
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowPfcPauseEtherTypeMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Ethernet type
message PatternFlowPfcPauseEtherType {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 34824
  optional uint32 value = 2;

  // Description missing in models
  // default = [34824]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowPfcPauseEtherTypeCounter increment = 5;

  // Description missing in models
  PatternFlowPfcPauseEtherTypeCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowPfcPauseEtherTypeMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowPfcPauseControlOpCodeCounter {

  // Description missing in models
  // default = 257
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowPfcPauseControlOpCodeMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Control operation code
message PatternFlowPfcPauseControlOpCode {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 257
  optional uint32 value = 2;

  // Description missing in models
  // default = [257]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowPfcPauseControlOpCodeCounter increment = 5;

  // Description missing in models
  PatternFlowPfcPauseControlOpCodeCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowPfcPauseControlOpCodeMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowPfcPauseClassEnableVectorCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowPfcPauseClassEnableVectorMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Destination
message PatternFlowPfcPauseClassEnableVector {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowPfcPauseClassEnableVectorCounter increment = 5;

  // Description missing in models
  PatternFlowPfcPauseClassEnableVectorCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowPfcPauseClassEnableVectorMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowPfcPausePauseClass0Counter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowPfcPausePauseClass0MetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Pause class 0
message PatternFlowPfcPausePauseClass0 {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowPfcPausePauseClass0Counter increment = 5;

  // Description missing in models
  PatternFlowPfcPausePauseClass0Counter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowPfcPausePauseClass0MetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowPfcPausePauseClass1Counter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowPfcPausePauseClass1MetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Pause class 1
message PatternFlowPfcPausePauseClass1 {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowPfcPausePauseClass1Counter increment = 5;

  // Description missing in models
  PatternFlowPfcPausePauseClass1Counter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowPfcPausePauseClass1MetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowPfcPausePauseClass2Counter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowPfcPausePauseClass2MetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Pause class 2
message PatternFlowPfcPausePauseClass2 {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowPfcPausePauseClass2Counter increment = 5;

  // Description missing in models
  PatternFlowPfcPausePauseClass2Counter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowPfcPausePauseClass2MetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowPfcPausePauseClass3Counter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowPfcPausePauseClass3MetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Pause class 3
message PatternFlowPfcPausePauseClass3 {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowPfcPausePauseClass3Counter increment = 5;

  // Description missing in models
  PatternFlowPfcPausePauseClass3Counter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowPfcPausePauseClass3MetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowPfcPausePauseClass4Counter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowPfcPausePauseClass4MetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Pause class 4
message PatternFlowPfcPausePauseClass4 {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowPfcPausePauseClass4Counter increment = 5;

  // Description missing in models
  PatternFlowPfcPausePauseClass4Counter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowPfcPausePauseClass4MetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowPfcPausePauseClass5Counter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowPfcPausePauseClass5MetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Pause class 5
message PatternFlowPfcPausePauseClass5 {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowPfcPausePauseClass5Counter increment = 5;

  // Description missing in models
  PatternFlowPfcPausePauseClass5Counter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowPfcPausePauseClass5MetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowPfcPausePauseClass6Counter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowPfcPausePauseClass6MetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Pause class 6
message PatternFlowPfcPausePauseClass6 {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowPfcPausePauseClass6Counter increment = 5;

  // Description missing in models
  PatternFlowPfcPausePauseClass6Counter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowPfcPausePauseClass6MetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowPfcPausePauseClass7Counter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowPfcPausePauseClass7MetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Pause class 7
message PatternFlowPfcPausePauseClass7 {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowPfcPausePauseClass7Counter increment = 5;

  // Description missing in models
  PatternFlowPfcPausePauseClass7Counter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowPfcPausePauseClass7MetricTag metric_tags = 7;
}

// mac counter pattern
message PatternFlowEthernetPauseDstCounter {

  // Description missing in models
  // default = 01:80:c2:00:00:01
  optional string start = 1;

  // Description missing in models
  // default = 00:00:00:00:00:01
  optional string step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowEthernetPauseDstMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 48
  optional uint32 length = 3;
}

// Destination MAC address
message PatternFlowEthernetPauseDst {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 01:80:c2:00:00:01
  optional string value = 2;

  // Description missing in models
  // default = ['01:80:c2:00:00:01']
  repeated string values = 3;

  // Description missing in models
  PatternFlowEthernetPauseDstCounter increment = 5;

  // Description missing in models
  PatternFlowEthernetPauseDstCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowEthernetPauseDstMetricTag metric_tags = 7;
}

// mac counter pattern
message PatternFlowEthernetPauseSrcCounter {

  // Description missing in models
  // default = 00:00:00:00:00:00
  optional string start = 1;

  // Description missing in models
  // default = 00:00:00:00:00:01
  optional string step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowEthernetPauseSrcMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 48
  optional uint32 length = 3;
}

// Source MAC address
message PatternFlowEthernetPauseSrc {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 00:00:00:00:00:00
  optional string value = 2;

  // Description missing in models
  // default = ['00:00:00:00:00:00']
  repeated string values = 3;

  // Description missing in models
  PatternFlowEthernetPauseSrcCounter increment = 5;

  // Description missing in models
  PatternFlowEthernetPauseSrcCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowEthernetPauseSrcMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowEthernetPauseEtherTypeCounter {

  // Description missing in models
  // default = 34824
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowEthernetPauseEtherTypeMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Ethernet type
message PatternFlowEthernetPauseEtherType {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 34824
  optional uint32 value = 2;

  // Description missing in models
  // default = [34824]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowEthernetPauseEtherTypeCounter increment = 5;

  // Description missing in models
  PatternFlowEthernetPauseEtherTypeCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowEthernetPauseEtherTypeMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowEthernetPauseControlOpCodeCounter {

  // Description missing in models
  // default = 1
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowEthernetPauseControlOpCodeMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Control operation code
message PatternFlowEthernetPauseControlOpCode {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 1
  optional uint32 value = 2;

  // Description missing in models
  // default = [1]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowEthernetPauseControlOpCodeCounter increment = 5;

  // Description missing in models
  PatternFlowEthernetPauseControlOpCodeCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowEthernetPauseControlOpCodeMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowEthernetPauseTimeCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowEthernetPauseTimeMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Time
message PatternFlowEthernetPauseTime {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowEthernetPauseTimeCounter increment = 5;

  // Description missing in models
  PatternFlowEthernetPauseTimeCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowEthernetPauseTimeMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowTcpSrcPortCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowTcpSrcPortMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// integer random pattern
message PatternFlowTcpSrcPortRandom {

  // The minimum possible value generated by the random value generator.
  // default = 0
  optional uint32 min = 1;

  // The maximum possible value generated by the random value generator.
  // default = 65535
  optional uint32 max = 2;

  // The seed value is used to initialize the random number generator to a deterministic
  // state. If the user provides a seed value of 0, the implementation will generate a
  // sequence of non-deterministic random values. For any other seed value, the sequence
  // of random numbers will be generated in a deterministic manner (specific to the implementation).
  // default = 1
  optional uint32 seed = 3;

  // The total number of values to be generated by the random value generator.
  // default = 1
  optional uint32 count = 4;
}

// Source port
message PatternFlowTcpSrcPort {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
      random = 6;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowTcpSrcPortCounter increment = 5;

  // Description missing in models
  PatternFlowTcpSrcPortCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowTcpSrcPortMetricTag metric_tags = 7;

  // Description missing in models
  PatternFlowTcpSrcPortRandom random = 8;
}

// integer counter pattern
message PatternFlowTcpDstPortCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowTcpDstPortMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// integer random pattern
message PatternFlowTcpDstPortRandom {

  // The minimum possible value generated by the random value generator.
  // default = 0
  optional uint32 min = 1;

  // The maximum possible value generated by the random value generator.
  // default = 65535
  optional uint32 max = 2;

  // The seed value is used to initialize the random number generator to a deterministic
  // state. If the user provides a seed value of 0, the implementation will generate a
  // sequence of non-deterministic random values. For any other seed value, the sequence
  // of random numbers will be generated in a deterministic manner (specific to the implementation).
  // default = 1
  optional uint32 seed = 3;

  // The total number of values to be generated by the random value generator.
  // default = 1
  optional uint32 count = 4;
}

// Destination port
message PatternFlowTcpDstPort {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
      random = 6;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowTcpDstPortCounter increment = 5;

  // Description missing in models
  PatternFlowTcpDstPortCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowTcpDstPortMetricTag metric_tags = 7;

  // Description missing in models
  PatternFlowTcpDstPortRandom random = 8;
}

// integer counter pattern
message PatternFlowTcpSeqNumCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowTcpSeqNumMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 32
  optional uint32 length = 3;
}

// Sequence number
message PatternFlowTcpSeqNum {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowTcpSeqNumCounter increment = 5;

  // Description missing in models
  PatternFlowTcpSeqNumCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowTcpSeqNumMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowTcpAckNumCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowTcpAckNumMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 32
  optional uint32 length = 3;
}

// Acknowledgement number
message PatternFlowTcpAckNum {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowTcpAckNumCounter increment = 5;

  // Description missing in models
  PatternFlowTcpAckNumCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowTcpAckNumMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowTcpDataOffsetCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowTcpDataOffsetMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 4
  optional uint32 length = 3;
}

// The number of 32 bit words in the TCP header. This indicates where the data begins.
message PatternFlowTcpDataOffset {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowTcpDataOffsetCounter increment = 5;

  // Description missing in models
  PatternFlowTcpDataOffsetCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowTcpDataOffsetMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowTcpEcnNsCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowTcpEcnNsMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// Explicit congestion notification, concealment protection.
message PatternFlowTcpEcnNs {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowTcpEcnNsCounter increment = 5;

  // Description missing in models
  PatternFlowTcpEcnNsCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowTcpEcnNsMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowTcpEcnCwrCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowTcpEcnCwrMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// Explicit congestion notification, congestion window reduced.
message PatternFlowTcpEcnCwr {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowTcpEcnCwrCounter increment = 5;

  // Description missing in models
  PatternFlowTcpEcnCwrCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowTcpEcnCwrMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowTcpEcnEchoCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowTcpEcnEchoMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// Explicit congestion notification, echo. 1 indicates the peer is ecn capable. 0 indicates
// that a packet with ipv4.ecn = 11 in the ip header was  received during normal transmission.
message PatternFlowTcpEcnEcho {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowTcpEcnEchoCounter increment = 5;

  // Description missing in models
  PatternFlowTcpEcnEchoCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowTcpEcnEchoMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowTcpCtlUrgCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowTcpCtlUrgMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// A value of 1 indicates that the urgent pointer field is significant.
message PatternFlowTcpCtlUrg {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowTcpCtlUrgCounter increment = 5;

  // Description missing in models
  PatternFlowTcpCtlUrgCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowTcpCtlUrgMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowTcpCtlAckCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowTcpCtlAckMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// A value of 1 indicates that the ackknowledgment field is significant.
message PatternFlowTcpCtlAck {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowTcpCtlAckCounter increment = 5;

  // Description missing in models
  PatternFlowTcpCtlAckCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowTcpCtlAckMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowTcpCtlPshCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowTcpCtlPshMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// Asks to push the buffered data to the receiving application.
message PatternFlowTcpCtlPsh {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowTcpCtlPshCounter increment = 5;

  // Description missing in models
  PatternFlowTcpCtlPshCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowTcpCtlPshMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowTcpCtlRstCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowTcpCtlRstMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// Reset the connection.
message PatternFlowTcpCtlRst {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowTcpCtlRstCounter increment = 5;

  // Description missing in models
  PatternFlowTcpCtlRstCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowTcpCtlRstMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowTcpCtlSynCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowTcpCtlSynMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// Synchronize sequenece numbers.
message PatternFlowTcpCtlSyn {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowTcpCtlSynCounter increment = 5;

  // Description missing in models
  PatternFlowTcpCtlSynCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowTcpCtlSynMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowTcpCtlFinCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowTcpCtlFinMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// Last packet from the sender.
message PatternFlowTcpCtlFin {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowTcpCtlFinCounter increment = 5;

  // Description missing in models
  PatternFlowTcpCtlFinCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowTcpCtlFinMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowTcpWindowCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowTcpWindowMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Tcp connection window.
message PatternFlowTcpWindow {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowTcpWindowCounter increment = 5;

  // Description missing in models
  PatternFlowTcpWindowCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowTcpWindowMetricTag metric_tags = 7;
}

// The one's complement of the one's complement sum of all 16 bit words in header and
// text.  An all-zero value means that no checksum will be transmitted.   While computing
// the checksum, the checksum field itself is replaced with zeros.
message PatternFlowTcpChecksum {

  message Choice {
    enum Enum {
      unspecified = 0;
      generated = 1;
      custom = 2;
    }
  }
  // The type of checksum
  // default = Choice.Enum.generated
  optional Choice.Enum choice = 1;

  message Generated {
    enum Enum {
      unspecified = 0;
      good = 1;
      bad = 2;
    }
  }
  // A system generated checksum value
  // default = Generated.Enum.good
  optional Generated.Enum generated = 2;

  // A custom checksum value
  optional uint32 custom = 3;
}

// integer counter pattern
message PatternFlowUdpSrcPortCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowUdpSrcPortMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// integer random pattern
message PatternFlowUdpSrcPortRandom {

  // The minimum possible value generated by the random value generator.
  // default = 0
  optional uint32 min = 1;

  // The maximum possible value generated by the random value generator.
  // default = 65535
  optional uint32 max = 2;

  // The seed value is used to initialize the random number generator to a deterministic
  // state. If the user provides a seed value of 0, the implementation will generate a
  // sequence of non-deterministic random values. For any other seed value, the sequence
  // of random numbers will be generated in a deterministic manner (specific to the implementation).
  // default = 1
  optional uint32 seed = 3;

  // The total number of values to be generated by the random value generator.
  // default = 1
  optional uint32 count = 4;
}

// Source port
message PatternFlowUdpSrcPort {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
      random = 6;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowUdpSrcPortCounter increment = 5;

  // Description missing in models
  PatternFlowUdpSrcPortCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowUdpSrcPortMetricTag metric_tags = 7;

  // Description missing in models
  PatternFlowUdpSrcPortRandom random = 8;
}

// integer counter pattern
message PatternFlowUdpDstPortCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowUdpDstPortMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// integer random pattern
message PatternFlowUdpDstPortRandom {

  // The minimum possible value generated by the random value generator.
  // default = 0
  optional uint32 min = 1;

  // The maximum possible value generated by the random value generator.
  // default = 65535
  optional uint32 max = 2;

  // The seed value is used to initialize the random number generator to a deterministic
  // state. If the user provides a seed value of 0, the implementation will generate a
  // sequence of non-deterministic random values. For any other seed value, the sequence
  // of random numbers will be generated in a deterministic manner (specific to the implementation).
  // default = 1
  optional uint32 seed = 3;

  // The total number of values to be generated by the random value generator.
  // default = 1
  optional uint32 count = 4;
}

// Destination port
message PatternFlowUdpDstPort {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
      random = 6;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowUdpDstPortCounter increment = 5;

  // Description missing in models
  PatternFlowUdpDstPortCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowUdpDstPortMetricTag metric_tags = 7;

  // Description missing in models
  PatternFlowUdpDstPortRandom random = 8;
}

// integer counter pattern
message PatternFlowUdpLengthCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowUdpLengthMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Length
message PatternFlowUdpLength {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowUdpLengthCounter increment = 5;

  // Description missing in models
  PatternFlowUdpLengthCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowUdpLengthMetricTag metric_tags = 7;
}

// UDP checksum
message PatternFlowUdpChecksum {

  message Choice {
    enum Enum {
      unspecified = 0;
      generated = 1;
      custom = 2;
    }
  }
  // The type of checksum
  // default = Choice.Enum.generated
  optional Choice.Enum choice = 1;

  message Generated {
    enum Enum {
      unspecified = 0;
      good = 1;
      bad = 2;
    }
  }
  // A system generated checksum value
  // default = Generated.Enum.good
  optional Generated.Enum generated = 2;

  // A custom checksum value
  optional uint32 custom = 3;
}

// integer counter pattern
message PatternFlowGreChecksumPresentCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGreChecksumPresentMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// Checksum present bit
message PatternFlowGreChecksumPresent {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowGreChecksumPresentCounter increment = 5;

  // Description missing in models
  PatternFlowGreChecksumPresentCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGreChecksumPresentMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGreReserved0Counter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGreReserved0MetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 12
  optional uint32 length = 3;
}

// Reserved bits
message PatternFlowGreReserved0 {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowGreReserved0Counter increment = 5;

  // Description missing in models
  PatternFlowGreReserved0Counter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGreReserved0MetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGreVersionCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGreVersionMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 3
  optional uint32 length = 3;
}

// GRE version number
message PatternFlowGreVersion {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowGreVersionCounter increment = 5;

  // Description missing in models
  PatternFlowGreVersionCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGreVersionMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGreProtocolCounter {

  // Description missing in models
  // default = 2048
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGreProtocolMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Protocol type of encapsulated payload
message PatternFlowGreProtocol {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
      auto = 1;
    }
  }
  // Description missing in models
  // default = Choice.Enum.auto
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 2048
  optional uint32 value = 2;

  // Description missing in models
  // default = [2048]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowGreProtocolCounter increment = 5;

  // Description missing in models
  PatternFlowGreProtocolCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGreProtocolMetricTag metric_tags = 7;

  // The OTG implementation can provide a system generated
  // value for this property. If the OTG is unable to generate a value
  // the default value must be used.
  // default = 2048
  optional uint32 auto = 8;
}

// Optional checksum of GRE header and payload. Only present if the checksum_present
// bit is set.
message PatternFlowGreChecksum {

  message Choice {
    enum Enum {
      unspecified = 0;
      generated = 1;
      custom = 2;
    }
  }
  // The type of checksum
  // default = Choice.Enum.generated
  optional Choice.Enum choice = 1;

  message Generated {
    enum Enum {
      unspecified = 0;
      good = 1;
      bad = 2;
    }
  }
  // A system generated checksum value
  // default = Generated.Enum.good
  optional Generated.Enum generated = 2;

  // A custom checksum value
  optional uint32 custom = 3;
}

// integer counter pattern
message PatternFlowGreReserved1Counter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGreReserved1MetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Optional reserved field. Only present if the checksum_present bit is set.
message PatternFlowGreReserved1 {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowGreReserved1Counter increment = 5;

  // Description missing in models
  PatternFlowGreReserved1Counter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGreReserved1MetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGtpv1VersionCounter {

  // Description missing in models
  // default = 1
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGtpv1VersionMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 3
  optional uint32 length = 3;
}

// GTPv1 version
message PatternFlowGtpv1Version {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 1
  optional uint32 value = 2;

  // Description missing in models
  // default = [1]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowGtpv1VersionCounter increment = 5;

  // Description missing in models
  PatternFlowGtpv1VersionCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGtpv1VersionMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGtpv1ProtocolTypeCounter {

  // Description missing in models
  // default = 1
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGtpv1ProtocolTypeMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// Protocol type, GTP is 1, GTP' is 0
message PatternFlowGtpv1ProtocolType {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 1
  optional uint32 value = 2;

  // Description missing in models
  // default = [1]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowGtpv1ProtocolTypeCounter increment = 5;

  // Description missing in models
  PatternFlowGtpv1ProtocolTypeCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGtpv1ProtocolTypeMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGtpv1ReservedCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGtpv1ReservedMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// Reserved field
message PatternFlowGtpv1Reserved {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowGtpv1ReservedCounter increment = 5;

  // Description missing in models
  PatternFlowGtpv1ReservedCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGtpv1ReservedMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGtpv1EFlagCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGtpv1EFlagMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// Extension header field present
message PatternFlowGtpv1EFlag {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowGtpv1EFlagCounter increment = 5;

  // Description missing in models
  PatternFlowGtpv1EFlagCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGtpv1EFlagMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGtpv1SFlagCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGtpv1SFlagMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// Sequence number field present
message PatternFlowGtpv1SFlag {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowGtpv1SFlagCounter increment = 5;

  // Description missing in models
  PatternFlowGtpv1SFlagCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGtpv1SFlagMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGtpv1PnFlagCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGtpv1PnFlagMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// N-PDU field present
message PatternFlowGtpv1PnFlag {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowGtpv1PnFlagCounter increment = 5;

  // Description missing in models
  PatternFlowGtpv1PnFlagCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGtpv1PnFlagMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGtpv1MessageTypeCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGtpv1MessageTypeMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 8
  optional uint32 length = 3;
}

// The type of GTP message Different types of messages are defined in 3GPP TS 29.060
// section 7.1
message PatternFlowGtpv1MessageType {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowGtpv1MessageTypeCounter increment = 5;

  // Description missing in models
  PatternFlowGtpv1MessageTypeCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGtpv1MessageTypeMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGtpv1MessageLengthCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGtpv1MessageLengthMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// The length of the payload (the bytes following the mandatory 8-byte GTP header) in
// bytes that includes any optional fields
message PatternFlowGtpv1MessageLength {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowGtpv1MessageLengthCounter increment = 5;

  // Description missing in models
  PatternFlowGtpv1MessageLengthCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGtpv1MessageLengthMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGtpv1TeidCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGtpv1TeidMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 32
  optional uint32 length = 3;
}

// Tunnel endpoint identifier (TEID) used to multiplex connections in the same GTP tunnel
message PatternFlowGtpv1Teid {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowGtpv1TeidCounter increment = 5;

  // Description missing in models
  PatternFlowGtpv1TeidCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGtpv1TeidMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGtpv1SquenceNumberCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGtpv1SquenceNumberMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Sequence number. Exists if any of the e_flag, s_flag, or pn_flag bits are on.  Must
// be interpreted only if the s_flag bit is on.
message PatternFlowGtpv1SquenceNumber {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowGtpv1SquenceNumberCounter increment = 5;

  // Description missing in models
  PatternFlowGtpv1SquenceNumberCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGtpv1SquenceNumberMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGtpv1NPduNumberCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGtpv1NPduNumberMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 8
  optional uint32 length = 3;
}

// N-PDU number. Exists if any of the e_flag, s_flag, or pn_flag bits are on.  Must
// be interpreted only if the pn_flag bit is on.
message PatternFlowGtpv1NPduNumber {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowGtpv1NPduNumberCounter increment = 5;

  // Description missing in models
  PatternFlowGtpv1NPduNumberCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGtpv1NPduNumberMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGtpv1NextExtensionHeaderTypeCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGtpv1NextExtensionHeaderTypeMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 8
  optional uint32 length = 3;
}

// Next extension header. Exists if any of the e_flag, s_flag, or pn_flag bits are on.
// Must be interpreted only if the e_flag bit is on.
message PatternFlowGtpv1NextExtensionHeaderType {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowGtpv1NextExtensionHeaderTypeCounter increment = 5;

  // Description missing in models
  PatternFlowGtpv1NextExtensionHeaderTypeCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGtpv1NextExtensionHeaderTypeMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGtpExtensionExtensionLengthCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGtpExtensionExtensionLengthMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 8
  optional uint32 length = 3;
}

// This field states the length of this extension header,  including the length, the
// contents, and the next extension header field, in 4-octet units, so the length of
// the extension must  always be a multiple of 4.
message PatternFlowGtpExtensionExtensionLength {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowGtpExtensionExtensionLengthCounter increment = 5;

  // Description missing in models
  PatternFlowGtpExtensionExtensionLengthCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGtpExtensionExtensionLengthMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGtpExtensionContentsCounter {

  // Description missing in models
  // default = 0
  optional uint64 start = 1;

  // Description missing in models
  // default = 1
  optional uint64 step = 2;

  // Description missing in models
  // default = 1
  optional uint64 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGtpExtensionContentsMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint64 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 48
  optional uint64 length = 3;
}

// The extension header contents
message PatternFlowGtpExtensionContents {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint64 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint64 values = 3;

  // Description missing in models
  PatternFlowGtpExtensionContentsCounter increment = 5;

  // Description missing in models
  PatternFlowGtpExtensionContentsCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGtpExtensionContentsMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGtpExtensionNextExtensionHeaderCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGtpExtensionNextExtensionHeaderMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 8
  optional uint32 length = 3;
}

// It states the type of the next extension, or 0 if no next  extension exists.  This
// permits chaining several next extension headers.
message PatternFlowGtpExtensionNextExtensionHeader {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowGtpExtensionNextExtensionHeaderCounter increment = 5;

  // Description missing in models
  PatternFlowGtpExtensionNextExtensionHeaderCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGtpExtensionNextExtensionHeaderMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGtpv2VersionCounter {

  // Description missing in models
  // default = 2
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGtpv2VersionMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 3
  optional uint32 length = 3;
}

// Version number
message PatternFlowGtpv2Version {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 2
  optional uint32 value = 2;

  // Description missing in models
  // default = [2]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowGtpv2VersionCounter increment = 5;

  // Description missing in models
  PatternFlowGtpv2VersionCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGtpv2VersionMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGtpv2PiggybackingFlagCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGtpv2PiggybackingFlagMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// If piggybacking_flag is set to 1 then another GTP-C message with its own header shall
// be present at the end of the current message
message PatternFlowGtpv2PiggybackingFlag {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowGtpv2PiggybackingFlagCounter increment = 5;

  // Description missing in models
  PatternFlowGtpv2PiggybackingFlagCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGtpv2PiggybackingFlagMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGtpv2TeidFlagCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGtpv2TeidFlagMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// If teid_flag is set to 1 then the TEID field will be present  between the message
// length and the sequence number. All messages except Echo and Echo reply require TEID
// to be present
message PatternFlowGtpv2TeidFlag {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowGtpv2TeidFlagCounter increment = 5;

  // Description missing in models
  PatternFlowGtpv2TeidFlagCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGtpv2TeidFlagMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGtpv2Spare1Counter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGtpv2Spare1MetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 3
  optional uint32 length = 3;
}

// A 3-bit reserved field (must be 0).
message PatternFlowGtpv2Spare1 {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowGtpv2Spare1Counter increment = 5;

  // Description missing in models
  PatternFlowGtpv2Spare1Counter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGtpv2Spare1MetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGtpv2MessageTypeCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGtpv2MessageTypeMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 8
  optional uint32 length = 3;
}

// An 8-bit field that indicates the type of GTP message. Different types of messages
// are defined in 3GPP TS 29.060 section 7.1
message PatternFlowGtpv2MessageType {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowGtpv2MessageTypeCounter increment = 5;

  // Description missing in models
  PatternFlowGtpv2MessageTypeCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGtpv2MessageTypeMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGtpv2MessageLengthCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGtpv2MessageLengthMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// A 16-bit field that indicates the length of the payload in bytes, excluding the mandatory
// GTP-c header (first 4 bytes). Includes the TEID and sequence_number if they are present.
message PatternFlowGtpv2MessageLength {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowGtpv2MessageLengthCounter increment = 5;

  // Description missing in models
  PatternFlowGtpv2MessageLengthCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGtpv2MessageLengthMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGtpv2TeidCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGtpv2TeidMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 32
  optional uint32 length = 3;
}

// Tunnel endpoint identifier. A 32-bit (4-octet) field used to multiplex different
// connections in the same GTP tunnel. Is present only if the teid_flag is set.
message PatternFlowGtpv2Teid {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowGtpv2TeidCounter increment = 5;

  // Description missing in models
  PatternFlowGtpv2TeidCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGtpv2TeidMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGtpv2SequenceNumberCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGtpv2SequenceNumberMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 24
  optional uint32 length = 3;
}

// The sequence number
message PatternFlowGtpv2SequenceNumber {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowGtpv2SequenceNumberCounter increment = 5;

  // Description missing in models
  PatternFlowGtpv2SequenceNumberCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGtpv2SequenceNumberMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowGtpv2Spare2Counter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowGtpv2Spare2MetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 8
  optional uint32 length = 3;
}

// Reserved field
message PatternFlowGtpv2Spare2 {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowGtpv2Spare2Counter increment = 5;

  // Description missing in models
  PatternFlowGtpv2Spare2Counter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowGtpv2Spare2MetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowArpHardwareTypeCounter {

  // Description missing in models
  // default = 1
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowArpHardwareTypeMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// Network link protocol type
message PatternFlowArpHardwareType {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 1
  optional uint32 value = 2;

  // Description missing in models
  // default = [1]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowArpHardwareTypeCounter increment = 5;

  // Description missing in models
  PatternFlowArpHardwareTypeCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowArpHardwareTypeMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowArpProtocolTypeCounter {

  // Description missing in models
  // default = 2048
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowArpProtocolTypeMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// The internetwork protocol for which the ARP request is intended
message PatternFlowArpProtocolType {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 2048
  optional uint32 value = 2;

  // Description missing in models
  // default = [2048]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowArpProtocolTypeCounter increment = 5;

  // Description missing in models
  PatternFlowArpProtocolTypeCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowArpProtocolTypeMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowArpHardwareLengthCounter {

  // Description missing in models
  // default = 6
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowArpHardwareLengthMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 8
  optional uint32 length = 3;
}

// Length (in octets) of a hardware address
message PatternFlowArpHardwareLength {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 6
  optional uint32 value = 2;

  // Description missing in models
  // default = [6]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowArpHardwareLengthCounter increment = 5;

  // Description missing in models
  PatternFlowArpHardwareLengthCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowArpHardwareLengthMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowArpProtocolLengthCounter {

  // Description missing in models
  // default = 4
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowArpProtocolLengthMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 8
  optional uint32 length = 3;
}

// Length (in octets) of internetwork addresses
message PatternFlowArpProtocolLength {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 4
  optional uint32 value = 2;

  // Description missing in models
  // default = [4]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowArpProtocolLengthCounter increment = 5;

  // Description missing in models
  PatternFlowArpProtocolLengthCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowArpProtocolLengthMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowArpOperationCounter {

  // Description missing in models
  // default = 1
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowArpOperationMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// The operation that the sender is performing
message PatternFlowArpOperation {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 1
  optional uint32 value = 2;

  // Description missing in models
  // default = [1]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowArpOperationCounter increment = 5;

  // Description missing in models
  PatternFlowArpOperationCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowArpOperationMetricTag metric_tags = 7;
}

// mac counter pattern
message PatternFlowArpSenderHardwareAddrCounter {

  // Description missing in models
  // default = 00:00:00:00:00:00
  optional string start = 1;

  // Description missing in models
  // default = 00:00:00:00:00:01
  optional string step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowArpSenderHardwareAddrMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 48
  optional uint32 length = 3;
}

// Media address of the sender
message PatternFlowArpSenderHardwareAddr {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 00:00:00:00:00:00
  optional string value = 2;

  // Description missing in models
  // default = ['00:00:00:00:00:00']
  repeated string values = 3;

  // Description missing in models
  PatternFlowArpSenderHardwareAddrCounter increment = 5;

  // Description missing in models
  PatternFlowArpSenderHardwareAddrCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowArpSenderHardwareAddrMetricTag metric_tags = 7;
}

// ipv4 counter pattern
message PatternFlowArpSenderProtocolAddrCounter {

  // Description missing in models
  // default = 0.0.0.0
  optional string start = 1;

  // Description missing in models
  // default = 0.0.0.1
  optional string step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowArpSenderProtocolAddrMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 32
  optional uint32 length = 3;
}

// Internetwork address of the sender
message PatternFlowArpSenderProtocolAddr {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0.0.0.0
  optional string value = 2;

  // Description missing in models
  // default = ['0.0.0.0']
  repeated string values = 3;

  // Description missing in models
  PatternFlowArpSenderProtocolAddrCounter increment = 5;

  // Description missing in models
  PatternFlowArpSenderProtocolAddrCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowArpSenderProtocolAddrMetricTag metric_tags = 7;
}

// mac counter pattern
message PatternFlowArpTargetHardwareAddrCounter {

  // Description missing in models
  // default = 00:00:00:00:00:00
  optional string start = 1;

  // Description missing in models
  // default = 00:00:00:00:00:01
  optional string step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowArpTargetHardwareAddrMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 48
  optional uint32 length = 3;
}

// Media address of the target
message PatternFlowArpTargetHardwareAddr {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 00:00:00:00:00:00
  optional string value = 2;

  // Description missing in models
  // default = ['00:00:00:00:00:00']
  repeated string values = 3;

  // Description missing in models
  PatternFlowArpTargetHardwareAddrCounter increment = 5;

  // Description missing in models
  PatternFlowArpTargetHardwareAddrCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowArpTargetHardwareAddrMetricTag metric_tags = 7;
}

// ipv4 counter pattern
message PatternFlowArpTargetProtocolAddrCounter {

  // Description missing in models
  // default = 0.0.0.0
  optional string start = 1;

  // Description missing in models
  // default = 0.0.0.1
  optional string step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowArpTargetProtocolAddrMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 32
  optional uint32 length = 3;
}

// Internetwork address of the target
message PatternFlowArpTargetProtocolAddr {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0.0.0.0
  optional string value = 2;

  // Description missing in models
  // default = ['0.0.0.0']
  repeated string values = 3;

  // Description missing in models
  PatternFlowArpTargetProtocolAddrCounter increment = 5;

  // Description missing in models
  PatternFlowArpTargetProtocolAddrCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowArpTargetProtocolAddrMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIcmpEchoTypeCounter {

  // Description missing in models
  // default = 8
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIcmpEchoTypeMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 8
  optional uint32 length = 3;
}

// The type of ICMP echo packet
message PatternFlowIcmpEchoType {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 8
  optional uint32 value = 2;

  // Description missing in models
  // default = [8]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowIcmpEchoTypeCounter increment = 5;

  // Description missing in models
  PatternFlowIcmpEchoTypeCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIcmpEchoTypeMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIcmpEchoCodeCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIcmpEchoCodeMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 8
  optional uint32 length = 3;
}

// The ICMP subtype.  The default code for ICMP echo request and reply is 0.
message PatternFlowIcmpEchoCode {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowIcmpEchoCodeCounter increment = 5;

  // Description missing in models
  PatternFlowIcmpEchoCodeCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIcmpEchoCodeMetricTag metric_tags = 7;
}

// ICMP checksum
message PatternFlowIcmpEchoChecksum {

  message Choice {
    enum Enum {
      unspecified = 0;
      generated = 1;
      custom = 2;
    }
  }
  // The type of checksum
  // default = Choice.Enum.generated
  optional Choice.Enum choice = 1;

  message Generated {
    enum Enum {
      unspecified = 0;
      good = 1;
      bad = 2;
    }
  }
  // A system generated checksum value
  // default = Generated.Enum.good
  optional Generated.Enum generated = 2;

  // A custom checksum value
  optional uint32 custom = 3;
}

// integer counter pattern
message PatternFlowIcmpEchoIdentifierCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIcmpEchoIdentifierMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// ICMP identifier
message PatternFlowIcmpEchoIdentifier {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowIcmpEchoIdentifierCounter increment = 5;

  // Description missing in models
  PatternFlowIcmpEchoIdentifierCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIcmpEchoIdentifierMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIcmpEchoSequenceNumberCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIcmpEchoSequenceNumberMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// ICMP sequence number
message PatternFlowIcmpEchoSequenceNumber {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowIcmpEchoSequenceNumberCounter increment = 5;

  // Description missing in models
  PatternFlowIcmpEchoSequenceNumberCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIcmpEchoSequenceNumberMetricTag metric_tags = 7;
}

// ICMP checksum
message PatternFlowIcmpCommonChecksum {

  message Choice {
    enum Enum {
      unspecified = 0;
      generated = 1;
      custom = 2;
    }
  }
  // The type of checksum
  // default = Choice.Enum.generated
  optional Choice.Enum choice = 1;

  message Generated {
    enum Enum {
      unspecified = 0;
      good = 1;
      bad = 2;
    }
  }
  // A system generated checksum value
  // default = Generated.Enum.good
  optional Generated.Enum generated = 2;

  // A custom checksum value
  optional uint32 custom = 3;
}

// integer counter pattern
message PatternFlowIcmpNextFieldsIdentifierCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIcmpNextFieldsIdentifierMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// ICMP identifier
message PatternFlowIcmpNextFieldsIdentifier {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowIcmpNextFieldsIdentifierCounter increment = 5;

  // Description missing in models
  PatternFlowIcmpNextFieldsIdentifierCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIcmpNextFieldsIdentifierMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIcmpNextFieldsSequenceNumberCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIcmpNextFieldsSequenceNumberMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// ICMP sequence number
message PatternFlowIcmpNextFieldsSequenceNumber {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowIcmpNextFieldsSequenceNumberCounter increment = 5;

  // Description missing in models
  PatternFlowIcmpNextFieldsSequenceNumberCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIcmpNextFieldsSequenceNumberMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIcmpv6EchoTypeCounter {

  // Description missing in models
  // default = 128
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIcmpv6EchoTypeMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 8
  optional uint32 length = 3;
}

// ICMPv6 echo type
message PatternFlowIcmpv6EchoType {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 128
  optional uint32 value = 2;

  // Description missing in models
  // default = [128]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowIcmpv6EchoTypeCounter increment = 5;

  // Description missing in models
  PatternFlowIcmpv6EchoTypeCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIcmpv6EchoTypeMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIcmpv6EchoCodeCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIcmpv6EchoCodeMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 8
  optional uint32 length = 3;
}

// ICMPv6 echo sub type
message PatternFlowIcmpv6EchoCode {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowIcmpv6EchoCodeCounter increment = 5;

  // Description missing in models
  PatternFlowIcmpv6EchoCodeCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIcmpv6EchoCodeMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIcmpv6EchoIdentifierCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIcmpv6EchoIdentifierMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// ICMPv6 echo identifier
message PatternFlowIcmpv6EchoIdentifier {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowIcmpv6EchoIdentifierCounter increment = 5;

  // Description missing in models
  PatternFlowIcmpv6EchoIdentifierCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIcmpv6EchoIdentifierMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIcmpv6EchoSequenceNumberCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIcmpv6EchoSequenceNumberMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// ICMPv6 echo sequence number
message PatternFlowIcmpv6EchoSequenceNumber {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowIcmpv6EchoSequenceNumberCounter increment = 5;

  // Description missing in models
  PatternFlowIcmpv6EchoSequenceNumberCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIcmpv6EchoSequenceNumberMetricTag metric_tags = 7;
}

// ICMPv6 checksum
message PatternFlowIcmpv6EchoChecksum {

  message Choice {
    enum Enum {
      unspecified = 0;
      generated = 1;
      custom = 2;
    }
  }
  // The type of checksum
  // default = Choice.Enum.generated
  optional Choice.Enum choice = 1;

  message Generated {
    enum Enum {
      unspecified = 0;
      good = 1;
      bad = 2;
    }
  }
  // A system generated checksum value
  // default = Generated.Enum.good
  optional Generated.Enum generated = 2;

  // A custom checksum value
  optional uint32 custom = 3;
}

// ICMPv6 checksum
message PatternFlowIcmpv6CommonChecksum {

  message Choice {
    enum Enum {
      unspecified = 0;
      generated = 1;
      custom = 2;
    }
  }
  // The type of checksum
  // default = Choice.Enum.generated
  optional Choice.Enum choice = 1;

  message Generated {
    enum Enum {
      unspecified = 0;
      good = 1;
      bad = 2;
    }
  }
  // A system generated checksum value
  // default = Generated.Enum.good
  optional Generated.Enum generated = 2;

  // A custom checksum value
  optional uint32 custom = 3;
}

// integer counter pattern
message PatternFlowPppAddressCounter {

  // Description missing in models
  // default = 255
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowPppAddressMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 8
  optional uint32 length = 3;
}

// PPP address
message PatternFlowPppAddress {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 255
  optional uint32 value = 2;

  // Description missing in models
  // default = [255]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowPppAddressCounter increment = 5;

  // Description missing in models
  PatternFlowPppAddressCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowPppAddressMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowPppControlCounter {

  // Description missing in models
  // default = 3
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowPppControlMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 8
  optional uint32 length = 3;
}

// PPP control
message PatternFlowPppControl {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 3
  optional uint32 value = 2;

  // Description missing in models
  // default = [3]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowPppControlCounter increment = 5;

  // Description missing in models
  PatternFlowPppControlCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowPppControlMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowPppProtocolTypeCounter {

  // Description missing in models
  // default = 33
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowPppProtocolTypeMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 16
  optional uint32 length = 3;
}

// PPP protocol type
message PatternFlowPppProtocolType {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      auto = 1;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.auto
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 33
  optional uint32 value = 2;

  // Description missing in models
  // default = [33]
  repeated uint32 values = 3;

  // The OTG implementation can provide a system generated
  // value for this property. If the OTG is unable to generate a value
  // the default value must be used.
  // default = 33
  optional uint32 auto = 4;

  // Description missing in models
  PatternFlowPppProtocolTypeCounter increment = 6;

  // Description missing in models
  PatternFlowPppProtocolTypeCounter decrement = 7;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowPppProtocolTypeMetricTag metric_tags = 8;
}

// integer counter pattern
message PatternFlowIgmpv1VersionCounter {

  // Description missing in models
  // default = 1
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIgmpv1VersionMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 4
  optional uint32 length = 3;
}

// Version number
message PatternFlowIgmpv1Version {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 1
  optional uint32 value = 2;

  // Description missing in models
  // default = [1]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowIgmpv1VersionCounter increment = 5;

  // Description missing in models
  PatternFlowIgmpv1VersionCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIgmpv1VersionMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIgmpv1TypeCounter {

  // Description missing in models
  // default = 1
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIgmpv1TypeMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 4
  optional uint32 length = 3;
}

// Type of message
message PatternFlowIgmpv1Type {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 1
  optional uint32 value = 2;

  // Description missing in models
  // default = [1]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowIgmpv1TypeCounter increment = 5;

  // Description missing in models
  PatternFlowIgmpv1TypeCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIgmpv1TypeMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowIgmpv1UnusedCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIgmpv1UnusedMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 8
  optional uint32 length = 3;
}

// Unused
message PatternFlowIgmpv1Unused {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowIgmpv1UnusedCounter increment = 5;

  // Description missing in models
  PatternFlowIgmpv1UnusedCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIgmpv1UnusedMetricTag metric_tags = 7;
}

// Checksum
message PatternFlowIgmpv1Checksum {

  message Choice {
    enum Enum {
      unspecified = 0;
      generated = 1;
      custom = 2;
    }
  }
  // The type of checksum
  // default = Choice.Enum.generated
  optional Choice.Enum choice = 1;

  message Generated {
    enum Enum {
      unspecified = 0;
      good = 1;
      bad = 2;
    }
  }
  // A system generated checksum value
  // default = Generated.Enum.good
  optional Generated.Enum generated = 2;

  // A custom checksum value
  optional uint32 custom = 3;
}

// ipv4 counter pattern
message PatternFlowIgmpv1GroupAddressCounter {

  // Description missing in models
  // default = 0.0.0.0
  optional string start = 1;

  // Description missing in models
  // default = 0.0.0.1
  optional string step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowIgmpv1GroupAddressMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 32
  optional uint32 length = 3;
}

// Group address
message PatternFlowIgmpv1GroupAddress {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0.0.0.0
  optional string value = 2;

  // Description missing in models
  // default = ['0.0.0.0']
  repeated string values = 3;

  // Description missing in models
  PatternFlowIgmpv1GroupAddressCounter increment = 5;

  // Description missing in models
  PatternFlowIgmpv1GroupAddressCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowIgmpv1GroupAddressMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowMplsLabelCounter {

  // Description missing in models
  // default = 16
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowMplsLabelMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 20
  optional uint32 length = 3;
}

// Label of routers
message PatternFlowMplsLabel {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      auto = 1;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.auto
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 16
  optional uint32 value = 2;

  // Description missing in models
  // default = [16]
  repeated uint32 values = 3;

  // The OTG implementation can provide a system generated
  // value for this property. If the OTG is unable to generate a value
  // the default value must be used.
  // default = 16
  optional uint32 auto = 4;

  // Description missing in models
  PatternFlowMplsLabelCounter increment = 6;

  // Description missing in models
  PatternFlowMplsLabelCounter decrement = 7;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowMplsLabelMetricTag metric_tags = 8;
}

// integer counter pattern
message PatternFlowMplsTrafficClassCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowMplsTrafficClassMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 3
  optional uint32 length = 3;
}

// Traffic class
message PatternFlowMplsTrafficClass {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowMplsTrafficClassCounter increment = 5;

  // Description missing in models
  PatternFlowMplsTrafficClassCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowMplsTrafficClassMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowMplsBottomOfStackCounter {

  // Description missing in models
  // default = 1
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowMplsBottomOfStackMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 1
  optional uint32 length = 3;
}

// Bottom of stack
message PatternFlowMplsBottomOfStack {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      auto = 1;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.auto
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 1
  optional uint32 value = 2;

  // Description missing in models
  // default = [1]
  repeated uint32 values = 3;

  // The OTG implementation can provide a system generated
  // value for this property. If the OTG is unable to generate a value
  // the default value must be used.
  // default = 1
  optional uint32 auto = 4;

  // Description missing in models
  PatternFlowMplsBottomOfStackCounter increment = 6;

  // Description missing in models
  PatternFlowMplsBottomOfStackCounter decrement = 7;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowMplsBottomOfStackMetricTag metric_tags = 8;
}

// integer counter pattern
message PatternFlowMplsTimeToLiveCounter {

  // Description missing in models
  // default = 64
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Metric tag can be used to enable tracking portion of or all bits in a corresponding
// header field for metrics per each applicable value. These would appear as tagged
// metrics in corresponding flow metrics.
message PatternFlowMplsTimeToLiveMetricTag {

  // Name used to identify the metrics associated with the values applicable for configured
  // offset and length inside corresponding header field
  // required = true
  optional string name = 1;

  // Offset in bits relative to start of corresponding header field
  // default = 0
  optional uint32 offset = 2;

  // Number of bits to track for metrics starting from configured offset of corresponding
  // header field
  // default = 8
  optional uint32 length = 3;
}

// Time to live
message PatternFlowMplsTimeToLive {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 64
  optional uint32 value = 2;

  // Description missing in models
  // default = [64]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowMplsTimeToLiveCounter increment = 5;

  // Description missing in models
  PatternFlowMplsTimeToLiveCounter decrement = 6;

  // One or more metric tags can be used to enable tracking portion of or all bits in
  // a corresponding header field for metrics per each applicable value. These would appear
  // as tagged metrics in corresponding flow metrics.
  repeated PatternFlowMplsTimeToLiveMetricTag metric_tags = 7;
}

// integer counter pattern
message PatternFlowSnmpv2cVersionCounter {

  // Description missing in models
  // default = 1
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Version
message PatternFlowSnmpv2cVersion {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 1
  optional uint32 value = 2;

  // Description missing in models
  // default = [1]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowSnmpv2cVersionCounter increment = 5;

  // Description missing in models
  PatternFlowSnmpv2cVersionCounter decrement = 6;
}

// integer counter pattern
message PatternFlowSnmpv2cPDURequestIdCounter {

  // Description missing in models
  // default = 0
  optional int32 start = 1;

  // Description missing in models
  // default = 1
  optional int32 step = 2;

  // Description missing in models
  // default = 1
  optional int32 count = 3;
}

// Identifies a particular SNMP request.
// This index is echoed back in the response from the SNMP agent,
// allowing the SNMP manager to match an incoming response to the appropriate request.
// 
// - Encoding of this field follows ASN.1 X.690(section 8.3) specification.
// Refer: http://www.itu.int/ITU-T/asn1/
message PatternFlowSnmpv2cPDURequestId {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional int32 value = 2;

  // Description missing in models
  // default = [0]
  repeated int32 values = 3;

  // Description missing in models
  PatternFlowSnmpv2cPDURequestIdCounter increment = 5;

  // Description missing in models
  PatternFlowSnmpv2cPDURequestIdCounter decrement = 6;
}

// integer counter pattern
message PatternFlowSnmpv2cPDUErrorIndexCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// When Error Status is non-zero,  this field contains a pointer that specifies which
// object generated the error.  Always zero in a request.
message PatternFlowSnmpv2cPDUErrorIndex {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowSnmpv2cPDUErrorIndexCounter increment = 5;

  // Description missing in models
  PatternFlowSnmpv2cPDUErrorIndexCounter decrement = 6;
}

// integer counter pattern
message PatternFlowSnmpv2cBulkPDURequestIdCounter {

  // Description missing in models
  // default = 0
  optional int32 start = 1;

  // Description missing in models
  // default = 1
  optional int32 step = 2;

  // Description missing in models
  // default = 1
  optional int32 count = 3;
}

// Identifies a particular SNMP request.
// This index is echoed back in the response from the SNMP agent,
// allowing the SNMP manager to match an incoming response to the appropriate request.
// 
// - Encoding of this field follows ASN.1 X.690(section 8.3) specification.
// Refer: http://www.itu.int/ITU-T/asn1/
message PatternFlowSnmpv2cBulkPDURequestId {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional int32 value = 2;

  // Description missing in models
  // default = [0]
  repeated int32 values = 3;

  // Description missing in models
  PatternFlowSnmpv2cBulkPDURequestIdCounter increment = 5;

  // Description missing in models
  PatternFlowSnmpv2cBulkPDURequestIdCounter decrement = 6;
}

// One variable binding in the Response-PDU is requested for the first non_repeaters
// variable bindings in the GetBulkRequest.
message PatternFlowSnmpv2cBulkPDUNonRepeaters {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;
}

// integer counter pattern
message PatternFlowSnmpv2cBulkPDUMaxRepetitionsCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// A maximum of max_repetitions variable bindings are requested in the Response-PDU
// for each of the remaining variable bindings in the GetBulkRequest after the non_repeaters
// variable bindings.
message PatternFlowSnmpv2cBulkPDUMaxRepetitions {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowSnmpv2cBulkPDUMaxRepetitionsCounter increment = 5;

  // Description missing in models
  PatternFlowSnmpv2cBulkPDUMaxRepetitionsCounter decrement = 6;
}

// integer counter pattern
message PatternFlowSnmpv2cVariableBindingValueIntegerValueCounter {

  // Description missing in models
  // default = 0
  optional int32 start = 1;

  // Description missing in models
  // default = 1
  optional int32 step = 2;

  // Description missing in models
  // default = 1
  optional int32 count = 3;
}

// Integer value returned for the requested OID.
message PatternFlowSnmpv2cVariableBindingValueIntegerValue {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional int32 value = 2;

  // Description missing in models
  // default = [0]
  repeated int32 values = 3;

  // Description missing in models
  PatternFlowSnmpv2cVariableBindingValueIntegerValueCounter increment = 5;

  // Description missing in models
  PatternFlowSnmpv2cVariableBindingValueIntegerValueCounter decrement = 6;
}

// ipv4 counter pattern
message PatternFlowSnmpv2cVariableBindingValueIpAddressValueCounter {

  // Description missing in models
  // default = 0.0.0.0
  optional string start = 1;

  // Description missing in models
  // default = 0.0.0.1
  optional string step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// IPv4 address returned for the requested OID.
message PatternFlowSnmpv2cVariableBindingValueIpAddressValue {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0.0.0.0
  optional string value = 2;

  // Description missing in models
  // default = ['0.0.0.0']
  repeated string values = 3;

  // Description missing in models
  PatternFlowSnmpv2cVariableBindingValueIpAddressValueCounter increment = 5;

  // Description missing in models
  PatternFlowSnmpv2cVariableBindingValueIpAddressValueCounter decrement = 6;
}

// integer counter pattern
message PatternFlowSnmpv2cVariableBindingValueCounterValueCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Counter returned for the requested OID.
message PatternFlowSnmpv2cVariableBindingValueCounterValue {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowSnmpv2cVariableBindingValueCounterValueCounter increment = 5;

  // Description missing in models
  PatternFlowSnmpv2cVariableBindingValueCounterValueCounter decrement = 6;
}

// integer counter pattern
message PatternFlowSnmpv2cVariableBindingValueTimeticksValueCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Timeticks returned for the requested OID.
message PatternFlowSnmpv2cVariableBindingValueTimeticksValue {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowSnmpv2cVariableBindingValueTimeticksValueCounter increment = 5;

  // Description missing in models
  PatternFlowSnmpv2cVariableBindingValueTimeticksValueCounter decrement = 6;
}

// integer counter pattern
message PatternFlowSnmpv2cVariableBindingValueBigCounterValueCounter {

  // Description missing in models
  // default = 0
  optional uint64 start = 1;

  // Description missing in models
  // default = 1
  optional uint64 step = 2;

  // Description missing in models
  // default = 1
  optional uint64 count = 3;
}

// Big counter returned for the requested OID.
message PatternFlowSnmpv2cVariableBindingValueBigCounterValue {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint64 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint64 values = 3;

  // Description missing in models
  PatternFlowSnmpv2cVariableBindingValueBigCounterValueCounter increment = 5;

  // Description missing in models
  PatternFlowSnmpv2cVariableBindingValueBigCounterValueCounter decrement = 6;
}

// integer counter pattern
message PatternFlowSnmpv2cVariableBindingValueUnsignedIntegerValueCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Unsigned integer value returned for the requested OID.
message PatternFlowSnmpv2cVariableBindingValueUnsignedIntegerValue {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowSnmpv2cVariableBindingValueUnsignedIntegerValueCounter increment = 5;

  // Description missing in models
  PatternFlowSnmpv2cVariableBindingValueUnsignedIntegerValueCounter decrement = 6;
}

// integer counter pattern
message PatternFlowSnmpv2cCommonRequestIdCounter {

  // Description missing in models
  // default = 0
  optional int32 start = 1;

  // Description missing in models
  // default = 1
  optional int32 step = 2;

  // Description missing in models
  // default = 1
  optional int32 count = 3;
}

// Identifies a particular SNMP request.
// This index is echoed back in the response from the SNMP agent,
// allowing the SNMP manager to match an incoming response to the appropriate request.
// 
// - Encoding of this field follows ASN.1 X.690(section 8.3) specification.
// Refer: http://www.itu.int/ITU-T/asn1/
message PatternFlowSnmpv2cCommonRequestId {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional int32 value = 2;

  // Description missing in models
  // default = [0]
  repeated int32 values = 3;

  // Description missing in models
  PatternFlowSnmpv2cCommonRequestIdCounter increment = 5;

  // Description missing in models
  PatternFlowSnmpv2cCommonRequestIdCounter decrement = 6;
}

// The one's complement of the one's complement sum of the message, with the checksum
// field replaced by zero for the purpose of computing the checksum.   An all-zero value
// means that no checksum was transmitted.
message PatternFlowRsvpRsvpChecksum {

  message Choice {
    enum Enum {
      unspecified = 0;
      generated = 1;
      custom = 2;
    }
  }
  // The type of checksum
  // default = Choice.Enum.generated
  optional Choice.Enum choice = 1;

  message Generated {
    enum Enum {
      unspecified = 0;
      good = 1;
      bad = 2;
    }
  }
  // A system generated checksum value
  // default = Generated.Enum.good
  optional Generated.Enum generated = 2;

  // A custom checksum value
  optional uint32 custom = 3;
}

// integer counter pattern
message PatternFlowRsvpTimeToLiveCounter {

  // Description missing in models
  // default = 64
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// The IP time-to-live(TTL) value with which the message was sent.
message PatternFlowRsvpTimeToLive {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 64
  optional uint32 value = 2;

  // Description missing in models
  // default = [64]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowRsvpTimeToLiveCounter increment = 5;

  // Description missing in models
  PatternFlowRsvpTimeToLiveCounter decrement = 6;
}

// integer counter pattern
message PatternFlowRsvpReservedCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Reserved
message PatternFlowRsvpReserved {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowRsvpReservedCounter increment = 5;

  // Description missing in models
  PatternFlowRsvpReservedCounter decrement = 6;
}

// ipv4 counter pattern
message PatternFlowRSVPPathSessionLspTunnelIpv4Ipv4TunnelEndPointAddressCounter {

  // Description missing in models
  // default = 0.0.0.0
  optional string start = 1;

  // Description missing in models
  // default = 0.0.0.1
  optional string step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// IPv4 address of the egress node for the tunnel.
message PatternFlowRSVPPathSessionLspTunnelIpv4Ipv4TunnelEndPointAddress {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0.0.0.0
  optional string value = 2;

  // Description missing in models
  // default = ['0.0.0.0']
  repeated string values = 3;

  // Description missing in models
  PatternFlowRSVPPathSessionLspTunnelIpv4Ipv4TunnelEndPointAddressCounter increment = 5;

  // Description missing in models
  PatternFlowRSVPPathSessionLspTunnelIpv4Ipv4TunnelEndPointAddressCounter decrement = 6;
}

// integer counter pattern
message PatternFlowRSVPPathSessionLspTunnelIpv4ReservedCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Reserved field, MUST be zero.
message PatternFlowRSVPPathSessionLspTunnelIpv4Reserved {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowRSVPPathSessionLspTunnelIpv4ReservedCounter increment = 5;

  // Description missing in models
  PatternFlowRSVPPathSessionLspTunnelIpv4ReservedCounter decrement = 6;
}

// integer counter pattern
message PatternFlowRSVPPathSessionLspTunnelIpv4TunnelIdCounter {

  // Description missing in models
  // default = 1
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// A 16-bit identifier used in the SESSION that remains constant over the life of the
// tunnel.
message PatternFlowRSVPPathSessionLspTunnelIpv4TunnelId {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 1
  optional uint32 value = 2;

  // Description missing in models
  // default = [1]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowRSVPPathSessionLspTunnelIpv4TunnelIdCounter increment = 5;

  // Description missing in models
  PatternFlowRSVPPathSessionLspTunnelIpv4TunnelIdCounter decrement = 6;
}

// integer counter pattern
message PatternFlowRSVPPathSessionExtTunnelIdAsIntegerCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// TBD
message PatternFlowRSVPPathSessionExtTunnelIdAsInteger {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowRSVPPathSessionExtTunnelIdAsIntegerCounter increment = 5;

  // Description missing in models
  PatternFlowRSVPPathSessionExtTunnelIdAsIntegerCounter decrement = 6;
}

// ipv4 counter pattern
message PatternFlowRSVPPathSessionExtTunnelIdAsIpv4Counter {

  // Description missing in models
  // default = 0.0.0.0
  optional string start = 1;

  // Description missing in models
  // default = 0.0.0.1
  optional string step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// IPv4 address of the ingress endpoint for the tunnel.
message PatternFlowRSVPPathSessionExtTunnelIdAsIpv4 {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0.0.0.0
  optional string value = 2;

  // Description missing in models
  // default = ['0.0.0.0']
  repeated string values = 3;

  // Description missing in models
  PatternFlowRSVPPathSessionExtTunnelIdAsIpv4Counter increment = 5;

  // Description missing in models
  PatternFlowRSVPPathSessionExtTunnelIdAsIpv4Counter decrement = 6;
}

// ipv4 counter pattern
message PatternFlowRSVPPathRsvpHopIpv4Ipv4AddressCounter {

  // Description missing in models
  // default = 0.0.0.0
  optional string start = 1;

  // Description missing in models
  // default = 0.0.0.1
  optional string step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// The IPv4 address of the interface through which the last RSVP-knowledgeable hop forwarded
// this message.
message PatternFlowRSVPPathRsvpHopIpv4Ipv4Address {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0.0.0.0
  optional string value = 2;

  // Description missing in models
  // default = ['0.0.0.0']
  repeated string values = 3;

  // Description missing in models
  PatternFlowRSVPPathRsvpHopIpv4Ipv4AddressCounter increment = 5;

  // Description missing in models
  PatternFlowRSVPPathRsvpHopIpv4Ipv4AddressCounter decrement = 6;
}

// integer counter pattern
message PatternFlowRSVPPathRsvpHopIpv4LogicalInterfaceHandleCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Logical Interface Handle (LIH) is used to distinguish logical outgoing interfaces.
// A node receiving an LIH in a Path message saves its value and returns it in the HOP
// objects of subsequent Resv messages sent to the node that originated the LIH. The
// LIH should be identically zero if there is no logical interface handle.
message PatternFlowRSVPPathRsvpHopIpv4LogicalInterfaceHandle {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowRSVPPathRsvpHopIpv4LogicalInterfaceHandleCounter increment = 5;

  // Description missing in models
  PatternFlowRSVPPathRsvpHopIpv4LogicalInterfaceHandleCounter decrement = 6;
}

// integer counter pattern
message PatternFlowRSVPPathTimeValuesType1RefreshPeriodRCounter {

  // Description missing in models
  // default = 30000
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// The refresh timeout period R used to generate this message;in milliseconds.
message PatternFlowRSVPPathTimeValuesType1RefreshPeriodR {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 30000
  optional uint32 value = 2;

  // Description missing in models
  // default = [30000]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowRSVPPathTimeValuesType1RefreshPeriodRCounter increment = 5;

  // Description missing in models
  PatternFlowRSVPPathTimeValuesType1RefreshPeriodRCounter decrement = 6;
}

// integer counter pattern
message PatternFlowRSVPPathExplicitRouteType1Ipv4PrefixLBitCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// The L bit is an attribute of the subobject. The L bit is set if the subobject represents
// a loose hop in the explicit route. If the bit is not set, the subobject represents
// a strict hop in the explicit route.
message PatternFlowRSVPPathExplicitRouteType1Ipv4PrefixLBit {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowRSVPPathExplicitRouteType1Ipv4PrefixLBitCounter increment = 5;

  // Description missing in models
  PatternFlowRSVPPathExplicitRouteType1Ipv4PrefixLBitCounter decrement = 6;
}

// ipv4 counter pattern
message PatternFlowRSVPPathExplicitRouteType1Ipv4PrefixIpv4AddressCounter {

  // Description missing in models
  // default = 0.0.0.0
  optional string start = 1;

  // Description missing in models
  // default = 0.0.0.1
  optional string step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// This IPv4 address is treated as a prefix based on the prefix length value below.
// Bits beyond the prefix are ignored on receipt and SHOULD be set to zero on transmission.
message PatternFlowRSVPPathExplicitRouteType1Ipv4PrefixIpv4Address {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0.0.0.0
  optional string value = 2;

  // Description missing in models
  // default = ['0.0.0.0']
  repeated string values = 3;

  // Description missing in models
  PatternFlowRSVPPathExplicitRouteType1Ipv4PrefixIpv4AddressCounter increment = 5;

  // Description missing in models
  PatternFlowRSVPPathExplicitRouteType1Ipv4PrefixIpv4AddressCounter decrement = 6;
}

// integer counter pattern
message PatternFlowRSVPPathExplicitRouteType1ASNumberLBitCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// The L bit is an attribute of the subobject. The L bit is set if the subobject represents
// a loose hop in the explicit route. If the bit is not set, the subobject represents
// a strict hop in the explicit route.
message PatternFlowRSVPPathExplicitRouteType1ASNumberLBit {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowRSVPPathExplicitRouteType1ASNumberLBitCounter increment = 5;

  // Description missing in models
  PatternFlowRSVPPathExplicitRouteType1ASNumberLBitCounter decrement = 6;
}

// integer counter pattern
message PatternFlowRSVPPathLabelRequestWithoutLabelRangeReservedCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// This field is reserved.   It MUST be set to zero on transmission and MUST be ignored
// on receipt.
message PatternFlowRSVPPathLabelRequestWithoutLabelRangeReserved {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowRSVPPathLabelRequestWithoutLabelRangeReservedCounter increment = 5;

  // Description missing in models
  PatternFlowRSVPPathLabelRequestWithoutLabelRangeReservedCounter decrement = 6;
}

// integer counter pattern
message PatternFlowRSVPPathLabelRequestWithoutLabelRangeL3pidCounter {

  // Description missing in models
  // default = 2048
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// An identifier of the layer 3 protocol using this path.  Standard Ethertype values
// are used e.g. The default value of 2048 ( 0x0800 ) represents Ethertype for IPv4.
// 
message PatternFlowRSVPPathLabelRequestWithoutLabelRangeL3pid {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 2048
  optional uint32 value = 2;

  // Description missing in models
  // default = [2048]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowRSVPPathLabelRequestWithoutLabelRangeL3pidCounter increment = 5;

  // Description missing in models
  PatternFlowRSVPPathLabelRequestWithoutLabelRangeL3pidCounter decrement = 6;
}

// ipv4 counter pattern
message PatternFlowRSVPPathSenderTemplateLspTunnelIpv4Ipv4TunnelSenderAddressCounter {

  // Description missing in models
  // default = 0.0.0.0
  optional string start = 1;

  // Description missing in models
  // default = 0.0.0.1
  optional string step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// IPv4 address for a sender node.
message PatternFlowRSVPPathSenderTemplateLspTunnelIpv4Ipv4TunnelSenderAddress {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0.0.0.0
  optional string value = 2;

  // Description missing in models
  // default = ['0.0.0.0']
  repeated string values = 3;

  // Description missing in models
  PatternFlowRSVPPathSenderTemplateLspTunnelIpv4Ipv4TunnelSenderAddressCounter increment = 5;

  // Description missing in models
  PatternFlowRSVPPathSenderTemplateLspTunnelIpv4Ipv4TunnelSenderAddressCounter decrement = 6;
}

// integer counter pattern
message PatternFlowRSVPPathSenderTemplateLspTunnelIpv4ReservedCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Reserved field, MUST be zero.
message PatternFlowRSVPPathSenderTemplateLspTunnelIpv4Reserved {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowRSVPPathSenderTemplateLspTunnelIpv4ReservedCounter increment = 5;

  // Description missing in models
  PatternFlowRSVPPathSenderTemplateLspTunnelIpv4ReservedCounter decrement = 6;
}

// integer counter pattern
message PatternFlowRSVPPathSenderTemplateLspTunnelIpv4LspIdCounter {

  // Description missing in models
  // default = 1
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// A 16-bit identifier used in the SENDER_TEMPLATE that can be changed to allow a sender
// to share resources with itself.
message PatternFlowRSVPPathSenderTemplateLspTunnelIpv4LspId {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 1
  optional uint32 value = 2;

  // Description missing in models
  // default = [1]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowRSVPPathSenderTemplateLspTunnelIpv4LspIdCounter increment = 5;

  // Description missing in models
  PatternFlowRSVPPathSenderTemplateLspTunnelIpv4LspIdCounter decrement = 6;
}

// integer counter pattern
message PatternFlowRSVPPathSenderTspecIntServVersionCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Message format version number.
message PatternFlowRSVPPathSenderTspecIntServVersion {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowRSVPPathSenderTspecIntServVersionCounter increment = 5;

  // Description missing in models
  PatternFlowRSVPPathSenderTspecIntServVersionCounter decrement = 6;
}

// integer counter pattern
message PatternFlowRSVPPathSenderTspecIntServReserved1Counter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Reserved.
message PatternFlowRSVPPathSenderTspecIntServReserved1 {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowRSVPPathSenderTspecIntServReserved1Counter increment = 5;

  // Description missing in models
  PatternFlowRSVPPathSenderTspecIntServReserved1Counter decrement = 6;
}

// integer counter pattern
message PatternFlowRSVPPathSenderTspecIntServOverallLengthCounter {

  // Description missing in models
  // default = 7
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Overall length (7 words not including header).
message PatternFlowRSVPPathSenderTspecIntServOverallLength {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 7
  optional uint32 value = 2;

  // Description missing in models
  // default = [7]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowRSVPPathSenderTspecIntServOverallLengthCounter increment = 5;

  // Description missing in models
  PatternFlowRSVPPathSenderTspecIntServOverallLengthCounter decrement = 6;
}

// integer counter pattern
message PatternFlowRSVPPathSenderTspecIntServServiceHeaderCounter {

  // Description missing in models
  // default = 1
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Service header, service number - '1' (Generic information) if in a PATH message.
message PatternFlowRSVPPathSenderTspecIntServServiceHeader {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 1
  optional uint32 value = 2;

  // Description missing in models
  // default = [1]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowRSVPPathSenderTspecIntServServiceHeaderCounter increment = 5;

  // Description missing in models
  PatternFlowRSVPPathSenderTspecIntServServiceHeaderCounter decrement = 6;
}

// integer counter pattern
message PatternFlowRSVPPathSenderTspecIntServZeroBitCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// MUST be 0.
message PatternFlowRSVPPathSenderTspecIntServZeroBit {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowRSVPPathSenderTspecIntServZeroBitCounter increment = 5;

  // Description missing in models
  PatternFlowRSVPPathSenderTspecIntServZeroBitCounter decrement = 6;
}

// integer counter pattern
message PatternFlowRSVPPathSenderTspecIntServReserved2Counter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Reserved.
message PatternFlowRSVPPathSenderTspecIntServReserved2 {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowRSVPPathSenderTspecIntServReserved2Counter increment = 5;

  // Description missing in models
  PatternFlowRSVPPathSenderTspecIntServReserved2Counter decrement = 6;
}

// integer counter pattern
message PatternFlowRSVPPathSenderTspecIntServLengthOfServiceDataCounter {

  // Description missing in models
  // default = 6
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Length of service data, 6 words not including per-service header.
message PatternFlowRSVPPathSenderTspecIntServLengthOfServiceData {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 6
  optional uint32 value = 2;

  // Description missing in models
  // default = [6]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowRSVPPathSenderTspecIntServLengthOfServiceDataCounter increment = 5;

  // Description missing in models
  PatternFlowRSVPPathSenderTspecIntServLengthOfServiceDataCounter decrement = 6;
}

// integer counter pattern
message PatternFlowRSVPPathSenderTspecIntServParameterIdTokenBucketTspecCounter {

  // Description missing in models
  // default = 127
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Parameter ID, parameter 127 (Token Bucket TSpec)
message PatternFlowRSVPPathSenderTspecIntServParameterIdTokenBucketTspec {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 127
  optional uint32 value = 2;

  // Description missing in models
  // default = [127]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowRSVPPathSenderTspecIntServParameterIdTokenBucketTspecCounter increment = 5;

  // Description missing in models
  PatternFlowRSVPPathSenderTspecIntServParameterIdTokenBucketTspecCounter decrement = 6;
}

// integer counter pattern
message PatternFlowRSVPPathSenderTspecIntServParameter127FlagCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Parameter 127 flags (none set)
message PatternFlowRSVPPathSenderTspecIntServParameter127Flag {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowRSVPPathSenderTspecIntServParameter127FlagCounter increment = 5;

  // Description missing in models
  PatternFlowRSVPPathSenderTspecIntServParameter127FlagCounter decrement = 6;
}

// integer counter pattern
message PatternFlowRSVPPathSenderTspecIntServParameter127LengthCounter {

  // Description missing in models
  // default = 5
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Parameter 127 length, 5 words not including per-service header
message PatternFlowRSVPPathSenderTspecIntServParameter127Length {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 5
  optional uint32 value = 2;

  // Description missing in models
  // default = [5]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowRSVPPathSenderTspecIntServParameter127LengthCounter increment = 5;

  // Description missing in models
  PatternFlowRSVPPathSenderTspecIntServParameter127LengthCounter decrement = 6;
}

// integer counter pattern
message PatternFlowRSVPPathSenderTspecIntServMinimumPolicedUnitCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// The minimum policed unit parameter should generally be set equal to the size of the
// smallest packet generated by the application.
message PatternFlowRSVPPathSenderTspecIntServMinimumPolicedUnit {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowRSVPPathSenderTspecIntServMinimumPolicedUnitCounter increment = 5;

  // Description missing in models
  PatternFlowRSVPPathSenderTspecIntServMinimumPolicedUnitCounter decrement = 6;
}

// integer counter pattern
message PatternFlowRSVPPathSenderTspecIntServMaximumPacketSizeCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// The maximum packet size parameter should be set to the size of the largest packet
// the application might wish to generate. This value must, by definition, be equal
// to or larger than the value of The minimum policed unit.
message PatternFlowRSVPPathSenderTspecIntServMaximumPacketSize {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowRSVPPathSenderTspecIntServMaximumPacketSizeCounter increment = 5;

  // Description missing in models
  PatternFlowRSVPPathSenderTspecIntServMaximumPacketSizeCounter decrement = 6;
}

// ipv4 counter pattern
message PatternFlowRSVPPathRecordRouteType1Ipv4AddressIpv4AddressCounter {

  // Description missing in models
  // default = 0.0.0.0
  optional string start = 1;

  // Description missing in models
  // default = 0.0.0.1
  optional string step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// A 32-bit unicast, host address.  Any network-reachable interface address is allowed
// here. Illegal addresses, such as certain loopback addresses, SHOULD NOT be used.
message PatternFlowRSVPPathRecordRouteType1Ipv4AddressIpv4Address {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0.0.0.0
  optional string value = 2;

  // Description missing in models
  // default = ['0.0.0.0']
  repeated string values = 3;

  // Description missing in models
  PatternFlowRSVPPathRecordRouteType1Ipv4AddressIpv4AddressCounter increment = 5;

  // Description missing in models
  PatternFlowRSVPPathRecordRouteType1Ipv4AddressIpv4AddressCounter decrement = 6;
}

// integer counter pattern
message PatternFlowRSVPPathRecordRouteType1Ipv4AddressPrefixLengthCounter {

  // Description missing in models
  // default = 32
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Prefix-length of IPv4 address.
message PatternFlowRSVPPathRecordRouteType1Ipv4AddressPrefixLength {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 32
  optional uint32 value = 2;

  // Description missing in models
  // default = [32]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowRSVPPathRecordRouteType1Ipv4AddressPrefixLengthCounter increment = 5;

  // Description missing in models
  PatternFlowRSVPPathRecordRouteType1Ipv4AddressPrefixLengthCounter decrement = 6;
}

// 0x01 = Global label. This flag indicates that the label will be understood if received
// on any interface.
message PatternFlowRSVPPathRecordRouteType1LabelFlags {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 1
  optional uint32 value = 2;

  // Description missing in models
  // default = [1]
  repeated uint32 values = 3;
}

// The C-Type of the included Label Object. Copied from the Label object.
message PatternFlowRSVPPathRecordRouteType1LabelCType {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 1
  optional uint32 value = 2;

  // Description missing in models
  // default = [1]
  repeated uint32 values = 3;
}

// integer counter pattern
message PatternFlowRSVPPathObjectsCustomTypeCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// User defined object type.
message PatternFlowRSVPPathObjectsCustomType {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowRSVPPathObjectsCustomTypeCounter increment = 5;

  // Description missing in models
  PatternFlowRSVPPathObjectsCustomTypeCounter decrement = 6;
}

// integer counter pattern
message PatternFlowLacpVersionCounter {

  // Description missing in models
  // default = 1
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// The LACP version number.
message PatternFlowLacpVersion {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 1
  optional uint32 value = 2;

  // Description missing in models
  // default = [1]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowLacpVersionCounter increment = 5;

  // Description missing in models
  PatternFlowLacpVersionCounter decrement = 6;
}

// integer counter pattern
message PatternFlowLacpduActorTypeCounter {

  // Description missing in models
  // default = 1
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// TLV Type for Actor Information. The value 0x01 identifies this TLV as containing
// information about the sending device (the Actor).
message PatternFlowLacpduActorType {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 1
  optional uint32 value = 2;

  // Description missing in models
  // default = [1]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowLacpduActorTypeCounter increment = 5;

  // Description missing in models
  PatternFlowLacpduActorTypeCounter decrement = 6;
}

// integer counter pattern
message PatternFlowLacpduActorLengthCounter {

  // Description missing in models
  // default = 20
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// The length of the Actor Information TLV payload in bytes.
message PatternFlowLacpduActorLength {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 20
  optional uint32 value = 2;

  // Description missing in models
  // default = [20]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowLacpduActorLengthCounter increment = 5;

  // Description missing in models
  PatternFlowLacpduActorLengthCounter decrement = 6;
}

// integer counter pattern
message PatternFlowLacpduActorSystemPriorityCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// The priority assigned to the Actor's system for use in aggregation. A lower numerical
// value indicates a higher priority. Used to select the active System ID when forming
// an aggregator.
message PatternFlowLacpduActorSystemPriority {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowLacpduActorSystemPriorityCounter increment = 5;

  // Description missing in models
  PatternFlowLacpduActorSystemPriorityCounter decrement = 6;
}

// mac counter pattern
message PatternFlowLacpduActorSystemIdCounter {

  // Description missing in models
  // default = 00:00:00:00:00:00
  optional string start = 1;

  // Description missing in models
  // default = 00:00:00:00:00:01
  optional string step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// The Actor's System ID, which is a globally unique MAC address assigned to the system
// containing the Actor.
message PatternFlowLacpduActorSystemId {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 00:00:00:00:00:00
  optional string value = 2;

  // Description missing in models
  // default = ['00:00:00:00:00:00']
  repeated string values = 3;

  // Description missing in models
  PatternFlowLacpduActorSystemIdCounter increment = 5;

  // Description missing in models
  PatternFlowLacpduActorSystemIdCounter decrement = 6;
}

// integer counter pattern
message PatternFlowLacpduActorKeyCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// The operational Key value assigned to the Actor's port. The key is generated based
// on port configuration (e.g., speed, duplex, trunk ID) and is used to identify potential
// aggregation groups. Only links with the same key can be aggregated together.
message PatternFlowLacpduActorKey {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowLacpduActorKeyCounter increment = 5;

  // Description missing in models
  PatternFlowLacpduActorKeyCounter decrement = 6;
}

// integer counter pattern
message PatternFlowLacpduActorPortPriorityCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// The priority assigned to the Actor's port. A lower numerical value indicates a higher
// priority. Used to prioritize ports for inclusion in a Link Aggregation Group (LAG)
// when the group is full.
message PatternFlowLacpduActorPortPriority {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowLacpduActorPortPriorityCounter increment = 5;

  // Description missing in models
  PatternFlowLacpduActorPortPriorityCounter decrement = 6;
}

// integer counter pattern
message PatternFlowLacpduActorPortNumberCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// The port number assigned to the Actor's port. It is a unique identifier for the port
// within the system.
message PatternFlowLacpduActorPortNumber {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowLacpduActorPortNumberCounter increment = 5;

  // Description missing in models
  PatternFlowLacpduActorPortNumberCounter decrement = 6;
}

// integer counter pattern
message PatternFlowLacpduActorReservedCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Reserved field for future use in the Actor TLV. Should be set to all zeros.
message PatternFlowLacpduActorReserved {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowLacpduActorReservedCounter increment = 5;

  // Description missing in models
  PatternFlowLacpduActorReservedCounter decrement = 6;
}

// integer counter pattern
message PatternFlowLacpduPartnerTypeCounter {

  // Description missing in models
  // default = 2
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// TLV Type for Partner Information. The value 0x02 identifies this TLV as containing
// information about the remote device (the Partner), as understood by the Actor.
message PatternFlowLacpduPartnerType {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 2
  optional uint32 value = 2;

  // Description missing in models
  // default = [2]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowLacpduPartnerTypeCounter increment = 5;

  // Description missing in models
  PatternFlowLacpduPartnerTypeCounter decrement = 6;
}

// integer counter pattern
message PatternFlowLacpduPartnerLengthCounter {

  // Description missing in models
  // default = 20
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// The length of the Partner Information TLV payload in bytes.
message PatternFlowLacpduPartnerLength {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 20
  optional uint32 value = 2;

  // Description missing in models
  // default = [20]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowLacpduPartnerLengthCounter increment = 5;

  // Description missing in models
  PatternFlowLacpduPartnerLengthCounter decrement = 6;
}

// integer counter pattern
message PatternFlowLacpduPartnerSystemPriorityCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// The priority of the Partner's system, as received by the Actor.
message PatternFlowLacpduPartnerSystemPriority {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowLacpduPartnerSystemPriorityCounter increment = 5;

  // Description missing in models
  PatternFlowLacpduPartnerSystemPriorityCounter decrement = 6;
}

// mac counter pattern
message PatternFlowLacpduPartnerSystemIdCounter {

  // Description missing in models
  // default = 00:00:00:00:00:00
  optional string start = 1;

  // Description missing in models
  // default = 00:00:00:00:00:01
  optional string step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// The Partner's System ID (MAC address), as received by the Actor.
message PatternFlowLacpduPartnerSystemId {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 00:00:00:00:00:00
  optional string value = 2;

  // Description missing in models
  // default = ['00:00:00:00:00:00']
  repeated string values = 3;

  // Description missing in models
  PatternFlowLacpduPartnerSystemIdCounter increment = 5;

  // Description missing in models
  PatternFlowLacpduPartnerSystemIdCounter decrement = 6;
}

// integer counter pattern
message PatternFlowLacpduPartnerKeyCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// The operational Key value of the Partner's port, as received by the Actor.
message PatternFlowLacpduPartnerKey {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowLacpduPartnerKeyCounter increment = 5;

  // Description missing in models
  PatternFlowLacpduPartnerKeyCounter decrement = 6;
}

// integer counter pattern
message PatternFlowLacpduPartnerPortPriorityCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// The priority of the Partner's port, as received by the Actor.
message PatternFlowLacpduPartnerPortPriority {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowLacpduPartnerPortPriorityCounter increment = 5;

  // Description missing in models
  PatternFlowLacpduPartnerPortPriorityCounter decrement = 6;
}

// integer counter pattern
message PatternFlowLacpduPartnerPortNumberCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// The port number of the Partner's port, as received by the Actor.
message PatternFlowLacpduPartnerPortNumber {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowLacpduPartnerPortNumberCounter increment = 5;

  // Description missing in models
  PatternFlowLacpduPartnerPortNumberCounter decrement = 6;
}

// integer counter pattern
message PatternFlowLacpduPartnerReservedCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Reserved field for future use in the Partner TLV. Should be set to all zeros.
message PatternFlowLacpduPartnerReserved {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowLacpduPartnerReservedCounter increment = 5;

  // Description missing in models
  PatternFlowLacpduPartnerReservedCounter decrement = 6;
}

// integer counter pattern
message PatternFlowLacpduCollectorTypeCounter {

  // Description missing in models
  // default = 3
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// TLV Type for Collector Information. The value 0x03 identifies this TLV.
message PatternFlowLacpduCollectorType {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 3
  optional uint32 value = 2;

  // Description missing in models
  // default = [3]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowLacpduCollectorTypeCounter increment = 5;

  // Description missing in models
  PatternFlowLacpduCollectorTypeCounter decrement = 6;
}

// integer counter pattern
message PatternFlowLacpduCollectorLengthCounter {

  // Description missing in models
  // default = 16
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// The length of the Collector Information TLV payload in bytes. The value must be 16
// (0x10).
message PatternFlowLacpduCollectorLength {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 16
  optional uint32 value = 2;

  // Description missing in models
  // default = [16]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowLacpduCollectorLengthCounter increment = 5;

  // Description missing in models
  PatternFlowLacpduCollectorLengthCounter decrement = 6;
}

// integer counter pattern
message PatternFlowLacpduCollectorMaxDelayCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Indicates the maximum delay, in units of 10 microseconds, that the transmitting system's
// aggregator will take to buffer frames from its collector before emitting a frame.
message PatternFlowLacpduCollectorMaxDelay {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowLacpduCollectorMaxDelayCounter increment = 5;

  // Description missing in models
  PatternFlowLacpduCollectorMaxDelayCounter decrement = 6;
}

// integer counter pattern
message PatternFlowLacpduTerminatorTypeCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// TLV Type for Terminator Information. The value 0x00 indicates the end of the TLV
// list.
message PatternFlowLacpduTerminatorType {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowLacpduTerminatorTypeCounter increment = 5;

  // Description missing in models
  PatternFlowLacpduTerminatorTypeCounter decrement = 6;
}

// integer counter pattern
message PatternFlowLacpduTerminatorLengthCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// The length of the Terminator TLV payload. The value must be 0.
message PatternFlowLacpduTerminatorLength {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowLacpduTerminatorLengthCounter increment = 5;

  // Description missing in models
  PatternFlowLacpduTerminatorLengthCounter decrement = 6;
}

// integer counter pattern
message PatternFlowLacpduActorStateActivityCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// LACP Activity (1=Active, 0=Passive)
message PatternFlowLacpduActorStateActivity {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowLacpduActorStateActivityCounter increment = 5;

  // Description missing in models
  PatternFlowLacpduActorStateActivityCounter decrement = 6;
}

// integer counter pattern
message PatternFlowLacpduActorStateTimeoutCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// LACP Timeout (1=Fast timeout, 0=Slow timeout)
message PatternFlowLacpduActorStateTimeout {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowLacpduActorStateTimeoutCounter increment = 5;

  // Description missing in models
  PatternFlowLacpduActorStateTimeoutCounter decrement = 6;
}

// integer counter pattern
message PatternFlowLacpduActorStateAggregationCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Aggregation (1=Aggregatable, 0=Individual)
message PatternFlowLacpduActorStateAggregation {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowLacpduActorStateAggregationCounter increment = 5;

  // Description missing in models
  PatternFlowLacpduActorStateAggregationCounter decrement = 6;
}

// integer counter pattern
message PatternFlowLacpduActorStateSynchronizationCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Synchronization (1=In Sync, 0=Out of Sync)
message PatternFlowLacpduActorStateSynchronization {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowLacpduActorStateSynchronizationCounter increment = 5;

  // Description missing in models
  PatternFlowLacpduActorStateSynchronizationCounter decrement = 6;
}

// integer counter pattern
message PatternFlowLacpduActorStateCollectingCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Collecting (1=Enabled, 0=Disabled)
message PatternFlowLacpduActorStateCollecting {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowLacpduActorStateCollectingCounter increment = 5;

  // Description missing in models
  PatternFlowLacpduActorStateCollectingCounter decrement = 6;
}

// integer counter pattern
message PatternFlowLacpduActorStateDistributingCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Distributing (1=Enabled, 0=Disabled)
message PatternFlowLacpduActorStateDistributing {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowLacpduActorStateDistributingCounter increment = 5;

  // Description missing in models
  PatternFlowLacpduActorStateDistributingCounter decrement = 6;
}

// integer counter pattern
message PatternFlowLacpduActorStateDefaultedCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Defaulted (1=Using defaulted partner info, 0=Using received partner info)
message PatternFlowLacpduActorStateDefaulted {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowLacpduActorStateDefaultedCounter increment = 5;

  // Description missing in models
  PatternFlowLacpduActorStateDefaultedCounter decrement = 6;
}

// integer counter pattern
message PatternFlowLacpduActorStateExpiredCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Expired (1=Expired, 0=Not Expired)
message PatternFlowLacpduActorStateExpired {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowLacpduActorStateExpiredCounter increment = 5;

  // Description missing in models
  PatternFlowLacpduActorStateExpiredCounter decrement = 6;
}

// integer counter pattern
message PatternFlowLacpduPartnerStateActivityCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// LACP Activity (1=Active, 0=Passive)
message PatternFlowLacpduPartnerStateActivity {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowLacpduPartnerStateActivityCounter increment = 5;

  // Description missing in models
  PatternFlowLacpduPartnerStateActivityCounter decrement = 6;
}

// integer counter pattern
message PatternFlowLacpduPartnerStateTimeoutCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// LACP Timeout (1=Fast timeout, 0=Slow timeout)
message PatternFlowLacpduPartnerStateTimeout {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowLacpduPartnerStateTimeoutCounter increment = 5;

  // Description missing in models
  PatternFlowLacpduPartnerStateTimeoutCounter decrement = 6;
}

// integer counter pattern
message PatternFlowLacpduPartnerStateAggregationCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Aggregation (1=Aggregatable, 0=Individual)
message PatternFlowLacpduPartnerStateAggregation {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowLacpduPartnerStateAggregationCounter increment = 5;

  // Description missing in models
  PatternFlowLacpduPartnerStateAggregationCounter decrement = 6;
}

// integer counter pattern
message PatternFlowLacpduPartnerStateSynchronizationCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Synchronization (1=In Sync, 0=Out of Sync)
message PatternFlowLacpduPartnerStateSynchronization {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowLacpduPartnerStateSynchronizationCounter increment = 5;

  // Description missing in models
  PatternFlowLacpduPartnerStateSynchronizationCounter decrement = 6;
}

// integer counter pattern
message PatternFlowLacpduPartnerStateCollectingCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Collecting (1=Enabled, 0=Disabled)
message PatternFlowLacpduPartnerStateCollecting {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowLacpduPartnerStateCollectingCounter increment = 5;

  // Description missing in models
  PatternFlowLacpduPartnerStateCollectingCounter decrement = 6;
}

// integer counter pattern
message PatternFlowLacpduPartnerStateDistributingCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Distributing (1=Enabled, 0=Disabled)
message PatternFlowLacpduPartnerStateDistributing {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowLacpduPartnerStateDistributingCounter increment = 5;

  // Description missing in models
  PatternFlowLacpduPartnerStateDistributingCounter decrement = 6;
}

// integer counter pattern
message PatternFlowLacpduPartnerStateDefaultedCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Defaulted (1=Using defaulted partner info, 0=Using received partner info)
message PatternFlowLacpduPartnerStateDefaulted {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowLacpduPartnerStateDefaultedCounter increment = 5;

  // Description missing in models
  PatternFlowLacpduPartnerStateDefaultedCounter decrement = 6;
}

// integer counter pattern
message PatternFlowLacpduPartnerStateExpiredCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Expired (1=Expired, 0=Not Expired)
message PatternFlowLacpduPartnerStateExpired {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowLacpduPartnerStateExpiredCounter increment = 5;

  // Description missing in models
  PatternFlowLacpduPartnerStateExpiredCounter decrement = 6;
}

// integer counter pattern
message PatternFlowIpv6ExtHeaderNextHeaderCounter {

  // Description missing in models
  // default = 59
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// The next header that identifies the type of header immediately following this IPv6
// Extension header. For TCP and UDP the values are 6 and 17 respectively. A value of
// 59 indicates that there are no further IPv6 Extension headers and that the payload
// will be appended after this header. The available defined values are listed in https://www.iana.org/assignments/ipv6-parameters/ipv6-parameters.xhtml#extension-header
message PatternFlowIpv6ExtHeaderNextHeader {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      auto = 1;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.auto
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 59
  optional uint32 value = 2;

  // Description missing in models
  // default = [59]
  repeated uint32 values = 3;

  // The OTG implementation can provide a system generated
  // value for this property. If the OTG is unable to generate a value
  // the default value must be used.
  // default = 59
  optional uint32 auto = 4;

  // Description missing in models
  PatternFlowIpv6ExtHeaderNextHeaderCounter increment = 6;

  // Description missing in models
  PatternFlowIpv6ExtHeaderNextHeaderCounter decrement = 7;
}

// integer counter pattern
message PatternFlowIpv6ExtHeaderHdrExtLenCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// The length of the IPv6 Extension header in 8 octet units, not including the first
// 8 octets of the Extension Header itself ( refer RFC 8200 ). When auto is assigned
// the implementation should automatically set it to the correct value.
message PatternFlowIpv6ExtHeaderHdrExtLen {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      auto = 1;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.auto
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // The OTG implementation can provide a system generated
  // value for this property. If the OTG is unable to generate a value
  // the default value must be used.
  // default = 0
  optional uint32 auto = 4;

  // Description missing in models
  PatternFlowIpv6ExtHeaderHdrExtLenCounter increment = 6;

  // Description missing in models
  PatternFlowIpv6ExtHeaderHdrExtLenCounter decrement = 7;
}

// integer counter pattern
message PatternFlowIpv6SegmentRoutingSegmentsLeftCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// 8-bit unsigned integer containing the number of remaining segments to be visited
// before the packet reaches its final destination. It is decremented at each segment
// endpoint. It points to the current active segment in the Segment List. This should
// not be more than the number of segments specified in the segment list. When auto
// is assigned the value is set to the number of segments specified.
message PatternFlowIpv6SegmentRoutingSegmentsLeft {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      auto = 1;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.auto
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // The OTG implementation can provide a system generated
  // value for this property. If the OTG is unable to generate a value
  // the default value must be used.
  // default = 0
  optional uint32 auto = 4;

  // Description missing in models
  PatternFlowIpv6SegmentRoutingSegmentsLeftCounter increment = 6;

  // Description missing in models
  PatternFlowIpv6SegmentRoutingSegmentsLeftCounter decrement = 7;
}

// integer counter pattern
message PatternFlowIpv6SegmentRoutingLastEntryCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// 8-bit unsigned integer that contains the zero-based index of the last element in
// the Segment List array. For example, if the Segment List contains 3 addresses (at
// indices 0, 1, 2), the value of Last Entry is 2. When auto is assigned the value should
// be automatically set by the implementation to one less than the number of segments
// specified.
message PatternFlowIpv6SegmentRoutingLastEntry {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      auto = 1;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.auto
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // The OTG implementation can provide a system generated
  // value for this property. If the OTG is unable to generate a value
  // the default value must be used.
  // default = 0
  optional uint32 auto = 4;

  // Description missing in models
  PatternFlowIpv6SegmentRoutingLastEntryCounter increment = 6;

  // Description missing in models
  PatternFlowIpv6SegmentRoutingLastEntryCounter decrement = 7;
}

// integer counter pattern
message PatternFlowIpv6SegmentRoutingTagCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// 16-bit field used to tag a packet as part of a class or group, enabling shared properties
// or policy treatment. If not used, it MUST be set to zero.
message PatternFlowIpv6SegmentRoutingTag {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowIpv6SegmentRoutingTagCounter increment = 5;

  // Description missing in models
  PatternFlowIpv6SegmentRoutingTagCounter decrement = 6;
}

// ipv6 counter pattern
message PatternFlowIpv6SegmentRoutingSegmentSegmentCounter {

  // Description missing in models
  // default = ::0
  optional string start = 1;

  // Description missing in models
  // default = ::1
  optional string step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// A 128-bit IPv6 address segment.
message PatternFlowIpv6SegmentRoutingSegmentSegment {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = ::0
  optional string value = 2;

  // Description missing in models
  // default = ['::0']
  repeated string values = 3;

  // Description missing in models
  PatternFlowIpv6SegmentRoutingSegmentSegmentCounter increment = 5;

  // Description missing in models
  PatternFlowIpv6SegmentRoutingSegmentSegmentCounter decrement = 6;
}

// integer counter pattern
message PatternFlowIpv6SegmentRoutingFlagsProtectedCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Protected Flag. Indicates if the segment is protected by a Fast Re-Route (FRR) mechanism.
message PatternFlowIpv6SegmentRoutingFlagsProtected {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowIpv6SegmentRoutingFlagsProtectedCounter increment = 5;

  // Description missing in models
  PatternFlowIpv6SegmentRoutingFlagsProtectedCounter decrement = 6;
}

// integer counter pattern
message PatternFlowIpv6SegmentRoutingFlagsOamCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// OAM Flag. Indicates if the packet is an Operations, Administration, and Maintenance
// (OAM) packet.
message PatternFlowIpv6SegmentRoutingFlagsOam {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowIpv6SegmentRoutingFlagsOamCounter increment = 5;

  // Description missing in models
  PatternFlowIpv6SegmentRoutingFlagsOamCounter decrement = 6;
}

// integer counter pattern
message PatternFlowIpv6SegmentRoutingFlagsAlertCounter {

  // Description missing in models
  // default = 0
  optional uint32 start = 1;

  // Description missing in models
  // default = 1
  optional uint32 step = 2;

  // Description missing in models
  // default = 1
  optional uint32 count = 3;
}

// Alert Flag. Indicates the presence of important TLVs that must be inspected.
message PatternFlowIpv6SegmentRoutingFlagsAlert {

  message Choice {
    enum Enum {
      unspecified = 0;
      value = 2;
      values = 3;
      increment = 4;
      decrement = 5;
    }
  }
  // Description missing in models
  // default = Choice.Enum.value
  optional Choice.Enum choice = 1;

  // Description missing in models
  // default = 0
  optional uint32 value = 2;

  // Description missing in models
  // default = [0]
  repeated uint32 values = 3;

  // Description missing in models
  PatternFlowIpv6SegmentRoutingFlagsAlertCounter increment = 5;

  // Description missing in models
  PatternFlowIpv6SegmentRoutingFlagsAlertCounter decrement = 6;
}

// Version details
message Version {

  // Version of API specification
  // default =
  optional string api_spec_version = 1;

  // Version of SDK generated from API specification
  // default =
  optional string sdk_version = 2;

  // Version of application consuming or serving the API
  // default =
  optional string app_version = 3;
}

// The request has succeeded with no application content but the server
// may return a list of detailed warnings.
message Success {
  Warning warning = 1;
}

// The request did not succeed and server has responded with error details.
message Failure {
  Error error = 1;
}

// Data that needs to be streamed
message Data {
  uint64 chunk_size = 1;
  bytes datum = 2;
}

message SetConfigRequest {
  Config config = 1;
}

message UpdateConfigRequest {
  ConfigUpdate config_update = 1;
}
message SetConfigResponse {
  Warning warning = 1;
}

message GetConfigResponse {
  Config config = 1;
}

message UpdateConfigResponse {
  Warning warning = 1;
}


message AppendConfigRequest {
  ConfigAppend config_append = 1;
}
message AppendConfigResponse {
  Warning warning = 1;
}


message DeleteConfigRequest {
  ConfigDelete config_delete = 1;
}
message DeleteConfigResponse {
  Warning warning = 1;
}


message SetControlStateRequest {
  ControlState control_state = 1;
}
message SetControlStateResponse {
  Warning warning = 1;
}


message SetControlActionRequest {
  ControlAction control_action = 1;
}
message SetControlActionResponse {
  ControlActionResponse control_action_response = 1;
}


message GetMetricsRequest {
  MetricsRequest metrics_request = 1;
}
message GetMetricsResponse {
  MetricsResponse metrics_response = 1;
}


message GetStatesRequest {
  StatesRequest states_request = 1;
}
message GetStatesResponse {
  StatesResponse states_response = 1;
}


message GetCaptureRequest {
  CaptureRequest capture_request = 1;
}
message GetCaptureResponse {
  bytes response_bytes = 1;
}

message GetVersionResponse {
  Version version = 1;
}


// Description missing in models
//
// For all RPCs defined in this service, API Server SHOULD provide JSON
// representation of `Error` message as an error string upon failure, ensuring
// name of enum constants (instead of value) for `kind` property is present
// in the representation
service Openapi {

  // Sets configuration resources on the traffic generator.
  rpc SetConfig(SetConfigRequest) returns (SetConfigResponse);
  // streaming version of the rpc SetConfig
  rpc streamSetConfig(stream Data) returns (SetConfigResponse);
  // Description missing in models
  rpc GetConfig(google.protobuf.Empty) returns (GetConfigResponse);
  // streaming version of the rpc GetConfig
  rpc streamGetConfig(google.protobuf.Empty) returns (stream Data);
  // Updates specific attributes of resources configured on the traffic generator. The
  // fetched configuration shall reflect the updates applied successfully.
  // The Response.Warnings in the Success response is available for implementers to disclose
  // additional information about a state change including any implicit changes that are
  // outside the scope of the state change.
  rpc UpdateConfig(UpdateConfigRequest) returns (UpdateConfigResponse);
  // Append new attributes of resources to existing configuration on the traffic generator.
  // Resource names should not be part of existing configuration of that resource type;
  // it should be unique for the operation to succeed. A failed append might leave the
  // configuration in an undefined state and if the error is due to some invalid or unsupported
  // configuration in the appended resources, it is expected that the user fix the error
  // and  restart from SetConfig operation. The fetched configuration shall also reflect
  // the new configuration applied successfully.
  rpc AppendConfig(AppendConfigRequest) returns (AppendConfigResponse);
  // Delete attributes of resources from existing configuration on the traffic generator.
  // Resource names should already be part of existing configuration of that resource
  // type; for the operation to succeed. A failed delete will leave the configuration
  // in an undefined state and if the error is due to some invalid or unsupported configuration
  // in the deleted  resources, it is expected that the user fix the error and restart
  // from SetConfig operation. On successful deletion the fetched configuration shall
  // not reflect the removed configuration.
  rpc DeleteConfig(DeleteConfigRequest) returns (DeleteConfigResponse);
  // Sets the operational state of configured resources.
  rpc SetControlState(SetControlStateRequest) returns (SetControlStateResponse);
  // streaming version of the rpc SetControlState
  rpc streamSetControlState(stream Data) returns (SetControlStateResponse);
  // Triggers actions against configured resources.
  rpc SetControlAction(SetControlActionRequest) returns (SetControlActionResponse);
  // streaming version of the rpc SetControlAction
  rpc streamSetControlAction(stream Data) returns (SetControlActionResponse);
  // Description missing in models
  rpc GetMetrics(GetMetricsRequest) returns (GetMetricsResponse);
  // streaming version of the rpc GetMetrics
  rpc streamGetMetrics(GetMetricsRequest) returns (stream Data);
  // Description missing in models
  rpc GetStates(GetStatesRequest) returns (GetStatesResponse);
  // streaming version of the rpc GetStates
  rpc streamGetStates(GetStatesRequest) returns (stream Data);
  // Description missing in models
  rpc GetCapture(GetCaptureRequest) returns (GetCaptureResponse);
  // streaming version of the rpc GetCapture
  rpc streamGetCapture(GetCaptureRequest) returns (stream Data);
  // Description missing in models
  rpc GetVersion(google.protobuf.Empty) returns (GetVersionResponse);
}
